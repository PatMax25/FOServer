                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

int week_patch=1;
int doubleloot=1;
bool dropchance(float chance)
{
	if(chance==0)
	return false;
	if(Random(0,100)<chance)
	return true;
	
	return false;
	
}

bool can_tc_modoc=false;
bool can_tc_klamath=false;
bool can_tc_gecko=false;
bool can_tc_bh=false;
bool can_tc_redding=false;
bool can_tc_den=false;
bool can_tc_necro=false;
bool can_tc_reno=false;

uint when_tc_modoc=0;
uint when_tc_klamath=0;
uint when_tc_gecko=0;
uint when_tc_bh=0;
uint when_tc_redding=0;
uint when_tc_den=0;
uint when_tc_necro=0;
uint when_tc_reno=0;                                                                  

import string GetCritterLexems(Critter&critter)from"lexems";
import string GetItemLexems(Item&item)from"lexems";

import bool IsLexem(Critter&critter,string&lex)from"lexems";
import bool IsLexem(Item&it,string&lex)from"lexems";
import bool IsLexem(string&lexems,string&lex)from"lexems";

import string GetLexem(Critter&critter,string&lex)from"lexems";
import string GetLexem(Item&item,string&lex)from"lexems";
import string GetLexem(string&lexems,string&lex)from"lexems"; 

import void SetLexem(Critter&critter,string&lex,string&value)from"lexems";
import void SetLexem(Item&item,string&lex,string&value)from"lexems";
import string SetLexem(string&lexems,string&lex,string&value)from"lexems";

import void UnsetLexem(Critter&critter,string&lex)from"lexems";
import void UnsetLexem(Item&item,string&lex)from"lexems";
import string UnsetLexem(string&lexems,string&lex)from"lexems";                                                                                      

shared class Serializator
{
	Serializator()
	{
		CurPos=0;
		BufSize=0;
		DataSize=0;
	}
	
	Serializator(uint approxSize)
	{
		CurPos=0;
		BufSize=0;
		DataSize=0;
		GrowBuffer(approxSize);
	}
	
	void GrowBuffer()
	{
		BufSize+=(128);
		Array.resize(BufSize);
	}
	
	void GrowBuffer(uint length)
	{
		BufSize+=length;
		Array.resize(BufSize);
	}
	
	bool Save(string&name)
	{
		if(DataSize==0)
		return false;
		bool result=SetAnyData(name,Array,DataSize);
		Clear();
		return result;
	}
	
	bool Load(string&name)
	{
		Clear();
		if(!IsAnyData(name))
		return false;
		if(!GetAnyData(name,Array))
		return false;
		BufSize=Array.length();
		DataSize=BufSize;
		return true;
	}
	
	void Clear()
	{
		CurPos=0;
		BufSize=0;
		DataSize=0;
	}
	
	Serializator@SetCurPos(uint pos)
	{
		if(pos>BufSize)
		GrowBuffer(pos-BufSize+(128));
		CurPos=pos;
		return this;
	}
	
	Serializator@Fill(uint8 value,uint length)
	{
		if(CurPos+length>BufSize)
		GrowBuffer(CurPos+length-BufSize+(128));
		for(uint i=0;i<length;i++)
		Array[CurPos++]=value;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@Set(const int64&value)
	{
		if(CurPos+8>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>56)&0xFF;
		Array[CurPos++]=(value>>48)&0xFF;
		Array[CurPos++]=(value>>40)&0xFF;
		Array[CurPos++]=(value>>32)&0xFF;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const int64&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const int32&value)
	{
		if(CurPos+4>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const int32&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const int16&value)
	{
		if(CurPos+2>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const int16&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const int8&value)
	{
		if(CurPos+1>BufSize)
		GrowBuffer();
		Array[CurPos++]=value;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const int8&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const uint64&value)
	{
		if(CurPos+8>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>56)&0xFF;
		Array[CurPos++]=(value>>48)&0xFF;
		Array[CurPos++]=(value>>40)&0xFF;
		Array[CurPos++]=(value>>32)&0xFF;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const uint64&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const uint32&value)
	{
		if(CurPos+4>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const uint32&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const uint16&value)
	{
		if(CurPos+2>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const uint16&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const uint8&value)
	{
		if(CurPos+1>BufSize)
		GrowBuffer();
		Array[CurPos++]=value;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const uint8&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const bool&value)
	{
		if(CurPos+1>BufSize)
		GrowBuffer();
		Array[CurPos++]=value?1:0;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const bool&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const string&value)
	{
		uint len=value.rawLength();
		if(CurPos+len+1>BufSize)
		GrowBuffer(CurPos+len+1-BufSize+(128));
		for(uint i=0;i<len;i++)
		Array[CurPos++]=value.rawGet(i);
		Array[CurPos++]=0;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const string&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const float&value)
	{
		int dummy=FloatToInt(value);
		return Set(dummy);
	}
	
	Serializator@opShl(const float&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const array<int64>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*8;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<int64>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<int32>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*4;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<int32>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<int16>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*2;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<int16>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<int8>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<int8>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<uint64>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*8;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<uint64>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<uint32>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*4;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<uint32>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<uint16>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*2;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<uint16>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<uint8>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<uint8>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<bool>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<bool>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<string>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		for(uint i=0,j=valuesLen;i<j;i++)
		len+=values[i].length();
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<string>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<float>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*4;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(FloatToInt(values[i]));
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<float>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const Critter&cr)
	{
		if(CurPos+4>BufSize)
		GrowBuffer();
		uint value=cr.Id;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const Critter&cr)
	{
		return Set(cr);
	}
	
	Serializator@Set(const Item&item)
	{
		if(CurPos+4>BufSize)
		GrowBuffer();
		uint value=item.Id;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const Item&item)
	{
		return Set(item);
	}
	
	Serializator@Get(int64&value)
	{
		value=0;
		if(CurPos+8>DataSize)
		return this;
		value|=Array[CurPos++]<<56;
		value|=Array[CurPos++]<<48;
		value|=Array[CurPos++]<<40;
		value|=Array[CurPos++]<<32;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(int64&value)
	{
		return Get(value);
	}
	
	Serializator@Get(int32&value)
	{
		value=0;
		if(CurPos+4>DataSize)
		return this;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(int32&value)
	{
		return Get(value);
	}
	
	Serializator@Get(int16&value)
	{
		value=0;
		if(CurPos+2>DataSize)
		return this;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(int16&value)
	{
		return Get(value);
	}
	
	Serializator@Get(int8&value)
	{
		value=0;
		if(CurPos+1>DataSize)
		return this;
		value=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(int8&value)
	{
		return Get(value);
	}
	
	Serializator@Get(uint64&value)
	{
		value=0;
		if(CurPos+8>DataSize)
		return this;
		value|=Array[CurPos++]<<56;
		value|=Array[CurPos++]<<48;
		value|=Array[CurPos++]<<40;
		value|=Array[CurPos++]<<32;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(uint64&value)
	{
		return Get(value);
	}
	
	Serializator@Get(uint32&value)
	{
		value=0;
		if(CurPos+4>DataSize)
		return this;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(uint32&value)
	{
		return Get(value);
	}
	
	Serializator@Get(uint16&value)
	{
		value=0;
		if(CurPos+2>DataSize)
		return this;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(uint16&value)
	{
		return Get(value);
	}
	
	Serializator@Get(uint8&value)
	{
		value=0;
		if(CurPos+1>DataSize)
		return this;
		value=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(uint8&value)
	{
		return Get(value);
	}
	
	Serializator@Get(bool&value)
	{
		value=false;
		if(CurPos+1>DataSize)
		return this;
		value=Array[CurPos++]==1?true:false;
		return this;
	}
	
	Serializator@opShr(bool&value)
	{
		return Get(value);
	}
	
	Serializator@Get(string&str)
	{
		uint len=0;
		for(uint i=CurPos;;i++)
		{
			if(i==DataSize)
			{
				str="";
				return this;
			}
			if(Array[i]==0)
			{
				len=i-CurPos;
				break;
			}
		}
		str.rawResize(len);
		for(uint i=0;i<len;i++)
		str.rawSet(i,Array[CurPos++]);
		CurPos++;
		return this;
	}
	
	Serializator@opShr(string&str)
	{
		return Get(str);
	}
	
	Serializator@Get(float&value)
	{
		int dummy=0;
		Get(dummy);
		value=IntToFloat(dummy);
		return this;
	}
	
	Serializator@opShr(float&value)
	{
		return Get(value);
	}
	
	Serializator@Get(array<int64>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<int64>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<int32>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<int32>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<float>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		{
			int dummy=0;
			Get(dummy);
			values[i]=IntToFloat(dummy);
		}
		return this;
	}
	
	Serializator@opShr(array<float>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<int16>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<int16>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<int8>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<int8>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<uint64>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<uint64>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<uint32>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<uint32>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<uint16>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<uint16>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<uint8>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<uint8>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<bool>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<bool>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<string>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<string>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(Critter@&cr)
	{
		@cr=null;
		if(CurPos+4>DataSize)
		return this;
		uint id=0;
		id|=Array[CurPos++]<<24;
		id|=Array[CurPos++]<<16;
		id|=Array[CurPos++]<<8;
		id|=Array[CurPos++];
		@cr=::GetCritter(id);
		return this;
	}
	
	Serializator@opShr(Critter@&cr)
	{
		return Get(cr);
	}
	
	Serializator@Get(Item@&item)
	{
		@item=null;
		if(CurPos+4>DataSize)
		return this;
		uint id=0;
		id|=Array[CurPos++]<<24;
		id|=Array[CurPos++]<<16;
		id|=Array[CurPos++]<<8;
		id|=Array[CurPos++];
		@item=::GetItem(id);
		return this;
	}
	
	Serializator@opShr(Item@&item)
	{
		return Get(item);
	}
	
	array<uint8>Array;
	uint CurPos;
	uint BufSize;
	uint DataSize;
};                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        

shared interface IBountyRecord
{
	uint GetCount();
	bool GetBounty(uint index,uint&out playerId,uint&out amount);
	void AddBounty(uint playerId,uint amount);
	uint FetchBounty(uint playerId);
};

class BountyRecord:IBountyRecord
{
	
	uint id; 
	
	array<uint>data;
	Serializator serialiser;
	
	BountyRecord(uint id)
	{
		this.id=id;
		
		if(serialiser.Load("BountyRecord_"+id))
		serialiser.Get(data);
		else
		
		UpdateData();
	}   
	
	uint GetCount()
	{
		return data.length()/2;
	}    
	
	bool GetBounty(uint index,uint&out playerId,uint&out amount)
	{
		if(index<GetCount())
		{
			playerId=data[index*2];
			amount=data[index*2+1];
			return true;
		}
		else
		{
			{;};
			return false;
		}
	}  
	
	void AddBounty(uint playerId,uint amount)
	{
		uint i;
		bool added=false;
		{;};
		if(data.length()>=2)
		{
			
			for(i=0;i<data.length();i+=2)
			{
				if(data[i]==playerId)
				{
					{;};
					data[i+1]+=amount;
					added=true;
					i=i+1;
					break;
				}
			}
		}
		
		if(!added)
		{
			{;};
			data.insertLast(playerId);
			data.insertLast(amount);
			i=data.length()-1;
		}
		
		uint temp;
		
		if(i>2)
		{;};
		
		for(uint j=i;j>2;j-=2)
		{
			if(data[j]>data[j-2])
			{
				{;};
				temp=data[j];
				data[j]=data[j-2];
				data[j-2]=temp;
				temp=data[j-1];
				data[j-1]=data[j-3];
				data[j-3]=temp;
			}
			else
			break;
		}
		UpdateData();
	}   
	
	uint FetchBounty(uint playerId)
	{
		uint value=0;
		uint i;
		{;};
		for(i=0;i<data.length();i+=2)
		{
			if(data[i]==playerId)
			{
				{;};
				value=data[i+1];
			}
		} 
		
		{;};
		for(uint j=i;i<data.length()-2;i+=2)
		{
			data[j]=data[j+2];
			data[j+1]=data[j+3];
		}
		data.resize(data.length()-2);
		{;};
		
		UpdateData();
		
		return value;
	}
	
	void UpdateData()
	{
		
		serialiser.Set(data); 
		
	}
}; 

import string@GetSafePlayerName(uint id)from"utils";           

array<IBountyRecord@>Records;       

void InitBountyRecord(Critter&npc)
{
	{;};
	{;};
	Records.insertLast(BountyRecord(npc.Id));
	{;};
	npc.ParamBase[(91)]=Records.length()-1;
	{;};
}

IBountyRecord@GetRecord(Critter@npc)
{
	{;};
	return Records[npc.Param[(91)]];
}       

bool PlayerKnowsAboutBounty(uint player1Id,uint player2Id)
{
	GameVar@var=GetUnicumVar((2019),player1Id,player2Id);
	if(var.GetValue()==0)
	{
		{;};
	}
	else
	{;};
	return var.GetValue()==1;
}   

void PlayerLearnsAboutBounty(uint player1Id,uint player2Id)
{
	GameVar@var=GetUnicumVar((2019),player1Id,player2Id);
	{;};
	var=1;
}   

void ResetBountyKnowledge(uint player1Id,uint player2Id)
{
	GameVar@var=GetUnicumVar((2019),player1Id,player2Id);
	{;};
	var=0;
}   

void RememberWhoSetBounty(uint npcId,uint playerId,uint bounteeId)
{
	GameVar@var=GetUnicumVar((2019),playerId,npcId);
	var=bounteeId;
	{;};
}   

void RememberWhoClaimedBounty(uint npcId,uint hunterId,uint bounteeId)
{
	GameVar@var=GetUnicumVar((2019),npcId,bounteeId);
	var=hunterId;
	{;};
}    

uint GetBountee(uint npcId,uint ordererId)
{
	GameVar@var=GetUnicumVar((2019),ordererId,npcId);
	return var.GetValue();
}    

void ClearBountee(uint npcId,uint ordererId)
{
	GameVar@var=GetUnicumVar((2019),ordererId,npcId);
	{;};
	var=0;
}   

uint GetHunter(uint npcId,uint bounteeId)
{
	GameVar@var=GetUnicumVar((2019),npcId,bounteeId);
	return var.GetValue();
}    

void ClearHunter(uint npcId,uint bounteeId)
{
	GameVar@var=GetUnicumVar((2019),npcId,bounteeId);
	{;};
	var=0;
}   

void CheckBountyHunters(Critter&cr,Critter@killer)
{
	if(!(@killer!=null)||!cr.IsPlayer())
	return;
	
	{;};
	bool knows=false;
	
	if(PlayerKnowsAboutBounty(killer.Id,cr.Id))
	{
		{;};
		knows=true;
	}
	else
	{
		
		array<Critter@>followers;
		uint num=killer.GetFollowGroup((0x0F),followers);
		if(num==0)
		{
			{;};
			Critter@leader=killer.GetFollowLeader();
			if((@leader!=null))
			num=leader.GetFollowGroup((0x0F),followers);
		}
		if(num>0)
		{;};
		for(uint i=0;i<num;i++)
		{
			if(PlayerKnowsAboutBounty(followers[i].Id,cr.Id))
			{
				{;};
				knows=true;
				break;
			}
		}
	}
	
	if(knows)
	{
		Item@ear=cr.AddItem((1806),1);
		ear.Val5=cr.Id;
		SetLexem(ear,"$name",cr.Name);
		cr.Say((11),"You've been hunted");
		cr.TimeoutBase[(241)]=((__FullSecond)+((((6)*__TimeMultiplier*60))));
	}
}   

void dlg_ChoosePlayer(Critter&player,Critter@npc,string@name)
{
	if(((@name!=null)&&name.length()==0))
	player.ParamBase[(90)]=0;
	if(((@name!=null)&&name.length()>0))
	{
		uint id=GetPlayerId(name);
		if(id==0)
		player.Say((12),"Wrong name");
		else if(id==player.Id)
		player.Say((12),"Are you out of your mind?");
		else
		{
			player.Say((12),"[Press continue]");
			player.ParamBase[(90)]=id;
		}
	}
	string money;
	string prefix;
	switch(npc.Param[(139)])
	{
		case 1:money="Dollars";
		case 2:money="Chips";
		case 3:money="Scrips";
		case 4:money="Pounds";
		case 5:money="Rings";
		default:money="Caps";
	}
	switch(npc.Param[(139)])
	{
		case 1:prefix="Enclave ";
		case 2:prefix="Memory ";
		case 3:prefix="NCR ";
		case 4:prefix="Vault City ";
		case 5:prefix="Pull ";
		default:prefix="Bottle ";
	}
	name+=("$prefix"+prefix);
	name+=("$money"+money);
}    

uint r_PlayerChosen(Critter&player,Critter@npc,int val)
{
	if(player.Param[(90)]==0)
	return val;
	return 0;
}    

void r_SetBounty(Critter&player,Critter@npc,int amount)
{
	IBountyRecord@record=GetRecord(npc);
	if(player.Param[(90)]==0)
	{
		
	}
	else
	{
		record.AddBounty(player.Param[(90)],amount);
		
		PlayerLearnsAboutBounty(player.Id,player.Param[(90)]);
		
		RememberWhoSetBounty(npc.Id,player.Id,player.Param[(90)]);
	}
}    

uint r_ShowFirstBounty(Critter&player,Critter@npc,int val)
{
	IBountyRecord@record=GetRecord(npc);
	if(record.GetCount()==0)
	{
		return val;
	}
	uint id,amount;
	record.GetBounty(0,id,amount);
	
	if(id==player.Id)
	{
		if(record.GetCount()==1)
		{
			return val;
		}
		player.ParamBase[(90)]=1;
	}
	else
	player.ParamBase[(90)]=0;
	return 0;
}    

uint r_ShowNextBounty(Critter&player,Critter@npc,int val)
{
	IBountyRecord@record=GetRecord(npc);
	if(record.GetCount()==0)
	{
		return val;
	}
	if(player.Param[(90)]+1<int(record.GetCount()))
	{
		uint id,amount;
		record.GetBounty(player.Param[(90)]+1,id,amount);
		
		if(id==player.Id)
		{
			if(player.Param[(90)]+2<int(record.GetCount()))
			player.ParamBase[(90)]+=2;
			
		}
		else
		player.ParamBase[(90)]++;
	}
	return 0;
}    

void dlg_ShowBounty(Critter&player,Critter@npc,string@text)
{
	if(!((@text!=null)&&text.length()==0))
	return;
	
	IBountyRecord@record=GetRecord(npc);
	uint id=0,amount=0;
	{;};
	if(!record.GetBounty(player.Param[(90)],id,amount))
	{
		{;};
		player.Say((12),"Couldn't get bounty for index: "+player.Param[(90)]);
	}
	else
	{
		text+="$bounty"+amount;
		text+="$player"+GetSafePlayerName(id);
		
		PlayerLearnsAboutBounty(player.Id,id);
	}
	string money;
	string prefix;
	switch(npc.Param[(139)])
	{
		case 1:money="Dollars";
		case 2:money="Chips";
		case 3:money="Scrips";
		case 4:money="Pounds";
		case 5:money="Rings";
		default:money="Caps";
	}
	switch(npc.Param[(139)])
	{
		case 1:prefix="Enclave ";
		case 2:prefix="Memory ";
		case 3:prefix="NCR ";
		case 4:prefix="Vault City ";
		case 5:prefix="Pull ";
		default:prefix="Bottle ";
	}
	text+=("$prefix"+prefix);
	text+=("$money"+money);
}    

bool d_HasProof(Critter&player,Critter@npc,int val)
{
	IBountyRecord@record=GetRecord(npc);
	
	uint id=0,amount=0;
	
	Item@proof=player.GetItem(0,(1));
	
	if(!(@proof!=null))
	return false;
	
	return proof.GetProtoId()==(1806);
}      

uint r_CheckBounty(Critter&player,Critter@npc,int val)
{
	IBountyRecord@record=GetRecord(npc);
	
	uint id=0,amount=0;
	
	Item@proof=player.GetItem(0,(1));  
	
	{;};
	for(uint i=0;i<record.GetCount();i++)
	{
		record.GetBounty(i,id,amount);
		{;};
		if(uint(proof.Val5)==id)
		{
			
			player.ParamBase[(90)]=id;
			
			DeleteItem(proof);
			return 0;
		}
	}
	
	return val;
}   

void r_FetchBounty(Critter&player,Critter@npc,int val)
{
	IBountyRecord@record=GetRecord(npc);
	
	uint amount=record.FetchBounty(player.Param[(90)]);
	if(amount==0)
	{
		Log("ERR: No bounty to fetch");
		return;
	}
	
	player.AddItem((41),amount);
	
	ResetBountyKnowledge(player.Id,player.Param[(90)]);
	
	RememberWhoClaimedBounty(npc.Id,player.Id,player.Param[(90)]);  
	
	uint bounteeId=GetBountee(npc.Id,player.Id);
	uint hunterId=GetHunter(npc.Id,bounteeId);
	if(player.Id==hunterId)
	{
		{;};
		
		ClearBountee(npc.Id,player.Id);
		
		ClearHunter(npc.Id,bounteeId);
	}
}   

bool d_HasInfo(Critter&player,Critter@npc,int val)
{
	GameVar@var;
	
	{;}; 
	
	uint bounteeId=GetBountee(npc.Id,player.Id);
	
	if(bounteeId==0)
	return false;
	else
	{;}; 
	
	uint hunterId=GetHunter(npc.Id,bounteeId);
	
	if(hunterId==0)
	return false;
	else
	{;};
	
	return true;
}   

void dlg_ShowHunter(Critter&player,Critter@npc,string@text)
{
	if(!((@text!=null)&&text.length()==0))
	return;
	
	GameVar@var; 
	
	uint bounteeId=GetBountee(npc.Id,player.Id);
	
	if(bounteeId==0)
	{
		player.Say((12),"ERR: You haven't set any bounty");
		return;
	}
	
	uint hunterId=GetHunter(npc.Id,bounteeId);
	
	if(hunterId==0)
	{
		player.Say((12),"ERR: Your bounty has not been claimed yet");
		return;
	}
	text+="$bountee"+GetSafePlayerName(bounteeId);
	text+="$hunter"+GetSafePlayerName(hunterId); 
	
	ClearBountee(npc.Id,player.Id);
	
	ClearHunter(npc.Id,bounteeId);
	string money;
	string prefix;
	switch(npc.Param[(139)])
	{
		case 1:money="Dollars";
		case 2:money="Chips";
		case 3:money="Scrips";
		case 4:money="Pounds";
		case 5:money="Rings";
		default:money="Caps";
	}
	switch(npc.Param[(139)])
	{
		case 1:prefix="Enclave ";
		case 2:prefix="Memory ";
		case 3:prefix="NCR ";
		case 4:prefix="Vault City ";
		case 5:prefix="Pull ";
		default:prefix="Bottle ";
	}
	text+=("$prefix"+prefix);
	text+=("$money"+money);
} 

void r_LogBounties(Critter&player,Critter@npc,int val)
{
	IBountyRecord@record=GetRecord(npc);
	
	uint id=0,amount=0;
	{;};
	for(uint i=0;i<record.GetCount();i++)
	{
		record.GetBounty(i,id,amount);
		
	}
}     

void critter_init(Critter&npc,bool firstTime)
{
	InitBountyRecord(npc);
	
}
