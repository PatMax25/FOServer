                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

int week_patch=1;
int doubleloot=1;
bool dropchance(float chance)
{
	if(chance==0)
	return false;
	if(Random(0,100)<chance)
	return true;
	
	return false;
	
}

bool can_tc_modoc=false;
bool can_tc_klamath=false;
bool can_tc_gecko=false;
bool can_tc_bh=false;
bool can_tc_redding=false;
bool can_tc_den=false;
bool can_tc_necro=false;
bool can_tc_reno=false;

uint when_tc_modoc=0;
uint when_tc_klamath=0;
uint when_tc_gecko=0;
uint when_tc_bh=0;
uint when_tc_redding=0;
uint when_tc_den=0;
uint when_tc_necro=0;
uint when_tc_reno=0;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

shared class Entire
{
	int Number;
	uint16 HexX;
	uint16 HexY;
	uint8 Direction;
};

uint ParseEntires(Map&map,array<Entire>&entires,int number)
{
	uint oldCount=entires.length();
	uint count=map.CountEntire(number);
	entires.resize(oldCount+count);
	
	for(uint i=0;i<count;i++)
	{
		Entire@ent=entires[oldCount+i];
		if(map.GetEntireCoords(number,i,ent.HexX,ent.HexY,ent.Direction)==false)
		return 0;
		ent.Number=number;
	}
	
	return count;
}

bool IsEntireFree(uint mappid,int number)
{
	Map@map=GetMapByPid(mappid,0);
	return IsEntireFree(map,number);
}

bool IsEntireFree(Map&map,int number)
{
	uint16 x,y;
	x=0;
	y=0;
	return GetEntireFreeHex(map,number,x,y);
}

bool GetEntireFreeHex(Map&map,int number,uint16&hx,uint16&hy,uint skip=0)
{
	uint count=map.CountEntire(number); 
	
	for(uint i=skip;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy)&&map.IsHexPassed(hx,hy))
		return true;
	}
	
	if(hx==0||hy==0||hx>=map.GetWidth()-1||hy>=map.GetHeight()-1)
	return false; 
	
	for(uint i=0;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy))
		{
			for(int x=-1;x<=1;x++)
			{
				for(int y=-1;y<=1;y++)
				{
					if(x==0&&y==0)
					continue;
					if(__MapHexagonal)
					{
						if((hx%2)==1&&((x==-1&&y==1)||(x==1&&y==1)))
						continue;
						if((hx%2)==0&&((x==-1&&y==-1)||(x==1&&y==-1)))
						continue;
					}
					
					if(map.IsHexPassed(hx+x,hy+y))
					{
						hx+=x;
						hy+=y;
						return true;
					}
				}
			}
		}
	}
	return false;
}

bool GetNearEntire(Map&map,int number,uint16&hx,uint16&hy)
{
	uint16 hxBase=hx;
	uint16 hyBase=hy;
	
	array<Entire>entires;
	uint count=ParseEntires(map,entires,number);
	if(count==0)
	return false;
	
	hx=entires[0].HexX;
	hy=entires[0].HexY;
	for(uint i=1;i<count;i++)
	{
		Entire@ent=entires[i];
		if(GetDistantion(hxBase,hyBase,ent.HexX,ent.HexY)<GetDistantion(hxBase,hyBase,hx,hy))
		{
			hx=ent.HexX;
			hy=ent.HexY;
		}
	}
	
	return true;
}                                                                                    

shared class Serializator
{
	Serializator()
	{
		CurPos=0;
		BufSize=0;
		DataSize=0;
	}
	
	Serializator(uint approxSize)
	{
		CurPos=0;
		BufSize=0;
		DataSize=0;
		GrowBuffer(approxSize);
	}
	
	void GrowBuffer()
	{
		BufSize+=(128);
		Array.resize(BufSize);
	}
	
	void GrowBuffer(uint length)
	{
		BufSize+=length;
		Array.resize(BufSize);
	}
	
	bool Save(string&name)
	{
		if(DataSize==0)
		return false;
		bool result=SetAnyData(name,Array,DataSize);
		Clear();
		return result;
	}
	
	bool Load(string&name)
	{
		Clear();
		if(!IsAnyData(name))
		return false;
		if(!GetAnyData(name,Array))
		return false;
		BufSize=Array.length();
		DataSize=BufSize;
		return true;
	}
	
	void Clear()
	{
		CurPos=0;
		BufSize=0;
		DataSize=0;
	}
	
	Serializator@SetCurPos(uint pos)
	{
		if(pos>BufSize)
		GrowBuffer(pos-BufSize+(128));
		CurPos=pos;
		return this;
	}
	
	Serializator@Fill(uint8 value,uint length)
	{
		if(CurPos+length>BufSize)
		GrowBuffer(CurPos+length-BufSize+(128));
		for(uint i=0;i<length;i++)
		Array[CurPos++]=value;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@Set(const int64&value)
	{
		if(CurPos+8>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>56)&0xFF;
		Array[CurPos++]=(value>>48)&0xFF;
		Array[CurPos++]=(value>>40)&0xFF;
		Array[CurPos++]=(value>>32)&0xFF;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const int64&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const int32&value)
	{
		if(CurPos+4>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const int32&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const int16&value)
	{
		if(CurPos+2>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const int16&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const int8&value)
	{
		if(CurPos+1>BufSize)
		GrowBuffer();
		Array[CurPos++]=value;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const int8&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const uint64&value)
	{
		if(CurPos+8>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>56)&0xFF;
		Array[CurPos++]=(value>>48)&0xFF;
		Array[CurPos++]=(value>>40)&0xFF;
		Array[CurPos++]=(value>>32)&0xFF;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const uint64&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const uint32&value)
	{
		if(CurPos+4>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const uint32&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const uint16&value)
	{
		if(CurPos+2>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const uint16&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const uint8&value)
	{
		if(CurPos+1>BufSize)
		GrowBuffer();
		Array[CurPos++]=value;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const uint8&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const bool&value)
	{
		if(CurPos+1>BufSize)
		GrowBuffer();
		Array[CurPos++]=value?1:0;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const bool&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const string&value)
	{
		uint len=value.rawLength();
		if(CurPos+len+1>BufSize)
		GrowBuffer(CurPos+len+1-BufSize+(128));
		for(uint i=0;i<len;i++)
		Array[CurPos++]=value.rawGet(i);
		Array[CurPos++]=0;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const string&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const float&value)
	{
		int dummy=FloatToInt(value);
		return Set(dummy);
	}
	
	Serializator@opShl(const float&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const array<int64>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*8;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<int64>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<int32>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*4;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<int32>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<int16>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*2;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<int16>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<int8>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<int8>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<uint64>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*8;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<uint64>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<uint32>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*4;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<uint32>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<uint16>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*2;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<uint16>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<uint8>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<uint8>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<bool>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<bool>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<string>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		for(uint i=0,j=valuesLen;i<j;i++)
		len+=values[i].length();
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<string>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<float>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*4;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(FloatToInt(values[i]));
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<float>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const Critter&cr)
	{
		if(CurPos+4>BufSize)
		GrowBuffer();
		uint value=cr.Id;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const Critter&cr)
	{
		return Set(cr);
	}
	
	Serializator@Set(const Item&item)
	{
		if(CurPos+4>BufSize)
		GrowBuffer();
		uint value=item.Id;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const Item&item)
	{
		return Set(item);
	}
	
	Serializator@Get(int64&value)
	{
		value=0;
		if(CurPos+8>DataSize)
		return this;
		value|=Array[CurPos++]<<56;
		value|=Array[CurPos++]<<48;
		value|=Array[CurPos++]<<40;
		value|=Array[CurPos++]<<32;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(int64&value)
	{
		return Get(value);
	}
	
	Serializator@Get(int32&value)
	{
		value=0;
		if(CurPos+4>DataSize)
		return this;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(int32&value)
	{
		return Get(value);
	}
	
	Serializator@Get(int16&value)
	{
		value=0;
		if(CurPos+2>DataSize)
		return this;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(int16&value)
	{
		return Get(value);
	}
	
	Serializator@Get(int8&value)
	{
		value=0;
		if(CurPos+1>DataSize)
		return this;
		value=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(int8&value)
	{
		return Get(value);
	}
	
	Serializator@Get(uint64&value)
	{
		value=0;
		if(CurPos+8>DataSize)
		return this;
		value|=Array[CurPos++]<<56;
		value|=Array[CurPos++]<<48;
		value|=Array[CurPos++]<<40;
		value|=Array[CurPos++]<<32;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(uint64&value)
	{
		return Get(value);
	}
	
	Serializator@Get(uint32&value)
	{
		value=0;
		if(CurPos+4>DataSize)
		return this;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(uint32&value)
	{
		return Get(value);
	}
	
	Serializator@Get(uint16&value)
	{
		value=0;
		if(CurPos+2>DataSize)
		return this;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(uint16&value)
	{
		return Get(value);
	}
	
	Serializator@Get(uint8&value)
	{
		value=0;
		if(CurPos+1>DataSize)
		return this;
		value=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(uint8&value)
	{
		return Get(value);
	}
	
	Serializator@Get(bool&value)
	{
		value=false;
		if(CurPos+1>DataSize)
		return this;
		value=Array[CurPos++]==1?true:false;
		return this;
	}
	
	Serializator@opShr(bool&value)
	{
		return Get(value);
	}
	
	Serializator@Get(string&str)
	{
		uint len=0;
		for(uint i=CurPos;;i++)
		{
			if(i==DataSize)
			{
				str="";
				return this;
			}
			if(Array[i]==0)
			{
				len=i-CurPos;
				break;
			}
		}
		str.rawResize(len);
		for(uint i=0;i<len;i++)
		str.rawSet(i,Array[CurPos++]);
		CurPos++;
		return this;
	}
	
	Serializator@opShr(string&str)
	{
		return Get(str);
	}
	
	Serializator@Get(float&value)
	{
		int dummy=0;
		Get(dummy);
		value=IntToFloat(dummy);
		return this;
	}
	
	Serializator@opShr(float&value)
	{
		return Get(value);
	}
	
	Serializator@Get(array<int64>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<int64>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<int32>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<int32>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<float>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		{
			int dummy=0;
			Get(dummy);
			values[i]=IntToFloat(dummy);
		}
		return this;
	}
	
	Serializator@opShr(array<float>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<int16>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<int16>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<int8>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<int8>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<uint64>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<uint64>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<uint32>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<uint32>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<uint16>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<uint16>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<uint8>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<uint8>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<bool>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<bool>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<string>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<string>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(Critter@&cr)
	{
		@cr=null;
		if(CurPos+4>DataSize)
		return this;
		uint id=0;
		id|=Array[CurPos++]<<24;
		id|=Array[CurPos++]<<16;
		id|=Array[CurPos++]<<8;
		id|=Array[CurPos++];
		@cr=::GetCritter(id);
		return this;
	}
	
	Serializator@opShr(Critter@&cr)
	{
		return Get(cr);
	}
	
	Serializator@Get(Item@&item)
	{
		@item=null;
		if(CurPos+4>DataSize)
		return this;
		uint id=0;
		id|=Array[CurPos++]<<24;
		id|=Array[CurPos++]<<16;
		id|=Array[CurPos++]<<8;
		id|=Array[CurPos++];
		@item=::GetItem(id);
		return this;
	}
	
	Serializator@opShr(Item@&item)
	{
		return Get(item);
	}
	
	array<uint8>Array;
	uint CurPos;
	uint BufSize;
	uint DataSize;
};                                                                                                                                                                                                                                                                                                                                                                                                                      

import Location@GetLocationOf(Critter&critter)from"utils";
import string GetLocationName(uint locId)from"utils";
import string GetLocationName(Location@loc)from"utils";
import bool ReadPids(array<int>&out pids,bool removeinvalid)from"utils";
import void ReadDefines(string@fileName,dictionary&items,array<string>@defines)from"utils";
import bool ParseDefine(const string&in line,string&out spid,int&out id)from"utils";
import int SkipWhitespaces(const string&in str,int start)from"utils";
import int SkipNonWhitespaces(const string&in str,int start)from"utils";
import bool IsParameterTag(string&str)from"utils";
import string GetParameterString(array<string@>@arr,string&parameter)from"utils";
import int GetIndexOfString(array<string@>@arr,string&str)from"utils";
import string GetConcatenatedString(array<string@>@arr,uint startindex,int stopindex)from"utils";
import string GetConditionOfCritter(Critter@cr)from"utils";
import string GetExtConditionOfCritter(Critter@cr)from"utils";
import uint GetAllOnlinePlayers(array<Critter@>&out players)from"utils";
import uint GetAuthenticatedPlayers(array<Critter@>&out players)from"utils";
import uint GetAuthenticatedPlayers(array<Critter@>&out players,bool ignorePriviledges)from"utils";
import uint GetNumberOfPlayersOnline()from"utils";
import void SetTurnBasedAvailability(Location@loc)from"utils";
import bool IsGuarded(Map@map)from"utils";
import bool IsPublic(Map@map)from"utils";
import bool IsEncounterMap(Map@map)from"utils";
import bool IsTown(Map@map)from"utils";
import bool IsDungeon(Map@map)from"utils";
import bool IsBaseControl(Map@map)from"utils";

import uint GetMapType(Map@map)from"utils";
import void LockDoor(uint x,uint y,Map@map,uint complexity,uint lockid)from"utils";
import void UnlockDoor(uint x,uint y,Map@map)from"utils";
import void ClearContainer(Item@container)from"utils";
import void MoveItemsCritterToCont(Critter&crFrom,Item&contTo,uint specid)from"utils";
import string GetCritterInfo(Critter&cr)from"utils";
import bool AddExpTeam(Critter&critter,int xp)from"utils";
import void ClearEnemyStack(Critter&critter)from"utils";
import void ClearEnemyStacksOnMap(Map@map)from"utils";
import bool IsCurrentEnemy(Critter&cr,uint targetId)from"utils";
import string@GetSafePlayerName(uint id)from"utils";
import string GetSafePlayerName(uint id,string&onSuccess,string&onError)from"utils";
import IDateTime@GetCurrentDateTime()from"utils";
import string GetCurrentDateTimeString()from"utils";
import string GetCurrentDateTimeString(bool date,bool time)from"utils";
import Critter@GetMostSkilled(array<Critter@>@group,int skill)from"utils";
import string GetAuthString(Critter&player)from"utils";
import string GetAuthString(int accesslevel)from"utils";
import bool CanRequestHelp(Critter&player)from"utils";
import void SetRequestedHelp(Critter&player)from"utils";
import void SetRequestedHelp(Critter&player,int minutes)from"utils";
import Critter@GetOnlineGM()from"utils";
import void Preprocess(Critter&player,string&commandString)from"utils";
import bool IsHumanoid(Critter@cr)from"utils";
import uint GetGroupIndex(Critter&cr)from"utils";
import uint GetGroupIndex(int st)from"utils";
import void SetGroupIndex(Critter&cr,uint val)from"utils";
import uint GetGroupRank(Critter&cr)from"utils";
import void SetGroupRank(Critter&cr,uint val)from"utils";
import uint GetGroupMode(Critter&cr)from"utils";
import void SetGroupMode(Critter&cr,uint val)from"utils";
import void SetGroupInfo(Critter&cr,uint faction,uint rank,uint mode)from"utils";
import void SetGroupInfoPack(Critter&cr,uint packInfo)from"utils";
import void ClearEvents(Critter&cr)from"utils";

import int GetGvar(uint gvar)from"utils";
import void SetGvar(uint gvar,uint value)from"utils";
import int GetLLvar(Location&location,uint llvar)from"utils";
import int GetLLvar(uint locationId,uint llvar)from"utils";
import void SetLLvar(Location&location,uint llvar,uint value)from"utils";
import int GetLMvar(Map&map,uint llvar)from"utils";
import int GetLMvar(uint mapId,uint llvar)from"utils";
import void SetLMvar(Map&map,uint llvar,uint value)from"utils";
import int GetLIvar(Item&item,uint llvar)from"utils";
import int GetLIvar(uint itemId,uint llvar)from"utils";
import void SetLIvar(Item&item,uint llvar,uint value)from"utils";
import int GetLvar(Critter&critter,uint lvar)from"utils";
import int GetLvar(uint id,uint lvar)from"utils";
import void SetLvar(Critter&critter,uint lvar,uint value)from"utils";
import void SetLvar(uint id,uint lvar,uint value)from"utils";
import int GetUvar(uint uvar,uint key,uint index)from"utils";
import void SetUvar(uint uvar,uint key,uint index,uint value)from"utils";

import uint GetContainerValue(Item@container)from"utils";
import uint BaseItemValue(uint pid,bool ammo)from"utils";
import uint BaseItemValue(uint pid,uint broken,uint det,bool ammo)from"utils";
import uint BaseItemValue(Item@item)from"utils";
import uint BaseItemValue(Item@item,uint proc)from"utils";
import uint BaseSingleItemValue(Item@item)from"utils";
import uint BaseSingleItemValue(Item@item,uint proc)from"utils";

import void SetBloodType(Critter@cr)from"utils";
import string GetBloodType(Critter@cr)from"utils";
import string GetBloodRandom()from"utils";

import void LogCommandUsage(Critter&player,string&commandString)from"utils";
import void DropTimeouts(Critter&cr)from"utils";

import bool HasItem(Critter@cr,uint pid)from"utils";
import bool HasSomeWeapon(Critter@cr)from"utils";
import uint GetBestWeaponSkill(Critter@cr)from"utils";
import void GiveBag(uint bag,Critter@cr)from"utils";
import void SetQuestGarbager(uint time,uint playerid,uint locid,uint var,uint val)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,uint factionRank,uint factionMode,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,array<int>params,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,array<int>params,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,uint factionRank,uint factionMode,bool isMob,uint level)from"utils";
import void AddScore(Critter@cr,uint score,uint points)from"utils";

import bool ReloadWeapon(Critter&cr)from"utils";
import Item@GetRadio(Critter&cr)from"utils";
import Item@GetRepairTool(Critter&cr)from"utils";
import Item@GetEquippedItem(Critter&cr,uint Pid)from"utils";
import Item@GetEquippedItem(Critter&cr,array<uint>&Pids)from"utils";
import Item@GetEquippedItemByType(Critter&cr,uint ItemType)from"utils"; 

import bool SkillRoll(Critter@cr,int skill,int bonus)from"utils";
import int SkillCheck(Critter&cr,int skill,int skillused,Item@item,int bonus)from"utils";
import string SkillName(uint8 skill)from"utils";
import void ChangeCrTypeSafe(Critter&cr,uint8 crType)from"utils";

import bool Pickable(Item@item)from"utils";

import void TransferItemsToContOnMap(Critter&cr,Map@map,int entid,int contpid,int itemtypes)from"utils";
import void TransferItemsFromContOnMap(Critter&cr,Map@map,int entid,int contpid)from"utils";

import string IpToString(uint ip)from"utils";

import void VerboseAction(Critter&cr,string&text)from"utils";
import void VerboseAction(Critter&cr,Critter&target,string&text)from"utils";
import void VerboseExperience(Critter&cr,int xpDiff,int levelDiff)from"utils";

import void SetChosenActions(Critter&cr,array<int>&actions)from"utils";

import void HexLine(uint16 x0,uint16 y0,uint16 x1,uint16 y1,array<uint16>@xList,array<uint16>@yList)from"utils";
import void HexCircle(uint16 x0,uint16 y0,uint16 radius,array<uint16>@xList,array<uint16>@yList)from"utils";

import void StartPersonalDataCleanup()from"utils";

import bool IsPersonalData(Location&location,string&name)from"utils";
import bool GetPersonalData(Location&location,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Location&location,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Location&location,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Location&location,string&name)from"utils";

import bool IsPersonalData(Map&map,string&name)from"utils";
import bool GetPersonalData(Map&map,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Map&map,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Map&map,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Map&map,string&name)from"utils";

import bool IsPersonalData(Critter&critter,string&name)from"utils";
import bool GetPersonalData(Critter&critter,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Critter&critter,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Critter&critter,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Critter&critter,string&name)from"utils";

import bool IsPersonalData(Item&item,string&name)from"utils";
import bool GetPersonalData(Item&item,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Item&item,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Item&item,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Item&item,string&name)from"utils";

import bool FindPreferredGridApprox(Map&map,uint16&hx,uint16&hy)from"utils";           

import bool StrToInt(string@s,uint64&inout val)from"strtoint";
import bool StrToInt(string@s,uint&inout val)from"strtoint";
import bool StrToInt(string@s,uint16&inout val)from"strtoint";
import bool StrToInt(string@s,uint8&inout val)from"strtoint";
import bool StrToInt(string@s,int64&inout val)from"strtoint";
import bool StrToInt(string@s,int16&inout val)from"strtoint";
import bool StrToInt(string@s,int8&inout val)from"strtoint";    

import int FindInArray(array<int>&arr,int value)from"utils";
import int FindInArray(array<uint>&arr,uint value)from"utils";
import int FindInArray(array<uint16>&arr,uint16 value)from"utils";
import int FindInArray(array<uint8>&arr,uint8 value)from"utils";
import bool FindInArray(array<int>&arr,int id,int&index)from"utils";
import bool FindInArray(array<uint>&arr,uint id,int&index)from"utils";
import bool FindInArray(array<uint8>&arr,uint8 id,int&index)from"utils";
import int FindInArray(array<string>&arr,string&value)from"utils";
import int FindInArray(array<string@>@arr,string&value)from"utils";
import bool Present(int what,array<int>&where)from"utils";
import bool Present(uint what,array<uint>&where)from"utils";
import bool Present(uint16 what,array<uint16>&where)from"utils";
import bool Present(string&what,array<string>&where)from"utils";
import bool Present(string&what,array<string@>@where)from"utils";

import uint CreateLocationForGroup(Critter&player,uint16 pid,uint16 worldX,uint16 worldY,array<Critter@>&)from"utils";
import bool FindFirstFreeHex(Map@map,uint16&x,uint16&y,uint8 dir,uint16 maxSteps)from"utils";
import bool FindNearestFreeHex(Map&map,uint16&x,uint16&y,uint radius)from"utils";

import bool GetItemCoordinates(Item&item,uint&mapID,uint16&x,uint16&y)from"utils";
import bool ItemOnHex(uint16 pid,Map@map,uint16 x,uint16 y)from"utils";

import void PrintCallstack()from"utils";
import void PrintCallstack(int level)from"utils";

import bool LocationHasCritters(Location&loc,uint findType)from"utils";
import uint LocationGetCritters(Location&loc,uint findType,array<Critter@>@critters)from"utils";
import uint LocationGetPlayersAndFollowers(Location&loc,uint findType,array<Critter@>@critters)from"utils";
import uint MapGetPlayersAndFollowers(Map&map,uint findType,array<Critter@>@critters)from"utils";
import uint CritterGetPlayersAndFollowers(Critter&critter,bool lookOnMe,uint findType,array<Critter@>@critters)from"utils";
import bool LocationHasItems(Location&loc,uint16 protoId)from"utils";
import uint LocationGetItems(Location&loc,uint16 protoId,array<Item@>@items)from"utils";
import void LocationDeleteItems(Location&loc,uint16 protoId)from"utils";

import bool IsDisposableEncounter(Location@loc)from"utils";

import bool IsT4Item(Item&item)from"utils";
import bool IsT3Item(Item&item)from"utils";
import uint16 AddT3Item()from"utils";
import uint16 AddT4Item()from"utils";
import uint16 AddImplant()from"utils";
import uint16 AddT4BP()from"utils";
import uint16 AddRareAmmo()from"utils";
import uint16 AddTypicalAmmo()from"utils";

import void SetDeterioration(Item&item)from"utils";  

shared class CPosition
{
	uint x;
	uint y;
	uint dir;
};

shared interface IRect
{
	bool IsWithin(Critter&cr);
};

shared class Rect:IRect
{
	uint x1;
	uint y1;
	uint x2;
	uint y2;
	
	Rect(uint x1,uint y1,uint x2,uint y2)
	{
		this.x1=x1;
		this.y1=y1;
		this.x2=x2;
		this.y2=y2;
	}
	
	bool IsWithin(Critter&cr)
	{
		return((cr.HexX>=this.x1&&cr.HexX<=this.x2)&&(cr.HexY>=this.y1&&cr.HexY<=this.y2));
	}
};

shared interface IDateTime
{
	uint16 get_Year();
	uint16 get_Month();
	uint16 get_DayOfWeek();
	uint16 get_Day();
	uint16 get_Hour();
	uint16 get_Minute();
	uint16 get_Second();
	uint16 get_Milliseconds();
	string@ToString();
};                                                                                                                                                                                                                                                                                                                                                                                                                                        

import void InitLogs()from"logging";
import void FLog(uint logindex,string&text)from"logging";
import void ILog(string&section,string&text)from"logging";
import void GMLog(Critter&cr,string&text)from"logging";
import void CloseLogs()from"logging";
import uint AddLog(string&filename)from"logging";
import uint AddLog(string&filename,uint index)from"logging";                                                         

import void WLog(string&type,string&message)from"debug";
import void WLog(string&type,string&message,int level)from"debug";
import void InitDebug()from"debug";                                                                                                                                                                                       

const string@FD_Bank_Result2String(uint res)
{
	if(res==(1))
	return"FD_BANK_RESULT_SUCCESS";
	else if(res==(2))
	return"FD_BANK_RESULT_UNKNOWN";
	else if(res==(3))
	return"FD_BANK_RESULT_TOO_MANY_ACCOUNTS";
	else if(res==(4))
	return"FD_BANK_RESULT_ALREADY_HAS_ACCOUNT";
	else if(res==(5))
	return"FD_BANK_RESULT_NOT_ENOUGH_MONEY";
	else if(res==(6))
	return"FD_BANK_RESULT_BANK_FULL";
	else if(res==(7))
	return"FD_BANK_RESULT_BANK_EMPTY";
	else if(res==(8))
	return"FD_BANK_RESULT_DATA_ERROR";
	else if(res==(9))
	return"FD_BANK_RESULT_INVALID_PLAYER";
	else if(res==(10))
	return"FD_BANK_RESULT_NO_ACCOUNT";
	else
	return"FD_Result: Unknown error code";
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        

class BankAccount
{
	uint ownerId;
	int balance;
	uint loan;
	uint type;
	uint rating;
	string name;
	
	array<uint>accesslist;
	uint accesscount;
	
	Serializator serializer;
	
	bool LoadData()
	{
		serializer.Clear();
		if(!serializer.Load(name))
		return false;
		serializer.Get(ownerId).Get(balance).Get(loan).Get(type).Get(accesslist).Get(accesscount).Get(rating);
		return true;
	}
	
	bool SaveData()
	{
		serializer.Clear();
		return serializer.Set(ownerId).Set(balance).Set(loan).Set(type).Set(accesslist).Set(accesscount).Set(rating).Save(name);
	}
	
	bool Init(string name)
	{
		ownerId=balance=loan=type=rating=accesscount=0;
		this.name=name;
		
		if(!LoadData())
		return SaveData();
		return true;
	}
	
	bool AddLoan(uint amount)
	{
		loan+=amount;
		return true;
	}
	
	bool AddMoney(uint amount)
	{
		balance+=amount;
		return true;
	}
	
	bool RemoveMoney(uint amount)
	{
		balance-=amount;
		return true;
	}
	
	bool SetOwner(uint ownerId)
	{
		this.ownerId=ownerId;
		return true;
	}
	
	uint AddAccess(uint playerid)
	{
		if(GetAccountType()==(0))
		return(14);
		
		if(HasAccess(playerid))
		return(12);
		
		accesslist.insertLast(playerid);
		accesscount+=1;
		return(1);
	}
	
	uint RemoveAccess(uint playerid)
	{
		if(GetAccountType()==(0))
		return(14);
		
		if(!HasAccess(playerid))
		return(13);
		
		int index=FindInArray(accesslist,playerid);
		
		if(index==-1)
		return(9);
		else
		accesslist.removeAt(uint(index));
		
		accesscount-=1;
		return(1);
	}
	
	bool HasAccess(uint playerid)
	{
		for(uint i=0;i<accesscount;i++)
		{
			if(accesslist[i]==playerid)
			return true;
		}
		return false;
	} 
	
	uint GetAccessCount()
	{
		return accesscount;
	}
	
	uint GetOwner()
	{
		return ownerId;
	}
	
	int GetBalance()
	{
		return balance;
	}
	
	uint SetCreditRating(uint rating)
	{
		this.rating=rating;
		return(1);
	}
	
	uint GetCreditRating()
	{
		return rating;
	}
	
	uint SetLoan(uint loan)
	{
		this.loan=loan;
		return(1);
	}
	
	uint GetLoan()
	{
		return loan;
	}
	
	uint GetAccountType()
	{
		return type;
	}
	
	uint SetAccountType(uint type)
	{
		if(type>2)
		return(11);
		
		this.type=type;
		return(1);
	}
	
	uint WithdrawMoney(int amount,uint playerid)
	{
		if(amount<0)
		return(11);
		
		if(amount>balance)
		return(5);
		
		Critter@player=GetCritter(playerid);
		if(!(@player!=null))
		return(9);
		
		if(amount==0)
		return(1);
		
		player.AddItem((41),amount);
		balance-=int(amount);
		return(1);
	}
	
	uint DepositMoney(int amount,uint playerid)
	{
		if(amount<0)
		return(11);
		
		Critter@player=GetCritter(playerid);
		if(!(@player!=null))
		return(9);
		
		if(amount>int(player.CountItem((41))))
		return(5);
		
		player.DeleteItem((41),amount);
		balance+=amount;
		
		if(balance>=(1000))
		rating=(1);
		if(balance>=(10000))
		rating=(2);
		if(balance>=(100000))
		rating=(3);
		
		return(1);
	}
};    

class Bank
{
	uint owner;
	uint totalmoney;
	uint numaccounts;
	uint loaninterest;
	float savingsinterest;
	bool initialized;
	
	string name;
	
	array<BankAccount>bankaccounts;
	Serializator serializer;
	
	bool InitAccounts()
	{
		WLog("banks","Found "+GetNumberOfAccounts()+" accounts...");
		WLog("banks","Loading accounts...");
		for(uint i=0;i<GetNumberOfAccounts();i++)
		{
			BankAccount account;
			uint dataid;
			if(!account.Init(name+"_acc_"+i))
			return false;
			bankaccounts.insertLast(account);
		}
		return true;
	}  
	
	bool LoadData()
	{
		serializer.Clear();
		if(!serializer.Load(this.name))
		return false;
		serializer.Get(owner).Get(totalmoney).Get(loaninterest)
		.Get(savingsinterest).Get(initialized).Get(numaccounts);
		return true;
	} 
	
	bool SaveData()
	{
		for(uint i=0;i<bankaccounts.length();i++)
		bankaccounts[i].SaveData();
		
		serializer.Clear();
		return serializer.Set(owner).Set(totalmoney).Set(loaninterest)
		.Set(savingsinterest).Set(initialized).Set(numaccounts).Save(this.name);
	}
	
	bool Init(string name)
	{
		WLog("banks","Initializing bank with the name "+name);
		
		this.name=name;
		
		this.owner=this.totalmoney=this.numaccounts=
		this.loaninterest=this.savingsinterest=0;
		this.initialized=false;
		
		if(!LoadData())
		if(!SaveData())
		return false;
		
		if(!InitAccounts())
		return false; 
		
		if(!initialized)
		{
			if(CreateBankAccount(0)!=(1))
			return false;
			if(!AddMoney((100000)))
			return false;
			SetLoanInterest(((5)));
			SetSaveInterest(((0.5f)/2));
			
			initialized=true;
		}
		
		if(!SaveData())
		return false;
		return true;
	} 
	
	bool AddMoney(int amount)
	{
		if((totalmoney+amount)>(2147483647))
		return false;
		
		if(amount<0)
		return false;
		
		totalmoney+=amount;
		return true;
	} 
	
	bool RemoveMoney(int amount)
	{
		if((totalmoney-amount)<0)
		return false;
		
		if(amount<0)
		return false;
		
		totalmoney-=amount;
		return true;
	} 
	
	bool SetMoney(uint amount)
	{
		totalmoney=amount;
		return true;
	} 
	
	bool AccountRemoveMoney(uint accountid,int amount)
	{
		if((bankaccounts[accountid].GetBalance()-amount)<0)
		return false;
		
		if(amount<0)
		return false;
		
		return bankaccounts[accountid].RemoveMoney(amount);
	}  
	
	int GetAccountID(uint playerid)
	{
		for(uint i=0;i<GetNumberOfAccounts();i++)
		{
			if(bankaccounts[i].GetOwner()==playerid)
			return i;
		}
		return-1;
	} 
	
	int GetAccountBalance(uint account)
	{
		return bankaccounts[account].GetBalance();
	} 
	
	uint GetOwner(uint account)
	{
		return bankaccounts[account].GetOwner();
	} 
	
	bool AccountExists(uint account)
	{
		if(account<GetNumberOfAccounts())
		return true;
		return false;
	}
	
	uint GetLoanInterest()
	{
		return loaninterest;
	}
	
	uint SetLoanInterest(uint interest)
	{
		loaninterest=interest;
		return(1);
	}
	
	float GetSaveInterest()
	{
		return savingsinterest;
	}
	
	uint SetSaveInterest(float interest)
	{
		savingsinterest=interest;
		return(1);
	}
	
	uint CreateBankAccount(int playerid)
	{
		if(GetNumberOfAccounts()==(100000))
		return(3);
		
		if(GetAccountID(playerid)!=-1)
		{
			return(4);
		}
		
		WLog("banks","Creating bank account with account id "+(GetNumberOfAccounts()));
		
		BankAccount account;
		if(!account.Init(name+"_acc_"+GetNumberOfAccounts()))
		return(8);
		account.SetOwner(playerid);
		
		bankaccounts.insertLast(account);
		
		numaccounts++;
		return(1);
	}
	
	uint DepositMoney(int playerid,uint account,int amount)
	{
		if(!AccountExists(account))
		return(10);
		
		if((totalmoney+amount)>(2147483647))
		return(6);
		
		uint ret=bankaccounts[account].DepositMoney(amount,playerid);
		
		if(ret==(1))
		return this.AddMoney(amount)?(1):(8);
		else
		return ret;
	}
	
	uint WithdrawMoney(int playerid,uint account,int amount)
	{
		if(!AccountExists(account))
		return(10);
		
		if((totalmoney-amount)<0)
		return(7);
		
		uint ret=bankaccounts[account].WithdrawMoney(amount,playerid);
		
		if(ret==(1))
		{
			if(!this.RemoveMoney(amount))
			return(8);
		}
		else
		{
			return ret;
		}
		
		return(1);
	}
	
	uint TransferMoney(uint accountfrom,uint accountto,uint amount)
	{
		if((!AccountExists(accountfrom))||(!AccountExists(accountto)))
		return(10);
		
		if(amount<0)
		return(11);
		
		if(bankaccounts[accountfrom].GetBalance()<int(amount))
		return(5);
		
		if(!(bankaccounts[accountfrom].RemoveMoney(amount)))
		return(8);
		if(!(bankaccounts[accountto].AddMoney(amount)))
		return(8);
		
		return(1);
	}
	
	uint TakeLoan(uint account,uint amount)
	{
		if(GetTotalMoney()<amount)
		return(7);
		
		if(!bankaccounts[account].AddMoney(amount))
		return(8);
		if(!bankaccounts[account].AddLoan(amount))
		return(8);
		
		return(1);
	}
	
	uint GetNumberOfAccounts()
	{
		return numaccounts;
	}
	
	uint GetTotalMoney()
	{
		return totalmoney;
	} 
	
	uint GetTotalBalance()
	{
		int sum=0;
		for(uint i=0,j=GetNumberOfAccounts();i<j;i++)
		sum+=bankaccounts[i].GetBalance();
		return sum;
	}
	
	float GetReserveRatio()
	{
		float balance=GetTotalBalance();
		balance=(((0.01f)>(balance))?(0.01f):(balance));
		return float(GetTotalMoney())/balance;
	}
	
	uint SetCreditRating(uint accountid,uint rating)
	{
		return bankaccounts[accountid].SetCreditRating(rating);
	}
	
	uint GetCreditRating(uint accountid)
	{
		return bankaccounts[accountid].GetCreditRating();
	}
	
	uint SetLoan(uint accountid,uint loan)
	{
		return bankaccounts[accountid].SetLoan(loan);
	}
	
	uint GetLoan(uint accountid)
	{
		return bankaccounts[accountid].GetLoan();
	}
	
	uint GetAccountType(uint accountid)
	{
		return bankaccounts[accountid].GetAccountType();
	}
	
	uint SetAccountType(uint accountid,uint accounttype)
	{
		return bankaccounts[accountid].SetAccountType(accounttype);
	}
	
	uint AddAccess(uint accountid,uint playerid)
	{
		return bankaccounts[accountid].AddAccess(playerid);
	}
	
	uint RemoveAccess(uint accountid,uint playerid)
	{
		return bankaccounts[accountid].RemoveAccess(playerid);
	}
	
	bool HasAccess(uint accountid,uint playerid)
	{
		return bankaccounts[accountid].HasAccess(playerid);
	}
	
	uint GetAccessCount(uint accountid)
	{
		return bankaccounts[accountid].GetAccessCount();
	}
	
	bool UpdateInterestAccounts(uint startIndex,uint amount)
	{
		return true;                   
		
	}
	
	void UpdateInterest()
	{
		float ratio=GetReserveRatio();
		if(ratio<=(0.9f))
		SetSaveInterest(0.0f);
		else if(ratio>=1.0)
		SetSaveInterest((0.5f));
		else
		{
			float interests=(4.0f*ratio+(0.9f))/5.0f;
			interests=100.0f*(ratio/interests-1.0);
			if(interests>(0.5f))
			interests=(0.5f);
			SetSaveInterest(interests);
		}
	}
}; 

import int WorldmapGetTotalValue()from"worldmap";

file f;
array<int>itempids;                  

void InitEconomy()
{
	do{WLog("banks","Initializing economy...");FLog((0),"Initializing economy...");}while(false);
	
	if(!InitBanks())
	{
		
		return;
	}
	
	InitItemsLevels();
	
	do{WLog("banks","The bank in Vault City has $"+BankGetTotalMoney((0)));FLog((0),"The bank in Vault City has $"+BankGetTotalMoney((0)));}while(false);
	do{WLog("banks","The bank in Redding has $"+BankGetTotalMoney((1)));FLog((0),"The bank in Redding has $"+BankGetTotalMoney((1)));}while(false);
	do{WLog("banks","The bank in Broken Hills has $"+BankGetTotalMoney((2)));FLog((0),"The bank in Broken Hills has $"+BankGetTotalMoney((2)));}while(false);
	do{WLog("banks","The bank in San Francisco $"+BankGetTotalMoney((3)));FLog((0),"The bank in San Francisco $"+BankGetTotalMoney((3)));}while(false);
	do{WLog("banks","The bank in NCR has $"+BankGetTotalMoney((4)));FLog((0),"The bank in NCR has $"+BankGetTotalMoney((4)));}while(false);
	do{WLog("banks","The bank in Hub has $"+BankGetTotalMoney((5)));FLog((0),"The bank in Hub has $"+BankGetTotalMoney((5)));}while(false);
	do{WLog("banks","The bank in Hub has $"+BankGetTotalMoney((6)));FLog((0),"The bank in Hub has $"+BankGetTotalMoney((6)));}while(false);
	
	GameVar@var=GetGlobalVar((4000));
	if((@var!=null)&&var.GetValue()==0)
	{
		do{WLog("banks","Creating bank interest event");FLog((0),"Creating bank interest event");}while(false);
		CreateTimeEvent(((__FullSecond)+((((1)*__TimeMultiplier*86400)))),"e_UpdateInterest",true);
		var=1;
	}
	else
	{
		do{WLog("banks","Bank interest event already exists");FLog((0),"Bank interest event already exists");}while(false);
	}
	
	if(!ReadPids(itempids,true))
	do{WLog("banks","Unable to read itempids.");FLog((0),"Unable to read itempids.");}while(false);
	
	GameVar@var2=GetGlobalVar((4005));
	if(!(@var2!=null)||var2.GetValue()==0)
	{
		do{WLog("banks","Setting item prices after proto.");FLog((0),"Setting item prices after proto.");}while(false);
		InitPrices();
		
		do{WLog("banks","Creating economy event");FLog((0),"Creating economy event");}while(false);
		CreateTimeEvent(((__FullSecond)+((((1)*__TimeMultiplier*3600)))),"e_UpdateEconomy",true);
		var2=1;
	}
	else
	{
		do{WLog("banks","Economy event already exists");FLog((0),"Economy event already exists");}while(false);
	} 
	
}          

uint GetItemPrice(uint pid)
{
	return(GetLvar(pid,(4006)));
}

int GetBaseModifier(Critter&player,Critter&trader,bool buy)
{
	int traderGroup=(trader.Param[(106)]);
	
	int barter_factor=buy?((trader.Param[(215)]*25)/player.Param[(215)]):((player.Param[(215)]*25)/trader.Param[(215)]);
	barter_factor=(((barter_factor)>(25))?(25):(((barter_factor)<(0))?(0):(barter_factor)));
	
	int rep_factor=25;
	if((((trader.Param[(534)]&((0x00000010)))!=0))&&(traderGroup>=2&&traderGroup<=99))
	{
		int reputation=player.Reputation[traderGroup];
		if(player.Param[(400)]!=0&&reputation<0)
		reputation=0;
		reputation=(((reputation)>(1000))?(1000):(((reputation)<(-1000))?(-1000):(reputation)));
		rep_factor=((reputation+1000)*50)/2000;
		rep_factor=(((rep_factor)>(50))?(50):(((rep_factor)<(0))?(0):(rep_factor)));
	}
	
	if(buy)
	return 150+barter_factor-rep_factor;
	else
	return 25+barter_factor+rep_factor;
} 

int GetItemSellModifier(Critter&player,Critter&trader)
{
	return 0;
} 

int GetItemBuyModifier(Critter&player,Critter&trader)
{
	return 1;
}               

void BanksAddMoney(uint amount)
{
	uint splitted=amount/(7);
	{;};
	
	for(int i=0;i<(7);i++)
	{
		BankAddMoney(i,splitted);
	}
	BankAddMoney(Random(0,(7)-1),amount%(7));
}      

void BanksRemoveMoney(uint amount)
{
	uint splitted=amount/(7);
	do{WLog("banks","Removing $"+amount+" divided among all "+(7)+" banks");FLog((0),"Removing $"+amount+" divided among all "+(7)+" banks");}while(false);
	uint cantafford=0;
	
	for(int i=0;i<(7);i++)
	{
		if((splitted+cantafford)>BankGetTotalMoney(i))
		{
			cantafford+=splitted;
		}
		else
		{
			BankRemoveMoney(i,splitted+cantafford);
			if(cantafford>0)
			cantafford-=splitted;
		}
	}
	
	if(cantafford>0)
	{
		
		do{WLog("banks","Warning, banks can't fully remove "+amount+". Amount doesn't exists in their combined reserves");FLog((0),"Warning, banks can't fully remove "+amount+". Amount doesn't exists in their combined reserves");}while(false);
	}
}      

uint BanksGetTotalMoney()
{
	uint money=0;
	for(int i=0;i<(7);i++)
	{
		money+=BankGetTotalMoney(i);
	}
	return money;
}

bool BanksTransferToCritter(Critter&critter,uint amount,uint type,bool virtual)
{
	string reason;
	switch(type)
	{
		case((0)):
		reason="unknown";
		break;
		case((1)):
		reason="shovelling crap";
		break;
		case((2)):
		reason="selling a merc";
		break;
		default:
		reason="unknown";
		break;
	}
	
	do{WLog("banks","Transfering $"+amount+" to "+critter.Name+". Reason: "+reason);FLog((0),"Transfering $"+amount+" to "+critter.Name+". Reason: "+reason);}while(false);
	
	if(BanksGetTotalMoney()>amount)
	{
		BanksRemoveMoney(amount);
		if(virtual)
		{
			GameVar@var=GetLocalVar((4050),critter.Id);
			if((@var!=null))
			var=var.GetValue()+amount;
			else
			{
				do{WLog("banks","LVAR_virtual_money for critter with id "+critter.Id+" not valid");FLog((0),"LVAR_virtual_money for critter with id "+critter.Id+" not valid");}while(false);
			}
		}
		else
		critter.AddItem((41),amount);
	}
	else
	{
		do{WLog("banks","Not enough money to transfer $"+amount+" to "+critter.Name);FLog((0),"Not enough money to transfer $"+amount+" to "+critter.Name);}while(false);
		return false;
	}
	return true;
}

string GetTransferReason(uint type)
{
	switch(type)
	{
		case((0)):
		return"unknown";
		case((1)):
		return"shovelling crap";
		case((3)):
		return"buying a merc";
		case((4)):
		return"paying merc wage";
		case((5)):
		return"buying a base/faction";
		case((6)):
		return"buying a mine";
		case((7)):
		return"guard loot";
		default:
		return"unknown";
	}
	return"unknown";
}

uint Addpropermoney(Critter@npc)
{
	switch(npc.Param[(139)])
	{
		case 0:return(41);
		case 1:return(1212);
		case 2:return(1211);
		case 3:return(1214);
		case 4:return(1213);
		case 5:return(1215);
	}
	return(41);
	
}

bool BanksTransferFromCritter(Critter&critter,uint amount,uint type,bool virtual)
{
	string reason=GetTransferReason(type);
	do{WLog("banks","Transfering $"+amount+" to banks, from "+critter.Name+". Reason: "+reason);FLog((0),"Transfering $"+amount+" to banks, from "+critter.Name+". Reason: "+reason);}while(false);
	
	if(virtual)
	{
		GameVar@var=GetLocalVar((4050),critter.Id);
		
		if(uint(var.GetValue())<amount)
		{
			do{WLog("banks",critter.Name+" doesn't have $"+amount);FLog((0),critter.Name+" doesn't have $"+amount);}while(false);
			return false;
		}
		var-=amount;
	}
	else
	{
		if(critter.CountItem(Addpropermoney(critter))<amount)
		{
			do{WLog("banks",critter.Name+" doesn't have $"+amount);FLog((0),critter.Name+" doesn't have $"+amount);}while(false);
			return false;
		}
		critter.DeleteItem(Addpropermoney(critter),amount);
	}
	BanksAddMoney(amount);
	return true;
}        

bool BankAddMoney(uint bankid,uint amount)
{
	return banks[bankid].AddMoney(amount);
}        

bool BankRemoveMoney(uint bankid,uint amount)
{
	return banks[bankid].RemoveMoney(amount);
}        

bool BankSetMoney(uint bankid,uint amount)
{
	return banks[bankid].SetMoney(amount);
}

bool BankTransferFromCritter(uint bankId,Critter&critter,uint amount,uint type,bool virtual)
{
	string reason=GetTransferReason(type);
	do{WLog("banks","Transfering $"+amount+" to bank "+bankId+", from "+critter.Name+". Reason: "+reason);FLog((0),"Transfering $"+amount+" to bank "+bankId+", from "+critter.Name+". Reason: "+reason);}while(false);
	
	if(virtual)
	{
		GameVar@var=GetLocalVar((4050),critter.Id);
		
		if(uint(var.GetValue())<amount)
		{
			do{WLog("banks",critter.Name+" doesn't have $"+amount);FLog((0),critter.Name+" doesn't have $"+amount);}while(false);
			return false;
		}
		var-=amount;
	}
	else
	{
		if(critter.CountItem((41))<amount)
		{
			do{WLog("banks",critter.Name+" doesn't have $"+amount);FLog((0),critter.Name+" doesn't have $"+amount);}while(false);
			return false;
		}
		critter.DeleteItem((41),amount);
	}
	BankAddMoney(bankId,amount);
	return true;
}         

bool BankAccountRemoveMoney(uint bankid,uint account,uint amount)
{
	return banks[bankid].AccountRemoveMoney(account,amount);
}        

uint BankCreateAccount(uint bankid,uint playerid)
{
	Critter@cr=GetCritter(playerid);
	if((@cr!=null))
	do{WLog("banks",cr.Name+"("+playerid+") wants to create account in bank "+bankid);FLog((0),cr.Name+"("+playerid+") wants to create account in bank "+bankid);}while(false);
	
	return banks[bankid].CreateBankAccount(playerid);
}          

uint BankDepositMoney(uint bankid,uint playerid,uint account,int amount)
{
	Critter@cr=GetCritter(playerid);
	uint res=banks[bankid].DepositMoney(playerid,account,amount);
	if((@cr!=null)&&res==(1))
	do{WLog("banks",cr.Name+"("+playerid+") is depositing $"+amount+" to account "+account+" in bank "+bankid);FLog((0),cr.Name+"("+playerid+") is depositing $"+amount+" to account "+account+" in bank "+bankid);}while(false);
	return res;
}          

uint BankWithdrawMoney(uint bankid,uint playerid,uint account,int amount)
{
	Critter@cr=GetCritter(playerid);
	uint res=banks[bankid].WithdrawMoney(playerid,account,amount);
	if((@cr!=null)&&res==(1))
	do{WLog("banks",cr.Name+"("+playerid+") is withdrawing $"+amount+" from account "+account+" in bank "+bankid);FLog((0),cr.Name+"("+playerid+") is withdrawing $"+amount+" from account "+account+" in bank "+bankid);}while(false);
	return res;
}          

uint BankTransferMoney(uint bankid,uint fromaccount,uint toaccount,uint amount)
{
	return banks[bankid].TransferMoney(fromaccount,toaccount,amount);
}        

uint BankGetAccountOwner(uint bankid,uint account)
{
	return banks[bankid].GetOwner(account);
}        

int BankGetAccountBalance(uint bankid,uint account)
{
	return banks[bankid].GetAccountBalance(account);
}        

int BankGetAccountID(uint bankid,uint playerid)
{
	return banks[bankid].GetAccountID(playerid);
}        

bool BankAccountExists(uint bankid,uint account)
{
	return banks[bankid].AccountExists(account);
}         

bool BankHasAccess(uint bankid,uint account,uint playerid)
{
	return banks[bankid].HasAccess(account,playerid);
}        

uint BankGetAccessCount(uint bankid,uint account)
{
	return banks[bankid].GetAccessCount(account);
}        

uint BankGetAccountType(uint bankid,uint account)
{
	return banks[bankid].GetAccountType(account);
}         

uint BankSetAccountType(uint bankid,uint account,uint accounttype)
{
	return banks[bankid].SetAccountType(account,accounttype);
}         

uint BankSetCreditRating(uint bankid,uint account,uint rating)
{
	return banks[bankid].SetCreditRating(account,rating);
}        

uint BankGetCreditRating(uint bankid,uint account)
{
	return banks[bankid].GetCreditRating(account);
}         

uint BankSetLoan(uint bankid,uint account,uint loan)
{
	return banks[bankid].SetLoan(account,loan);
}        

uint BankGetLoan(uint bankid,uint account)
{
	return banks[bankid].GetLoan(account);
}         

uint BankAddAccess(uint bankid,uint account,uint playerid)
{
	return banks[bankid].AddAccess(account,playerid);
}         

uint BankRemoveAccess(uint bankid,uint account,uint playerid)
{
	return banks[bankid].RemoveAccess(account,playerid);
}       

uint BankGetLoanInterest(uint bankid)
{
	return banks[bankid].GetLoanInterest();
}        

uint BankSetLoanInterest(uint bankid,uint interest)
{
	return banks[bankid].SetLoanInterest(interest);
}       

float BankGetSaveInterest(uint bankid)
{
	return banks[bankid].GetSaveInterest();
}        

uint BankSetSaveInterest(uint bankid,float interest)
{
	return banks[bankid].SetSaveInterest(interest);
}       

uint BankGetTotalMoney(uint bankid)
{
	return banks[bankid].GetTotalMoney();
}       

uint BankGetTotalBalance(uint bankid)
{
	return banks[bankid].GetTotalBalance();
}       

float BankGetReserveRatio(uint bankid)
{
	return banks[bankid].GetReserveRatio();
}           

uint BankTakeLoan(uint bankid,uint account,uint amount)
{
	return banks[bankid].TakeLoan(account,amount);
}       

uint BankGetNumberOfAccounts(uint bankid)
{
	return banks[bankid].GetNumberOfAccounts();
}         

bool InitBanks()
{
	for(int i=0;i<(7);i++)
	{
		Bank bank;
		banks.insertLast(bank);
		if(!banks[i].Init("bank_"+i))
		return false;
	}
	return true;
} 

void InitPrices()
{
	for(uint i=0;i<itempids.length();i++)
	{
		uint pid=itempids[i];
		
		ProtoItem@proto=GetProtoItem(i);
		if(!(@proto!=null))
		continue;
		
		do{WLog("banks","Setting protoprice for PID "+i+" to "+proto.Cost);FLog((0),"Setting protoprice for PID "+i+" to "+proto.Cost);}while(false);
		SetLvar(i,(4006),proto.Cost);
	}
}   

void UpdatePrices()
{
	for(uint i=0;i<itempids.length();i++)
	{
		uint pid=itempids[i];
		
		ProtoItem@proto=GetProtoItem(pid);
		if(!(@proto!=null))
		continue;
		
		int price=GetLvar(pid,(4006));
		if(price==0)
		continue;
		
		uint count=1;
		uint last_count=GetLvar(pid,(4008));
		int delta=(last_count-count);
		if((delta==0)&&(count!=0))
		delta=-1;
		
		int pcost=proto.Cost;      
		
		price=(((price)>(int(proto.Cost)))?(int(proto.Cost)):(((price)<(0))?(0):(price))); 
		
		SetLvar(pid,(4006),price);
		SetLvar(pid,(4008),count);
	}
} 

uint e_UpdateInterestAccounts(array<uint>@values)
{
	
	if(banks[values[0]].UpdateInterestAccounts(values[1],(250)))
	return 0;
	values[1]+=(250);
	return(((7))*__TimeMultiplier);
}   

uint e_UpdateInterest(array<uint>@values)
{
	uint __nowZZZ=GetTick();
	do{WLog("banks","Updating bank interest");FLog((0),"Updating bank interest");}while(false);
	
	for(int i=0;i<(7);i++)
	{
		banks[i].UpdateInterest();
		uint[]data={i,0};
		CreateTimeEvent(((__FullSecond)+(((1+i)*__TimeMultiplier))),"e_UpdateInterestAccounts",data,true);
	}
	uint __endZZZ=GetTick();if(__endZZZ-__nowZZZ>40) Log("I am being executed for a very long time! ("+(__endZZZ-__nowZZZ)+" ms)");
	return(((1)*__TimeMultiplier*86400));
}

uint e_UpdateEconomy(array<uint>@values)
{
	uint __nowZZZ=GetTick();
	do{WLog("banks","Running economy update cycle.");FLog((0),"Running economy update cycle.");}while(false);
	
	array<float>ratios((7));
	for(uint i=0;i<(7);i++)
	{
		ratios[i]=BankGetReserveRatio(i);
		do{WLog("banks","Bank "+i+" ratio is "+int(1000*ratios[i]));FLog((0),"Bank "+i+" ratio is "+int(1000*ratios[i]));}while(false);
	}
	uint maxid=0;
	uint minid=0;
	
	for(uint i=1;i<(7);i++)
	{
		if(ratios[i]<ratios[minid])
		minid=i;
		if(ratios[i]>ratios[maxid])
		maxid=i;
	}
	if(maxid!=minid)
	{
		uint transfer=BankGetTotalMoney(maxid)/20;
		BankRemoveMoney(maxid,transfer);
		BankAddMoney(minid,transfer);
		do{WLog("banks","Transferring "+transfer+" from "+maxid+" to "+minid);FLog((0),"Transferring "+transfer+" from "+maxid+" to "+minid);}while(false);
	}   
	
	uint __endZZZ=GetTick();if(__endZZZ-__nowZZZ>40) Log("I am being executed for a very long time! ("+(__endZZZ-__nowZZZ)+" ms)");
	return(((1)*__TimeMultiplier*3600));
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   

import bool IsCompanion(Critter&follower)from"follower";                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

uint BonusNumber(Item@it)
{
	uint number=0;
	if(it.Val5!=0)return 5;
	else if(it.Val4!=0)return 4;
	else if(it.Val3!=0)return 3;
	else if(it.Val2!=0)return 2;
	else if(it.Val1!=0)return 1;
	else return 0;
}                        

uint GetTraderMod(Critter&trader,Item&item)
{
	return GetTraderMod(trader,item.GetProtoId());
}

uint GetTraderMod(Critter&trader,uint16 pid)
{   
	
	int appsum=ItemLevel(pid)-GetTraderLevel(trader,TradingItemType(pid));
	
	return 100-20*(((appsum)>0)?(appsum):(-(appsum)));
}

uint GetItemCost(Item&item,Critter&cr,Critter&trader,bool sell)
{
	if(cr.IsPlayer()&&(trader.IsPlayer()))
	return 0;
	float cost=0;
	uint basecost=0;   
	
	basecost=item.Cost;
	
	uint16 pid=item.GetProtoId(); 
	
	if(pid==(572))
	return basecost; 
	
	if(IsCompanion(trader))
	return basecost;
	
	uint ammocost=0;
	uint tradermod=100;
	uint tradermodammo=100;
	float tradmodBuy=1550-cr.Param[(215)];
	float tradmodSell=100+cr.Param[(215)]*3+cr.Param[(452)]*10;
	if(tradmodBuy<tradmodSell)
	tradmodBuy=tradmodSell;
	if(sell)
	cost=basecost*(tradmodSell/1000);
	else cost=basecost*(tradmodBuy/1000);
	if(item.Val1==1)
	basecost*=2;
	if(item.Val1==2)
	basecost*=3;
	if(item.Val1==3)
	basecost*=4;
	if(item.Val1==4)
	basecost*=5;
	if(item.Val1==5)
	basecost*=6;
	if(trader.ParamBase[(139)]==0)
	{
		if(trader.ParamBase[(124)]>0)
		{
			if(sell)cost=0;
			if(pid==(41))
			cost=1;
		}
		if(pid==(41))
		cost=1;
		if(pid==(1212))
		cost=0;
		if(pid==(1211))
		cost=0;
		if(pid==(1214))
		cost=0;
		if(pid==(1213))
		cost=0;
		if(pid==(1215))
		cost=0;
	}
	if(trader.ParamBase[(139)]==1)
	{
		if(trader.ParamBase[(124)]>0)
		{
			if(sell)cost=0;
			if(pid==(1212))
			cost=1;
		}
		if(pid==(41))
		cost=0;
		if(pid==(1212))
		cost=1;
		if(pid==(1211))
		cost=0;
		if(pid==(1214))
		cost=0;
		if(pid==(1213))
		cost=0;
		if(pid==(1215))
		cost=0;
	}
	if(trader.ParamBase[(139)]==2)
	{
		if(trader.ParamBase[(124)]>0)
		{
			if(sell)cost=0;
			if(pid==(1211))
			cost=1;
		}
		if(pid==(41))
		cost=0;
		if(pid==(1212))
		cost=0;
		if(pid==(1211))
		cost=1;
		if(pid==(1214))
		cost=0;
		if(pid==(1213))
		cost=0;
		if(pid==(1215))
		cost=0;
	}
	if(trader.ParamBase[(139)]==3)
	{
		if(trader.ParamBase[(124)]>0)
		{
			if(sell)cost=0;
			if(pid==(1214))
			cost=1;
		}
		if(pid==(41))
		cost=0;
		if(pid==(1212))
		cost=0;
		if(pid==(1211))
		cost=0;
		if(pid==(1214))
		cost=1;
		if(pid==(1213))
		cost=0;
		if(pid==(1215))
		cost=0;
	}
	if(trader.ParamBase[(139)]==4)
	{
		if(trader.ParamBase[(124)]>0)
		{
			if(sell)cost=0;
			if(pid==(1213))
			cost=1;
		}
		if(pid==(41))
		cost=0;
		if(pid==(1212))
		cost=0;
		if(pid==(1211))
		cost=0;
		if(pid==(1214))
		cost=0;
		if(pid==(1213))
		cost=1;
		if(pid==(1215))
		cost=0;
	}
	if(trader.ParamBase[(139)]==5)
	{
		if(trader.ParamBase[(124)]>0)
		{
			if(sell)cost=0;
			if(pid==(1215))
			cost=1;
		}
		if(pid==(41))
		cost=0;
		if(pid==(1212))
		cost=0;
		if(pid==(1211))
		cost=0;
		if(pid==(1214))
		cost=0;
		if(pid==(1213))
		cost=0;
		if(pid==(1215))
		cost=1;
	}
	if(trader.ParamBase[(139)]==6)
	{
		uint ec=trader.ParamBase[(124)];
		uint bc=trader.ParamBase[(125)];
		uint nc=trader.ParamBase[(126)];
		uint vc=trader.ParamBase[(127)];
		uint mc=trader.ParamBase[(128)];
		switch(pid)
		{
			case(41):cost=1;break;
			case(1212):cost=ec;break;
			case(1211):cost=bc;break;
			case(1214):cost=nc;break;
			case(1213):cost=vc;break;
			case(1215):cost=mc;break;
			default:
			if(sell)
			cost=0;
			else cost=basecost;
			break;
		}
	}
	if(trader.ParamBase[(139)]==7)
	{
		switch(pid)
		{
			case(41):cost=trader.ParamBase[(124)];break;
			case(1212):cost=trader.ParamBase[(125)];break;
			case(1211):cost=trader.ParamBase[(126)];break;
			case(1214):cost=trader.ParamBase[(127)];break;
			case(1213):cost=trader.ParamBase[(128)];break;
			case(1215):cost=trader.ParamBase[(129)];break;
			default:
			if(sell)
			cost=0;
			else cost=item.Val9;
			
			if(cost==0&&!sell)
			cost=basecost;
			break;
		}
	}
	if(trader.ParamBase[(139)]==8)
	{
		switch(pid)
		{
			
			case(1212):if(sell)cost=1;else cost=50;break;
			case(1211):if(sell)cost=1;else cost=50;break;
			case(1214):if(sell)cost=1;else cost=50;break;
			case(1213):if(sell)cost=1;else cost=50;break;
			case(1215):if(sell)cost=1;else cost=50;break;
			case(25572):cost=100000;break;
			default:if(sell)cost=0;else cost=basecost;break;
		}
	}
	if(pid==(25572)&&trader.ParamBase[(139)]!=7)
	cost=100000;
	if(item.GetType()==(4)&&trader.ParamBase[(89)]>203&&sell&&trader.ParamBase[(139)]!=7)
	cost=1;
	return cost;
} 

uint GetItemCostPlain(Item&item,Critter&cr,Critter&trader)
{
	if(cr.IsPlayer()&&(trader.IsPlayer()))
	return 0;
	uint16 pid=item.GetProtoId(); 
	
	if(IsCompanion(trader))
	return item.Cost;
	uint ammocost=0;
	uint tradermod=100;
	uint tradermodammo=100;
	uint cost=item.Cost;
	
	if(item.Val1==1)
	cost*=2;
	if(item.Val1==2)
	cost*=3;
	if(item.Val1==3)
	cost*=4;
	if(item.Val1==4)
	cost*=5;
	if(item.Val1==5)
	cost*=6;
	
	if(trader.ParamBase[(139)]==0)
	{
		if(pid==(41))
		cost=1;
		if(pid==(1212))
		cost=0;
		if(pid==(1211))
		cost=0;
		if(pid==(1214))
		cost=0;
		if(pid==(1213))
		cost=0;
		if(pid==(1215))
		cost=0;
	}
	if(trader.ParamBase[(139)]==1)
	{
		if(pid==(41))
		cost=0;
		if(pid==(1212))
		cost=1;
		if(pid==(1211))
		cost=0;
		if(pid==(1214))
		cost=0;
		if(pid==(1213))
		cost=0;
		if(pid==(1215))
		cost=0;
	}
	if(trader.ParamBase[(139)]==2)
	{
		if(pid==(41))
		cost=0;
		if(pid==(1212))
		cost=0;
		if(pid==(1211))
		cost=1;
		if(pid==(1214))
		cost=0;
		if(pid==(1213))
		cost=0;
		if(pid==(1215))
		cost=0;
	}
	if(trader.ParamBase[(139)]==3)
	{
		if(pid==(41))
		cost=0;
		if(pid==(1212))
		cost=0;
		if(pid==(1211))
		cost=0;
		if(pid==(1214))
		cost=1;
		if(pid==(1213))
		cost=0;
		if(pid==(1215))
		cost=0;
	}
	if(trader.ParamBase[(139)]==4)
	{
		if(pid==(41))
		cost=0;
		if(pid==(1212))
		cost=0;
		if(pid==(1211))
		cost=0;
		if(pid==(1214))
		cost=0;
		if(pid==(1213))
		cost=1;
		if(pid==(1215))
		cost=0;
	}
	if(trader.ParamBase[(139)]==5)
	{
		if(pid==(41))
		cost=0;
		if(pid==(1212))
		cost=0;
		if(pid==(1211))
		cost=0;
		if(pid==(1214))
		cost=0;
		if(pid==(1213))
		cost=0;
		if(pid==(1215))
		cost=1;
	}
	if(trader.ParamBase[(139)]==6)
	{
		uint ec=trader.ParamBase[(124)];
		uint bc=trader.ParamBase[(125)];
		uint nc=trader.ParamBase[(126)];
		uint vc=trader.ParamBase[(127)];
		uint mc=trader.ParamBase[(128)];
		switch(pid)
		{
			case(41):cost=1;break;
			case(1212):cost=ec;break;
			case(1211):cost=bc;break;
			case(1214):cost=nc;break;
			case(1213):cost=vc;break;
			case(1215):cost=mc;break;
			default:cost=item.Cost;
			break;
		}
	}
	if(trader.ParamBase[(139)]==7)
	{
		switch(pid)
		{
			case(41):cost=trader.ParamBase[(124)];break;
			case(1212):cost=trader.ParamBase[(125)];break;
			case(1211):cost=trader.ParamBase[(126)];break;
			case(1214):cost=trader.ParamBase[(127)];break;
			case(1213):cost=trader.ParamBase[(128)];break;
			case(1215):cost=trader.ParamBase[(129)];break;
			default:cost=item.Val9;if(cost==0)cost=item.Cost;
			break;
		}
	}
	if(trader.ParamBase[(139)]==8)
	{
		switch(pid)
		{
			
			case(1212):cost=50;break;
			case(1211):cost=50;break;
			case(1214):cost=50;break;
			case(1213):cost=50;break;
			case(1215):cost=50;break;
			case(25572):cost=100000;break;
			default:cost=item.Cost;break;
		}
	}
	if(pid==(25572))
	cost=100000;
	
	return cost;
}  

void SendLevelThresholds(Critter&cr)
{
	cr.RunClientScript("_ItemLevelThreshold1",0,0,0,"",LevelThreshold1);
	cr.RunClientScript("_ItemLevelThreshold2",0,0,0,"",LevelThreshold2);
} 

uint TradingItemType(Item&item)
{
	return TradingItemType(item.GetProtoId());
}

uint TradingItemType(uint pid)
{
	ProtoItem@pi=GetProtoItem(pid);
	if(!(@pi!=null))
	{
		Log("Invalid pid: "+pid);
		return(6);
	}
	uint type=pi.Type;
	switch(type)
	{
		case(3):
		{
			int skill=pi.Weapon_Skill_0;
			switch(skill)
			{
				case(200):
				return(0);
				case(201):
				return(1);
				case(202):
				return(2);
				default:
				return(6);
			}
		}
		case(4):
		switch(pid)
		{
			case(359):
			case(363):
			case(360):
			case(121):
			case(29):
			case(30):
			case(33):
			case(31):
			case(111):
			case(357):
			
			case(34):
			case(95):
			case(358):
			case(163):
			case(361):
			case(362):
			return(0);
			
			case(35):
			case(36):
			case(14):
			case(37):
			case(32):
			case(382):
			return(1);
			
			case(38):
			case(39):
			return(2);
			default:
			return(0);
		}
		case(1):
		return(3);
		case(2):
		switch(pid)
		{
			case(49):
			case(273):
			case(40):
			case(144):
			case(48):
			case(109):
			case(260):
			return(5);
			
			case(71):
			case(310):
			case(124):
			case(125):
			case(106):
			case(311):
			case(469):
			case(378):
			case(81):
			case(103):
			case(541):
			return(6);    
			
			default:
			return(4);
		}
		case(5):
		switch(pid)
		{
			case(47):
			case(408):
			case(91):
			case(409):
			case(428):
			case(440):
			return(5);
			case(73):
			case(76):
			case(80):
			case(86):
			case(102):
			case(225):
			case(228):
			case(237):
			case(331):
			case(471):
			case(22050):
			return(7);
			case(22073):
			case(22074):
			case(22075):
			case(22076):
			case(22077):
			case(22078):
			case(22079):
			case(22080):
			case(22081):
			case(22082):
			case(22083):
			case(22084):
			case(22085):
			case(22086):
			case(22087):
			case(22088):
			case(22089):
			case(22090):
			case(22091):
			case(22092):
			case(22093):
			case(22094):
			return(8);
			default:
			return(6);
		}
		default:
		return(6);
	}
	return(6);
}

array<int>LevelThreshold1((9));
array<int>LevelThreshold2((9));    

void InitItemsLevels()
{
	LevelThreshold1[((0))]=GetProtoItem((22)).Cost;LevelThreshold2[((0))]=GetProtoItem((143)).Cost;
	LevelThreshold1[((1))]=GetProtoItem((12)).Cost;LevelThreshold2[((1))]=GetProtoItem((389)).Cost;
	LevelThreshold1[((2))]=GetProtoItem((24)).Cost;LevelThreshold2[((2))]=GetProtoItem((406)).Cost;  
	
	LevelThreshold1[((3))]=GetProtoItem((2)).Cost;LevelThreshold2[((3))]=GetProtoItem((240)).Cost;
	LevelThreshold1[((4))]=GetProtoItem((87)).Cost;LevelThreshold2[((4))]=GetProtoItem((110)).Cost;
	
	LevelThreshold1[((6))]=10000000;
	LevelThreshold1[((5))]=GetProtoItem((40)).Cost;LevelThreshold2[((5))]=GetProtoItem((144)).Cost;
	LevelThreshold1[((7))]=10000000;
	LevelThreshold1[((8))]=10000000;
	
}
uint ItemLevel(Item&item)
{
	return ItemLevel(item.GetProtoId());
}

uint ItemLevel(uint pid)
{
	ProtoItem@pi=GetProtoItem(pid);
	uint itemtype=TradingItemType(pid);
	if(pi.Type==(4))
	{
		if(pid==(32))
		return 1;
		if(pid==(382))
		return 2;
		
		if(pi.Cost<GetProtoItem((36)).Cost)
		return 1;
		if(pi.Cost<GetProtoItem((33)).Cost)
		return 2;
		return 3;
	}
	if(pi.Cost<uint(LevelThreshold1[itemtype]))
	return 1;
	if(pi.Cost<uint(LevelThreshold2[itemtype]))
	return 2;
	return 3;
}   

uint GetTraderLevel(Critter@npc,uint type)
{
	return((npc.Param[(533)])>>(2*type))%4;
}

array<int>GetTraderLevels(Critter@npc)
{
	array<int>levels;
	levels.resize((9));
	for(uint i=0;i<(9);i++)
	levels[i]=GetTraderLevel(npc,i);
	return levels;
}

void SetTraderLevel(Critter@npc,uint type,uint level)
{
	uint perk=npc.Param[(533)];
	perk|=(3<<(2*type));
	perk^=(3<<(2*type));
	perk|=(level<<(2*type));
	npc.ParamBase[(533)]=perk;
}

void SetTraderLevels(Critter@npc,array<uint>&levels)
{
	if(levels.length()<(9))
	return;
	uint perk=0;
	for(int i=(9)-1;i>=0;i--)
	{
		perk<<=2;
		perk+=(levels[i])%4;
	}
	npc.ParamBase[(533)]=perk;
}

void GetTraderLevels(Critter@npc,array<uint>&levels)
{
	levels.resize((9));
	uint perk=npc.Param[(533)];
	for(int i=0;i<(9);i++)
	{
		levels[i]=perk%4;
		perk>>=2;
	}
}   

uint[]TraderBaseCapacity=
{
	0,30000,90000,150000,
	0,30000,90000,150000,
	0,30000,90000,150000,
	0,30000,90000,150000,
	0,15000,45000,75000,
	0,15000,45000,75000,
	0,15000,45000,75000,
	0,7500,22500,37500,
	0,7500,22500,37500,
};

uint[]TraderCapacityPercentage=
{
	33,33,34,
	100,0,0,
	33,67,0,
	20,30,50
};

uint TraderCapacity(Critter@npc,uint type,uint itemlevel)
{
	uint traderlevel=GetTraderLevel(npc,type);
	return(TraderBaseCapacity[4*type+traderlevel]*npc.Param[(215)]*TraderCapacityPercentage[3*traderlevel+itemlevel-1])/10000;
}

uint TraderCapacity(Critter@npc)
{
	array<uint>traderlevels;
	GetTraderLevels(npc,traderlevels);
	uint total=0;
	for(int i=0;i<(9);i++)
	total+=TraderBaseCapacity[4*i+traderlevels[i]];
	return(total*npc.Param[(215)])/100+TraderMoneyCapacity(npc);
}

uint TraderMoneyCapacity(Critter@npc)
{
	return(2*npc.Param[(215)]*npc.Param[(215)])/30;
}

array<Bank>banks;

void SaveBankData()
{
	for(uint i=0;i<banks.length();i++)
	banks[i].SaveData();
} 

array<uint16>PIDs;   

uint e_LogEconomy(array<uint>@values)
{
	uint __nowZZZ=GetTick();
	
	IDateTime@dt=GetCurrentDateTime();
	
	if(values[0]==0)
	{
		values[0]=1;
		uint __endZZZ=GetTick();if(__endZZZ-__nowZZZ>40) Log("I am being executed for a very long time! ("+(__endZZZ-__nowZZZ)+" ms)");
		return((60-dt.Minute)*__TimeMultiplier*60);
	}
	
	file f;
	f.open("logs/economy.log","a");
	
	f.writeString("; ----------------------------------------- ; ");
	f.writeString("\n; Starting economy log: "+dt.ToString());
	f.writeString("\n; @year,month,day,hour,minute");
	f.writeString("\n; pid,instances,totalCount(loop version),totalCount2(WorldItemCount),BaseItemValue(pid),totalBaseValue, number at npcs, value at npcs, number at traders, value at traders, number at players invs, value at players invs, number at logged players invs, value at logged players invs, number at followers, value at followers");
	f.writeString("\n; $BankMoney,EncounterStore");
	f.writeString("\n; ----------------------------------------- ; ");
	
	f.writeString("\n@"+dt.Year+","+dt.Month+","+dt.Day+","+dt.Hour+","+dt.Minute);
	
	for(uint i=0,len=itempids.length();i<len;i++)
	{
		uint16 pid=itempids[i];
		ProtoItem@proto=GetProtoItem(pid);
		if(!(@proto!=null))
		continue;
		if(proto.Type==(3)||
		proto.Type==(1)||
		proto.Type==(4)||
		proto.Type==(2)||
		proto.Type==(5))
		{
			array<Item@>items;
			uint totalNum=0;
			uint totalValue=0;
			uint totalTradersNum=0;
			uint totalTradersValue=0;
			uint totalNpcsNum=0;
			uint totalNpcsValue=0;
			uint totalPlayersNum=0;
			uint totalPlayersValue=0;
			uint totalLoggedPlayersNum=0;
			uint totalLoggedPlayersValue=0;
			uint totalFollowersNum=0;
			uint totalFollowersValue=0;
			uint num=GetAllItems(pid,items);
			if(num>0)
			{
				for(uint i=0;i<num;i++)
				{
					uint count=items[i].IsStackable()?items[i].GetCount():1;
					uint value=BaseItemValue(items[i]);
					totalNum+=count;
					totalValue+=value;
					if(items[i].Accessory==(1))
					{
						Critter@cr=GetCritter(items[i].CritId);
						if((@cr!=null)&&(cr.IsNpc()&&!(((cr.Param[(534)]&((0x00000020)))!=0))))
						{
							totalNpcsNum+=count;
							totalNpcsValue+=value;
						}
						if((@cr!=null)&&(cr.IsNpc()&&!(((cr.Param[(534)]&((0x00000020)))!=0)))&&(((cr.Param[(534)]&((0x00000010)))!=0)))
						{
							totalTradersNum+=count;
							totalTradersValue+=value;
						}
						if((@cr!=null)&&(((cr.Param[(534)]&((0x00000020)))!=0)))
						{
							totalFollowersNum+=count;
							totalFollowersValue+=value;
						}
						
						if((@cr!=null)&&cr.IsPlayer())
						{
							totalLoggedPlayersNum+=count;
							totalLoggedPlayersValue+=value;
						}
						if(items[i].CritId<(5000000))
						{
							totalPlayersNum+=count;
							totalPlayersValue+=value;
						}
					}
				}
			}
			
			f.writeString("\n"+pid+","+num+","+totalNum+","+WorldItemCount(pid)+","+BaseItemValue(pid,false)+","+totalValue+
			","+totalNpcsNum+","+totalNpcsValue+","+totalTradersNum+","+totalTradersValue+
			","+totalPlayersNum+","+totalPlayersValue+","+totalLoggedPlayersNum+","+totalLoggedPlayersValue+
			","+totalFollowersNum+","+totalFollowersValue);
		}
	}
	f.writeString("\n$"+BanksGetTotalMoney()+","+WorldmapGetTotalValue());
	f.writeString("\n");
	f.close();
	uint __endZZZ=GetTick();if(__endZZZ-__nowZZZ>40) Log("I am being executed for a very long time! ("+(__endZZZ-__nowZZZ)+" ms)");
	return((1)*__TimeMultiplier*3600);
}
