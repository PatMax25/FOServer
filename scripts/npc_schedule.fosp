                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

int week_patch=1;
int doubleloot=1;
bool dropchance(float chance)
{
	if(chance==0)
	return false;
	if(Random(0,100)<chance)
	return true;
	
	return false;
	
}

bool can_tc_modoc=false;
bool can_tc_klamath=false;
bool can_tc_gecko=false;
bool can_tc_bh=false;
bool can_tc_redding=false;
bool can_tc_den=false;
bool can_tc_necro=false;
bool can_tc_reno=false;

uint when_tc_modoc=0;
uint when_tc_klamath=0;
uint when_tc_gecko=0;
uint when_tc_bh=0;
uint when_tc_redding=0;
uint when_tc_den=0;
uint when_tc_necro=0;
uint when_tc_reno=0;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        

shared interface Buffer
{
	bool IsRaw(uint len);
	
	Buffer@opCom();
	
	Buffer@opNeg();                    
	
	 Buffer@opShr(int8&value); Buffer@opShl(int8 value); Buffer@Get(int8&value); Buffer@Set(int8&value);
	 Buffer@opShr(int16&value); Buffer@opShl(int16 value); Buffer@Get(int16&value); Buffer@Set(int16&value);
	 Buffer@opShr(int32&value); Buffer@opShl(int32 value); Buffer@Get(int32&value); Buffer@Set(int32&value);
	 Buffer@opShr(int64&value); Buffer@opShl(int64 value); Buffer@Get(int64&value); Buffer@Set(int64&value);
	 Buffer@opShr(uint8&value); Buffer@opShl(uint8 value); Buffer@Get(uint8&value); Buffer@Set(uint8&value);
	 Buffer@opShr(uint16&value); Buffer@opShl(uint16 value); Buffer@Get(uint16&value); Buffer@Set(uint16&value);
	 Buffer@opShr(uint32&value); Buffer@opShl(uint32 value); Buffer@Get(uint32&value); Buffer@Set(uint32&value);
	 Buffer@opShr(uint64&value); Buffer@opShl(uint64 value); Buffer@Get(uint64&value); Buffer@Set(uint64&value);
	 Buffer@opShr(bool&value); Buffer@opShl(bool value); Buffer@Get(bool&value); Buffer@Set(bool&value);
	 Buffer@opShr(string&value); Buffer@opShl(string value); Buffer@Get(string&value); Buffer@Set(string&value);
	 Buffer@opShr(float&value); Buffer@opShl(float value); Buffer@Get(float&value); Buffer@Set(float&value);
	
	 Buffer@opShr(array<int8>&value); Buffer@opShl(array<int8>&value); Buffer@Get(array<int8>&value); Buffer@Set(array<int8>&value);
	 Buffer@opShr(array<int16>&value); Buffer@opShl(array<int16>&value); Buffer@Get(array<int16>&value); Buffer@Set(array<int16>&value);
	 Buffer@opShr(array<int32>&value); Buffer@opShl(array<int32>&value); Buffer@Get(array<int32>&value); Buffer@Set(array<int32>&value);
	 Buffer@opShr(array<int64>&value); Buffer@opShl(array<int64>&value); Buffer@Get(array<int64>&value); Buffer@Set(array<int64>&value);
	 Buffer@opShr(array<uint8>&value); Buffer@opShl(array<uint8>&value); Buffer@Get(array<uint8>&value); Buffer@Set(array<uint8>&value);
	 Buffer@opShr(array<uint16>&value); Buffer@opShl(array<uint16>&value); Buffer@Get(array<uint16>&value); Buffer@Set(array<uint16>&value);
	 Buffer@opShr(array<uint32>&value); Buffer@opShl(array<uint32>&value); Buffer@Get(array<uint32>&value); Buffer@Set(array<uint32>&value);
	 Buffer@opShr(array<uint64>&value); Buffer@opShl(array<uint64>&value); Buffer@Get(array<uint64>&value); Buffer@Set(array<uint64>&value);
	 Buffer@opShr(array<bool>&value); Buffer@opShl(array<bool>&value); Buffer@Get(array<bool>&value); Buffer@Set(array<bool>&value);
	 Buffer@opShr(array<string>&value); Buffer@opShl(array<string>&value); Buffer@Get(array<string>&value); Buffer@Set(array<string>&value);
	 Buffer@opShr(array<float>&value); Buffer@opShl(array<float>&value); Buffer@Get(array<float>&value); Buffer@Set(array<float>&value);
	
	 Buffer@opShr(array<array<int8>>&value); Buffer@opShl(array<array<int8>>&value); Buffer@Get(array<array<int8>>&value); Buffer@Set(array<array<int8>>&value);
	 Buffer@opShr(array<array<int16>>&value); Buffer@opShl(array<array<int16>>&value); Buffer@Get(array<array<int16>>&value); Buffer@Set(array<array<int16>>&value);
	 Buffer@opShr(array<array<int32>>&value); Buffer@opShl(array<array<int32>>&value); Buffer@Get(array<array<int32>>&value); Buffer@Set(array<array<int32>>&value);
	 Buffer@opShr(array<array<int64>>&value); Buffer@opShl(array<array<int64>>&value); Buffer@Get(array<array<int64>>&value); Buffer@Set(array<array<int64>>&value);
	 Buffer@opShr(array<array<uint8>>&value); Buffer@opShl(array<array<uint8>>&value); Buffer@Get(array<array<uint8>>&value); Buffer@Set(array<array<uint8>>&value);
	 Buffer@opShr(array<array<uint16>>&value); Buffer@opShl(array<array<uint16>>&value); Buffer@Get(array<array<uint16>>&value); Buffer@Set(array<array<uint16>>&value);
	 Buffer@opShr(array<array<uint32>>&value); Buffer@opShl(array<array<uint32>>&value); Buffer@Get(array<array<uint32>>&value); Buffer@Set(array<array<uint32>>&value);
	 Buffer@opShr(array<array<uint64>>&value); Buffer@opShl(array<array<uint64>>&value); Buffer@Get(array<array<uint64>>&value); Buffer@Set(array<array<uint64>>&value);
	 Buffer@opShr(array<array<bool>>&value); Buffer@opShl(array<array<bool>>&value); Buffer@Get(array<array<bool>>&value); Buffer@Set(array<array<bool>>&value);
	 Buffer@opShr(array<array<string>>&value); Buffer@opShl(array<array<string>>&value); Buffer@Get(array<array<string>>&value); Buffer@Set(array<array<string>>&value);
	 Buffer@opShr(array<array<float>>&value); Buffer@opShl(array<array<float>>&value); Buffer@Get(array<array<float>>&value); Buffer@Set(array<array<float>>&value);
	
	 Buffer@opShr(array<array<array<int8>>>&value); Buffer@opShl(array<array<array<int8>>>&value); Buffer@Get(array<array<array<int8>>>&value); Buffer@Set(array<array<array<int8>>>&value);
	 Buffer@opShr(array<array<array<int16>>>&value); Buffer@opShl(array<array<array<int16>>>&value); Buffer@Get(array<array<array<int16>>>&value); Buffer@Set(array<array<array<int16>>>&value);
	 Buffer@opShr(array<array<array<int32>>>&value); Buffer@opShl(array<array<array<int32>>>&value); Buffer@Get(array<array<array<int32>>>&value); Buffer@Set(array<array<array<int32>>>&value);
	 Buffer@opShr(array<array<array<int64>>>&value); Buffer@opShl(array<array<array<int64>>>&value); Buffer@Get(array<array<array<int64>>>&value); Buffer@Set(array<array<array<int64>>>&value);
	 Buffer@opShr(array<array<array<uint8>>>&value); Buffer@opShl(array<array<array<uint8>>>&value); Buffer@Get(array<array<array<uint8>>>&value); Buffer@Set(array<array<array<uint8>>>&value);
	 Buffer@opShr(array<array<array<uint16>>>&value); Buffer@opShl(array<array<array<uint16>>>&value); Buffer@Get(array<array<array<uint16>>>&value); Buffer@Set(array<array<array<uint16>>>&value);
	 Buffer@opShr(array<array<array<uint32>>>&value); Buffer@opShl(array<array<array<uint32>>>&value); Buffer@Get(array<array<array<uint32>>>&value); Buffer@Set(array<array<array<uint32>>>&value);
	 Buffer@opShr(array<array<array<uint64>>>&value); Buffer@opShl(array<array<array<uint64>>>&value); Buffer@Get(array<array<array<uint64>>>&value); Buffer@Set(array<array<array<uint64>>>&value);
	 Buffer@opShr(array<array<array<bool>>>&value); Buffer@opShl(array<array<array<bool>>>&value); Buffer@Get(array<array<array<bool>>>&value); Buffer@Set(array<array<array<bool>>>&value);
	 Buffer@opShr(array<array<array<string>>>&value); Buffer@opShl(array<array<array<string>>>&value); Buffer@Get(array<array<array<string>>>&value); Buffer@Set(array<array<array<string>>>&value);
	 Buffer@opShr(array<array<array<float>>>&value); Buffer@opShl(array<array<array<float>>>&value); Buffer@Get(array<array<array<float>>>&value); Buffer@Set(array<array<array<float>>>&value);
	
	 Buffer@opUShr(array<int8>&arr); Buffer@opUShrAssign(array<int8>&arr); array<int8>AsInt8();
	 Buffer@opUShr(array<int16>&arr); Buffer@opUShrAssign(array<int16>&arr); array<int16>AsInt16();
	 Buffer@opUShr(array<int32>&arr); Buffer@opUShrAssign(array<int32>&arr); array<int32>AsInt32();
	 Buffer@opUShr(array<int64>&arr); Buffer@opUShrAssign(array<int64>&arr); array<int64>AsInt64();
	 Buffer@opUShr(array<uint8>&arr); Buffer@opUShrAssign(array<uint8>&arr); array<uint8>AsUint8();
	 Buffer@opUShr(array<uint16>&arr); Buffer@opUShrAssign(array<uint16>&arr); array<uint16>AsUint16();
	 Buffer@opUShr(array<uint32>&arr); Buffer@opUShrAssign(array<uint32>&arr); array<uint32>AsUint32();
	 Buffer@opUShr(array<uint64>&arr); Buffer@opUShrAssign(array<uint64>&arr); array<uint64>AsUint64();
};  

import Buffer@NewBuffer()from"buffer";    

 import Buffer@NewBuffer(array<int8>@data)from"buffer";
 import Buffer@NewBuffer(array<int16>@data)from"buffer";
 import Buffer@NewBuffer(array<int32>@data)from"buffer";
 import Buffer@NewBuffer(array<int64>@data)from"buffer";
 import Buffer@NewBuffer(array<uint8>@data)from"buffer";
 import Buffer@NewBuffer(array<uint16>@data)from"buffer";
 import Buffer@NewBuffer(array<uint32>@data)from"buffer";
 import Buffer@NewBuffer(array<uint64>@data)from"buffer";                                 

import void WLog(string&type,string&message)from"debug";
import void WLog(string&type,string&message,int level)from"debug";
import void InitDebug()from"debug";                                                                                                                                                                                                                                                                                                                                                                                                                       

import Location@GetLocationOf(Critter&critter)from"utils";
import string GetLocationName(uint locId)from"utils";
import string GetLocationName(Location@loc)from"utils";
import bool ReadPids(array<int>&out pids,bool removeinvalid)from"utils";
import void ReadDefines(string@fileName,dictionary&items,array<string>@defines)from"utils";
import bool ParseDefine(const string&in line,string&out spid,int&out id)from"utils";
import int SkipWhitespaces(const string&in str,int start)from"utils";
import int SkipNonWhitespaces(const string&in str,int start)from"utils";
import bool IsParameterTag(string&str)from"utils";
import string GetParameterString(array<string@>@arr,string&parameter)from"utils";
import int GetIndexOfString(array<string@>@arr,string&str)from"utils";
import string GetConcatenatedString(array<string@>@arr,uint startindex,int stopindex)from"utils";
import string GetConditionOfCritter(Critter@cr)from"utils";
import string GetExtConditionOfCritter(Critter@cr)from"utils";
import uint GetAllOnlinePlayers(array<Critter@>&out players)from"utils";
import uint GetAuthenticatedPlayers(array<Critter@>&out players)from"utils";
import uint GetAuthenticatedPlayers(array<Critter@>&out players,bool ignorePriviledges)from"utils";
import uint GetNumberOfPlayersOnline()from"utils";
import void SetTurnBasedAvailability(Location@loc)from"utils";
import bool IsGuarded(Map@map)from"utils";
import bool IsPublic(Map@map)from"utils";
import bool IsEncounterMap(Map@map)from"utils";
import bool IsTown(Map@map)from"utils";
import bool IsDungeon(Map@map)from"utils";
import bool IsBaseControl(Map@map)from"utils";

import uint GetMapType(Map@map)from"utils";
import void LockDoor(uint x,uint y,Map@map,uint complexity,uint lockid)from"utils";
import void UnlockDoor(uint x,uint y,Map@map)from"utils";
import void ClearContainer(Item@container)from"utils";
import void MoveItemsCritterToCont(Critter&crFrom,Item&contTo,uint specid)from"utils";
import string GetCritterInfo(Critter&cr)from"utils";
import bool AddExpTeam(Critter&critter,int xp)from"utils";
import void ClearEnemyStack(Critter&critter)from"utils";
import void ClearEnemyStacksOnMap(Map@map)from"utils";
import bool IsCurrentEnemy(Critter&cr,uint targetId)from"utils";
import string@GetSafePlayerName(uint id)from"utils";
import string GetSafePlayerName(uint id,string&onSuccess,string&onError)from"utils";
import IDateTime@GetCurrentDateTime()from"utils";
import string GetCurrentDateTimeString()from"utils";
import string GetCurrentDateTimeString(bool date,bool time)from"utils";
import Critter@GetMostSkilled(array<Critter@>@group,int skill)from"utils";
import string GetAuthString(Critter&player)from"utils";
import string GetAuthString(int accesslevel)from"utils";
import bool CanRequestHelp(Critter&player)from"utils";
import void SetRequestedHelp(Critter&player)from"utils";
import void SetRequestedHelp(Critter&player,int minutes)from"utils";
import Critter@GetOnlineGM()from"utils";
import void Preprocess(Critter&player,string&commandString)from"utils";
import bool IsHumanoid(Critter@cr)from"utils";
import uint GetGroupIndex(Critter&cr)from"utils";
import uint GetGroupIndex(int st)from"utils";
import void SetGroupIndex(Critter&cr,uint val)from"utils";
import uint GetGroupRank(Critter&cr)from"utils";
import void SetGroupRank(Critter&cr,uint val)from"utils";
import uint GetGroupMode(Critter&cr)from"utils";
import void SetGroupMode(Critter&cr,uint val)from"utils";
import void SetGroupInfo(Critter&cr,uint faction,uint rank,uint mode)from"utils";
import void SetGroupInfoPack(Critter&cr,uint packInfo)from"utils";
import void ClearEvents(Critter&cr)from"utils";

import int GetGvar(uint gvar)from"utils";
import void SetGvar(uint gvar,uint value)from"utils";
import int GetLLvar(Location&location,uint llvar)from"utils";
import int GetLLvar(uint locationId,uint llvar)from"utils";
import void SetLLvar(Location&location,uint llvar,uint value)from"utils";
import int GetLMvar(Map&map,uint llvar)from"utils";
import int GetLMvar(uint mapId,uint llvar)from"utils";
import void SetLMvar(Map&map,uint llvar,uint value)from"utils";
import int GetLIvar(Item&item,uint llvar)from"utils";
import int GetLIvar(uint itemId,uint llvar)from"utils";
import void SetLIvar(Item&item,uint llvar,uint value)from"utils";
import int GetLvar(Critter&critter,uint lvar)from"utils";
import int GetLvar(uint id,uint lvar)from"utils";
import void SetLvar(Critter&critter,uint lvar,uint value)from"utils";
import void SetLvar(uint id,uint lvar,uint value)from"utils";
import int GetUvar(uint uvar,uint key,uint index)from"utils";
import void SetUvar(uint uvar,uint key,uint index,uint value)from"utils";

import uint GetContainerValue(Item@container)from"utils";
import uint BaseItemValue(uint pid,bool ammo)from"utils";
import uint BaseItemValue(uint pid,uint broken,uint det,bool ammo)from"utils";
import uint BaseItemValue(Item@item)from"utils";
import uint BaseItemValue(Item@item,uint proc)from"utils";
import uint BaseSingleItemValue(Item@item)from"utils";
import uint BaseSingleItemValue(Item@item,uint proc)from"utils";

import void SetBloodType(Critter@cr)from"utils";
import string GetBloodType(Critter@cr)from"utils";
import string GetBloodRandom()from"utils";

import void LogCommandUsage(Critter&player,string&commandString)from"utils";
import void DropTimeouts(Critter&cr)from"utils";

import bool HasItem(Critter@cr,uint pid)from"utils";
import bool HasSomeWeapon(Critter@cr)from"utils";
import uint GetBestWeaponSkill(Critter@cr)from"utils";
import void GiveBag(uint bag,Critter@cr)from"utils";
import void SetQuestGarbager(uint time,uint playerid,uint locid,uint var,uint val)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,uint factionRank,uint factionMode,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,array<int>params,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,array<int>params,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,uint factionRank,uint factionMode,bool isMob,uint level)from"utils";
import void AddScore(Critter@cr,uint score,uint points)from"utils";

import bool ReloadWeapon(Critter&cr)from"utils";
import Item@GetRadio(Critter&cr)from"utils";
import Item@GetRepairTool(Critter&cr)from"utils";
import Item@GetEquippedItem(Critter&cr,uint Pid)from"utils";
import Item@GetEquippedItem(Critter&cr,array<uint>&Pids)from"utils";
import Item@GetEquippedItemByType(Critter&cr,uint ItemType)from"utils"; 

import bool SkillRoll(Critter@cr,int skill,int bonus)from"utils";
import int SkillCheck(Critter&cr,int skill,int skillused,Item@item,int bonus)from"utils";
import string SkillName(uint8 skill)from"utils";
import void ChangeCrTypeSafe(Critter&cr,uint8 crType)from"utils";

import bool Pickable(Item@item)from"utils";

import void TransferItemsToContOnMap(Critter&cr,Map@map,int entid,int contpid,int itemtypes)from"utils";
import void TransferItemsFromContOnMap(Critter&cr,Map@map,int entid,int contpid)from"utils";

import string IpToString(uint ip)from"utils";

import void VerboseAction(Critter&cr,string&text)from"utils";
import void VerboseAction(Critter&cr,Critter&target,string&text)from"utils";
import void VerboseExperience(Critter&cr,int xpDiff,int levelDiff)from"utils";

import void SetChosenActions(Critter&cr,array<int>&actions)from"utils";

import void HexLine(uint16 x0,uint16 y0,uint16 x1,uint16 y1,array<uint16>@xList,array<uint16>@yList)from"utils";
import void HexCircle(uint16 x0,uint16 y0,uint16 radius,array<uint16>@xList,array<uint16>@yList)from"utils";

import void StartPersonalDataCleanup()from"utils";

import bool IsPersonalData(Location&location,string&name)from"utils";
import bool GetPersonalData(Location&location,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Location&location,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Location&location,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Location&location,string&name)from"utils";

import bool IsPersonalData(Map&map,string&name)from"utils";
import bool GetPersonalData(Map&map,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Map&map,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Map&map,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Map&map,string&name)from"utils";

import bool IsPersonalData(Critter&critter,string&name)from"utils";
import bool GetPersonalData(Critter&critter,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Critter&critter,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Critter&critter,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Critter&critter,string&name)from"utils";

import bool IsPersonalData(Item&item,string&name)from"utils";
import bool GetPersonalData(Item&item,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Item&item,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Item&item,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Item&item,string&name)from"utils";

import bool FindPreferredGridApprox(Map&map,uint16&hx,uint16&hy)from"utils";           

import bool StrToInt(string@s,uint64&inout val)from"strtoint";
import bool StrToInt(string@s,uint&inout val)from"strtoint";
import bool StrToInt(string@s,uint16&inout val)from"strtoint";
import bool StrToInt(string@s,uint8&inout val)from"strtoint";
import bool StrToInt(string@s,int64&inout val)from"strtoint";
import bool StrToInt(string@s,int16&inout val)from"strtoint";
import bool StrToInt(string@s,int8&inout val)from"strtoint";    

import int FindInArray(array<int>&arr,int value)from"utils";
import int FindInArray(array<uint>&arr,uint value)from"utils";
import int FindInArray(array<uint16>&arr,uint16 value)from"utils";
import int FindInArray(array<uint8>&arr,uint8 value)from"utils";
import bool FindInArray(array<int>&arr,int id,int&index)from"utils";
import bool FindInArray(array<uint>&arr,uint id,int&index)from"utils";
import bool FindInArray(array<uint8>&arr,uint8 id,int&index)from"utils";
import int FindInArray(array<string>&arr,string&value)from"utils";
import int FindInArray(array<string@>@arr,string&value)from"utils";
import bool Present(int what,array<int>&where)from"utils";
import bool Present(uint what,array<uint>&where)from"utils";
import bool Present(uint16 what,array<uint16>&where)from"utils";
import bool Present(string&what,array<string>&where)from"utils";
import bool Present(string&what,array<string@>@where)from"utils";

import uint CreateLocationForGroup(Critter&player,uint16 pid,uint16 worldX,uint16 worldY,array<Critter@>&)from"utils";
import bool FindFirstFreeHex(Map@map,uint16&x,uint16&y,uint8 dir,uint16 maxSteps)from"utils";
import bool FindNearestFreeHex(Map&map,uint16&x,uint16&y,uint radius)from"utils";

import bool GetItemCoordinates(Item&item,uint&mapID,uint16&x,uint16&y)from"utils";
import bool ItemOnHex(uint16 pid,Map@map,uint16 x,uint16 y)from"utils";

import void PrintCallstack()from"utils";
import void PrintCallstack(int level)from"utils";

import bool LocationHasCritters(Location&loc,uint findType)from"utils";
import uint LocationGetCritters(Location&loc,uint findType,array<Critter@>@critters)from"utils";
import uint LocationGetPlayersAndFollowers(Location&loc,uint findType,array<Critter@>@critters)from"utils";
import uint MapGetPlayersAndFollowers(Map&map,uint findType,array<Critter@>@critters)from"utils";
import uint CritterGetPlayersAndFollowers(Critter&critter,bool lookOnMe,uint findType,array<Critter@>@critters)from"utils";
import bool LocationHasItems(Location&loc,uint16 protoId)from"utils";
import uint LocationGetItems(Location&loc,uint16 protoId,array<Item@>@items)from"utils";
import void LocationDeleteItems(Location&loc,uint16 protoId)from"utils";

import bool IsDisposableEncounter(Location@loc)from"utils";

import bool IsT4Item(Item&item)from"utils";
import bool IsT3Item(Item&item)from"utils";
import uint16 AddT3Item()from"utils";
import uint16 AddT4Item()from"utils";
import uint16 AddImplant()from"utils";
import uint16 AddT4BP()from"utils";
import uint16 AddRareAmmo()from"utils";
import uint16 AddTypicalAmmo()from"utils";

import void SetDeterioration(Item&item)from"utils";  

shared class CPosition
{
	uint x;
	uint y;
	uint dir;
};

shared interface IRect
{
	bool IsWithin(Critter&cr);
};

shared class Rect:IRect
{
	uint x1;
	uint y1;
	uint x2;
	uint y2;
	
	Rect(uint x1,uint y1,uint x2,uint y2)
	{
		this.x1=x1;
		this.y1=y1;
		this.x2=x2;
		this.y2=y2;
	}
	
	bool IsWithin(Critter&cr)
	{
		return((cr.HexX>=this.x1&&cr.HexX<=this.x2)&&(cr.HexY>=this.y1&&cr.HexY<=this.y2));
	}
};

shared interface IDateTime
{
	uint16 get_Year();
	uint16 get_Month();
	uint16 get_DayOfWeek();
	uint16 get_Day();
	uint16 get_Hour();
	uint16 get_Minute();
	uint16 get_Second();
	uint16 get_Milliseconds();
	string@ToString();
};                                                     

import bool IsNight()from"world_common";
import bool IsDay()from"world_common";
import bool IsMorning()from"world_common";
import bool IsAfternoon()from"world_common";
import bool IsEvening()from"world_common";
import bool IsHospital(Map@map)from"world_common";
import bool IsCave(Map@map)from"world_common";
import bool IsMine(Map@map)from"world_common";
import bool IsJail(Map@map)from"world_common";
import bool IsBase(Map@map)from"world_common";
import bool IsTent(Map@map)from"world_common";
import bool IsWarzone(Map@map)from"world_common";              

class CNpcScheduleInstance:INpcScheduleInstance
{
	CNpcSchedule@prototype;
	uint prototypePID;
	
	uint ownerId;
	
	bool firstCall;
	
	CNpcTaskInstance@currentTask;
	array<CNpcTaskInstance@>tasks;
	array<CNpcTaskInstance@>tasksQueue;
	
	CNpcScheduleInstance()
	{
		this.Init();
	}
	
	CNpcScheduleInstance(CNpcSchedule&prototype,Critter&owner)
	{
		this.Init();
		
		this.ownerId=owner.Id;
		this.SetPrototype(prototype);
	}
	
	void Init()
	{
		this.prototypePID=this.ownerId=0;
		@this.prototype=null;
		
		this.firstCall=true;
		
		@this.currentTask=null;
		this.tasks.resize(0);
		this.tasksQueue.resize(0);
	} 
	
	INpcSchedule@get_Prototype()
	{
		return(this.prototype);
	}
	
	uint get_Owner()
	{
		return(this.ownerId);
	}
	
	string get_FullName()
	{
		return(this.prototype.Name+"["+this.prototype.PID+","+this.Owner+"]");
	} 
	
	void SetPrototype(CNpcSchedule&proto)
	{
		@this.currentTask=null;
		this.tasks.resize(0);
		this.tasksQueue.resize(0);
		
		@this.prototype=proto;
		this.prototypePID=this.prototype.PID;
		
		for(uint t=0,tLen=this.prototype.tasks.length();t<tLen;t++)
		{
			CNpcTaskInstance@instance=CNpcTaskInstance(this.prototype.tasks[t]);
			instance.state=TASKSTATE_READY;
			instance.idx=t;
			
			this.tasks.insertLast(instance);
		}
	}
	
	uint Run(Critter&npc)
	{
		if(this.firstCall)
		{
			for(uint t=0,tLen=this.tasks.length();t<tLen;t++)
			{
				if(this.tasks[t].state==TASKSTATE_READY&&
				this.tasks[t].prototype.type==TASK_FIRST_CALL)
				{
					WLog("npc_schedule","Task '"+this.tasks[t].prototype.Name+"' added to queue (first call): "+this.tasks[t].prototype.FullName,0);
					this.tasks[t].state=TASKSTATE_STARTING;
					this.tasksQueue.insertLast(this.tasks[t]);
				}
			}
			
			this.firstCall=false;
		}
		
		if((@this.currentTask!=null))
		{ 
			
			if(this.currentTask.state==TASKSTATE_FINISHED)
			{
				if((__FullSecond)>=this.currentTask.lastRun+((1)*60))
				{
					WLog("npc_schedule","Task '"+this.currentTask.prototype.Name+"' finished : "+this.currentTask.prototype.FullName,0);
					this.currentTask.state=TASKSTATE_READY;
					@this.currentTask=null;
				}
			}
			else if(this.currentTask.state==TASKSTATE_STARTING)
			{
				WLog("npc_schedule","Task '"+this.currentTask.prototype.Name+"' started : "+this.currentTask.prototype.FullName,0);
				
				this.currentTask.Start();
				this.currentTask.state=TASKSTATE_RUNNING;
			}
			
			if((@this.currentTask!=null)&&this.currentTask.state==TASKSTATE_RUNNING)
			{
				if((__FullSecond)>=this.currentTask.lastRun+this.currentTask.waitTime)
				{
					this.currentTask.Run(npc);
					this.currentTask.lastRun=(__FullSecond);
				}
			}
		}
		else
		{
			
			if(this.tasksQueue.length()>0)
			{
				WLog("npc_schedule","Task '"+this.tasksQueue.first().prototype.Name+"' removed from queue : "+this.tasksQueue.first().prototype.FullName,0);
				
				@this.currentTask=this.tasksQueue.first();
				this.tasksQueue.removeFirst();
				
				this.currentTask.state=TASKSTATE_STARTING;
			}
		}  
		
		for(uint t=0,tLen=this.tasks.length();t<tLen;t++)
		{
			if(this.tasks[t].prototype.type==TASK_FIRST_CALL)
			continue;
			
			if(this.tasks[t].state==TASKSTATE_SKIP)
			{
				WLog("npc_schedule","Task skipped : "+tasks[t].prototype.FullName,0);
				continue;
			}
			
			if(this.tasks[t].state==TASKSTATE_READY)
			{
				bool add=false;
				
				if(this.tasks[t].prototype.Type==TASK_TIME)
				{
					if(this.tasks[t].prototype.Hours.length()==this.tasks[t].prototype.Minutes.length())
					{
						for(uint h=0,hLen=this.tasks[t].prototype.Hours.length();h<hLen;h++)
						{
							if(this.tasks[t].prototype.Hours[h]==__Hour&&
							this.tasks[t].prototype.Minutes[h]==__Minute)
							{
								add=true;
								break;
							}
						}
					}
				}
				else if(this.tasks[t].prototype.Type==TASK_HOUR)
				{
					for(uint h=0,hLen=this.tasks[t].prototype.Hours.length();h<hLen;h++)
					{
						if(this.tasks[t].prototype.Hours[h]==__Hour)
						{
							add=true;
							break;
						}
					}
				}
				else if(this.tasks[t].prototype.Type==TASK_MINUTE)
				{
					for(uint m=0,mLen=this.tasks[t].prototype.Minutes.length();m<mLen;m++)
					{
						if(this.tasks[t].prototype.Minutes[m]==__Minute)
						{
							add=true;
							break;
						}
					}
				}
				else if(this.tasks[t].prototype.Type==TASK_NIGHT)
				{
					add=IsNight();
				}
				else if(this.tasks[t].prototype.Type==TASK_DAY)
				{
					add=IsDay();
				}
				else if(this.tasks[t].prototype.Type==TASK_MORNING)
				{
					add=IsMorning();
				}
				else if(this.tasks[t].prototype.Type==TASK_AFTERNOON)
				{
					add=IsAfternoon();
				}
				else if(this.tasks[t].prototype.Type==TASK_EVENING)
				{
					add=IsEvening();
				}
				else if(this.tasks[t].prototype.Type==TASK_IDLE)
				{
					add=(!(@this.currentTask!=null)&&this.tasksQueue.length()==0);
				}
				else
				{
					WLog("npc_schedule","Unknown task type<"+this.tasks[t].prototype.Type+"> : "+this.tasks[t].prototype.FullName,10);
				}
				
				if(add&&(this.tasks[t].prototype.roll==uint(-1)||Random(0,this.tasks[t].prototype.roll)==0))
				{
					WLog("npc_schedule","Task '"+this.tasks[t].prototype.Name+"' added to queue : "+this.tasks[t].prototype.FullName,0);
					this.tasks[t].state=TASKSTATE_STARTING;
					this.tasksQueue.insertLast(this.tasks[t]);
				}
			}
		}
		
		if((@this.currentTask!=null)&&currentTask.nextRun>0)
		{
			uint next=currentTask.nextRun;
			currentTask.nextRun=0;
			return(next);
		}
		return(((10)));
	}
	
	void Save(Buffer&buffer)
	{
		buffer<<this.prototype.PID<<this.ownerId;
		buffer<<this.tasks.length();
		if(this.tasks.length()>0)
		{
			for(uint t=0,tLen=this.tasks.length();t<tLen;t++)
			{
				this.tasks[t].Save(buffer);
			}
		}
		buffer<<((@this.currentTask!=null)?this.currentTask.idx:uint(-1));
		buffer<<this.tasksQueue.length();
		if(this.tasksQueue.length()>0)
		{
			for(uint t=0,tLen=this.tasksQueue.length();t<tLen;t++)
			{
				buffer<<this.tasksQueue[t].idx;
			}
		}
	}
	
	bool Load(Buffer&buffer)
	{
		buffer>>this.prototypePID>>this.ownerId;
		
		WLog("npc_schedule","Loading schedule instance, "+this.prototypePID+", "+this.ownerId,0);
		
		CNpcSchedule@proto=GetSchedulePrototype(this.prototypePID);
		if((@proto!=null))
		this.SetPrototype(proto);
		
		uint tasksLength=0;
		buffer>>tasksLength;
		
		for(uint t=0;t<tasksLength;t++)
		{
			if(t>=this.tasks.length())
			{
				WLog("npc_schedule","Invalid tasks length : "+tasksLength+" vs "+this.tasks.length(),30);
				return(false);
			}
			
			WLog("npc_schedule","Loading task instance #"+t,0);
			this.tasks[t].Load(buffer);
		}
		
		uint currentTaskIdx=0;
		buffer>>currentTaskIdx;
		if(currentTaskIdx!=uint(-1)&&currentTaskIdx<this.tasks.length())
		{
			WLog("npc_schedule","Current task: "+currentTaskIdx,0);
			@this.currentTask=this.tasks[currentTaskIdx];
		}
		
		uint tasksQueueLength=0;
		buffer>>tasksQueueLength;
		WLog("npc_schedule","Queued tasks: "+tasksQueueLength,0);
		if(tasksQueueLength>0)
		{
			for(uint t=0;t<tasksQueueLength;t++)
			{
				uint taskIdx=uint(-1);
				buffer>>taskIdx;
				if(taskIdx!=uint(-1)&&taskIdx<this.tasks.length())
				{
					WLog("npc_schedule","Queued task idx: "+taskIdx,0);
					tasksQueue.insertLast(this.tasks[taskIdx]);
				}
			}
		}
		
		return(true);
	}
};

class CNpcTaskInstance:INpcTaskInstance
{
	CNpcTask@prototype;
	
	uint idx;
	
	NpcTaskState state;
	
	uint lastRun;
	uint nextRun;
	uint waitTime;
	
	array<CNpcTaskAction@>actionsQueue;
	array<bool>ifs;
	
	array<CNpcTaskInstanceData@>data;
	
	CNpcTaskInstance(CNpcTask&task)
	{
		@this.prototype=task;
		this.idx=uint(-1);
		this.state=TASKSTATE_SKIP;
		
		this.lastRun=this.nextRun=this.waitTime=0;
		
		this.actionsQueue.resize(0);
		this.ifs.resize(0);
		this.data.resize(0);
	} 
	
	uint get_WaitTime()
	{
		return(this.waitTime);
	}
	
	void set_WaitTime(uint value)
	{
		this.waitTime=value;
	} 
	
	void SetData(string&name,array<uint8>&data)
	{
		for(uint d=0,dLen=this.data.length();d<dLen;d++)
		{
			if(strlwr(this.data[d].name)==strlwr(name))
			{
				this.data[d].data=data;
				return;
			}
		}
		
		CNpcTaskInstanceData@newData=CNpcTaskInstanceData(name,data);
		this.data.insertLast(newData);
	}
	
	bool GetData(string&name,array<uint8>&outData)
	{
		for(uint d=0,dLen=this.data.length();d<dLen;d++)
		{
			if(strlwr(this.data[d].name)==strlwr(name))
			{
				outData=this.data[d].data;
				return(true);
			}
		}
		
		return(false);
	}
	
	void ClearData(string&name)
	{
		for(uint d=0,dLen=this.data.length();d<dLen;d++)
		{
			if(strlwr(this.data[d].name)==strlwr(name))
			{
				this.data.removeAt(d);
			}
		}
	}
	
	void Start()
	{
		this.waitTime=0;
		this.actionsQueue=this.prototype.actions;
		this.ifs.resize(0);
	}
	
	void Finish()
	{
		this.waitTime=0;
		this.actionsQueue.resize(0);
		this.ifs.resize(0);
	}
	
	void Run(Critter&npc)
	{
		bool onMap=((@npc.GetMap()!=null));
		this.waitTime=0;
		
		if(this.lastRun==0)
		{
			if(npc.IsNpc())
			npc.ErasePlane(-1,true);
			npc.SetHomePos(npc.HexX,npc.HexY,npc.Dir);
		}
		
		if(this.actionsQueue.length()==0)
		{
			this.state=TASKSTATE_FINISHED;
			return;
		}
		
		CNpcTaskAction@action=this.actionsQueue.first(); 
		
		bool finished=true;
		if(action.Type==ACTION_IF||action.Type==ACTION_ENDIF)
		{
			if(action.Type==ACTION_IF)
			{
				bool result=action.function(action,this,npc);
				this.ifs.insertLast(result);
			}
			else if(action.Type==ACTION_ENDIF)
			this.ifs.removeLast();
			
			finished=true;
			this.nextRun=((1));
		}
		else if(this.ifs.length()>0)
		{
			if(this.ifs.last()==true)
			{
				if(!action.requireMap||(action.requireMap&&onMap))
				finished=action.function(action,this,npc);
				else
				{
					WLog("npc_schedule","Action<"+action.Type+"> skipped : not on map",0);
					this.nextRun=((1));
				}
			}
			else
			this.nextRun=((1));
		}
		else
		{
			if(!action.requireMap||(action.requireMap&&onMap))
			finished=action.function(action,this,npc);
			else
			{
				WLog("npc_schedule","Action<"+action.Type+"> skipped : not on map",0);
				this.nextRun=((1));
			}
		}
		
		if(finished)
		this.actionsQueue.removeFirst();
	}
	
	void Save(Buffer&buffer)
	{
		uint dataLength=this.data.length();
		buffer<<int(this.state)<<this.lastRun<<this.nextRun<<this.waitTime;
		buffer<<dataLength;
		for(uint d=0;d<dataLength;d++)
		{
			this.data[d].Save(buffer);
		}
	}
	
	void Load(Buffer&buffer)
	{
		int stateTemp=0;
		buffer>>stateTemp>>this.lastRun>>this.nextRun>>this.waitTime;
		this.state=NpcTaskState(stateTemp);
		
		uint dataLength=0;
		buffer>>dataLength;
		WLog("npc_schedule","Data: "+dataLength,0);
		for(uint d=0;d<dataLength;d++)
		{
			CNpcTaskInstanceData@newData=CNpcTaskInstanceData(buffer);
			WLog("npc_schedule","Data("+newData.name+"): "+newData.data.length(),0);
			
			this.data.insertLast(newData);
		}
	}
};

class CNpcTaskInstanceData
{
	string name;
	array<uint8>data;
	
	CNpcTaskInstanceData(Buffer&buffer)
	{
		buffer>>this.name>>this.data;
	}
	
	CNpcTaskInstanceData(string&name,array<uint8>&data)
	{
		this.name=name;
		this.data=data;
	}
	
	void Save(Buffer&buffer)
	{
		buffer<<this.name<<this.data;
	}
};           

import bool LockerClose(Item&item)from"lockers";
import bool LockerOpen(Item&item)from"lockers";

import Item@GetEmitterOnHex(Map&map,uint16 hexX,uint16 hexY)from"special_map_objects";
import void SetForceFieldOn(Map@map,int id)from"special_map_objects";
import void SetForceFieldFullIntegrity(Map@map,int id)from"special_map_objects";  

void ActionNotImplemented(string&actionName,string&enumName,int value)
{
	string valueName=""+value;
	
	if(EnumContains(enumName,value))
	{
		array<string@>names;
		array<int>values;
		uint count=GetEnum(enumName,names,values);
		for(uint e=0;e<count;e++)
		{
			if(values[e]==value)
			{
				valueName=names[e];
				break;
			}
		}
	}
	
	WLog("npc_schedule","Not implemented "+actionName+"<"+valueName+">",10);
}  

bool Action_Container(INpcTaskAction&self,INpcTaskInstance&task,Critter&npc)
{
	Map@map=npc.GetMap();
	
	NpcActionContainer container=NpcActionContainer(-1);int container_temp=0;Buffer@buffer=NewBuffer(self.Data);buffer>>container_temp;container=NpcActionContainer(container_temp);
	
	if(container==CONTAINER_OPEN)
	{
		uint16 pid=0,hexX=0,hexY=0;
		uint anim2=0;
		
		buffer>>pid>>hexX>>hexY>>anim2;
		
		Item@item=npc.GetMap().GetItem(hexX,hexY,pid);
		if((@item!=null))
		{
			WLog("npc_schedule","Container(Open): "+hexX+","+hexY+","+pid+","+anim2,0);
			npc.Animate(0,anim2,npc.GetItem(0,(1)),true,true);
			LockerOpen(item);
		}
		else
		WLog("npc_schedule","Container(Open): "+hexX+","+hexY+","+pid+","+anim2,0);
	}
	else if(container==CONTAINER_CLOSE)
	{
		uint16 pid=0,hexX=0,hexY=0;
		uint anim2=0;
		
		buffer>>pid>>hexX>>hexY>>anim2;
		
		Item@container=npc.GetMap().GetItem(hexX,hexY,pid);
		if((@container!=null))
		{
			WLog("npc_schedule","Container(Close): "+hexX+","+hexY+","+pid+","+anim2,0);
			npc.Animate(0,anim2,npc.GetItem(0,(1)),true,true);
			LockerClose(container);
		}
		else
		WLog("npc_schedule","Container(Close): "+hexX+","+hexY+","+pid+","+anim2,0);
	}
	else if(container==CONTAINER_OPEN_NEAR)
	{
		uint anim2=0;
		
		buffer>>anim2;
		
		uint16 hexX=npc.HexX;
		uint16 hexY=npc.HexY;
		
		map.MoveHexByDir(hexX,hexY,npc.Dir,1);
		
		Item@container=map.GetItem(hexX,hexY,0);
		if((@container!=null)&&container.GetType()==(8))
		{
			WLog("npc_schedule","Container(OpenNear): ("+hexX+","+hexY+"),"+anim2,0);
			npc.Animate(0,anim2,npc.GetItem(0,(1)),true,true);
			LockerOpen(container);
		}
		else
		WLog("npc_schedule","Invalid Container(OpenNear): ("+hexX+","+hexY+")",0);
	}
	else if(container==CONTAINER_CLOSE_NEAR)
	{
		uint anim2=0;
		
		buffer>>anim2;
		
		uint16 hexX=npc.HexX;
		uint16 hexY=npc.HexY;
		
		map.MoveHexByDir(hexX,hexY,npc.Dir,1);
		Item@container=map.GetItem(hexX,hexY,0);
		if((@container!=null)&&container.GetType()==(8))
		{
			WLog("npc_schedule","Container(CloseNear): ("+hexX+","+hexY+"),"+anim2,0);
			npc.Animate(0,anim2,npc.GetItem(0,(1)),true,true);
			LockerClose(container);
		}
		else
		WLog("npc_schedule","Invalid Container(CloseNear): ("+hexX+","+hexY+")",0);
	}
	else
	ActionNotImplemented("CONTAINER","NpcActionContainer",container);
	
	return(true);
}

bool Action_EditItem(INpcTaskAction&self,INpcTaskInstance&task,Critter&npc)
{
	if(npc.LastSpawnedItem==0)
	return(true);
	
	Item@item=GetItem(npc.LastSpawnedItem);
	if(!(@item!=null)||item.IsNotValid)
	return(true);
	
	NpcActionEditItem edit=NpcActionEditItem(-1);int edit_temp=0;Buffer@buffer=NewBuffer(self.Data);buffer>>edit_temp;edit=NpcActionEditItem(edit_temp);
	
	if(edit==EDITITEM_UPDATE)
	{
		item.Update();
	}
	
	else if(edit==EDITITEM_SETFLAG)
	{
		uint flag=0;
		buffer>>flag;
		
		WLog("npc_schedule","EditItem (set flag): "+flag,0);
		((item.Flags)=(item.Flags)|(flag));
	}
	else if(edit==EDITITEM_UNSETFLAG)
	{
		uint flag=0;
		buffer>>flag;
		
		WLog("npc_schedule","EditItem (unset flag): "+flag,0);
		(item.Flags=((item.Flags)&(~(flag))));
	}
	else if(edit==EDITITEM_FLAGS)
	{
		uint flags=0;
		buffer>>flags;
		
		WLog("npc_schedule","EditItem (flags): "+flags,0);
		item.Flags=flags;
	}
	
	else if(edit==EDITITEM_SETSCRIPT)
	{
		string script="";
		buffer>>script;
		
		item.SetScript(script);
	}
	else if(edit==EDITITEM_SETEVENT)
	{
		int event=0;
		string function="";
		buffer>>function;
		
		item.SetEvent(event,function);
	}
	
	else if(edit==EDITITEM_PICMAP)
	{
		string pic="";
		buffer>>pic;
		
		if(pic.length()>0)
		item.PicMap=GetStrHash(pic);
	}
	else if(edit==EDITITEM_PICINV)
	{
		string pic="";
		buffer>>pic;
		
		if(pic.length()>0)
		item.PicInv=GetStrHash(pic);
	}
	
	else
	ActionNotImplemented("EDITITEM","NpcActionEditItem",edit);
	
	return(true);
}

bool Action_Home(INpcTaskAction&self,INpcTaskInstance&task,Critter&npc)
{
	NpcActionHome home=NpcActionHome(-1);int home_temp=0;Buffer@buffer=NewBuffer(self.Data);buffer>>home_temp;home=NpcActionHome(home_temp);
	
	if(home==HOME_SET)
	{
		uint16 hexX=0,hexY=0;
		uint8 dir=0;
		
		buffer>>hexX>>hexY>>dir;
		
		WLog("npc_schedule","Home: "+hexX+","+hexY+","+dir,0);
		npc.SetHomePos(hexX,hexY,dir);
	}
	else if(home==HOME_SETRANDOM)
	{
		array<array<uint16>>positions;
		
		buffer>>positions;
		
		if(positions.length()==0)
		return(true);
		
		int tries=50;
		while(tries>0)
		{
			uint idx=Random(0,positions.length()-1);
			if(positions[idx].length<3)
			{
				tries--;
				continue;
			}
			
			if(npc.GetMap().IsHexPassed(positions[idx][0],positions[idx][1]))
			{
				WLog("npc_schedule","RandomHome: "+positions[idx][0]+","+positions[idx][1]+","+positions[idx][2],0);
				npc.SetHomePos(positions[idx][0],positions[idx][1],positions[idx][2]);
				break;
			}
			
			tries--;
		}
	}
	else if(home==HOME_SAVE)
	{
		uint mapId=0;
		uint16 hexX=0,hexY=0;
		uint8 dir=0;
		
		npc.GetHomePos(mapId,hexX,hexY,dir);
		WLog("npc_schedule","SaveHome: "+hexX+","+hexY+","+dir,0);
		
		Buffer@data=NewBuffer();
		data<<hexX<<hexY<<dir;
		
		task.SetData("home",data.AsUint8());
	}
	else if(home==HOME_LOAD)
	{
		array<uint8>data;
		if(task.GetData("home",data))
		{
			uint16 hexX=0,hexY=0;
			uint8 dir=0;
			
			Buffer@buffer=NewBuffer(data);
			buffer>>hexX>>hexY>>dir;
			
			WLog("npc_schedule","HomeLoad: "+hexX+","+hexY+","+dir,0);
			npc.SetHomePos(hexX,hexY,dir);
		}
		else
		WLog("npc_schedule","HomeLoad: missing data",0);
	}
	else if(home==HOME_RESET)
	{
		WLog("npc_schedule","HomeReset: "+npc.HexX+","+npc.HexY+","+npc.Dir,0);
		npc.SetHomePos(npc.HexX,npc.HexY,npc.Dir);
	}
	
	else
	ActionNotImplemented("HOME","NpcActionHome",home); 
	
	return(true);
}

bool Action_If(INpcTaskAction&self,INpcTaskInstance&task,Critter&npc)
{
	NpcActionIf requirement=NpcActionIf(-1);int requirement_temp=0;Buffer@buffer=NewBuffer(self.Data);buffer>>requirement_temp;requirement=NpcActionIf(requirement_temp);
	
	if(requirement==IF_NEVER)
	{
		WLog("npc_schedule","IF_NEVER",0);
		return(false);
	}
	else if(requirement==IF_ALWAYS)
	{
		WLog("npc_schedule","IF_ALWAYS",0);
		return(true);
	}
	
	else if(requirement==IF_TASKVAR_LOWER||
	requirement==IF_TASKVAR_LOWEREQUAL||
	requirement==IF_TASKVAR_EQUAL||
	requirement==IF_TASKVAR_NOTEQUAL||
	requirement==IF_TASKVAR_GREATER||
	requirement==IF_TASKVAR_GREATEREQUAL)
	{
		string name="";
		int var=0,value=0;
		
		buffer>>name>>value;
		name="var:"+strlwr(name);
		
		array<uint8>data;
		if(task.GetData(name,data))
		{
			Buffer@dataBuffer=NewBuffer(data);
			dataBuffer>>var;
		}
		
		if(requirement==IF_TASKVAR_LOWER)
		return(var<value);
		else if(requirement==IF_TASKVAR_LOWEREQUAL)
		return(var<=value);
		else if(requirement==IF_TASKVAR_EQUAL)
		return(var==value);
		else if(requirement==IF_TASKVAR_NOTEQUAL)
		return(var!=value);
		else if(requirement==IF_TASKVAR_GREATER)
		return(var>value);
		else if(requirement==IF_TASKVAR_GREATEREQUAL)
		return(var>=value);
		else
		ActionNotImplemented("IF(TASKVAR)","NpcActionIf",requirement);
		
		return(false);
	} 
	
	else if(requirement==IF_PERCENT)
	{
		uint8 percent=0;
		buffer>>percent;
		percent=(((percent)>(100))?(100):(((percent)<(1))?(1):(percent)));
		return(int(percent)<=Random(1,100));
	}
	
	else if(requirement==IF_NIGHT)
	return(IsNight());
	else if(requirement==IF_DAY)
	return(IsDay());
	else if(requirement==IF_MORNING)
	return(IsMorning());
	else if(requirement==IF_AFTERNOON)
	return(IsAfternoon());
	else if(requirement==IF_EVENING)
	return(IsEvening());
	else if(requirement==IF_YEAR)
	{
		uint8 year=0;
		buffer>>year;
		
		return(year==__Year);
	}
	else if(requirement==IF_MONTH)
	{
		uint8 month=0;
		buffer>>month;
		
		return(month==__Month);
	}
	else if(requirement==IF_DAYOFMONTH)
	{
		uint8 day=0;
		buffer>>day;
		
		return(day==__Day);
	}
	else if(requirement==IF_HOUR)
	{
		uint8 hour=0;
		buffer>>hour;
		
		return(hour==__Hour);
	}
	else if(requirement==IF_MINUTE)
	{
		uint8 minute=0;
		buffer>>minute;
		
		return(minute==__Minute);
	}
	
	else if(requirement==IF_WORLDMAP)
	{
		return(npc.GetMapProtoId()==0);
	}
	else if(requirement==IF_NOT_WORLDMAP)
	{
		return(npc.GetMapProtoId()!=0);
	}
	
	else if(requirement==IF_MAP_PID)
	{
		uint16 mapPid=uint16(-1);
		buffer>>mapPid;
		
		return(npc.GetMapProtoId()==mapPid);
	}
	else if(requirement==IF_MAP_PIDS)
	{
		array<uint16>mapPids;
		buffer>>mapPids;
		
		for(uint m=0,mLen=mapPids.length();m<mLen;m++)
		{
			if(npc.GetMapProtoId()==mapPids[m])
			return(true);
		}
		
		return(false);
	}
	else if(requirement==IF_NOT_MAP_PID)
	{
		uint16 mapPid=uint16(-1);
		buffer>>mapPid;
		
		return(npc.GetMapProtoId()!=mapPid);
	}
	else if(requirement==IF_NOT_MAP_PIDS)
	{
		array<uint16>mapPids;
		buffer>>mapPids;
		
		bool result=true;
		for(uint m=0,mLen=mapPids.length();m<mLen;m++)
		{
			if(npc.GetMapProtoId()==mapPids[m])
			{
				result=false;
				break;
			}
		}
		
		return(result);
	}
	
	else if(requirement==IF_CONTAINER_OPENED||
	requirement==IF_CONTAINER_CLOSED)
	{
		uint16 pid=0,hexX=0,hexY=0;
		buffer>>pid>>hexX>>hexY;
		Item@container=npc.GetMap().GetItem(hexX,hexY,pid);
		if((@container!=null))
		{
			if(requirement==IF_CONTAINER_OPENED)
			return((((container.LockerCondition)&((0x01)))!=0));
			
			if(requirement==IF_CONTAINER_CLOSED)
			return(!(((container.LockerCondition)&((0x01)))!=0));
		}
		
		return(false);
	}
	
	else if(requirement==IF_PARAMBASE_LOWER||
	requirement==IF_PARAMBASE_LOWEREQUAL||
	requirement==IF_PARAMBASE_EQUAL||
	requirement==IF_PARAMBASE_NOTEQUAL||
	requirement==IF_PARAMBASE_GREATER||
	requirement==IF_PARAMBASE_GREATEREQUAL||
	
	requirement==IF_PARAM_LOWER||
	requirement==IF_PARAM_LOWEREQUAL||
	requirement==IF_PARAM_EQUAL||
	requirement==IF_PARAM_NOTEQUAL||
	requirement==IF_PARAM_GREATER||
	requirement==IF_PARAM_GREATEREQUAL)
	{
		uint16 param=0;
		int value=0;
		buffer>>param>>value;
		param=(((param)>((1200)-1))?((1200)-1):(((param)<(0))?(0):(param)));
		
		int var=0;
		
		if(requirement==IF_PARAMBASE_LOWER||
		requirement==IF_PARAMBASE_LOWEREQUAL||
		requirement==IF_PARAMBASE_EQUAL||
		requirement==IF_PARAMBASE_NOTEQUAL||
		requirement==IF_PARAMBASE_GREATER||
		requirement==IF_PARAMBASE_GREATEREQUAL)
		{
			var=npc.ParamBase[param];
		}
		
		else if(requirement==IF_PARAM_LOWER||
		requirement==IF_PARAM_LOWEREQUAL||
		requirement==IF_PARAM_EQUAL||
		requirement==IF_PARAM_NOTEQUAL||
		requirement==IF_PARAM_GREATER||
		requirement==IF_PARAM_GREATEREQUAL)
		{
			var=npc.Param[param];
		}
		
		else
		{
			ActionNotImplemented("IF(PARAMBASE/PARAM)","NpcActionIf",requirement);
			return(false);
		}
		
		if(requirement==IF_PARAMBASE_LOWER||requirement==IF_PARAM_LOWER)
		return(var<value);
		else if(requirement==IF_PARAMBASE_LOWEREQUAL||requirement==IF_PARAM_LOWEREQUAL)
		return(var<=value);
		else if(requirement==IF_PARAMBASE_EQUAL||requirement==IF_PARAM_EQUAL)
		return(var==value);
		else if(requirement==IF_PARAMBASE_NOTEQUAL||requirement==IF_PARAM_NOTEQUAL)
		return(var!=value);
		else if(requirement==IF_PARAMBASE_GREATER||requirement==IF_PARAM_GREATER)
		return(var>value);
		else if(requirement==IF_PARAMBASE_GREATEREQUAL||requirement==IF_PARAM_GREATEREQUAL)
		return(var>=value);
		else
		ActionNotImplemented("IF(PARAMBASE/PARAM)","NpcActionIf",requirement);
		
		return(false);
	}
	
	else
	ActionNotImplemented("IF","NpcActionIf",requirement);
	
	return(false);
}

bool Action_EndIf(INpcTaskAction&self,INpcTaskInstance&task,Critter&npc)
{
	WLog("npc_schedule","EndIf",0);
	
	return(true);
}

bool Action_Inventory(INpcTaskAction&self,INpcTaskInstance&task,Critter&npc)
{
	NpcActionInventory inv=NpcActionInventory(-1);int inv_temp=0;Buffer@buffer=NewBuffer(self.Data);buffer>>inv_temp;inv=NpcActionInventory(inv_temp);
	
	if(inv==INV_ADDITEM)
	{
		uint16 pid=0;
		uint count=0;
		buffer>>pid>>count;
		if(count>0)
		{
			Item@item=npc.AddItem(pid,count);
			if((@item!=null))
			{
				WLog("npc_schedule","AddItem OK: "+pid+","+count,0); 
				
				item.Val9=npc.Id;
				npc.LastSpawnedItem=item.Id;
			}
			else
			WLog("npc_schedule","AddItem FAIL: "+pid+","+count,0);
		}
	}
	else if(inv==INV_SUBITEM)
	{
		uint16 pid=0;
		uint count=0;
		buffer>>pid>>count;
		if(count>0)
		{
			Item@item=npc.GetItem(pid,-1);
			if((@item!=null))
			{
				if(count==uint(-1))
				{
					WLog("npc_schedule","SubItem OK: "+pid+",all",0);
					DeleteItem(item);
				}
				else
				{
					WLog("npc_schedule","SubItem OK: "+pid+","+count,0);
					do{if(item.GetCount()>(count)) item.SetCount(item.GetCount()-(count));else DeleteItem(item);}while(false);
				}
			}
			else
			WLog("npc_schedule","SubItem FAIL: "+pid+","+(count==uint(-1)?"all":""+count),0);
		}
	}
	
	else if(inv==INV_FAVITEM)
	{
		uint8 slot=0;
		uint16 pid=0;
		
		buffer>>slot>>pid;
		
		WLog("npc_schedule","FavouriteItem: "+slot+","+pid,0);
		npc.SetFavoriteItem(slot,pid);
	}
	
	else
	ActionNotImplemented("INV","NpcActionInventory",inv);
	
	return(true);
}

bool Action_Map(INpcTaskAction&self,INpcTaskInstance&task,Critter&npc)
{
	NpcActionMap map=NpcActionMap(-1);int map_temp=0;Buffer@buffer=NewBuffer(self.Data);buffer>>map_temp;map=NpcActionMap(map_temp);
	
	Map@npcMap=npc.GetMap();
	
	if(map==MAP_CREATEITEM)
	{
		uint16 pid=0,hexX=0,hexY=0;
		uint count=0;
		
		buffer>>pid>>hexX>>hexY>>count;
		
		Item@item=npcMap.AddItem(hexX,hexY,pid,count);
		if((@item!=null))
		{
			
			item.Val9=npc.Id;
			npc.LastSpawnedItem=item.Id;
		}
	}
	else if(map==MAP_DELETEITEM)
	{
		uint16 pid=0,hexX=0,hexY=0;
		
		buffer>>pid>>hexX>>hexY;
		
		array<Item@>items;
		array<Item@>delete;
		uint count=npcMap.GetItems(hexX,hexY,items);
		for(uint i=0;i<count;i++)
		{
			if(items[i].Proto.ProtoId==pid)
			delete.insertLast(items[i]);
		}
		if(delete.length()>0)
		{
			WLog("npc_schedule","DeleteItem: removing "+delete.length()+"/"+items.length(),0);
			DeleteItems(delete);
		}
	}
	
	else
	ActionNotImplemented("MAP","NpcActionMap",map);
	
	return(true);
}

bool Action_Say(INpcTaskAction&self,INpcTaskInstance&task,Critter&npc)
{
	NpcActionSay say=NpcActionSay(-1);int say_temp=0;Buffer@buffer=NewBuffer(self.Data);buffer>>say_temp;say=NpcActionSay(say_temp);
	
	if(say==SAY_SINGLE)
	{
		uint8 sayType=0;
		string text="";
		
		Buffer@buffer=NewBuffer(self.Data);
		buffer>>sayType>>text;
		
		if(sayType==0||text.length()==0)
		return(true);   
		
		npc.Say(sayType,text);
	}
	else if(say==SAY_RANDOM)
	{
		uint8 sayType=0;
		array<string>text;
		
		buffer>>sayType>>text;
		
		if(sayType==0||text.length()==0)
		return(true);   
		
		npc.Say(sayType,text[Random(0,text.length()-1)]);
	}
	else if(say==SAY_TASKVAR)
	{                
		
	}
	
	else
	ActionNotImplemented("SAY","NpcActionSay",say);
	
	return(true);
}

bool Action_TaskVar(INpcTaskAction&self,INpcTaskInstance&task,Critter&npc)
{
	NpcActionTaskVar taskvar=NpcActionTaskVar(-1);int taskvar_temp=0;Buffer@buffer=NewBuffer(self.Data);buffer>>taskvar_temp;taskvar=NpcActionTaskVar(taskvar_temp);
	
	if(taskvar==TASKVAR_DELETE)
	{
		string name="";
		buffer>>name;
		task.ClearData("var:"+strlwr(name));
	}
	else if(taskvar==TASKVAR_SET||
	taskvar==TASKVAR_ADD||
	taskvar==TASKVAR_SUB)
	{
		string name="";
		int value=0;
		
		buffer>>name>>value;
		name="var:"+strlwr(name);
		
		int var=0;
		array<uint8>data;
		if(task.GetData(name,data))
		{
			Buffer@oldData=NewBuffer(data);
			oldData>>var;
		}
		
		if(taskvar==TASKVAR_SET)
		var=value;
		else if(taskvar==TASKVAR_ADD)
		var+=value;
		else if(taskvar==TASKVAR_SUB)
		var-=value;
		else
		{
			ActionNotImplemented("TASKVAR(SET/ADD/SUB)","NpcActionTaskVar",taskvar);
			return(true);
		}
		
		Buffer@newData=NewBuffer();
		newData<<var;
		task.SetData(name,newData.AsUint8());
	}
	else if(taskvar==TASKVAR_SETRANDOM||
	taskvar==TASKVAR_ADDRANDOM||
	taskvar==TASKVAR_SUBRANDOM)
	{
		string name="";
		int value_from=0,value_to=0;
		
		buffer>>name>>value_from>>value_to;
		name="var:"+strlwr(name);
		
		int var=0;
		array<uint8>data;
		if(task.GetData(name,data))
		{
			Buffer@oldData=NewBuffer(data);
			oldData>>var;
		}
		
		if(taskvar==TASKVAR_SETRANDOM)
		var=Random(value_from,value_to);
		else if(taskvar==TASKVAR_ADDRANDOM)
		var+=Random(value_from,value_to);
		else if(taskvar==TASKVAR_SUBRANDOM)
		var-=Random(value_from,value_to);
		else
		ActionNotImplemented("TASKVAR(*RANDOM)","NpcActionTaskVar",taskvar);
		
		Buffer@newData=NewBuffer();
		newData<<var;
		
		task.SetData(name,newData.AsUint8());
	}
	
	else if(taskvar==TASKVAR_COPYTO||taskvar==TASKVAR_COPYFROM)
	{
		string name="";
		uint8 varType=0;
		uint16 varId=0;
		
		buffer>>name>>varType>>varId;
		name="var:"+strlwr(name);
		
		int var=0;
		array<uint8>data;
		if(task.GetData(name,data))
		{
			Buffer@oldData=NewBuffer(data);
			oldData>>var;
		}
		
		GameVar@gameVar=null;
		if(varType==(0))
		{
			@gameVar=GetGlobalVar(varId);
		}
		else if(varType==(3))
		{
			@gameVar=GetLocalVar(varId,npc.GetMap().GetLocation().Id);
		}
		else if(varType==(4))
		{
			@gameVar=GetLocalVar(varId,npc.GetMap().Id);
		}
		else if(varType==(1))
		{
			@gameVar=GetLocalVar(varId,npc.Id);
		}
		else
		{
			WLog("npc_schedule","Invalid var_type<"+varType+">",20);
			return(true);
		}
		
		if((@gameVar!=null))
		{
			if(taskvar==TASKVAR_COPYTO)
			gameVar=var;
			else if(taskvar==TASKVAR_COPYFROM)
			{
				var=gameVar.GetValue();
				Buffer@varBuffer=NewBuffer();
				varBuffer<<var;
				task.SetData(name,varBuffer.AsUint8());
			}
			else
			ActionNotImplemented("TASKVAR(COPY)","NpcActionTaskVar",taskvar);
		}
		else
		WLog("npc_schedule","Invalid gamevar type<"+varType+"> id<"+varId+">",20);
		
	}
	
	else
	ActionNotImplemented("TASKVAR","NpcActionTaskVar",taskvar);
	
	return(true);
}

bool Action_Wait(INpcTaskAction&self,INpcTaskInstance&task,Critter&npc)
{
	NpcActionWait wait=NpcActionWait(-1);int wait_temp=0;Buffer@buffer=NewBuffer(self.Data);buffer>>wait_temp;wait=NpcActionWait(wait_temp);
	
	if(wait==WAIT_TIME)
	{
		uint time=0;
		
		buffer>>time;
		
		task.WaitTime=time;
		
		return(true);
	}
	else if(wait==WAIT_RANDOM)
	{
		uint min=0,max=0;
		
		buffer>>min>>max;
		
		uint time=Random(min,max);
		
		task.WaitTime=time;
		
		return(true);
	}
	else if(wait==WAIT_HOME)
	{
		uint mapId=0;
		uint16 hexX=0,hexY=0;
		uint8 dir=0;
		
		npc.GetHomePos(mapId,hexX,hexY,dir);
		if(npc.GetMapId()==mapId&&npc.HexX==hexX&&npc.HexY==hexY&&npc.Dir==dir)
		{
			WLog("npc_schedule","WAIT_HOME: OK",0);
			return(true);
		}
		
		return(false);
	}
	else if(wait==WAIT_FAVITEM)
	{
		uint8 slot=0;
		
		buffer>>slot;
		
		Item@item=npc.GetItem(0,slot);
		if((@item!=null)&&item.Proto.ProtoId==npc.GetFavoriteItem(slot))
		{
			WLog("npc_schedule","WaitFavoriteItem: OK",0);
			return(true);
		}
		
		return(false);
	}
	
	else
	ActionNotImplemented("WAIT","NpcActionWait",wait);
	
	return(true);
}  

bool Action_Verbose(INpcTaskAction&self,INpcTaskInstance&task,Critter&npc)
{
	string text="";
	Buffer@buffer=NewBuffer(self.Data);
	buffer>>text;
	
	VerboseAction(npc,text);
	
	return(true);
}

bool Action_DemandAnswer(INpcTaskAction&self,INpcTaskInstance&task,Critter&npc)
{
	Map@map=npc.GetMap();
	
	uint8 sayType=0;
	string text="";
	
	Buffer@buffer=NewBuffer(self.Data);
	buffer>>sayType>>text;
	
	if(sayType==0||text.length()==0)
	return(true);
	
	uint16 hexX=npc.HexX;
	uint16 hexY=npc.HexY;
	
	uint moved=0;
	while(moved++<10)
	{
		map.MoveHexByDir(hexX,hexY,npc.Dir,1);
		Critter@cr=map.GetCritter(hexX,hexY);
		if((@cr!=null))
		{
			if(cr.IsLife()&&IsHumanoid(cr)&&!cr.IsKnockout())
			{
				cr.Say(sayType,text);
				return(true);
			}
		}
	}
	
	return(true);
}

bool Action_Animate(INpcTaskAction&self,INpcTaskInstance&task,Critter&npc)
{
	uint anim2=0;
	bool clearSequence=false,delayPlay=true;
	
	Buffer@buffer=NewBuffer(self.Data);
	buffer>>anim2>>clearSequence>>delayPlay;
	
	npc.Animate(0,anim2,npc.GetItem(0,(1)),clearSequence,delayPlay);
	
	return(true);
}  

bool Action_Sleep(INpcTaskAction&self,INpcTaskInstance&task,Critter&npc)
{
	if(IsNight())
	{
		npc.ToKnockout((82),(86),(88),25,npc.HexX,npc.HexY);
		
		return(false);
	}
	
	return(true);
}

bool Action_WakeUp(INpcTaskAction&self,INpcTaskInstance&task,Critter&npc)
{
	if((npc.IsKnockout()||npc.Param[(75)]<0))
	{
		if(!npc.IsDead())
		npc.ToLife();
		
		npc.ParamBase[(75)]=npc.Param[(8)];
	}
	
	return(true);
}

bool Action_FixForcefield(INpcTaskAction&self,INpcTaskInstance&task,Critter&npc)
{
	Map@map=npc.GetMap();
	
	uint16 hexX=0,hexY=0;
	uint anim2=0;
	
	Buffer@buffer=NewBuffer(self.Data);
	buffer>>hexX>>hexY>>anim2;
	
	Item@forcefield=GetEmitterOnHex(map,hexX,hexY);
	if((@forcefield!=null))
	{
		WLog("npc_schedule","Fixing forcefield: "+hexX+","+hexY+","+anim2,0);
		npc.Animate(0,anim2,npc.GetItem(0,(1)),true,true);
		SetForceFieldOn(map,forcefield.Val0);
		SetForceFieldFullIntegrity(map,forcefield.Val0);
	}
	else
	WLog("npc_schedule","Invalid forcefield: "+hexX+","+hexY+","+anim2,0);
	
	return(true);
}

bool Action_Custom(INpcTaskAction&self,INpcTaskInstance&task,Critter&npc)
{
	string functionName="";
	
	Buffer@buffer=NewBuffer(self.Data);
	buffer>>functionName;
	
	NpcTaskCustomAction custom;
	
	@custom.self=self;
	@custom.task=task;
	@custom.npc=npc;
	
	int result=CallGenericFunction(functionName,custom);
	
	if(result<=0)
	return(false);
	else
	return(true);
}           

enum NpcTaskType
{
	TASK_NONE=0,
	
	TASK_FIRST_CALL,
	
	TASK_TIME,
	TASK_HOUR,
	TASK_MINUTE,
	TASK_NIGHT,
	TASK_DAY,
	TASK_MORNING,
	TASK_AFTERNOON,
	TASK_EVENING,
	TASK_IDLE
};

enum NpcTaskActionType
{
	ACTION_NONE=0,  
	
	ACTION_CONTAINER,
	ACTION_EDITITEM,
	ACTION_HOME,
	ACTION_IF,
	ACTION_ENDIF,
	ACTION_INVENTORY,
	ACTION_MAP,
	ACTION_SAY,
	ACTION_TASK,
	ACTION_TASKVAR,
	ACTION_WAIT,  
	
	ACTION_DEMANDANSWER,
	ACTION_VERBOSE,
	
	ACTION_ANIMATE,
	ACTION_SLEEP,
	ACTION_WAKEUP,
	
	ACTION_FIXFORCEFIELD,
	
	ACTION_CUSTOM
};

enum NpcTaskState
{
	TASKSTATE_UNKNOWN=0, 
	
	TASKSTATE_SKIP, 
	
	TASKSTATE_READY, 
	
	TASKSTATE_STARTING, 
	
	TASKSTATE_RUNNING, 
	
	TASKSTATE_FINISHED
};

enum NpcActionContainer
{
	CONTAINER_OPEN,
	CONTAINER_CLOSE,
	CONTAINER_OPEN_NEAR,
	CONTAINER_CLOSE_NEAR
};

enum NpcActionEditItem
{
	EDITITEM_UPDATE,
	
	EDITITEM_SETFLAG,
	EDITITEM_UNSETFLAG,
	EDITITEM_FLAGS,
	
	EDITITEM_SETSCRIPT,
	EDITITEM_SETEVENT,
	
	EDITITEM_PICMAP,
	EDITITEM_PICINV
};

enum NpcActionHome
{
	HOME_SET,
	HOME_SETRANDOM,
	HOME_SAVE,
	HOME_LOAD,
	HOME_RESET
};

enum NpcActionIf
{
	IF_NEVER=0,
	IF_ALWAYS=1,
	
	IF_TASKVAR_LOWER,
	IF_TASKVAR_LOWEREQUAL,
	IF_TASKVAR_EQUAL,
	IF_TASKVAR_NOTEQUAL,
	IF_TASKVAR_GREATER,
	IF_TASKVAR_GREATEREQUAL,
	
	IF_PERCENT,
	
	IF_NIGHT,
	IF_DAY,
	IF_MORNING,
	IF_AFTERNOON,
	IF_EVENING,
	IF_YEAR,
	IF_MONTH,
	IF_DAYOFMONTH,
	IF_HOUR,
	IF_MINUTE,
	
	IF_WORLDMAP,
	IF_NOT_WORLDMAP,
	IF_MAP_PID,
	IF_MAP_PIDS,
	IF_NOT_MAP_PID,
	IF_NOT_MAP_PIDS,
	
	IF_CONTAINER_OPENED,
	IF_CONTAINER_CLOSED,
	
	IF_PARAMBASE_LOWER,
	IF_PARAMBASE_LOWEREQUAL,
	IF_PARAMBASE_EQUAL,
	IF_PARAMBASE_NOTEQUAL,
	IF_PARAMBASE_GREATER,
	IF_PARAMBASE_GREATEREQUAL,
	IF_PARAM_LOWER,
	IF_PARAM_LOWEREQUAL,
	IF_PARAM_EQUAL,
	IF_PARAM_NOTEQUAL,
	IF_PARAM_GREATER,
	IF_PARAM_GREATEREQUAL
};

enum NpcActionInventory
{
	INV_ADDITEM=0,
	INV_SUBITEM,
	INV_FAVITEM
};

enum NpcActionMap
{
	MAP_CREATEITEM,
	MAP_DELETEITEM,
};

enum NpcActionSay
{
	SAY_SINGLE=0,
	SAY_RANDOM,
	
	SAY_TASKVAR=100
};

enum NpcActionTask
{
	
};
enum NpcActionTaskVar
{
	TASKVAR_DELETE=0,
	TASKVAR_SET,
	TASKVAR_ADD,
	TASKVAR_SUB,
	TASKVAR_SETRANDOM,
	TASKVAR_ADDRANDOM,
	TASKVAR_SUBRANDOM,
	TASKVAR_COPYTO,
	TASKVAR_COPYFROM
};

enum NpcActionWait
{
	WAIT_TIME=0,
	WAIT_RANDOM,
	WAIT_HOME,
	WAIT_FAVITEM
};

shared interface INpcSchedule
{
	
	uint PID{get;}
	string Name{get;}
	string FullName{get;} 
	
	INpcTask@AddTask_OnFirstCall(string&name); 
	
	INpcTask@AddTask_OnIdle(string&name);
	
	INpcTask@AddTask_OnTime(string&name,uint8 hour,uint8 minute);
	INpcTask@AddTask_OnTimes(string&name,array<uint8>&hours,array<uint8>&minutes);
	INpcTask@AddTask_OnHour(string&name,uint8 hour);
	INpcTask@AddTask_OnMinute(string&name,uint8 minute);
	INpcTask@AddTask_OnHours(string&name,array<uint8>&hours);
	INpcTask@AddTask_OnMinutes(string&name,array<uint8>&minutes); 
	
	INpcTask@AddTask_OnNight(string&name);
	INpcTask@AddTask_OnDay(string&name);
	INpcTask@AddTask_OnMorning(string&name);
	INpcTask@AddTask_OnAfternoon(string&name);
	INpcTask@AddTask_OnEvening(string&name); 
	
	INpcTask@AddTask_EveryNight(string&name);
	INpcTask@AddTask_EveryDay(string&name);
	INpcTask@AddTask_EveryMorning(string&name);
	INpcTask@AddTask_EveryAfternoon(string&name);
	INpcTask@AddTask_EveryEvening(string&name);
	
	INpcTask@AddTask_EveryFullHour(string&name);
	
	uint GetTasks(array<INpcTask@>&tasks);
};

shared interface INpcScheduleInstance
{
	
	uint Owner{get;}
	string FullName{get;} 
	
	uint Run(Critter&npc);
};

shared interface INpcTask
{
	
	string Name{get;}
	string FullName{get;}
	
	array<uint8>Hours{get;}
	array<uint8>Minutes{get;} 
	
	INpcSchedule@ParentSchedule();
	uint GetActions(array<INpcTaskAction@>&actions); 
	
	INpcTask@Roll(uint max);  
	
	INpcTask@Container_Open(uint16 pid,uint16 hexX,uint16 hexY,uint anim2);
	INpcTask@Container_Close(uint16 pid,uint16 hexX,uint16 hexY,uint anim2);
	INpcTask@Container_OpenNear(uint anim2);
	INpcTask@Container_CloseNear(uint anim2);
	
	INpcTask@EditItem_Update();
	INpcTask@EditItem_SetFlag(uint flag);
	INpcTask@EditItem_UnsetFlag(uint flag);
	INpcTask@EditItem_Flags(uint flags);
	INpcTask@EditItem_SetScript(string&script);
	INpcTask@EditItem_SetEvent(int event,string&function);
	INpcTask@EditItem_PicMap(string&picmap);
	INpcTask@EditItem_PicInv(string&picinv);
	
	INpcTask@Home_Set(uint16 hexX,uint16 hexY,uint8 dir);
	INpcTask@Home_SetRandom(array<array<uint16>>positions);
	INpcTask@Home_Save();
	INpcTask@Home_Load();
	INpcTask@Home_Reset();
	
	INpcTask@If_Never();
	INpcTask@If_Always();
	INpcTask@If_TaskVarLower(string&name,int value);
	INpcTask@If_TaskVarLowerEqual(string&name,int value);
	INpcTask@If_TaskVarEqual(string&name,int value);
	INpcTask@If_TaskVarNotEqual(string&name,int value);
	INpcTask@If_TaskVarGreater(string&name,int value);
	INpcTask@If_TaskVarGreaterEqual(string&name,int value);
	INpcTask@If_Percent(uint8 percent);
	INpcTask@If_Night();
	INpcTask@If_Day();
	INpcTask@If_Morning();
	INpcTask@If_Afternoon();
	INpcTask@If_Evening();
	INpcTask@If_Year(uint8 year);
	INpcTask@If_Month(uint8 month);
	INpcTask@If_DayOfMonth(uint8 day);
	INpcTask@If_Hour(uint8 hour);
	INpcTask@If_Minute(uint8 minute);
	INpcTask@If_Worldmap();
	INpcTask@If_NotWorldmap();
	INpcTask@If_MapPid(uint16 pid);
	INpcTask@If_NotMapPid(uint16 pid);
	INpcTask@If_MapPids(array<uint16>pids);
	INpcTask@If_NotMapPids(array<uint16>pids);
	INpcTask@If_ContainerOpened(uint16 pid,uint16 hexX,uint16 hexY);
	INpcTask@If_ContainerClosed(uint16 pid,uint16 hexX,uint16 hexY);
	INpcTask@If_ParamBaseLower(uint16 param,int value);
	INpcTask@If_ParamBaseLowerEqual(uint16 param,int value);
	INpcTask@If_ParamBaseEqual(uint16 param,int value);
	INpcTask@If_ParamBaseNotEqual(uint16 param,int value);
	INpcTask@If_ParamBaseGreater(uint16 param,int value);
	INpcTask@If_ParamBaseGreaterEqual(uint16 param,int value);
	INpcTask@If_ParamLower(uint16 param,int value);
	INpcTask@If_ParamLowerEqual(uint16 param,int value);
	INpcTask@If_ParamEqual(uint16 param,int value);
	INpcTask@If_ParamNotEqual(uint16 param,int value);
	INpcTask@If_ParamGreater(uint16 param,int value);
	INpcTask@If_ParamGreaterEqual(uint16 param,int value);
	INpcTask@EndIf();
	
	INpcTask@Inventory_AddItem(uint16 pid);
	INpcTask@Inventory_AddItem(uint16 pid,uint count);
	INpcTask@Inventory_SubItem(uint16 pid);
	INpcTask@Inventory_SubItem(uint16 pid,uint count);
	INpcTask@Inventory_SetFavouriteItem(uint8 slot,uint16 pid);
	INpcTask@Inventory_UseFavouriteItem(uint8 slot,uint16 pid);
	
	INpcTask@Map_CreateItem(uint16 pid,uint16 hexX,uint16 hexY,uint count);
	INpcTask@Map_DeleteItem(uint16 pid,uint16 hexX,uint16 hexY);
	
	INpcTask@Say(uint8 sayType,string&text);
	INpcTask@Say_Wait(uint8 sayType,string&text);
	INpcTask@Say_Random(uint8 sayType,array<string>&text);
	INpcTask@Say_TaskVar(string&name);      
	
	INpcTask@TaskVar_Delete(string&name);
	INpcTask@TaskVar_Set(string&name,int value);
	INpcTask@TaskVar_Add(string&name);
	INpcTask@TaskVar_Sub(string&name);
	INpcTask@TaskVar_Add(string&name,int value_add);
	INpcTask@TaskVar_Sub(string&name,int value_sub);
	INpcTask@TaskVar_SetRandom(string&name,int from,int to);
	INpcTask@TaskVar_AddRandom(string&name,int from,int to);
	INpcTask@TaskVar_SubRandom(string&name,int from,int to);
	INpcTask@TaskVar_CopyToGlobalVar(string&name,uint16 GVAR);
	INpcTask@TaskVar_CopyFromGlobalVar(string&name,uint16 GVAR);
	INpcTask@TaskVar_CopyToLocationVar(string&name,uint16 LLVAR);
	INpcTask@TaskVar_CopyFromLocationVar(string&name,uint16 LLVAR);
	INpcTask@TaskVar_CopyToMapVar(string&name,uint16 LMVAR);
	INpcTask@TaskVar_CopyFromMapVar(string&name,uint16 LMVAR);
	INpcTask@TaskVar_CopyToCritterVar(string&name,uint16 LVAR);
	INpcTask@TaskVar_CopyFromCritterVar(string&name,uint16 LVAR);
	
	INpcTask@Wait(uint time);
	INpcTask@Wait_Random(uint min,uint max);
	INpcTask@Wait_Home();
	INpcTask@Wait_FavouriteItem(uint8 slot);  
	
	INpcTask@VerboseAction(string&text);
	INpcTask@DemandAnswer(uint8 sayType,string&text);
	
	INpcTask@Animate(uint anim2,bool clearSequence,bool delayPlay);
	
	INpcTask@Sleep();
	INpcTask@WakeUp();    
	
	INpcTask@Walk_Home(uint16 hexX,uint16 hexY,uint8 dir);
	INpcTask@Walk_Home(array<uint16>&position);
	INpcTask@Walk_RandomHome(array<array<uint16>>positions);
	INpcTask@Walk_Patrol(array<array<uint16>>&patrol,bool saveHome);
	
	INpcTask@CustomAction(string&functionName,bool requireMap);
};

shared interface INpcTaskInstance
{
	
	uint WaitTime{get;set;}  
	
	void SetData(string&name,array<uint8>&data);
	bool GetData(string&name,array<uint8>&data);
	void ClearData(string&name);
};

shared interface INpcTaskAction
{
	
	uint8 Type{get;}
	array<uint8>Data{get;} 
	
	INpcTask@ParentTask();
};  

class NpcTaskCustomAction:IObject
{
	INpcTaskAction@self;
	INpcTaskInstance@task;
	Critter@npc;
};

funcdef bool FTaskAction(INpcTaskAction&,INpcTaskInstance&,Critter&);                      

enum HardcodedSchedules
{
	
	RADIATED_AI=1,  
	
	PATROL_ADYTUM=10,
	PATROL_HINKLEY,
	PATROL_HUB,
	PATROL_LOST_HILLS,
	PATROL_NAVARRO,
	PATROL_SHADY_SANDS,
	PATROL_SAN_FRANCISCO,
	PATROL_VAULT_CITY, 
	
	GRAVE_KEEPER=100,
	JAIL_EMITTERS,
	
	SETH_GENERIC=200,
	SETH_OUTSIDE,
	SETH_ARMORER,
	SETH_COOK,
	SETH_PRISONER,
	SETH_RANGER,
	
	SETH_GUARD_DBM1=220,
	SETH_GUARD_DBM2,
	SETH_GUARD_DBL1,
	SETH_GUARD_DBL2,
	SETH_GUARD_DBR1,
	SETH_GUARD_DBR2,
	SETH_GUARD_NBL1,
	SETH_GUARD_NBL2,
	SETH_GUARD_NBR1,
	SETH_GUARD_NBR2,
	SETH_GUARD_NBM1,
	SETH_GUARD_NBM2,
	SETH_GUARD_RANGER1,
	SETH_GUARD_RANGER2
};

int[]public_schedules=
{
	GRAVE_KEEPER,
	RADIATED_AI,
	
};

void InitHardcodedSchedules()
{
	Radiated_AI(); 
	
	Grave_Keeper();
	Jail(); 
	
} 

void hlist(Critter&cr,int,int,int)
{
	array<string@>names;
	array<int>values;
	uint count=GetEnum("HardcodedSchedules",names,values);
	for(uint e=0;e<count;e++)
	{
		if(values[e]<=0)
		continue;
		
		if(!(@names[e]!=null)||names[e].length()==0)
		continue;
		
		INpcSchedule@schedule=GetScheduleByPid(values[e]);
		if((@schedule!=null))
		{
			
			if(public_schedules.find(schedule.PID)>=0)
			
			cr.Say((11),values[e]+", "+names[e]+", \""+schedule.Name+"\"");
		}
	}
}

void OverrideNpcSchedule(uint pid,INpcSchedule@schedule)
{
	CNpcSchedule@prototypeRaw=cast<CNpcSchedule>(schedule);
	prototypeRaw.pid=pid;
	
	bool added=false;
	for(uint p=0,pLen=prototypes.length();p<pLen;p++)
	{
		if(prototypes[p].PID==pid)
		{
			added=true;
			WLog("npc_schedule","Overriding hardcoded schedule prototype : "+prototypeRaw.FullName,10);
			prototypes[p]=prototypeRaw;
		}
	}
	if(!added)
	{
		WLog("npc_schedule","Adding hardcoded schedule prototype : "+prototypeRaw.FullName,10);
		AddNpcSchedule(prototypeRaw);
	}
	
	CNpcSchedule@proto=GetSchedulePrototype(pid);
	if(!(@proto!=null))
	{
		WLog("npc_schedule","Cannot fetch prototype PID<"+pid+">",30);
		return;
	}
	
	for(uint i=0,iLen=instances.length();i<iLen;i++)
	{
		if(instances[i].prototypePID==pid)
		{
			uint owner=instances[i].Owner;
			WLog("npc_schedule","Overriding hardcoded schedule instance : "+instances[i].FullName,10);
			instances[i].SetPrototype(proto);
			for(uint t=0,tLen=instances[i].tasks.length();t<tLen;t++)
			{
				instances[i].tasks[t].state=TASKSTATE_READY;
			}
		}
	}
}

void Radiated_AI()
{
	INpcSchedule@schedule=CreateNpcSchedule("Radiated AI");     
	
	uint16[][]ncr_sleep=
	{
		{155,79,5}
	};
	
	schedule.AddTask_OnTime("SleepEarly",23,00)
	.Roll(9)
	.If_MapPid((45))
	.Walk_RandomHome(ncr_sleep)
	.EndIf()
	.Sleep();
	
	schedule.AddTask_OnTime("Sleep",01,00)
	.If_MapPid((45))
	.Walk_RandomHome(ncr_sleep)
	.EndIf()
	.Sleep();
	
	uint16[][]ncr_bulletin=
	{
		{131,124,0},
		{130,184,0}
	};
	
	schedule.AddTask_OnMorning("Bulletin")
	.Roll(1500)
	.If_MapPid((45))
	.Walk_RandomHome(ncr_bulletin)
	.EndIf()
	.Wait(((2)*__TimeMultiplier))
	.Say((6),"reads bulletin")
	.Wait_Random(((5)*__TimeMultiplier),((35)*__TimeMultiplier))
	.Say((2),"Nothing interesting... as always."); 
	
	uint16[]CaravanJobMaps=
	{
		(221)
	};
	
	uint16[][]CaravanJobHubPacker=
	{
		{92,56,5},
		{92,57,5},
		{93,56,0},
		{93,57,0},
		{94,56,0}
	};
	uint16[][]CaravanJobHubWagon=
	{
		{89,53,5},
		{91,53,0}
	};
	uint16[][]CaravanJobHubDrop=
	{
		{73,73,4},
		{74,73,5},
		{75,70,0},
		{75,71,0},
		{75,72,0},
		{75,73,0},
		{76,70,0},
		{77,70,0}
	};
	schedule.AddTask_OnEvening("CaravanJob")
	.Roll(1)
	.If_NotMapPids(CaravanJobMaps)
	
	.EndIf()
	.If_MapPids(CaravanJobMaps)
	
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubPacker)
	.Walk_RandomHome(CaravanJobHubWagon)
	.EndIf()
	.Animate((28),true,true)
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubDrop)
	.EndIf()
	.Animate((27),true,true)
	
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubWagon)
	.EndIf()
	.Animate((28),true,true)
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubDrop)
	.EndIf()
	.Animate((27),true,true)
	
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubWagon)
	.EndIf()
	.Animate((28),true,true)
	.If_Percent(25)
	.Say((2),"Hngh... These boxes are heavier than i though...")
	.EndIf()
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubDrop)
	.EndIf()
	.Animate((27),true,true)
	
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubWagon)
	.EndIf()
	.Animate((28),true,true)
	.Wait(((1)*__TimeMultiplier))
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubDrop)
	.EndIf()
	.Animate((27),true,true)
	
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubWagon)
	.EndIf()
	.Animate((28),true,true)
	.Wait(((1)*__TimeMultiplier))
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubDrop)
	.EndIf()
	.Animate((27),true,true)
	.If_Percent(25)
	.Say_Wait((2),"Half of job done, ha!")
	.EndIf()
	
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubWagon)
	.EndIf()
	.Animate((28),true,true)
	.Wait(((1)*__TimeMultiplier))
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubDrop)
	.EndIf()
	.Animate((27),true,true)
	
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubWagon)
	.EndIf()
	.Animate((28),true,true)
	.Wait(((1)*__TimeMultiplier))
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubDrop)
	.EndIf()
	.Animate((27),true,true)
	
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubWagon)
	.EndIf()
	.Animate((28),true,true)
	.Wait(((1)*__TimeMultiplier))
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubDrop)
	.EndIf()
	.Animate((27),true,true)
	
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubWagon)
	.EndIf()
	.Animate((28),true,true)
	.Wait(((1)*__TimeMultiplier))
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubDrop)
	.EndIf()
	.Animate((27),true,true)
	.If_Percent(25)
	.Say((2),"Just one more...")
	.EndIf()
	
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubWagon)
	.EndIf()
	.Animate((28),true,true)
	.Wait(((1)*__TimeMultiplier))
	.If_MapPid((221))
	.Walk_RandomHome(CaravanJobHubDrop)
	.EndIf()
	.Animate((27),true,true)
	.Walk_RandomHome(CaravanJobHubPacker)
	.EndIf();
	
	uint16[]BarrelMaps=
	{
		(45)
	};
	uint16[][]BarrelNCR=
	{
		{36,74,4},
		{23,84,3},
		{34,103,5},
		{59,106,0},
		{75,85,0},
		{56,79,2}
	};
	schedule.AddTask_OnIdle("Barrel")
	.Roll(500)
	.If_MapPids(BarrelMaps)
	.If_MapPid((45))
	.Walk_RandomHome(BarrelNCR)
	.EndIf()
	.Wait(((1)*__TimeMultiplier))
	.Animate((28),true,true)
	.If_Morning()
	.VerboseAction("warms hands")
	.EndIf() 
	
	.If_Evening()
	.VerboseAction("puts something into fire")
	.EndIf()
	.If_Night()
	.VerboseAction("warms hands")
	.EndIf()
	.Wait_Random(((10)*__TimeMultiplier),((30)*__TimeMultiplier))
	.EndIf();
	
	uint16[][]ncr_nukacola1=
	{
		{109,231,5}
	};
	uint16[][]ncr_nukacola2=
	{
		{127,234,0},
		{122,230,2},
		{117,234,3}
	};
	schedule.AddTask_OnIdle("NukaCola")
	.Roll(500)
	.Walk_RandomHome(ncr_nukacola1)
	.Animate((28),true,true)
	.VerboseAction("takes nuka cola")
	.Walk_RandomHome(ncr_nukacola2)
	.Wait(((1)*__TimeMultiplier))
	.VerboseAction("drinks nuka cola")
	.Animate((28),true,true)
	.Wait(((3)*__TimeMultiplier))
	.Say((2),"Oh yea!")
	.Wait_Random(((1)*__TimeMultiplier),((1)*__TimeMultiplier*60));
	
	schedule.AddTask_OnIdle("Song: Caravan")
	.Roll(5000)
	.If_NotMapPid((70))
	.Say_Wait((2),"Carry me, caravan, take me away...")
	.Say_Wait((2),"...take me to Quincy, take me to The Gray..")
	.Say_Wait((2),"...Modoc with fields full of grain...")
	.Say_Wait((2),"..I have to see you... again and again...")
	.Say_Wait((2),"...take me... Junktown Caravan...")
	.Say_Wait((2),"...yes I know you can...")
	.Wait(((1)*__TimeMultiplier*60))
	.EndIf();                                    
	
	OverrideNpcSchedule(RADIATED_AI,schedule);
}                           

void Grave_Keeper()
{
	INpcSchedule@schedule=CreateNpcSchedule("Grave Keeper");
	INpcTask@task=null;                                
	
	uint16[]graves=
	{
		(75),
		(6),
		(62),
		(247)
	};
	uint16[][]graves_cathedral=
	{
		{112,42},
		{116,42},
		{120,42},
		{125,42},
		{124,49},
		{124,56},
		{125,64},
		{120,64},
		{116,64},
		{112,64},
		{111,56}
	};
	uint16[][]idle_cathedral=
	{
		{83,63,1},
		{81,63,2},
		{79,63,2},
		{77,63,2},
		{77,63,3},
		{75,64,3},
		{75,66,3},
		{75,68,4},
		{76,69,4},
		{77,70,5},
		{79,70,5},
		{82,70,0},
		{83,65,1},
		{83,67,0},
		{83,69,0},
		
		{82,57,5},
		{62,57,5}
	};
	uint16[][]graves_den=
	{
		{123,146},
		{120,145},
		{116,145},
		{113,145},
		{109,145},
		{123,155},
		{119,155},
		{115,155},
		{111,155},
		{108,155},
		{122,160},
		{119,161},
		{115,160},
		{112,160},
		{109,161}
	};
	uint16[][]idle_den=
	{
		
		{85,88,0},
		{85,89,0},
		{85,90,0},
		{85,91,0},
		{85,92,0},
		{85,93,0},
		{85,94,0},
		{85,95,0},
		{85,96,0},
		{85,97,0},
		{85,98,0},
		{85,99,0},
		{85,100,0},
		{85,101,0},
		{85,102,0},
		{85,103,0},
		{85,104,0},
		{85,105,0},
		{85,106,0},
		{85,107,0},
		{85,108,0},
		{85,109,0},
		{85,110,0},
		{85,111,0},
		{85,112,0},
		{85,113,0}
	};
	uint16[][]graves_redding=
	{
		{73,28},
		{69,28},
		{65,28},
		{61,28},
		{73,35},
		{69,35},
		{65,35},
		{61,35}
	};
	uint16[][]idle_redding=
	{ 
		
		{78,61,5},
		{86,54,0},
		{86,55,0}
	};
	uint16[][]graves_golgotha=
	{ 
		
		{42,66},
		{49,62},
		{61,65},
		{69,59},
		{76,70},
		{83,67},
		{80,55},
		{59,97},
		{72,91},
		{83,99},
		{80,105},
		{79,115},
		{77,126},
		{69,118},
		{84,138},
		{122,123},
		{119,105},
		{113,99},
		{109,94},
		{114,93},
		{123,98},
		{132,96},
		{110,67},
		{115,68},
		{122,64},
		{118,56},
		{105,58},
		{108,51},
		{113,48},
		{102,36}
		
	};
	uint16[][]idle_golgotha=
	{
		
		{97,46,3}
	};
	@task=schedule.AddTask_OnIdle("Check graves")
	.Roll(50)
	.If_NotMapPids(graves)
	.Say((9),"INVALID MAP")
	.Wait(((10)*__TimeMultiplier))
	.EndIf()
	.If_MapPids(graves)
	 .If_MapPid((75)); for(uint g=0,gLen=graves_cathedral.length();g<gLen;g++) { task.If_ContainerOpened(344,graves_cathedral[g][0],graves_cathedral[g][1]); uint16[][]home={ {graves_cathedral[g][0]+2,graves_cathedral[g][1]+1,0}, {graves_cathedral[g][0]+2,graves_cathedral[g][1]+2,0}, {graves_cathedral[g][0]-1,graves_cathedral[g][1]-1,3}, {graves_cathedral[g][0]-1,graves_cathedral[g][1],3} }; home.removeAt(0); task.Walk_RandomHome(home) .If_ContainerOpened(344,graves_cathedral[g][0],graves_cathedral[g][1]) .Container_Close(344,graves_cathedral[g][0],graves_cathedral[g][1],(28)) .EndIf() .EndIf(); } task.Walk_RandomHome(idle_cathedral) .Wait_Random(((15)*__TimeMultiplier),((30)*__TimeMultiplier)) .EndIf()
	 .If_MapPid((6)); for(uint g=0,gLen=graves_den.length();g<gLen;g++) { task.If_ContainerOpened(344,graves_den[g][0],graves_den[g][1]); uint16[][]home={ {graves_den[g][0]+2,graves_den[g][1]+1,0}, {graves_den[g][0]+2,graves_den[g][1]+2,0}, {graves_den[g][0]-1,graves_den[g][1]-1,3}, {graves_den[g][0]-1,graves_den[g][1],3} }; home.removeAt(0); task.Walk_RandomHome(home) .If_ContainerOpened(344,graves_den[g][0],graves_den[g][1]) .Container_Close(344,graves_den[g][0],graves_den[g][1],(28)) .EndIf() .EndIf(); } task.Walk_RandomHome(idle_den) .Wait_Random(((15)*__TimeMultiplier),((30)*__TimeMultiplier)) .EndIf()
	 .If_MapPid((62)); for(uint g=0,gLen=graves_redding.length();g<gLen;g++) { task.If_ContainerOpened(344,graves_redding[g][0],graves_redding[g][1]); uint16[][]home={ {graves_redding[g][0]+2,graves_redding[g][1]+1,0}, {graves_redding[g][0]+2,graves_redding[g][1]+2,0}, {graves_redding[g][0]-1,graves_redding[g][1]-1,3}, {graves_redding[g][0]-1,graves_redding[g][1],3} }; home.removeAt(0); task.Walk_RandomHome(home) .If_ContainerOpened(344,graves_redding[g][0],graves_redding[g][1]) .Container_Close(344,graves_redding[g][0],graves_redding[g][1],(28)) .EndIf() .EndIf(); } task.Walk_RandomHome(idle_redding) .Wait_Random(((15)*__TimeMultiplier),((30)*__TimeMultiplier)) .EndIf()
	 .If_MapPid((247)); for(uint g=0,gLen=graves_golgotha.length();g<gLen;g++) { task.If_ContainerOpened(344,graves_golgotha[g][0],graves_golgotha[g][1]); uint16[][]home={ {graves_golgotha[g][0]+2,graves_golgotha[g][1]+1,0}, {graves_golgotha[g][0]+2,graves_golgotha[g][1]+2,0}, {graves_golgotha[g][0]-1,graves_golgotha[g][1]-1,3}, {graves_golgotha[g][0]-1,graves_golgotha[g][1],3} }; home.removeAt(0); task.Walk_RandomHome(home) .If_ContainerOpened(344,graves_golgotha[g][0],graves_golgotha[g][1]) .Container_Close(344,graves_golgotha[g][0],graves_golgotha[g][1],(28)) .EndIf() .EndIf(); } task.Walk_RandomHome(idle_golgotha) .Wait_Random(((15)*__TimeMultiplier),((30)*__TimeMultiplier)) .EndIf()
	 .If_MapPid((247)); for(uint g=0,gLen=graves_golgotha.length();g<gLen;g++) { task.If_ContainerOpened(345,graves_golgotha[g][0],graves_golgotha[g][1]); uint16[][]home={ {graves_golgotha[g][0]+2,graves_golgotha[g][1]+1,0}, {graves_golgotha[g][0]+2,graves_golgotha[g][1]+2,0}, {graves_golgotha[g][0]-1,graves_golgotha[g][1]-1,3}, {graves_golgotha[g][0]-1,graves_golgotha[g][1],3} }; home.removeAt(0); task.Walk_RandomHome(home) .If_ContainerOpened(345,graves_golgotha[g][0],graves_golgotha[g][1]) .Container_Close(345,graves_golgotha[g][0],graves_golgotha[g][1],(28)) .EndIf() .EndIf(); } task.Walk_RandomHome(idle_golgotha) .Wait_Random(((15)*__TimeMultiplier),((30)*__TimeMultiplier)) .EndIf()
	.EndIf();
	
	OverrideNpcSchedule(GRAVE_KEEPER,schedule);
} 

void Jail()
{
	INpcSchedule@schedule=CreateNpcSchedule("Jail: emitters");
	INpcTask@task=null;
	
	uint16[][]emitters_idle=
	{
		{178,203,2},
		{176,203,2}
	};
	uint16[][]emitters_west=
	{
		{180,218,0},
		{168,218,1},
		{168,226,1},
		{180,226,0},
		{180,234,0},
		{168,234,1},
		{168,242,1},
		{180,242,0},
		{180,250,0},
		{168,250,1}
	};
	uint16[][]emitters_east=
	{
		{152,218,0},
		{140,218,1},
		{140,226,1},
		{152,226,0},
		{152,234,0},
		{140,234,1},
		{140,242,1},
		{152,242,0},
		{152,250,0},
		{140,250,1}
	};             
	
	@task=schedule.AddTask_OnMinute("Check emitters",00)
	 .If_MapPid((380)); for(uint e=0,eLen=emitters_west.length();e<eLen;e++) { if(emitters_west[e][2]==0) task.Walk_Home(emitters_west[e][0]-1,emitters_west[e][1]+1,4); else task.Walk_Home(emitters_west[e][0]+1,emitters_west[e][1]+1,0);  } task.EndIf()
	 .If_MapPid((380)); for(uint e=0,eLen=emitters_east.length();e<eLen;e++) { if(emitters_east[e][2]==0) task.Walk_Home(emitters_east[e][0]-1,emitters_east[e][1]+1,4); else task.Walk_Home(emitters_east[e][0]+1,emitters_east[e][1]+1,0);  } task.EndIf()
	.Walk_RandomHome(emitters_idle);
	
	OverrideNpcSchedule(JAIL_EMITTERS,schedule);
}  

import bool GodOfTheRealm(uint id)from"cheats";
import bool WrathOfTheGod(Critter&di)from"cheats";  

uint lastSchedulePID=1;
uint lastScheduleID=1;

class CNpcSchedule:INpcSchedule
{
	uint pid;
	string name;
	bool hardcoded;
	
	array<CNpcTask@>tasks;
	
	CNpcSchedule(string&name)
	{
		this.Init();
		
		this.pid=lastSchedulePID++;
		this.name=name;
	}
	
	CNpcSchedule()
	{
		this.Init();
	}
	
	void Init()
	{
		this.pid=0;
		this.name="";
		this.hardcoded=false;
		this.tasks.resize(0);
	} 
	
	uint get_PID()
	{
		return(this.pid);
	}
	
	string get_Name()
	{
		return(this.name);
	}
	
	string get_FullName()
	{
		return(this.Name+"["+this.PID+"]");
	} 
	
	CNpcSchedule Clone()
	{
		CNpcSchedule clone=this;
		
		return(clone);
	}
	
	CNpcTask@AddTask(NpcTaskType type,string&name)
	{
		CNpcTask@task=CNpcTask(name,this);
		
		task.type=type;
		
		tasks.insertLast(task);
		
		return(task);
	}
	
	INpcTask@AddTask_OnFirstCall(string&name)
	{
		return(AddTask(TASK_FIRST_CALL,name));
	}
	
	INpcTask@AddTask_OnIdle(string&name)
	{
		return(AddTask(TASK_IDLE,name));
	}
	
	INpcTask@AddTask_OnTime(string&name,uint8 hour,uint8 minute)
	{
		if(hour>23||minute>59)
		{
			WLog("npc_schedule","Invalid arguments for new task<"+name+">, ignoring : "+this.FullName,20);
			return(null);
		}
		
		uint8[]checked_h={hour};
		uint8[]checked_m={minute};
		
		return(AddTask_OnTimes(name,checked_h,checked_m));
	}
	
	INpcTask@AddTask_OnTimes(string&name,array<uint8>&hours,array<uint8>&minutes)
	{
		if(hours.length()!=minutes.length())
		{
			WLog("npc_schedule","Invalid arguments length for new task<"+name+">, ignoring : "+this.FullName,20);
			return(null);
		}
		
		array<uint8>checked_h,checked_m;
		
		for(uint h=0,hLen=hours.length();h<hLen;h++)
		{
			if(hours[h]>23||minutes[h]>59)
			{
				WLog("npc_schedule","Invalid arguments for new task<"+name+">, ignoring : "+this.FullName,20);
				continue;
			}
			
			checked_h.insertLast(hours[h]);
			checked_m.insertLast(minutes[h]);
		}
		
		if(checked_h.length()==0||checked_h.length()!=checked_m.length())
		{
			WLog("npc_schedule","No times set, task not created : "+this.FullName,20);
			return(null);
		}
		
		CNpcTask@task=AddTask(TASK_TIME,name);
		
		task.hours=checked_h;
		task.minutes=checked_m;
		
		return(task);
	}
	
	INpcTask@AddTask_OnHour(string&name,uint8 hour)
	{
		if(hour>23)
		{
			WLog("npc_schedule","Invalid arguments for new task<"+name+">, ignoring : "+this.FullName,20);
			return(null);
		}
		
		uint8[]checked={hour};
		
		return(AddTask_OnHours(name,checked));
	}
	
	INpcTask@AddTask_OnHours(string&name,array<uint8>&hours)
	{
		array<uint8>checked;
		
		for(uint h=0,hLen=hours.length();h<hLen;h++)
		{
			if(hours[h]>23)
			{
				WLog("npc_schedule","Invalid hour argument for new task<"+name+">, ignoring : "+this.FullName,20);
				continue;
			}
			
			if(checked.find(hours[h])<0)
			checked.insertLast(hours[h]);
		}
		
		if(checked.length()==0)
		{
			WLog("npc_schedule","No hours set, task not created : "+this.FullName,20);
			return(null);
		}
		
		CNpcTask@task=AddTask(TASK_HOUR,name);
		
		task.hours=checked;
		
		return(task);
	}
	
	INpcTask@AddTask_OnMinute(string&name,uint8 minute)
	{
		if(minute>59)
		{
			WLog("npc_schedule","Invalid minute argument for new task<"+name+">, ignoring : "+this.FullName,20);
			return(null);
		}
		
		uint8[]checked={minute};
		
		return(AddTask_OnMinutes(name,checked));
	}
	
	INpcTask@AddTask_OnMinutes(string&name,array<uint8>&minutes)
	{
		array<uint8>checked;
		
		for(uint m=0,mLen=minutes.length();m<mLen;m++)
		{
			if(minutes[m]>59)
			{
				WLog("npc_schedule","Invalid minute arguments for new task<"+name+">, ignoring : "+this.FullName,20);
				return(null);
			}
			
			if(checked.find(minutes[m])<0)
			checked.insertLast(minutes[m]);
		}
		
		if(checked.length()==0)
		{
			WLog("npc_schedule","No minutes set, task not created : "+this.FullName,20);
			return(null);
		}
		
		CNpcTask@task=AddTask(TASK_MINUTE,name);
		
		task.minutes=checked;
		
		return(task);
	}
	
	INpcTask@AddTask_OnNight(string&name)
	{
		return(AddTask(TASK_NIGHT,name));
	}
	
	INpcTask@AddTask_OnDay(string&name)
	{
		return(AddTask(TASK_DAY,name));
	}
	
	INpcTask@AddTask_OnMorning(string&name)
	{
		return(AddTask(TASK_MORNING,name));
	}
	
	INpcTask@AddTask_OnAfternoon(string&name)
	{
		return(AddTask(TASK_AFTERNOON,name));
	}
	
	INpcTask@AddTask_OnEvening(string&name)
	{
		return(AddTask(TASK_EVENING,name));
	}
	
	INpcTask@AddTask_EveryNight(string&name)
	{
		return(this.AddTask_OnTime(name,22,0));
	}
	
	INpcTask@AddTask_EveryDay(string&name)
	{
		return(this.AddTask_EveryMorning(name));
	}
	
	INpcTask@AddTask_EveryMorning(string&name)
	{
		return(this.AddTask_OnTime(name,7,0));
	}
	
	INpcTask@AddTask_EveryAfternoon(string&name)
	{
		return(this.AddTask_OnTime(name,12,0));
	}
	INpcTask@AddTask_EveryEvening(string&name)
	{
		return(this.AddTask_OnTime(name,18,0));
	}
	
	INpcTask@AddTask_EveryFullHour(string&name)
	{
		return(this.AddTask_OnMinute(name,0));
	} 
	
	uint GetTasks(array<INpcTask@>&tasksList)
	{
		uint count=0;
		for(uint t=0,tLen=this.tasks.length();t<tLen;t++)
		{
			tasksList.insertLast(this.tasks[t]);
			count++;
		}
		
		return(count);
	}
	
	void Save(Buffer&buffer)
	{
		buffer<<this.pid<<this.name<<this.tasks.length();
		
		for(uint t=0,tLen=this.tasks.length();t<tLen;t++)
		{
			this.tasks[t].Save(buffer);
		}
	}
	
	void Load(Buffer&buffer)
	{
		this.Init();
		
		uint tasksCount=0;
		
		buffer>>this.pid>>this.name>>tasksCount;
		
		WLog("npc_schedule","Loading schedule, "+tasksCount+" task"+(tasksCount!=1?"s":"")+" : "+this.FullName,0);
		for(uint a=0;a<tasksCount;a++)
		{
			CNpcTask@task=CNpcTask(this);
			task.Load(buffer);
			this.tasks.insertLast(task);
		}
	}
};

class CNpcTask:INpcTask
{
	string name;
	
	INpcSchedule@parentSchedule;
	
	array<CNpcTaskAction@>actions;
	array<CNpcTaskAction@>actionsQueue;
	
	NpcTaskType type;
	
	array<uint8>hours;
	array<uint8>minutes;
	uint roll;
	
	CNpcTask(INpcSchedule&parentSchedule)
	{
		this.Init();
		
		@this.parentSchedule=parentSchedule;
	}
	
	CNpcTask(string&name,INpcSchedule&parentSchedule)
	{
		this.Init();
		
		this.name=name;
		@this.parentSchedule=parentSchedule;
	}
	
	void Init(bool keepParent=false)
	{
		this.name="";
		
		if(!keepParent)
		@this.parentSchedule=null;
		
		this.actions.resize(0);
		
		this.type=TASK_NONE;
		
		this.hours.resize(0);
		this.minutes.resize(0);
		this.roll=uint(-1);
	} 
	
	NpcTaskType get_Type()
	{
		return(this.type);
	}
	
	string get_Name()
	{
		return(this.name);
	}
	
	string get_FullName()
	{
		return(this.parentSchedule.FullName+"->"+this.Name);
	}
	
	array<uint8>get_Hours()
	{
		
		return(this.hours);
	}
	
	array<uint8>get_Minutes()
	{
		return(this.minutes);
	} 
	
	INpcSchedule@ParentSchedule()
	{
		return(this.parentSchedule);
	}
	
	uint GetActions(array<INpcTaskAction@>&actionsList)
	{
		uint count=0;
		for(uint a=0,aLen=this.actions.length();a<aLen;a++)
		{
			actionsList.insertLast(this.actions[a]);
			count++;
		}
		
		return(count);
	}
	
	void Save(Buffer&buffer)
	{
		buffer<<this.name<<uint(this.actions.length());
		buffer<<int(this.type)<<this.hours<<this.minutes<<this.roll;
		
		for(uint a=0,aLen=this.actions.length();a<aLen;a++)
		{
			this.actions[a].Save(buffer);
		}
	}
	
	void Load(Buffer&buffer)
	{
		this.Init(true);
		
		uint dataCount=0,actionCount=0;
		
		buffer>>this.name>>actionCount;
		
		WLog("npc_schedule","Loading task, "+actionCount+" action"+(actionCount!=1?"s":"")+" : "+this.FullName,0);
		
		int typeTemp=TASK_NONE;
		
		buffer>>typeTemp>>this.hours>>this.minutes>>this.roll;
		
		this.type=NpcTaskType(typeTemp);
		
		for(uint a=0;a<actionCount;a++)
		{
			CNpcTaskAction@action=CNpcTaskAction(this);
			
			action.Load(buffer);
			
			FTaskAction@function=null;
			switch(action.type)
			{ 
				
				case ACTION_CONTAINER:
				@function=Action_Container;
				break;
				case ACTION_EDITITEM:
				@function=Action_EditItem;
				break;
				case ACTION_HOME:
				@function=Action_Home;
				break;
				case ACTION_IF:
				@function=Action_If;
				break;
				case ACTION_ENDIF:
				@function=Action_EndIf;
				break;
				case ACTION_INVENTORY:
				@function=Action_Inventory;
				break;
				case ACTION_MAP:
				@function=Action_Map;
				break;
				case ACTION_SAY:
				@function=Action_Say;
				break;
				case ACTION_TASKVAR:
				@function=Action_TaskVar;
				break;
				case ACTION_WAIT:
				@function=Action_Wait;
				break;  
				
				case ACTION_VERBOSE:
				@function=Action_Verbose;
				break;
				case ACTION_DEMANDANSWER:
				@function=Action_DemandAnswer;
				break;
				case ACTION_ANIMATE:
				@function=Action_Animate;
				break;
				case ACTION_SLEEP:
				@function=Action_Sleep;
				break;
				case ACTION_WAKEUP:
				@function=Action_WakeUp;
				break;
				case ACTION_FIXFORCEFIELD:
				@function=Action_FixForcefield;
				break;
				
				case ACTION_CUSTOM:
				@function=Action_Custom;
				break;
			}
			
			if((@function!=null))
			{
				WLog("npc_schedule","Loading action #"+a+", type<"+action.type+"> : "+this.FullName,0);
				this.AddAction(action.type,function,action.data,action.requireMap);
			}
			else
			WLog("npc_schedule","Unknown action type<"+action.type+"> : "+this.FullName,20);
		}
	}  
	
	void AddAction(NpcTaskActionType type,FTaskAction&function,bool requireMap)final
	{
		array<uint8>dummy;
		dummy.resize(0);
		
		this.AddAction(type,function,dummy,requireMap);
	}
	
	void AddAction(NpcTaskActionType type,FTaskAction&function,array<uint8>data,bool requireMap)final
	{
		CNpcTaskAction@action=CNpcTaskAction(this);
		
		action.type=type;
		action.Function(function,data);
		action.requireMap=requireMap;
		
		this.actions.insertLast(action);
	}        
	
	 INpcTask@Add_EditItem(array<uint8>data,bool map){AddAction(ACTION_EDITITEM,Action_EditItem,data,map);return(this);} INpcTask@Add_EditItem(NpcActionEditItem type,bool map){Buffer@buffer=Buffer_EditItem(type);return(Add_EditItem(buffer.AsUint8(),map));} Buffer@Buffer_EditItem(NpcActionEditItem type){Buffer@buffer=NewBuffer();buffer<<int(type);return(buffer);}
	 INpcTask@Add_Container(array<uint8>data,bool map){AddAction(ACTION_CONTAINER,Action_Container,data,map);return(this);} INpcTask@Add_Container(NpcActionContainer type,bool map){Buffer@buffer=Buffer_Container(type);return(Add_Container(buffer.AsUint8(),map));} Buffer@Buffer_Container(NpcActionContainer type){Buffer@buffer=NewBuffer();buffer<<int(type);return(buffer);}
	 INpcTask@Add_Home(array<uint8>data,bool map){AddAction(ACTION_HOME,Action_Home,data,map);return(this);} INpcTask@Add_Home(NpcActionHome type,bool map){Buffer@buffer=Buffer_Home(type);return(Add_Home(buffer.AsUint8(),map));} Buffer@Buffer_Home(NpcActionHome type){Buffer@buffer=NewBuffer();buffer<<int(type);return(buffer);}
	 INpcTask@Add_If(array<uint8>data,bool map){AddAction(ACTION_IF,Action_If,data,map);return(this);} INpcTask@Add_If(NpcActionIf type,bool map){Buffer@buffer=Buffer_If(type);return(Add_If(buffer.AsUint8(),map));} Buffer@Buffer_If(NpcActionIf type){Buffer@buffer=NewBuffer();buffer<<int(type);return(buffer);}
	 INpcTask@Add_Inventory(array<uint8>data,bool map){AddAction(ACTION_INVENTORY,Action_Inventory,data,map);return(this);} INpcTask@Add_Inventory(NpcActionInventory type,bool map){Buffer@buffer=Buffer_Inventory(type);return(Add_Inventory(buffer.AsUint8(),map));} Buffer@Buffer_Inventory(NpcActionInventory type){Buffer@buffer=NewBuffer();buffer<<int(type);return(buffer);}
	 INpcTask@Add_Map(array<uint8>data,bool map){AddAction(ACTION_MAP,Action_Map,data,map);return(this);} INpcTask@Add_Map(NpcActionMap type,bool map){Buffer@buffer=Buffer_Map(type);return(Add_Map(buffer.AsUint8(),map));} Buffer@Buffer_Map(NpcActionMap type){Buffer@buffer=NewBuffer();buffer<<int(type);return(buffer);}
	 INpcTask@Add_Say(array<uint8>data,bool map){AddAction(ACTION_SAY,Action_Say,data,map);return(this);} INpcTask@Add_Say(NpcActionSay type,bool map){Buffer@buffer=Buffer_Say(type);return(Add_Say(buffer.AsUint8(),map));} Buffer@Buffer_Say(NpcActionSay type){Buffer@buffer=NewBuffer();buffer<<int(type);return(buffer);}
	 INpcTask@Add_TaskVar(array<uint8>data,bool map){AddAction(ACTION_TASKVAR,Action_TaskVar,data,map);return(this);} INpcTask@Add_TaskVar(NpcActionTaskVar type,bool map){Buffer@buffer=Buffer_TaskVar(type);return(Add_TaskVar(buffer.AsUint8(),map));} Buffer@Buffer_TaskVar(NpcActionTaskVar type){Buffer@buffer=NewBuffer();buffer<<int(type);return(buffer);}
	 INpcTask@Add_Wait(array<uint8>data,bool map){AddAction(ACTION_WAIT,Action_Wait,data,map);return(this);} INpcTask@Add_Wait(NpcActionWait type,bool map){Buffer@buffer=Buffer_Wait(type);return(Add_Wait(buffer.AsUint8(),map));} Buffer@Buffer_Wait(NpcActionWait type){Buffer@buffer=NewBuffer();buffer<<int(type);return(buffer);}   
	
	INpcTask@Roll(uint max)
	{
		this.roll=max;
		
		return(this);
	}    
	
	INpcTask@Container_Open(uint16 pid,uint16 hexX,uint16 hexY,uint anim2)
	{
		Buffer@buffer=Buffer_Container(CONTAINER_OPEN);
		buffer<<pid<<hexX<<hexY<<anim2;
		
		return(Add_Container(buffer.AsUint8(),true));
	}
	
	INpcTask@Container_Close(uint16 pid,uint16 hexX,uint16 hexY,uint anim2)
	{
		Buffer@buffer=Buffer_Container(CONTAINER_CLOSE);
		buffer<<pid<<hexX<<hexY<<anim2;
		
		return(Add_Container(buffer.AsUint8(),true));
	}
	
	INpcTask@Container_OpenNear(uint anim2)
	{
		Buffer@buffer=Buffer_Container(CONTAINER_OPEN_NEAR);
		buffer<<anim2;
		
		return(Add_Container(buffer.AsUint8(),true));
	}
	
	INpcTask@Container_CloseNear(uint anim2)
	{
		Buffer@buffer=Buffer_Container(CONTAINER_CLOSE_NEAR);
		buffer<<anim2;
		
		return(Add_Container(buffer.AsUint8(),true));
	}  
	
	INpcTask@EditItem_Update()
	{
		return(Add_EditItem(EDITITEM_UPDATE,false));
	}
	
	INpcTask@EditItem_SetFlag(uint flag)
	{
		Buffer@buffer=Buffer_EditItem(EDITITEM_SETFLAG);
		buffer<<flag;
		
		return(Add_EditItem(buffer.AsUint8(),false));
	}
	
	INpcTask@EditItem_UnsetFlag(uint flag)
	{
		Buffer@buffer=Buffer_EditItem(EDITITEM_UNSETFLAG);
		buffer<<flag;
		
		return(Add_EditItem(buffer.AsUint8(),false));
	}
	
	INpcTask@EditItem_Flags(uint flags)
	{
		Buffer@buffer=Buffer_EditItem(EDITITEM_FLAGS);
		buffer<<flags;
		
		return(Add_EditItem(buffer.AsUint8(),false));
	}
	
	INpcTask@EditItem_PicMap(string&picmap)
	{
		Buffer@buffer=Buffer_EditItem(EDITITEM_PICMAP);
		buffer<<picmap;
		
		return(Add_EditItem(buffer.AsUint8(),false));
	}
	
	INpcTask@EditItem_SetScript(string&script)
	{
		Buffer@buffer=Buffer_EditItem(EDITITEM_SETSCRIPT);
		buffer<<script;
		
		return(Add_EditItem(buffer.AsUint8(),false));
	}
	
	INpcTask@EditItem_SetEvent(int event,string&function)
	{
		Buffer@buffer=Buffer_EditItem(EDITITEM_SETEVENT);
		buffer<<event<<function;
		
		return(Add_EditItem(buffer.AsUint8(),false));
	}
	
	INpcTask@EditItem_PicInv(string&picinv)
	{
		Buffer@buffer=Buffer_EditItem(EDITITEM_PICINV);
		buffer<<picinv;
		
		return(Add_EditItem(buffer.AsUint8(),false));
	}  
	
	INpcTask@Home_Set(uint16 hexX,uint16 hexY,uint8 dir)
	{
		Buffer@buffer=Buffer_Home(HOME_SET);
		buffer<<hexX<<hexY<<dir; 
		
		return(this.Add_Home(buffer.AsUint8(),true));
	}
	
	INpcTask@Home_SetRandom(array<array<uint16>>positions)
	{
		array<array<uint16>>checked;
		
		for(uint p=0,pLen=positions.length();p<pLen;p++)
		{
			if(positions[p].length()>=3)
			{
				uint16[]needed={positions[p][0],positions[p][1],(((positions[p][2])>(5))?(5):(((positions[p][2])<(0))?(0):(positions[p][2])))};
				checked.insertLast(needed);
			}
		}
		
		if(checked.length()==0)
		{
			WLog("npc_schedule","Invalid positions list, action not added : "+this.FullName,10);
			PrintCallstack();
		}
		Buffer@buffer=Buffer_Home(HOME_SETRANDOM);
		buffer<<positions; 
		
		return(this.Add_Home(buffer.AsUint8(),true));
	}
	
	INpcTask@Home_Save()
	{
		return(this.Add_Home(HOME_SAVE,true));
	}
	
	INpcTask@Home_Load()
	{
		return(this.Add_Home(HOME_LOAD,true));
	}
	
	INpcTask@Home_Reset()
	{
		return(this.Add_Home(HOME_RESET,true));
	}  
	
	INpcTask@If_Never()
	{
		return(Add_If(IF_NEVER,false));
	}
	
	INpcTask@If_Always()
	{
		return(Add_If(IF_ALWAYS,false));
	}
	
	INpcTask@If_TaskVarLower(string&name,int value)
	{
		Buffer@buffer=Buffer_If(IF_TASKVAR_LOWER);
		buffer<<name<<value;
		
		return(this.Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_TaskVarLowerEqual(string&name,int value)
	{
		Buffer@buffer=Buffer_If(IF_TASKVAR_LOWEREQUAL);
		buffer<<name<<value;
		
		return(this.Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_TaskVarEqual(string&name,int value)
	{
		Buffer@buffer=Buffer_If(IF_TASKVAR_EQUAL);
		buffer<<name<<value;
		
		return(this.Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_TaskVarNotEqual(string&name,int value)
	{
		Buffer@buffer=Buffer_If(IF_TASKVAR_NOTEQUAL);
		buffer<<name<<value;
		
		return(this.Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_TaskVarGreater(string&name,int value)
	{
		Buffer@buffer=Buffer_If(IF_TASKVAR_GREATER);
		buffer<<name<<value;
		
		return(this.Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_TaskVarGreaterEqual(string&name,int value)
	{
		Buffer@buffer=Buffer_If(IF_TASKVAR_GREATEREQUAL);
		buffer<<name<<value;
		
		return(this.Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_Percent(uint8 percent)
	{
		percent=(((percent)>(100))?(100):(((percent)<(1))?(1):(percent)));
		
		Buffer@buffer=Buffer_If(IF_PERCENT);
		buffer<<percent;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_Night()
	{
		return(Add_If(IF_NIGHT,false));
	}
	
	INpcTask@If_Day()
	{
		return(Add_If(IF_DAY,false));
	}
	
	INpcTask@If_Morning()
	{
		return(Add_If(IF_MORNING,false));
	}
	
	INpcTask@If_Afternoon()
	{
		return(Add_If(IF_AFTERNOON,false));
	}
	
	INpcTask@If_Evening()
	{
		return(Add_If(IF_EVENING,false));
	}
	INpcTask@If_Year(uint8 year)
	{
		Buffer@buffer=Buffer_If(IF_YEAR);
		buffer<<year;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_Month(uint8 month)
	{
		if(month==0||month>12)
		{
			WLog("npc_schedule","Invalid month, ignoring",20);
			return(this);
		}
		
		Buffer@buffer=Buffer_If(IF_MONTH);
		buffer<<month;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_DayOfMonth(uint8 day)
	{
		Buffer@buffer=Buffer_If(IF_DAYOFMONTH);
		buffer<<day;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_Hour(uint8 hour)
	{
		if(hour>23)
		{
			WLog("npc_schedule","Invalid hour, ignoring",20);
			return(this);
		}
		
		Buffer@buffer=Buffer_If(IF_HOUR);
		buffer<<hour;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_Minute(uint8 minute)
	{
		if(minute>59)
		{
			WLog("npc_schedule","Invalid minute, ignoring",20);
			return(this);
		}
		
		Buffer@buffer=Buffer_If(IF_MINUTE);
		buffer<<minute;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_Worldmap()
	{
		return(Add_If(IF_WORLDMAP,false));
	}
	
	INpcTask@If_NotWorldmap()
	{
		return(Add_If(IF_NOT_WORLDMAP,false));
	}
	
	INpcTask@If_MapPid(uint16 pid)
	{
		Buffer@buffer=Buffer_If(IF_MAP_PID);
		buffer<<pid;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_MapPids(array<uint16>pids)
	{
		Buffer@buffer=Buffer_If(IF_MAP_PIDS);
		buffer<<pids;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_NotMapPid(uint16 pid)
	{
		Buffer@buffer=Buffer_If(IF_NOT_MAP_PID);
		buffer<<pid;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_NotMapPids(array<uint16>pids)
	{
		Buffer@buffer=Buffer_If(IF_NOT_MAP_PIDS);
		buffer<<pids;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_ContainerOpened(uint16 hexX,uint16 hexY,uint16 pid)
	{
		Buffer@buffer=Buffer_If(IF_CONTAINER_OPENED);
		buffer<<hexX<<hexY<<pid;
		
		return(Add_If(buffer.AsUint8(),true));
	}
	
	INpcTask@If_ContainerClosed(uint16 hexX,uint16 hexY,uint16 pid)
	{
		Buffer@buffer=Buffer_If(IF_CONTAINER_CLOSED);
		buffer<<hexX<<hexY<<pid;
		
		return(Add_If(buffer.AsUint8(),true));
	}
	
	INpcTask@If_ParamBaseLower(uint16 param,int value)
	{
		param=(((param)>(999))?(999):(((param)<(0))?(0):(param)));
		
		Buffer@buffer=Buffer_If(IF_PARAMBASE_LOWER);
		buffer<<param<<value;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_ParamBaseLowerEqual(uint16 param,int value)
	{
		param=(((param)>(999))?(999):(((param)<(0))?(0):(param)));
		
		Buffer@buffer=Buffer_If(IF_PARAMBASE_LOWEREQUAL);
		buffer<<param<<value;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_ParamBaseEqual(uint16 param,int value)
	{
		param=(((param)>(999))?(999):(((param)<(0))?(0):(param)));
		
		Buffer@buffer=Buffer_If(IF_PARAMBASE_EQUAL);
		buffer<<param<<value;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_ParamBaseNotEqual(uint16 param,int value)
	{
		param=(((param)>(999))?(999):(((param)<(0))?(0):(param)));
		
		Buffer@buffer=Buffer_If(IF_PARAMBASE_NOTEQUAL);
		buffer<<param<<value;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_ParamBaseGreater(uint16 param,int value)
	{
		param=(((param)>(999))?(999):(((param)<(0))?(0):(param)));
		
		Buffer@buffer=Buffer_If(IF_PARAMBASE_GREATER);
		buffer<<param<<value;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_ParamBaseGreaterEqual(uint16 param,int value)
	{
		param=(((param)>(999))?(999):(((param)<(0))?(0):(param)));
		
		Buffer@buffer=Buffer_If(IF_PARAMBASE_GREATEREQUAL);
		buffer<<param<<value;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_ParamLower(uint16 param,int value)
	{
		param=(((param)>(999))?(999):(((param)<(0))?(0):(param)));
		
		Buffer@buffer=Buffer_If(IF_PARAM_LOWER);
		buffer<<param<<value;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_ParamLowerEqual(uint16 param,int value)
	{
		param=(((param)>(999))?(999):(((param)<(0))?(0):(param)));
		
		Buffer@buffer=Buffer_If(IF_PARAM_LOWEREQUAL);
		buffer<<param<<value;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_ParamEqual(uint16 param,int value)
	{
		param=(((param)>(999))?(999):(((param)<(0))?(0):(param)));
		
		Buffer@buffer=Buffer_If(IF_PARAM_EQUAL);
		buffer<<param<<value;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_ParamNotEqual(uint16 param,int value)
	{
		param=(((param)>(999))?(999):(((param)<(0))?(0):(param)));
		
		Buffer@buffer=Buffer_If(IF_PARAM_NOTEQUAL);
		buffer<<param<<value;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_ParamGreater(uint16 param,int value)
	{
		param=(((param)>(999))?(999):(((param)<(0))?(0):(param)));
		
		Buffer@buffer=Buffer_If(IF_PARAM_GREATER);
		buffer<<param<<value;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@If_ParamGreaterEqual(uint16 param,int value)
	{
		param=(((param)>(999))?(999):(((param)<(0))?(0):(param)));
		
		Buffer@buffer=Buffer_If(IF_PARAM_GREATEREQUAL);
		buffer<<param<<value;
		
		return(Add_If(buffer.AsUint8(),false));
	}
	
	INpcTask@EndIf()
	{
		this.AddAction(ACTION_ENDIF,Action_EndIf,false);
		
		return(this);
	}  
	
	INpcTask@Inventory_AddItem(uint16 pid)
	{
		return(this.Inventory_AddItem(pid,1));
	}
	
	INpcTask@Inventory_AddItem(uint16 pid,uint count)
	{
		Buffer@buffer=Buffer_Inventory(INV_ADDITEM);
		buffer<<pid<<count;
		
		return(this.Add_Inventory(buffer.AsUint8(),false));
	}
	
	INpcTask@Inventory_SubItem(uint16 pid)
	{
		return(this.Inventory_SubItem(pid,uint(-1)));
	}
	
	INpcTask@Inventory_SubItem(uint16 pid,uint count)
	{
		Buffer@buffer=Buffer_Inventory(INV_SUBITEM);
		buffer<<pid<<count;
		
		return(this.Add_Inventory(buffer.AsUint8(),false));
	}
	
	INpcTask@Inventory_SetFavouriteItem(uint8 slot,uint16 pid)
	{
		if(slot>(3))
		{
			WLog("npc_schedule","Invalid slot<"+slot+">, ignoring",20);
			return(this);
		}
		
		Buffer@buffer=Buffer_Inventory(INV_FAVITEM);
		buffer<<slot<<pid;
		
		return(this.Add_Inventory(buffer.AsUint8(),false));
	}
	
	INpcTask@Inventory_UseFavouriteItem(uint8 slot,uint16 pid)
	{
		this.Inventory_SetFavouriteItem(slot,pid);
		this.Wait_FavouriteItem(slot);
		
		return(this);
	}  
	
	INpcTask@Map_CreateItem(uint16 pid,uint16 hexX,uint16 hexY,uint count)
	{
		Buffer@buffer=Buffer_Map(MAP_CREATEITEM);
		buffer<<pid<<hexX<<hexY<<count;
		
		return(this.Add_Map(buffer.AsUint8(),true));
	}
	
	INpcTask@Map_DeleteItem(uint16 pid,uint16 hexX,uint16 hexY)
	{
		Buffer@buffer=Buffer_Map(MAP_DELETEITEM);
		buffer<<pid<<hexX<<hexY;
		
		return(this.Add_Map(buffer.AsUint8(),true));
	}  
	
	INpcTask@Say(uint8 sayType,string&text)
	{
		Buffer@buffer=Buffer_Say(SAY_SINGLE);
		buffer<<sayType<<text;
		
		return(this.Add_Say(buffer.AsUint8(),false));
	}
	
	INpcTask@Say_Wait(uint8 sayType,string&text)
	{
		this.Say(sayType,text);
		this.Wait(((1)*__TimeMultiplier)+((text.length()%10)*__TimeMultiplier));
		
		return(this);
	}
	
	INpcTask@Say_TaskVar(string&name)
	{      
		
		return(this);
	}
	
	INpcTask@Say_Random(uint8 sayType,array<string>&text)
	{
		if(text.length()==0)
		return(this);
		
		Buffer@buffer=Buffer_Say(SAY_RANDOM);
		buffer<<sayType<<text;
		
		return(this.Add_Say(buffer.AsUint8(),false));
	}  
	
	INpcTask@TaskVar_Delete(string&name)
	{
		Buffer@buffer=Buffer_TaskVar(TASKVAR_DELETE);
		buffer<<name;
		
		return(this.Add_TaskVar(buffer.AsUint8(),false));
	}
	
	INpcTask@TaskVar_Set(string&name,int value)
	{
		Buffer@buffer=Buffer_TaskVar(TASKVAR_SET);
		buffer<<name<<value;
		
		return(this.Add_TaskVar(buffer.AsUint8(),false));
	}
	
	INpcTask@TaskVar_Add(string&name)
	{
		return(this.TaskVar_Add(name,1));
	}
	
	INpcTask@TaskVar_Sub(string&name)
	{
		return(this.TaskVar_Sub(name,1));
	}
	
	INpcTask@TaskVar_Add(string&name,int value_add)
	{
		Buffer@buffer=Buffer_TaskVar(TASKVAR_ADD);
		buffer<<name<<value_add;
		
		return(this.Add_TaskVar(buffer.AsUint8(),false));
	}
	
	INpcTask@TaskVar_Sub(string&name,int value_sub)
	{
		Buffer@buffer=Buffer_TaskVar(TASKVAR_SUB);
		buffer<<name<<value_sub;
		
		return(this.Add_TaskVar(buffer.AsUint8(),false));
	}
	
	INpcTask@TaskVar_SetRandom(string&name,int from,int to)
	{
		Buffer@buffer=Buffer_TaskVar(TASKVAR_SETRANDOM);
		buffer<<name<<from<<to;
		
		return(this.Add_TaskVar(buffer.AsUint8(),false));
	}
	
	INpcTask@TaskVar_AddRandom(string&name,int from,int to)
	{
		Buffer@buffer=Buffer_TaskVar(TASKVAR_ADDRANDOM);
		buffer<<name<<from<<to;
		
		return(this.Add_TaskVar(buffer.AsUint8(),false));
	}
	
	INpcTask@TaskVar_SubRandom(string&name,int from,int to)
	{
		Buffer@buffer=Buffer_TaskVar(TASKVAR_SUBRANDOM);
		buffer<<name<<from<<to;
		
		return(this.Add_TaskVar(buffer.AsUint8(),false));
	}
	
	INpcTask@CopyToGameVar(string&name,uint8 varType,uint16 varId,bool map)
	{
		Buffer@buffer=Buffer_TaskVar(TASKVAR_COPYTO);
		buffer<<name<<varType<<varId;
		
		return(this.Add_TaskVar(buffer.AsUint8(),map));
	}
	
	INpcTask@CopyFromGameVar(string&name,uint8 varType,uint16 varId,bool map)
	{
		Buffer@buffer=Buffer_TaskVar(TASKVAR_COPYFROM);
		buffer<<name<<varType<<varId;
		
		return(this.Add_TaskVar(buffer.AsUint8(),map));
	}
	
	INpcTask@TaskVar_CopyToGlobalVar(string&name,uint16 GVAR)
	{
		return(CopyToGameVar(name,(0),GVAR,false));
	}
	
	INpcTask@TaskVar_CopyFromGlobalVar(string&name,uint16 GVAR)
	{
		return(CopyFromGameVar(name,(0),GVAR,false));
	}
	
	INpcTask@TaskVar_CopyToLocationVar(string&name,uint16 LLVAR)
	{
		return(CopyToGameVar(name,(3),LLVAR,true));
	}
	
	INpcTask@TaskVar_CopyFromLocationVar(string&name,uint16 LLVAR)
	{
		return(CopyFromGameVar(name,(3),LLVAR,true));
	}
	
	INpcTask@TaskVar_CopyToMapVar(string&name,uint16 LMVAR)
	{
		return(CopyToGameVar(name,(4),LMVAR,true));
	}
	
	INpcTask@TaskVar_CopyFromMapVar(string&name,uint16 LMVAR)
	{
		return(CopyFromGameVar(name,(4),LMVAR,true));
	}
	
	INpcTask@TaskVar_CopyToCritterVar(string&name,uint16 LVAR)
	{
		return(CopyToGameVar(name,(1),LVAR,false));
	}
	
	INpcTask@TaskVar_CopyFromCritterVar(string&name,uint16 LVAR)
	{
		return(CopyFromGameVar(name,(1),LVAR,false));
	}  
	
	INpcTask@Wait(uint time)
	{
		Buffer@buffer=Buffer_Wait(WAIT_TIME);
		buffer<<time;
		
		return(this.Add_Wait(buffer.AsUint8(),false));
	}
	
	INpcTask@Wait_Random(uint min,uint max)
	{
		if(max<=min)
		{
			WLog("npc_schedule","Maximum <= Minimum; using Wait(minimum) instead : "+this.FullName,10);
			return(this.Wait(min));
		}
		Buffer@buffer=Buffer_Wait(WAIT_RANDOM);
		buffer<<min<<max;
		
		return(Add_Wait(buffer.AsUint8(),false));
	}
	
	INpcTask@Wait_Home()
	{
		return(this.Add_Wait(WAIT_HOME,true));
	}
	
	INpcTask@Wait_FavouriteItem(uint8 slot)
	{
		if(slot>=(4))
		{
			WLog("npc_schedule","Invalid slot, ignoring",0);
			return(this);
		}
		
		Buffer@buffer=Buffer_Wait(WAIT_FAVITEM);
		buffer<<slot;
		
		return(this.Add_Wait(buffer.AsUint8(),false));
	}  
	
	INpcTask@VerboseAction(string&text)
	{
		Buffer@buffer=NewBuffer();
		buffer<<text;
		
		this.AddAction(ACTION_VERBOSE,Action_Verbose,buffer.AsUint8(),false);
		
		return(this);
	}
	
	INpcTask@DemandAnswer(uint8 sayType,string&text)
	{
		Buffer@buffer=NewBuffer();
		buffer<<sayType<<text;
		
		this.AddAction(ACTION_DEMANDANSWER,Action_DemandAnswer,buffer.AsUint8(),true);
		
		return(this);
	}  
	
	INpcTask@Animate(uint anim2,bool clearSequence,bool delayPlay)
	{
		Buffer@buffer=NewBuffer();
		buffer<<anim2<<clearSequence<<delayPlay;
		
		this.AddAction(ACTION_ANIMATE,Action_Animate,buffer.AsUint8(),true);
		
		return(this);
	}  
	
	INpcTask@Sleep()
	{
		this.AddAction(ACTION_SLEEP,Action_Sleep,true);
		
		WakeUp();
		
		return(this);
	}
	
	INpcTask@WakeUp()
	{
		this.AddAction(ACTION_WAKEUP,Action_WakeUp,false);
		
		return(this);
	}
	
	INpcTask@FixForcefield(uint16 hexX,uint16 hexY,uint anim2)
	{
		Buffer@buffer=NewBuffer();
		buffer<<hexX<<hexY<<anim2;
		
		this.AddAction(ACTION_FIXFORCEFIELD,Action_FixForcefield,buffer.AsUint8(),true);
		
		return(this);
	}  
	
	INpcTask@Walk_Home(uint16 hexX,uint16 hexY,uint8 dir)
	{
		Home_Set(hexX,hexY,dir);
		Wait_Home();
		
		return(this);
	}
	
	INpcTask@Walk_Home(array<uint16>&position)
	{
		if(position.length()<3)
		return(this);
		
		return(Walk_Home(position[0],position[1],position[2]));
	}
	
	INpcTask@Walk_RandomHome(array<array<uint16>>positions)
	{
		this.Home_SetRandom(positions);
		this.Wait_Home();
		
		return(this);
	}
	
	INpcTask@Walk_Patrol(array<array<uint16>>&patrol,bool saveHome)
	{
		if(patrol.length()<1)
		return(this);
		
		array<array<uint16>>checked;
		
		for(uint p=0,pLen=patrol.length();p<pLen;p++)
		{
			if(patrol[p].length()!=3||patrol[p][2]>5)
			{
				WLog("npc_schedule","Invalid position, ignoring : "+this.FullName,10);
				continue;
			}
			checked.insertLast(patrol[p]);
		}
		
		if(checked.length()==0)
		{
			WLog("npc_schedule","Invalid positions list, action not added : "+this.FullName,10);
			PrintCallstack();
		}
		
		if(saveHome)
		this.Home_Save();
		
		for(uint c=0,cLen=checked.length();c<cLen;c++)
		{
			this.Walk_Home(checked[c]);
		}
		
		if(saveHome)
		{
			this.Home_Load();
			this.Wait_Home();
		}
		
		return(this);
	}
	
	INpcTask@CustomAction(string&functionName,bool requireMap)
	{
		Buffer@buffer=NewBuffer();
		buffer<<functionName;
		
		this.AddAction(ACTION_CUSTOM,Action_Custom,buffer.AsUint8(),requireMap);
		
		return(this);
	}
};

class CNpcTaskAction:INpcTaskAction
{
	INpcTask@parentTask;
	
	NpcTaskActionType type;
	array<uint8>data;
	FTaskAction@function;
	
	bool requireMap;
	
	CNpcTaskAction(INpcTask&parentTask)
	{
		this.Init();
		
		@this.parentTask=parentTask;
	} 
	
	uint8 get_Type()
	{
		return(this.type);
	}
	
	array<uint8>get_Data()
	{
		return(this.data);
	} 
	
	void Init(bool keepParent=false)
	{
		this.type=ACTION_NONE;
		this.data.resize(0);
		@this.function=null;
		
		this.requireMap=true;
		
		if(!keepParent)
		@this.parentTask=null;
	}
	
	INpcTask@ParentTask()
	{
		return(this.parentTask);
	}
	
	bool Function(FTaskAction&function)
	{
		if(!(@function!=null))
		return(false);
		
		@this.function=function;
		this.data.resize(0);
		
		return(true);
	}
	
	bool Function(FTaskAction&function,array<uint8>data)
	{
		if(this.Function(function))
		{
			this.data=data;
			return(true);
		}
		
		return(false);
	}
	
	void Save(Buffer&buffer)
	{
		buffer<<int(this.type);
		buffer<<this.data;
		buffer<<this.requireMap;
	}
	
	void Load(Buffer&buffer)
	{
		this.Init(true);
		
		int typeTemp=0;
		
		buffer>>typeTemp>>this.data;
		buffer>>this.requireMap;
		
		this.type=NpcTaskActionType(typeTemp);
	}
};

array<CNpcSchedule@>prototypes;
array<CNpcScheduleInstance@>instances;

void InitNpcSchedules()
{  
	
	if(IsAnyData("NpcSchedule"))
	{
		array<uint8>scheduleData;
		
		if(!GetAnyData("NpcSchedule",scheduleData))
		{
			Log("Error loading npc schedules data");
			return;
		}
		
		Buffer@data=NewBuffer(scheduleData);
		
		uint countPrototypes=0,countInstances=0;
		data>>lastSchedulePID>>lastScheduleID>>countPrototypes>>countInstances;
		
		WLog("npc_schedule","Loading schedules prototypes ("+countPrototypes+")",0);
		for(uint s=0;s<countPrototypes;s++)
		{
			CNpcSchedule@schedule=CNpcSchedule();
			schedule.Load(data);
			prototypes.insertLast(schedule);
		}
		
		WLog("npc_schedule","Loading schedules instances ("+countInstances+")",0);
		for(uint s=0;s<countInstances;s++)
		{
			WLog("npc_schedule","Loading schedule instance "+(s+1)+"/"+countInstances,0);
			CNpcScheduleInstance@instance=CNpcScheduleInstance();
			if(instance.Load(data))
			instances.insertLast(instance);
		}
		
		WLog("npc_schedule","Initializing hardcoded schedules",0);
		InitHardcodedSchedules();
	}
	else
	{
		WLog("npc_schedule","Initializing hardcoded schedules",0);
		InitHardcodedSchedules();
	}
	
	Log("Initialized npc schedules ("+prototypes.length()+" prototype"+(prototypes.length()!=1?"s":"")+", "+instances.length()+" instance"+(instances.length()!=1?"s":"")+")");
}

void SaveNpcSchedules()
{
	Buffer@data=NewBuffer();
	
	uint countPrototypes=prototypes.length(),countInstances=instances.length();
	
	data<<lastSchedulePID<<lastScheduleID<<countPrototypes<<countInstances;
	
	for(uint p=0;p<countPrototypes;p++)
	{
		prototypes[p].Save(data);
	}
	
	for(uint i=0;i<countInstances;i++)
	{
		instances[i].Save(data);
	}
	
	EraseAnyData("NpcSchedule");
	SetAnyData("NpcSchedule",data.AsUint8());
}

INpcSchedule@CreateNpcSchedule(string&name)
{
	CNpcSchedule@schedule=CNpcSchedule(name);
	
	WLog("npc_schedule","Created schedule : "+schedule.FullName,0);
	
	return(schedule);
}

bool AddNpcSchedule(INpcSchedule@schedule)
{
	if(!(@schedule!=null))
	{
		WLog("npc_schedule","Schedule not valid",20);
		return(false);
	}
	
	for(uint p=0,pLen=prototypes.length();p<pLen;p++)
	{
		if(prototypes[p].PID==schedule.PID)
		{
			WLog("npc_schedule","Schedule with PID<"+schedule.PID+"> already exists",10);
			return(false);
		}
		if(prototypes[p].Name==schedule.Name)
		{
			WLog("npc_schedule","Schedule with name<"+schedule.Name+"> already exists",10);
			return(false);
		}
	}
	
	prototypes.insertLast(cast<CNpcSchedule>(schedule));
	WLog("npc_schedule","Added schedule with PID<"+prototypes.last().PID+"> name<"+prototypes.last().Name+">",0);
	
	return(true);
}

INpcSchedule@GetScheduleByPid(uint pid)
{
	for(uint p=0,pLen=prototypes.length();p<pLen;p++)
	{
		if(prototypes[p].pid==pid)
		return(prototypes[p]);
	}
	
	return(null);
}

CNpcSchedule@GetSchedulePrototype(uint pid)
{
	for(uint p=0,pLen=prototypes.length();p<pLen;p++)
	{
		if(prototypes[p].pid==pid)
		return(prototypes[p]);
	}
	
	return(null);
}

INpcSchedule@GetScheduleByName(string&name)
{
	for(uint p=0,pLen=prototypes.length();p<pLen;p++)
	{
		if(prototypes[p].name==name)
		return(prototypes[p]);
	}
	
	return(null);
}

INpcScheduleInstance@GetScheduleByOwner(uint id)
{
	for(uint i=0,iLen=instances.length();i<iLen;i++)
	{
		
		if(instances[i].Owner==id)
		return(instances[i]);
	}
	
	return(null);
}

bool SetSchedule(string&name,Critter&npc)
{
	for(uint p=0,pLen=prototypes.length();p<pLen;p++)
	{
		if(prototypes[p].Name==name)
		{
			return(SetSchedule(prototypes[p].pid,npc));
		}
	}
	
	return(false);
}

bool SetSchedule(uint pid,Critter&npc)
{
	RemoveNpcSchedule(npc);
	
	CNpcSchedule@proto=GetSchedulePrototype(pid);
	
	if(!(@proto!=null))
	{
		WLog("npc_schedule","Can't set schedule PID<"+pid+"> for "+npc.Name+"<"+npc.Id+"> : UNUSUABLE",20);
		return(false);
	}
	
	CNpcScheduleInstance@instance=CNpcScheduleInstance(proto,npc);
	
	instances.insertLast(instance);
	WLog("npc_schedule","Added schedule for "+npc.Name+" : "+instance.FullName,0);
	
	npc.AddTimeEvent("cte_NpcSchedule",((1)*__TimeMultiplier),(10));
	
	return(true);
}

void RemoveNpcSchedule(Critter&npc)
{
	npc.EraseTimeEvents(int((10)));
	for(uint i=0,iLen=instances.length();i<iLen;i++)
	{
		if(instances[i].Owner==npc.Id)
		{
			WLog("npc_schedule","Removing schedule instance : "+instances[i].FullName,0);
			instances.removeAt(i);
			return;
		}
	} 
	
}

uint cte_NpcSchedule(Critter&npc,int identifier,uint&)
{
	if(identifier!=(10))
	return(0);
	
	if(npc.IsDead())
	return(((5)));
	
	INpcScheduleInstance@instance=GetScheduleByOwner(npc.Id);
	if(!(@instance!=null))
	{
		WLog("npc_schedule","Schedule instance does not exist, removing critter event: "+npc.Name,0);
		return(0);
	}
	
	uint delay=instance.Run(npc);
	
	if(delay>0)
	return(delay);
	
	return(((10)));
}

void purge(Critter&cr,int,int,int)
{
	
	if(!GodOfTheRealm(cr.Id))
	{
		cr.Say((11),"No.");
		return;
	} 
	
	removeall(cr,0,0,0);
	InitNpcSchedules();
}

void removeall(Critter&cr,int,int,int)
{
	
	if(!GodOfTheRealm(cr.Id))
	{
		cr.Say((11),"No.");
		return;
	} 
	
	EraseAnyData("NpcSchedule");
	prototypes.resize(0);
	instances.resize(0);
	lastSchedulePID=1000;
}

void setLast(Critter&cr,int schedulePid,int,int,string@,array<int>@)
{
	set(cr,schedulePid,0,cr.LastSpawnedCritter);
}

void set(Critter&cr,int schedulePid,int x,int crId)
{
	Critter@npc=GetCritter(crId);
	if(!(@npc!=null))
	{
		cr.Say((11),"Critter<"+crId+"> not valid.");
		return;
	} 
	
	if(!npc.IsNpc())
	{
		if(WrathOfTheGod(cr)&&x==42)
		cr.Say((11),"WARNING: Schedule target is a player");
		else
		{
			cr.Say((11),"Critter<"+crId+"> must be NPC.");
			return;
		}
	} 
	
	if(schedulePid!=0&&!(@GetScheduleByPid(schedulePid)!=null))
	{
		cr.Say((11),"Schedule<"+schedulePid+"> not valid.");
		return;
	} 
	
	if(public_schedules.find(schedulePid)<0)
	{
		cr.Say((11),"Schedule<"+schedulePid+"> not on public.");
		return;
	} 
	
	if(SetSchedule(schedulePid,npc))
	{
		cr.Say((11),"Schedule<"+schedulePid+"> set.");                 
		
	}
	else
	cr.Say((11),"Schedule<"+schedulePid+"> NOT set.");
}

void unset(Critter&cr,int,int x,int crId)
{
	Critter@npc=GetCritter(crId);
	if(!(@npc!=null))
	{
		cr.Say((11),"Critter<"+crId+"> not valid.");
		return;
	} 
	
	if(!npc.IsNpc())
	{
		if(WrathOfTheGod(cr)&&x==42)
		cr.Say((11),"WARNING: Schedule target is a player");
		else
		{
			cr.Say((11),"Critter<"+crId+"> must be NPC.");
			return;
		}
	} 
	
	RemoveNpcSchedule(npc);  
	
}

