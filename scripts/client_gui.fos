//
// FOnline: 2238
// Rotators
//
// client_gui.fos
//

// Client GUI

#define CLIENT_GUI
#include "client_gui_h.fos"
#include "_client_defines.fos"
#include "sprite.fos"
#include "_colors.fos"

#define REMOVE_FROM_ARRAY                                           \
    # (a, idx)       { if(a.length() > 0 && uint(idx) < a.length()) \
                           for(uint iter = idx; iter < a.length() - 1; iter++) { a[iter] = a[iter + 1]; }; a.resize(a.length() - 1); }
#define IS_COLLISION    # (x1, y1, x2, y2, w, h)((x1) >= (x2) && (x1) <= (x2) + (w) && (y1) >= (y2) && (y1) <= (y2) + (h))

import void SetupFixboyAddons() from "client_fixboy";
import bool IsClientScreenBig() from "client_main";

array<GUIScreen@> AllScreens;
array<GUIScreen@> ActiveScreens;
array<bool>       KeyPressed;
// array<KeybData@>  KbData;
IGUIScreenOpt@    LastScreenOpt = null;
// IGUIElementOpt@ LastElementOpt=null;

/* class KeybData
{
    KeybData(int8 r, int8 rs, int8 e, int8 es)
    {
        Char.resize(4);
        Char[0] = r;
        Char[1] = rs;
        Char[2] = e;
        Char[3] = es;
    }
    array<uint8> Char;     // Russian, Rissian Shift, English, English Shift
}; */


bool GUI_IsKeyPressed(uint8 key)
{
    return KeyPressed[key];
}

// do usuniecia
/* bool ProcessKey(uint8 key, string& text, uint8& letter)
{
    if(KeyPressed.length() == 0)
        return false;

    if(key == DIK_BACK)
    {
        if(text.length() > 0)
            text.resize(text.length() - 1);
        return true;
    }

    KeybData@ k = KbData[key];
    if(!(k is null))
    {
        bool shiftDown = (KeyPressed[DIK_LSHIFT] || KeyPressed[DIK_RSHIFT]);
        uint len = text.length();
        text.resize(len + 1);
        text[len] = k.Char[ GetKeybLang() * 2 + (shiftDown ? 1 : 0)];
        letter = text[len];
        return true;
    }
    return false;
} */

/* bool ProcessKey( uint8 key, string& keyText, string& text )
{
    if( key == DIK_BACK )
    {
        if( text.length() > 0 )
            text[ -1 ] = "";
        return true;
    }

    if( keyText != "" )
    {
        text += keyText;
        return true;
    }
    return false;
} */

/* uint8 GUI_GetCharacter(uint8 key)
{
    KeybData@ k = KbData[key];
    if(!(k is null))
    {
        bool shiftDown = (GUI_IsKeyPressed(DIK_LSHIFT) || GUI_IsKeyPressed(DIK_RSHIFT));
        return k.Char[ GetKeybLang() * 2 + (shiftDown ? 1 : 0)];
    }
    else
        return 0;
} 

uint8 GUI_GetCharacterShift(uint8 key, bool shiftDown)
{
    KeybData@ k = KbData[key];
    if(!(k is null))
    {
        return k.Char[ GetKeybLang() * 2 + (shiftDown ? 1 : 0)];
    }
    else
        return 0;
} */

/* uint8 GUI_GetCharacter(uint8 key, string& keyText)
{
    if( keyText != "" )
    {
        return keyText.Char[key];
    }
    else
        return 0;
} */

/* uint8 GUI_GetCharacterShift(uint8 key, bool shiftDown, string& keyText)
{
    if( keyText != "" )
    {
        return k.Char[ GetKeybLang() * 2 + (shiftDown ? 1 : 0)];
    }
    else
        return 0;
} */

void GUI_GetIniCoords(string& ini, int& left, int& top, int& right, int& bottom)
{
    array<string@>@ values = split(::GetIfaceIniStr(ini), " ");
    if(values.length() < 4)
    {
        Message("Wrong ini data for entry: " + ini + ".");
        left = top = right = bottom = 0;
        return;
    }
    StrToInt(values[0], left);
    StrToInt(values[1], top);
    StrToInt(values[2], right);
    StrToInt(values[3], bottom);
}

class GUIScreen : IGUIScreenOpt
{
    GUIScreen(string@ sprName, int path)
    {
        if(@sprName != null)
            Surface.Load(sprName, path);
        Index = 0;
        IsCanMove = true;
        IsModal = true;
        IsMultiinstance = false;
        IsIgnoreBorders = false;
        IsCloseOnMiss = false;
        IsAutoCursor = false;
        IsHardcoded = false;
        IsLMouseDown = false;

        AutoCursorType = CURSOR_DEFAULT;
        AutoCursorPrev = CURSOR_DEFAULT;

        PosX = __ScreenWidth / 2 - Surface.Width / 2;
        PosY = __ScreenHeight / 2 - Surface.Height / 2;
        width = height = 0;
        // LastX=0;
        // LastY=0;
        @CallbackShow = null;
        @CallbackHide = null;
        @CallbackMove = null;
        @CallbackFocus = null;
        @CallbackMouseDown = null;
	     @CallbackKeyPress = null;
    }

    void Draw()
    {
        //if(IsClientScreenBig() && Index == CLIENT_SCREEN_DIALOG)
			//SetDefaultFont(FONT_THIN, COLOR_TEXT);
		if(IsHardcoded)
        {
            // ::DrawHardcodedScreen(Index);
            // ::GetHardcodedScreenPos(Index, PosX, PosY);
			DrawHardcodedScreen(Index);
            GetHardcodedScreenPos(Index, PosX, PosY);
        }
		
		if(Surface.Id != 0)
            DrawSprite(Surface.Id, -1, PosX, PosY, 0);

        if(valid(screenControl))
            screenControl.Draw();

         //brzydki tymczasowy merg z gui z w2155
         for(uint i=0,j=elements.length();i<j;i++)
         {
            elements[i].Draw(PosX,PosY);
         }
		 //if(IsClientScreenBig() && Index == CLIENT_SCREEN_DIALOG)
			//SetDefaultFont(FONT_FALLOUT, COLOR_TEXT);
    }
    void Update(uint dt)
    {
        //if(IsClientScreenBig() && Index == CLIENT_SCREEN_DIALOG)
			//SetDefaultFont(FONT_THIN, COLOR_TEXT);
			
		if(valid(screenControl))
            screenControl.Update();
		
		

         //brzydki tymczasowy merg z gui z w2155
         for(uint i=0,j=elements.length();i<j;i++)
         {
            elements[i].Update(dt);
         }
		 //if(IsClientScreenBig() && Index == CLIENT_SCREEN_DIALOG)
			//SetDefaultFont(FONT_FALLOUT, COLOR_TEXT);
    }

    bool MouseDown(int x, int y, int click)
    {
        bool intercepted = false;
        if(valid(screenControl))
            intercepted = screenControl.MouseDown(x, y, click);

        if(@CallbackMouseDown != null) CallbackMouseDown.OnMouseDown(click); 
         
        if(!intercepted)
        {
            if(!IsHardcoded && click == MOUSE_CLICK_LEFT && IS_COLLISION(x, y, PosX, PosY, GetWidth(), GetHeight()))
            {
                IsLMouseDown = true;
                // LastX=x;
                // LastY=y;
                return true;
            }
            else if(IsCloseOnMiss)
            {
                HideScreen(0, 0, 0, 0);
                return true;
            }
            // window loosing focus
            if(!IsModal && !IsHardcoded && !IS_COLLISION(x, y, PosX, PosY, GetWidth(), GetHeight()))
            {
                if(!(CallbackFocus is null))
                    CallbackFocus.OnLostFocus();
            }
        }
        return intercepted;
    }

    bool MouseUp(int x, int y, int click)
    {
        IsLMouseDown = false;
        if(valid(screenControl))
            return screenControl.MouseUp(x, y, click);
        else
            return false;
    }

    void MouseMove(int fromX, int fromY, int toX, int toY)
    {
        if(IsCanMove && IsLMouseDown)
        {
            int lastPosX = PosX;
            int lastPosY = PosY;
            int offsX = toX - fromX;
            int offsY = toY - fromY;
            // LastX=fromX;
            // LastY=fromY;
            PosX += offsX;
            PosY += offsY;

            // Check screen borders
            if(!IsIgnoreBorders)
            {
                int px = PosX;
                int py = PosY;
                if(PosX < 0)
                    PosX = 0;
                if(PosY < 0)
                    PosY = 0;
                if(PosX + GetWidth() > __ScreenWidth)
                    PosX = __ScreenWidth - GetWidth();
                if(PosY + GetHeight() > __ScreenHeight)
                    PosY = __ScreenHeight - GetHeight();
                // LastX+=PosX-px;
                // LastY+=PosY-py;
            }
            if(lastPosX != PosX || lastPosY != PosY)
            {
                if(!(CallbackMove is null))
                    CallbackMove.OnMove(PosX, PosY);
                if(valid(screenControl))
                    screenControl.Position(GetPosX(), GetPosY());
            }
        }

        if(valid(screenControl))
            screenControl.MouseMove(fromX, fromY, toX, toY);
    }

    // bool KeyDown(uint8 key, string& keyText)
	bool KeyDown(uint8 key, string& keyText)
    {
        if(not (CallbackKeyPress is null)) CallbackKeyPress.OnKeyPress(key, keyText);

        if(valid(screenControl))
            return screenControl.KeyDown(key, keyText);
        else
            return false;
    }

    void InputLost()
    {
        IsLMouseDown = false;
        // for(uint i=0,j=Elements.length();i<j;i++) Elements[i].InputLost();
    }

    /*GUIScreen@ GetNewInstance()
       {
            GUIScreen screen=this;
            IGUIScreenCallbackShow@ newCallback=CallbackShow;
            //for(uint i=0,j=controls.length();i<j;i++) @screen.controls[i]=controls[i].Clone();
            return @screen;
       }*/

    IControl@ Control()
    {
        return(@screenControl);
    }
    IGUIScreenOpt@ Control(IControl@ control)
    {
        @screenControl = control;
        @LastScreenOpt = this;
        control.Init();
        control.Position(GetPosX(), GetPosY());
        control.Width(GetWidth());
        control.Height(GetHeight());
        @LastScreenOpt = null;
        return this;
    }

    // Options
    IGUIScreenOpt@ SetCallbackShow(IGUIScreenCallbackShow@ callback)   { @CallbackShow = callback; return this; }
    IGUIScreenOpt@ SetCallbackHide(IGUIScreenCallbackHide@ callback)   { @CallbackHide = callback; return this; }
	//IGUIScreenOpt@ CallbackMove(IGUIScreenCallbackMove@ callback){@MoveCallback=callback; return this;}
    IGUIScreenOpt@ SetCallbackMove(IGUIScreenCallbackMove@ callback)   { @CallbackMove = callback; return this; }
    IGUIScreenOpt@ SetCallbackFocus(IGUIScreenCallbackFocus@ callback) { @CallbackFocus = callback; return this; }
    IGUIScreenOpt@ SetCallbackMouseDown(IGUIScreenCallbackMouseDown@ callback){@CallbackMouseDown=callback; return this;}
	 IGUIScreenOpt@ SetCallbackKeyPress(IGUIScreenCallbackKeyPress@ callback){@CallbackKeyPress=callback; return this;}

    IGUIScreenOpt@ Position(int x, int y)                   { PosX = x; PosY = y; return this; }
    IGUIScreenOpt@ Size(int w, int h)                       { width = w; height = h; return this; }   // custom size, (in case there is no surface for example)
    IGUIScreenOpt@ CanMove(bool enabled)                    { IsCanMove = enabled; return this; }
    IGUIScreenOpt@ Modal(bool enabled)                      { IsModal = enabled; return this; }
    IGUIScreenOpt@ Multiinstance(bool enabled)              { IsMultiinstance = enabled; return this; }
    IGUIScreenOpt@ IgnoreBorders(bool enabled)              { IsIgnoreBorders = enabled; return this; }
    IGUIScreenOpt@ CloseOnMiss(bool enabled)                { IsCloseOnMiss = enabled; return this; }
    IGUIScreenOpt@ AutoCursor(bool enabled, int cursorType) { IsAutoCursor = enabled; AutoCursorType = cursorType; return this; }
    IGUIScreenOpt@ Hardcoded(bool enabled)                  { IsHardcoded = enabled; return this; }
	
	
	IGUIScreenOpt@ SizeByMultipleImages(int horizontalCount, int verticalCount)
	{
		this.horizontalCount = horizontalCount;
		this.verticalCount = verticalCount;
		this.screenWidth  = Surface.Width * horizontalCount;
		this.screenHeight = Surface.Height * verticalCount;
		this.PosX=__ScreenWidth/2-screenWidth/2;
		this.PosY=__ScreenHeight/2-screenHeight/2;
		return this;
	}
    // Info
    int GetPosX()   { return PosX; }
    int GetPosY()   { return PosY; }
    int GetWidth()  { return width != 0 ? width : Surface.Width; }
    int GetHeight() { return height != 0 ? height : Surface.Height; }
    int GetIndex()  { return Index; }

    // Data
    int Index;
    int PosX;
    int PosY;
    int width;
    int height;
	int screenWidth;
	int screenHeight;
	uint horizontalCount;
	uint verticalCount;
    // int LastX;
    // int LastY;
    Sprite                   Surface;
    bool                     IsCanMove;
    bool                     IsModal;
    bool                     IsMultiinstance;
    bool                     IsIgnoreBorders;
    bool                     IsCloseOnMiss;
    bool                     IsAutoCursor;
    bool                     IsHardcoded;
    bool                     IsLMouseDown;

    int                      AutoCursorType;
    int                      AutoCursorPrev;

    IGUIScreenCallbackShow@  CallbackShow;
    IGUIScreenCallbackHide@  CallbackHide;
    IGUIScreenCallbackMove@  CallbackMove;
    IGUIScreenCallbackFocus@ CallbackFocus;
    IGUIScreenCallbackMouseDown@ CallbackMouseDown; 
	 IGUIScreenCallbackKeyPress@ CallbackKeyPress;
	 IGUIScreenCallbackMouseMove@ MouseMoveCallback;
	 IGUIScreenCallbackMouseClick@ MouseClickCallback; 
    // main control container for all screen child-controls
    IControl@                screenControl;
    //tymczasowy brzydki merg z guimodem:
    IGUIElementOpt@[] elements;
};

//
// API
//

// Create new screen
IGUIScreenOpt@ GUI_CreateScreen(int screenIndex, string@ sprName)
{
    if(screenIndex == 0)
        return null;
    DeleteScreen(screenIndex);
    return CreateScreen(screenIndex, sprName);
}

// Delete old screen, hardcoded screens included
void GUI_DeleteScreen(int screenIndex)
{
    if(screenIndex == 0)
        return;
    DeleteScreen(screenIndex);
}

// Valid only on IGUIScreenCallbackShow::OnShow callback
IGUIScreenOpt@ GUI_GetScreenOptions()
{
    return LastScreenOpt;
}


//
// Engine callbacks
//

void GUI_Init()
{
    AllScreens.resize(0);
    ActiveScreens.resize(0);
    KeyPressed.resize(0x100);
    for(uint i = 0, j = KeyPressed.length(); i < j; i++)
        KeyPressed[i] = false;

    // Register hardcoded screens
    CreateScreen(CLIENT_MAIN_SCREEN_LOGIN, null);
    CreateScreen(CLIENT_MAIN_SCREEN_REGISTRATION, null);
    CreateScreen(CLIENT_MAIN_SCREEN_OPTIONS, null);
    CreateScreen(CLIENT_MAIN_SCREEN_CREDITS, null);
    CreateScreen(CLIENT_MAIN_SCREEN_GAME, null);
    CreateScreen(CLIENT_MAIN_SCREEN_GLOBAL_MAP, null);
    CreateScreen(CLIENT_MAIN_SCREEN_WAIT, null);
    CreateScreen(CLIENT_SCREEN_INVENTORY, null);
    CreateScreen(CLIENT_SCREEN_PICKUP, null);
    CreateScreen(CLIENT_SCREEN_MINIMAP, null);
    CreateScreen(CLIENT_SCREEN_CHARACTER, null);
    CreateScreen(CLIENT_SCREEN_DIALOG, null);
    CreateScreen(CLIENT_SCREEN_BARTER, null);
    CreateScreen(CLIENT_SCREEN_PIP_BOY, null);
    CreateScreen(CLIENT_SCREEN_FIX_BOY, null);
    CreateScreen(CLIENT_SCREEN_MENU, null);
    CreateScreen(CLIENT_SCREEN_AIM, null);
    CreateScreen(CLIENT_SCREEN_TEST, null);
    CreateScreen(CLIENT_SCREEN_SPLIT, null);
    CreateScreen(CLIENT_SCREEN_TIMER, null);
    CreateScreen(CLIENT_SCREEN_DIALOGBOX, null);
    CreateScreen(CLIENT_SCREEN_ELEVATOR, null);
    CreateScreen(CLIENT_SCREEN_SAY, null);
    CreateScreen(CLIENT_SCREEN_CHA_NAME, null);
    CreateScreen(CLIENT_SCREEN_CHA_AGE, null);
    CreateScreen(CLIENT_SCREEN_CHA_SEX, null);
    CreateScreen(CLIENT_SCREEN_GM_TOWN, null);
    CreateScreen(CLIENT_SCREEN_INPUT_BOX, null);
    CreateScreen(CLIENT_SCREEN_SKILLBOX, null);
    CreateScreen(CLIENT_SCREEN_USE, null);
    CreateScreen(CLIENT_SCREEN_PERK, null);
    CreateScreen(CLIENT_SCREEN_TOWN_VIEW, null);
    CreateScreen(CLIENT_SCREEN_SAVE_LOAD, null);
    for(uint i = 0, j = AllScreens.length(); i < j; i++)
        AllScreens[i].IsHardcoded = true;

    // Keyboard init
	/*
    KbData.resize(0x100);
    @KbData[DIK_1] =                         KeybData('1', '!', '1', '!');
    @KbData[DIK_2] =                         KeybData('2', '"', '2', '@');
    @KbData[DIK_3] =                         KeybData('3', 'ą', '3', '#');
    @KbData[DIK_4] =                         KeybData('4', ';', '4', '$');
    @KbData[DIK_5] =                         KeybData('5', '%', '5', '%');
    @KbData[DIK_6] =                         KeybData('6', ':', '6', '^');
    @KbData[DIK_7] =                         KeybData('7', '?', '7', '&');
    @KbData[DIK_8] =                         KeybData('8', '*', '8', '*');
    @KbData[DIK_9] =                         KeybData('9', '(', '9', '(');
    @KbData[DIK_0] =                         KeybData('0', ')', '0', ')');
    @KbData[DIK_MINUS] =                     KeybData('-', '_', '-', '_');
    @KbData[DIK_EQUALS] =            KeybData('=', '+', '=', '+');
    @KbData[DIK_Q] =                         KeybData('é', 'É', 'q', 'Q');
    @KbData[DIK_W] =                         KeybData('ö', 'Ö', 'w', 'W');
    @KbData[DIK_E] =                         KeybData('ó', 'Ó', 'e', 'E');
    @KbData[DIK_R] =                         KeybData('ę', 'Ę', 'r', 'R');
    @KbData[DIK_T] =                         KeybData('ĺ', 'Ĺ', 't', 'T');
    @KbData[DIK_Y] =                         KeybData('í', 'Í', 'y', 'Y');
    @KbData[DIK_U] =                         KeybData('ă', 'Ă', 'u', 'U');
    @KbData[DIK_I] =                         KeybData('ř', 'Ř', 'i', 'I');
    @KbData[DIK_O] =                         KeybData('ů', 'Ů', 'o', 'O');
    @KbData[DIK_P] =                         KeybData('ç', 'Ç', 'p', 'P');
    @KbData[DIK_LBRACKET] =          KeybData('ő', 'Ő', '[', '{');
    @KbData[DIK_RBRACKET] =          KeybData('ú', 'Ú', ']', '}');
    @KbData[DIK_A] =                         KeybData('ô', 'Ô', 'a', 'A');
    @KbData[DIK_S] =                         KeybData('ű', 'Ű', 's', 'S');
    @KbData[DIK_D] =                         KeybData('â', 'Â', 'd', 'D');
    @KbData[DIK_F] =                         KeybData('ŕ', 'Ŕ', 'f', 'F');
    @KbData[DIK_G] =                         KeybData('ď', 'Ď', 'g', 'G');
    @KbData[DIK_H] =                         KeybData('đ', 'Đ', 'h', 'H');
    @KbData[DIK_J] =                         KeybData('î', 'Î', 'j', 'J');
    @KbData[DIK_K] =                         KeybData('ë', 'Ë', 'k', 'K');
    @KbData[DIK_L] =                         KeybData('ä', 'Ä', 'l', 'L');
    @KbData[DIK_SEMICOLON] =         KeybData('ć', 'Ć', ';', ':');
    @KbData[DIK_APOSTROPHE] =        KeybData('ý', 'Ý', '"', '"');   // todo '
    @KbData[DIK_Z] =                         KeybData('˙', 'ß', 'z', 'Z');
    @KbData[DIK_X] =                         KeybData('÷', '×', 'x', 'X');
    @KbData[DIK_C] =                         KeybData('ń', 'Ń', 'c', 'C');
    @KbData[DIK_V] =                         KeybData('ě', 'Ě', 'v', 'V');
    @KbData[DIK_B] =                         KeybData('č', 'Č', 'b', 'B');
    @KbData[DIK_N] =                         KeybData('ň', 'Ň', 'n', 'N');
    @KbData[DIK_M] =                         KeybData('ü', 'Ü', 'm', 'M');
    @KbData[DIK_COMMA] =                     KeybData('á', 'Á', ',', '<');
    @KbData[DIK_PERIOD] =            KeybData('ţ', 'Ţ', '.', '>');
    @KbData[DIK_SLASH] =                     KeybData('.', ',', '/', '?');
    @KbData[DIK_MULTIPLY] =          KeybData('*', '*', '*', '*');
    @KbData[DIK_SPACE] =                     KeybData(' ', ' ', ' ', ' ');
    @KbData[DIK_GRAVE] =                     KeybData('¸', '¨', '`', '~');
    @KbData[DIK_NUMPAD1] =           KeybData('1', '1', '1', '1');
    @KbData[DIK_NUMPAD2] =           KeybData('2', '2', '2', '2');
    @KbData[DIK_NUMPAD3] =           KeybData('3', '3', '3', '3');
    @KbData[DIK_NUMPAD4] =           KeybData('4', '4', '4', '4');
    @KbData[DIK_NUMPAD5] =           KeybData('5', '5', '5', '5');
    @KbData[DIK_NUMPAD6] =           KeybData('6', '6', '6', '6');
    @KbData[DIK_NUMPAD8] =           KeybData('8', '8', '8', '8');
    @KbData[DIK_NUMPAD9] =           KeybData('9', '9', '9', '9');
    @KbData[DIK_NUMPAD0] =           KeybData('0', '0', '0', '0');
    @KbData[DIK_SUBTRACT] =          KeybData('-', '-', '-', '-');
    @KbData[DIK_ADD] =                       KeybData('+', '+', '+', '+');
    @KbData[DIK_DECIMAL] =           KeybData('.', '.', '.', '.');
    @KbData[DIK_DIVIDE] =            KeybData('/', '/', '/', '/');
    @KbData[DIK_RETURN] =            KeybData('\n', '\n', '\n', '\n');
    @KbData[DIK_NUMPADENTER] =       KeybData('\n', '\n', '\n', '\n');
    @KbData[DIK_TAB] =                       KeybData('\t', '\t', '\t', '\t'); */
}

int GUI_GetActiveMainScreen()
{
    return ActiveScreens.length() > 0 ? ActiveScreens.first().Index : CLIENT_SCREEN_NONE;
}

int GUI_GetActiveScreen()
{
    return ActiveScreens.length() > 0 ? ActiveScreens.last().Index : CLIENT_SCREEN_NONE;
}

void GUI_GetActiveScreens(array<int>& result)
{
    result.resize(ActiveScreens.length());
    for(uint i = 0, j = result.length(); i < j; i++)
        result[i] = ActiveScreens[i].Index;
}

int GUI_GetMainScreen()
{
    int screenIndex = CLIENT_SCREEN_NONE;
    if(ActiveScreens.length() > 0)
        screenIndex = ActiveScreens[0].Index;
    return screenIndex;
}

IGUIScreenOpt@ GUI_GetScreen(int screenIndex)
{
    return GetScreen(screenIndex);
}

void GUI_ShowScreen(int screenIndex, int p0, int p1, int p2)
{
    GUIScreen@ screen = GetScreen(screenIndex);
	if(!(screen is null))
    {
        if(!screen.IsMultiinstance)
        {
            // Close all another instances
            for(uint i = ActiveScreens.length(); i > 0;)         // From end
            {
                i--;
                if(ActiveScreens[i].Index == screenIndex)
                {
                    ActiveScreens.removeAt(i);
                    if(!(screen.CallbackHide is null))
                        screen.CallbackHide.OnHide(p0, p1, p2);
                }
            }
        }

        // Create new instance
        // @screen=screen.GetNewInstance(); <- currently we don't handle this
        ActiveScreens.insertLast(screen);

        // Set screen cursor
        if(screen.IsAutoCursor)
        {
            if(screen.AutoCursorPrev < 0)
                screen.AutoCursorPrev = GetCurrentCursor();
            ChangeCursor(screen.AutoCursorType);
        }

        // Call init callbacks
        if(!(screen.CallbackShow is null))
        {
            @LastScreenOpt = screen;
            screen.CallbackShow.OnShow(p0, p1, p2);
            @LastScreenOpt = null;
        }
        /*for(uint i=0,j=screen.Elements.length();i<j;i++)
           {
                GUIElement@ e=screen.Elements[i];
                if(not (e.CallbackInit is null))
                {
                        @LastElementOpt=e;
                        e.CallbackInit.OnInit();
                        @LastElementOpt=e;
                }
           }*/
        if(screenIndex == CLIENT_SCREEN_FIX_BOY)
            SetupFixboyAddons();
    }
}

void GUI_HideScreen(int screenIndex, int p0, int p1, int p2)
{
    for(uint i = ActiveScreens.length(); i > 0;)   // From end
    {
        i--;
        GUIScreen@ screen = ActiveScreens[i];
        if(screen.Index == screenIndex)
        {
            ActiveScreens.removeAt(i);
            if(!(screen.CallbackHide is null))
                screen.CallbackHide.OnHide(p0, p1, p2);

            // Restore cursor
            if(screen.IsAutoCursor)
            {
                ChangeCursor(screen.AutoCursorPrev);
            }
            break;
        }
    }
}

void GUI_Render( bool mainScreen )
{
    if( mainScreen )
    {
        if( ActiveScreens.length() > 0 )
        {
            GUIScreen@ screen = ActiveScreens[0];
            DrawHardcodedScreen( screen.Index );
            GetHardcodedScreenPos( screen.Index, screen.PosX, screen.PosY );
			screen.Draw();
        }
        return;
    }

    for(uint i = 1, j = ActiveScreens.length(); i < j; i++)
    {
        GUIScreen@ screen = ActiveScreens[i];
        screen.Draw();
    }
}

/* void GUI_Render( bool mainScreen )
{
	if( mainScreen )
    {
        if( ActiveScreens.length() > 0 )
        {
            GUIScreen@ screen = ActiveScreens[ 0 ];
			screen.Draw();
        }
    }
	else
	{
		for(uint i = 0, j = ActiveScreens.length(); i < j; i++)
		{
			GUIScreen@ screen = ActiveScreens[i];
			screen.Draw();
		}
	}
} */

/* void GUI_Render()
{
    for(uint i = 0, j = ActiveScreens.length(); i < j; i++)
    {
        GUIScreen@ screen = ActiveScreens[i];
        screen.Draw();
    }
} */

void GUI_Update(uint dt)
{
    for(uint i = 0, j = ActiveScreens.length(); i < j; i++)
    {
        GUIScreen@ screen = ActiveScreens[i];
        screen.Update(dt);
    }
}

bool GUI_MouseDown(int x, int y, int click)
{
    uint len = ActiveScreens.length();
    if(len != 0)
    {
        GUIScreen@ screen = ActiveScreens[len - 1];
        bool       result = screen.MouseDown(x, y, click);
        if(result)
            return true;

        if(len > 1 && !screen.IsHardcoded && !screen.IsModal && click == MOUSE_CLICK_LEFT &&
           !IS_COLLISION(x, y, screen.PosX, screen.PosY, screen.GetWidth(), screen.GetHeight()))
        {
            for(uint i = ActiveScreens.length() - 1; i > 0;)       // From end
            {
                i--;
                GUIScreen@ nextScreen = ActiveScreens[i];
                if(IS_COLLISION(x, y, nextScreen.PosX, nextScreen.PosY, nextScreen.Surface.Width, nextScreen.Surface.Height))
                {
                    // Swap screens
                    GUIScreen@ tmpScreen = ActiveScreens[i];
                    @ActiveScreens[i] = ActiveScreens[len - 1];
                    @ActiveScreens[len - 1] = tmpScreen;
                    return GUI_MouseDown(x, y, click);                    // Click new screen
                }
            }
        }
    }
    return false;
}

bool GUI_MouseUp(int x, int y, int click)
{
    uint len = ActiveScreens.length();
    if(len != 0)
        return ActiveScreens[len - 1].MouseUp(x, y, click);
    return false;
}

void GUI_MouseMove(int fromX, int fromY, int toX, int toY)
{
    uint len = ActiveScreens.length();
    if(len != 0)
        ActiveScreens[len - 1].MouseMove(fromX, fromY, toX, toY);
}

/* bool GUI_KeyDown(uint8 key)
{
    if(KeyPressed.length() != 0)
        KeyPressed[key] = true;
    uint len = ActiveScreens.length();
    if(len != 0)
         return ActiveScreens[len - 1].KeyDown(key);
    return false;
} */

bool GUI_KeyDown( uint8 key, string& keyText )
{
    if( KeyPressed.length() != 0 )
        KeyPressed[ key ] = true;
    uint len = ActiveScreens.length();
    if( len != 0 )
        return ActiveScreens[ len - 1 ].KeyDown( key, keyText );
    return false;
}

// bool GUI_KeyUp(uint8 key)
bool GUI_KeyUp( uint8 key, string& keyText )
{
    if(KeyPressed.length() != 0)
        KeyPressed[key] = false;
    return false;
}

void GUI_InputLost()
{
    for(uint i = 0, j = KeyPressed.length(); i < j; i++)
        KeyPressed[i] = false;
    uint len = ActiveScreens.length();
    if(len != 0)
        ActiveScreens[len - 1].InputLost();
}

//
// Internal
//

IGUIScreenOpt@ CreateScreen(int screenIndex, string@ sprName)
{
    
	
	GUIScreen screen(sprName, PT_ART_INTRFACE);
    screen.CanMove(true);
    screen.Position(__ScreenWidth / 2 - screen.Surface.Width / 2, __ScreenHeight / 2 - screen.Surface.Height / 2);
    screen.Index = screenIndex;
    AllScreens.insertLast(screen);
    return @screen;
}

void DeleteScreen(int screenIndex)
{
    for(uint i = 0; i < ActiveScreens.length();)
    {
        if(ActiveScreens[i].Index == screenIndex)
        {
            ActiveScreens.removeAt(i);
            i = 0;
        }
        else
        {
            i++;
        }
    }

    for(uint i = 0, j = AllScreens.length(); i < j; i++)
    {
        if(AllScreens[i].Index == screenIndex)
        {
            AllScreens.removeAt(i);
            break;
        }
    }
}

GUIScreen@ GetScreen(int screenIndex)
{
    if(screenIndex == 0)
        return null;
			
    for(uint i = 0, j = AllScreens.length(); i < j; i++)
        if(AllScreens[i].Index == screenIndex)
            return @AllScreens[i];
    return null;
}

GUIScreen@ GetActiveScreen(int screenIndex)
{
	if(screenIndex ==0 ) return null;
	for(uint i=0,j=ActiveScreens.length(); i<j; i++) 
	{
		if(ActiveScreens[i].Index == screenIndex) return @ActiveScreens[i];
	}
	return null;
}

/* bool ProcessKey(uint8 key, string& text, uint8& letter)
{
    if(KeyPressed.length() == 0)
        return false;

    if(key == DIK_BACK)
    {
        if(text.length() > 0)
            text.resize(text.length() - 1);
        return true;
    }

    KeybData@ k = KbData[key];
    if(!(k is null))
    {
        bool shiftDown = (KeyPressed[DIK_LSHIFT] || KeyPressed[DIK_RSHIFT]);
        uint len = text.length();
        text.resize(len + 1);
        text[len] = k.Char[ GetKeybLang() * 2 + (shiftDown ? 1 : 0)];
        letter = text[len];
        return true;
    }
    return false;
} */

bool ProcessKey( uint8 key, string& keyText, string& text )
{
    if( key == DIK_BACK )
    {
        if( text.length() > 0 )
            text[ -1 ] = "";
        return true;
    }

    if( keyText != "" )
    {
        text += keyText;
        return true;
    }
    return false;
}

//stary guimod z w2155


IGUIElementTextOpt@ GUI_AddText(int screenIndex)
{
	int zero = 0;
	return GUI_AddText(screenIndex, "", zero, zero);
}

IGUIElementTextOpt@ GUI_AddText(int screenIndex, string@ text, int x, int y)
{
	if(screenIndex==0) return null;
	if(GetScreen(screenIndex) is null) CreateScreen(screenIndex,null);
	GUIScreen@ screen=GetScreen(screenIndex);
	
	IGUIElementOpt@ element;

	@element = GUIElementText(text, x, y);  

	screen.elements.insertLast(@element);

	@screen=GetActiveScreen(screenIndex);
	if(@screen!=null)
	{
		if(@screen.elements !=null)
		{
			screen.elements.insertLast(@element);
		}
	}
	
	return cast<IGUIElementTextOpt@>(element);
}

IGUIElementImageOpt@	GUI_AddImage(int screenIndex)
{
	int zero = 0;
	return GUI_AddImage(screenIndex, null, zero, zero, zero);
}

IGUIElementImageOpt@ GUI_AddImage(int screenIndex, string@ sprName, int patch, int x, int y)
{
	if(screenIndex==0) return null;
	if(GetScreen(screenIndex) is null) CreateScreen(screenIndex,null);
	GUIScreen@ screen=GetScreen(screenIndex);
	
	IGUIElementOpt@ element;
	@element = GUIElementImage(sprName, patch, x, y);  

	screen.elements.insertLast(@element);

	@screen=GetActiveScreen(screenIndex);
	if(@screen!=null)
	{
		if(@screen.elements !=null)
		{
			screen.elements.insertLast(@element);
		}
	}

	return cast<IGUIElementImageOpt@>(element);
}

IGUIElementButtonOpt@ GUI_AddButton(int screenIndex)
{
	int zero = 0;
	return GUI_AddButton(screenIndex, zero, zero);
}

IGUIElementButtonOpt@ GUI_AddButton(int screenIndex, int x, int y)
{
	if(screenIndex==0) return null;
	if(GetScreen(screenIndex) is null) CreateScreen(screenIndex,null);
	GUIScreen@ screen=GetScreen(screenIndex);
	
	IGUIElementOpt@ element;
	@element = GUIElementButton(x, y);  

	screen.elements.insertLast(@element);

	@screen=GetActiveScreen(screenIndex);
	if(@screen!=null)
	{
		if(@screen.elements !=null)
		{
			screen.elements.insertLast(@element);
		}
	}

	return cast<IGUIElementButtonOpt@>(element);
}


class GUIElement : IGUIElementOpt
{

	GUIElement(int width, int height)
	{
		InitGUIElement(0,0,width,height);
	}

	void InitGUIElement(int x, int y, int width, int height)
	{
		this.id=0;
		this.posX=x;
		this.posY=y;
		this.elementWidth = width;
		this.elementHeight = height;
		this.isFocused=false;
		this.absolutePosition = false;
		this.collisionTransparent = false;
		this.readyForClickEvent = false;
		this.visible=true;
		this.MousePressed.resize(MOUSE_CLICK_EXT4+1);
		this.texts.resize(0);
		this.images.resize(0);

		
		for(uint i=0,j=MousePressed.length();i<j;i++) 
			MousePressed[i]=false;
		
		@callbackInit=null;
		@callbackDraw=null;
		@callbackMouseDown=null;
		@callbackMouseClick=null;
		@callbackKeyPress=null;
		@callbackMouseMove=null;
		@callbackValueChange=null;
		@callbackStateChange=null;
	}


	void Draw(int screenX, int screenY)
	{
		if(visible)
		{
			this.screenX=screenX;
			this.screenY=screenY;

			if(not (callbackDraw is null)) callbackDraw.OnDraw(id);

			for (uint i=0; i<images.length(); i++) 
				images[i].Draw(screenX+posX, screenY+posY);

			for (uint i=0; i<texts.length(); i++) 
				texts[i].Draw(screenX+posX, screenY+posY);	
		}
	}

	void Update(uint dt) 
	{
	}

	void MouseDown(int click)
	{
		this.MousePressed[click]=true;
		this.readyForClickEvent = true;

		if(@callbackMouseDown != null) callbackMouseDown.OnMouseDown(click);
	}

	void MouseUp(int click, bool isCollision)
	{
		if(not (callbackMouseClick is null) && MousePressed[click] && isCollision && readyForClickEvent) 
		{
			callbackMouseClick.OnMouseClick(id, click);

			for (uint i=0; i<images.length(); i++)
			{
				if(IS_COLLISION(mousePosX,mousePosY,screenX+posX+images[i].GetPosX(),screenY+posY+images[i].GetPosY(),images[i].GetWidth(),images[i].GetHeight()))
				{
					callbackMouseClick.OnMouseClick(images[i].GetId(), click);
				}
			}
		
			for (uint i=0; i<texts.length(); i++)
			{
				if(IS_COLLISION(mousePosX,mousePosY,screenX+posX+texts[i].GetPosX(),screenY+posY+texts[i].GetPosY(),texts[i].GetWidth(),texts[i].GetHeight()))
				{
					callbackMouseClick.OnMouseClick(texts[i].GetId(), click);
				}
			}
		}
		this.MousePressed[click]=false;
		this.readyForClickEvent = false;
	}

	void MouseMove(int x, int y)
	{
		this.mousePosX=x;
		this.mousePosY=y;
		if(@callbackMouseMove!=null) callbackMouseMove.OnMouseMove(x, y);
	}

    // bool KeyPress(uint8 key)
	bool KeyPress( uint8 key, string& keyText )
	{
		return false;
	}

	void KeyUp(uint8 key,  string& keyText ) 	
	{
	}

	void InputLost()
	{
		for(uint i=0,j=MousePressed.length();i<j;i++)
			MousePressed[i]=false;
	}

	IGUIElementOpt@ GetNewInstance()
	{
		IGUIElementOpt @newElement=this;
		return @newElement;
	}

	// Options
	IGUIElementOpt@ CallbackInit(IGUIElementCallbackInit@ callback) { @callbackInit=callback; return this; }
	IGUIElementOpt@ CallbackDraw(IGUIElementCallbackDraw@ callback) { @callbackDraw=callback; return this; }
	IGUIElementOpt@ CallbackMouseDown(IGUIElementCallbackMouseDown@ callback) { @callbackMouseDown=callback; return this; }
	IGUIElementOpt@ CallbackMouseClick(IGUIElementCallbackMouseClick@ callback) { @callbackMouseClick=callback; return this; }
	IGUIElementOpt@ CallbackKeyPress(IGUIElementCallbackKeyPress@ callback) { @callbackKeyPress=callback; return this; }
	IGUIElementOpt@ CallbackMouseMove(IGUIElementCallbackMouseMove@ callback) { @callbackMouseMove=callback; return this; }

	IGUIElementOpt@ Position(int x, int y)
	{
		posX=x;
		posY=y;
		return this;
	}

	IGUIElementOpt@ Position(int x, int y, int w, int h)
	{
		elementWidth=w;
		elementHeight=h;
		return Position(x, y);
	}

	IGUIElementOpt@ Position(string& iniKey)
	{
		posX=0;
		posY=0;
		elementWidth=0;
		elementHeight=0;

		// Parse four values from ini option
		string@ str=GetIfaceIniStr(iniKey);
		if(@str==null || str=="") return this;

		string@[]@ valuesStr=splitEx(str," ");
		if(valuesStr.length()!=4) return this;

		int[] values(4);
		for(int i=0;i<4;i++)
			if(not StrToInt(valuesStr[i],values[i])) return this;

		posX=values[0];
		posY=values[1];
		elementWidth=values[2]-values[0]+1;
		elementHeight=values[3]-values[1]+1;
		return this;
	}

	IGUIElementOpt@ Visible(bool visible)
	{
		this.visible = visible;
		return this;
	}

	IGUIElementOpt@ AbsolutePosition(bool absolutePosition) 
	{
		this.absolutePosition = absolutePosition;
		return this;
	}

	IGUIElementOpt@ AbsolutePosition(int x, int y)
	{
		this.absolutePosition = true;
		return Position(x, y);
	}

	IGUIElementOpt@ CollisionTransparent(bool collisionTransparent)
	{
		this.collisionTransparent = collisionTransparent;
		return this;
	}

	IGUIElementOpt@ AddText(int id, string@ text, int x, int y, int width, int height, int font, uint color, int flags)
	{
		uint textsLength = texts.length();
		texts.resize(textsLength+1);
		@texts[textsLength] = @GUIElementText(id, text, x, y, width, height, font, color, flags);
		return this;
	}

	IGUIElementOpt@ AddImage(int id, string@ sprName, int x, int y)
	{
		return AddImage(id, PT_ART_INTRFACE, sprName, x, y);
	}

	IGUIElementOpt@ AddImage(int id, int patch, string@ sprName, int x, int y)
	{
      Message("Warning: \"IGUIElementOpt@ AddImage(int id, int patch, string@ sprName, int x, int y)\" - Not implemented");
		//uint imagesLength = images.length();
		//images.resize(imagesLength+1);
		//@images[imagesLength] = @GUIElementImage(id, patch, sprName, x, y);
		return this;
	}

	void SetFocused(bool state){
		this.isFocused=state;
	}

	void SetVisible(bool visible){
		this.visible = visible;
	}

	void SetAbsolutePosition(bool absolutePosition){
		this.absolutePosition = absolutePosition;
	}

	void SetCollisionTransparent(bool collisionTransparent){
		this.collisionTransparent = collisionTransparent;
	}

	IGUIElementCallbackInit@ GetCallbackInit(){
		return @callbackInit;
	}

	

	// Info
	int GetId() { return id; }
	int GetPosX() { return posX; }
	int GetPosY() { return posY; }
	int GetWidth() { return elementWidth; }
	int GetHeight() { return elementHeight; }
	bool IsFocused() { return isFocused; }
	bool IsAbsolutePosition() { return absolutePosition; }
	bool IsCollisionTransparent() { return collisionTransparent; }

	bool IsCollision(int screenX, int screenY, int mouseX, int mouseY)
	{
		if(absolutePosition)
		{
			screenX = 0;
			screenY = 0;
		}
		return ((mouseX)>=(screenX+posX) && (mouseX)<=(screenX+posX + elementWidth) && (mouseY)>=(screenY+posY) && (mouseY)<=(screenY+posY + elementHeight));
	}

	bool IsVisible()
	{
		return visible;
	}
	
	// Data
	int id;
	uint elementWidth;
	uint elementHeight;
	int posX;
	int posY;
	int mousePosX;
	int mousePosY;
	int screenX;
	int screenY;
	
	bool isFocused;
	bool visible;
	bool collisionTransparent;
	bool absolutePosition; // Is Absolute position
	bool readyForClickEvent;
	bool[] MousePressed;

	IGUIElementOpt@[] images;
	IGUIElementOpt@[] texts;

	IGUIElementCallbackInit@ callbackInit;
	IGUIElementCallbackDraw@ callbackDraw;
	IGUIElementCallbackMouseDown@ callbackMouseDown;
	IGUIElementCallbackMouseClick@ callbackMouseClick;
	IGUIElementCallbackKeyPress@ callbackKeyPress;
	IGUIElementCallbackMouseMove@ callbackMouseMove;
	IGUIElementCallbackValueChange@ callbackValueChange;
	IGUIElementCallbackStateChange@ callbackStateChange;
	IGUIElementCallbackInit@ InitCallback;
	IGUIElementCallbackDraw@ DrawCallback;
	IGUIElementCallbackMouseDown@ MouseDownCallback;
	IGUIElementCallbackMouseClick@ MouseClickCallback;
	IGUIElementCallbackKeyPress@ KeyPressCallback;
	IGUIElementCallbackMouseMove@ MouseMoveCallback;
	IGUIElementCallbackValueChange@ ValueChangeCallback;
	IGUIElementCallbackStateChange@ StateChangeCallback;
}


class GUIElementText : GUIElement, IGUIElementTextOpt
{
	GUIElementText()
	{
		InitText(0, "", 0, 0, 50, 10, FONT_FALLOUT, COLOR_TEXT, COLOR_TEXT, 0);
	}
	
	GUIElementText(int id, string@ text, int x, int y)
	{
		InitText(id, text, x, y, 50, 10, FONT_FALLOUT, COLOR_TEXT, COLOR_TEXT, 0);
	}	

	GUIElementText(string@ text, int x, int y)
	{
		InitText(0, text, x, y, 50, 10, FONT_FALLOUT, COLOR_TEXT, COLOR_TEXT, 0);
	}

	GUIElementText(string@ text, int x, int y, int width, int height)
	{
		InitText(0, text, x, y, width, height, FONT_FALLOUT, COLOR_TEXT, COLOR_TEXT, 0);
	}	

	GUIElementText(int id, string@ text, int x, int y, int width, int height, int font, uint color, int flags)
	{
		InitText(id, text, x, y, width, height, font, color, color, flags);
	}	

	GUIElementText(int id, string@ text, int x, int y, int width, int height, int font, uint color, uint colorDown, int flags)
	{
		InitText(id, text, x, y, width, height, font, color, colorDown, flags);
	}	

	void InitText(int id, string@ text, int x, int y, int width, int height, int font, uint color, uint colorDown, int flags)
	{

		GUIElement::InitGUIElement(x, y, 0, 0);

		this.id=id;
		this.posX = x;
		this.posY = y;
		this.elementWidth = width;
		this.elementHeight = height;

		this.dX = 0;
		this.dY = 0; 
		this.upDX = 0;
		this.upDY = 0; 
		this.downDX = 0;
		this.downDY = 0;

		if(text is null) this.text="null";
		else this.text=text; 

		this.font = font;
		this.textColor = color;
		this.textColorUp = color;
		this.textColorDown = colorDown;
		this.textFlags = flags;
		
		collisionTransparent = true;
		this.visible=true;
	}

	void Draw(int screenX, int screenY)
	{
		if(visible)
		{
			if(not absolutePosition)
				DrawText(text, screenX+posX+dX, screenY+posY+dY, elementWidth, elementHeight, textColor, font, textFlags);
			else 
				DrawText(text, posX, posY, elementWidth, elementHeight, textColor, font, textFlags);
		}
	}

	IGUIElementTextOpt@ Position(int x, int y)
	{
		return cast<IGUIElementTextOpt>(GUIElement::Position(x, y));
	}

	IGUIElementTextOpt@ Position(int x, int y, int w, int h)
	{
		return cast<IGUIElementTextOpt>(GUIElement::Position(x, y, w, h));
	}

	IGUIElementTextOpt@ Position(string& iniKey)
	{
		return cast<IGUIElementTextOpt>(GUIElement::Position(iniKey));
	}

	IGUIElementTextOpt@ AbsolutePosition(int x, int y)
	{
		return cast<IGUIElementTextOpt>(GUIElement::AbsolutePosition(x, y));
	}

	IGUIElementTextOpt@ AbsolutePosition(bool absolutePosition)
	{
		return cast<IGUIElementTextOpt>(GUIElement::AbsolutePosition(absolutePosition));
	}

	IGUIElementTextOpt@ Visible(bool visible)
	{
		return cast<IGUIElementTextOpt>(GUIElement::Visible(visible));
	}
 
	IGUIElementTextOpt@ Text(string@ text)
	{
		return Text(text, font, textColor);
	}

	IGUIElementTextOpt@ Text(string@ text, int font, uint color)
	{
		return Text(text, font, color, textFlags);
	}

	IGUIElementTextOpt@ Text(string@ text, int font, uint color, int flags)
	{
		return Text(text, font, color, color, flags);
	}

	IGUIElementTextOpt@ Text(string@ text, int font, uint color, uint downColor, int flags)
	{
		if(text is null) this.text="";
		else this.text=text; 

		this.font = font;
		this.textColor = color;
		this.textColorUp = color;
		this.textColorDown = downColor;
		this.textFlags = flags;
		return this;
	}
	
	IGUIElementTextOpt@ TextBoxSize(int width, int height)
	{
		this.elementWidth = width;
		this.elementHeight = height;

		return this;
	}

	IGUIElementTextOpt@ TextOptions(int font, uint color)
	{
		return TextOptions(font, color, color, 0);
	}

	IGUIElementTextOpt@ TextOptions(int font, uint color, int flags)
	{
		return TextOptions(font, color, color, flags);
	}

	IGUIElementTextOpt@ TextOptions(int font, uint color, uint colorDown, int flags)
	{
		this.font = font;
		this.textColor = color;
		this.textColorUp = color;
		this.textColorDown = colorDown;
		this.textFlags = flags;

		return this;
	}

	IGUIElementTextOpt@ TextColor(uint color)
	{
		this.textColor = color;
		return this;
	}
	
	
	void SetTextShift(int deltaX, int deltaY, int deltaDownX, int deltaDownY) {
		this.dX = deltaX;
		this.dY = deltaY;
		this.upDX = deltaX;
		this.upDY = deltaY; 
		this.downDX = deltaDownX;
		this.downDY = deltaDownY;
	}

	void SetTextWidth(int width) 
	{
		this.elementWidth = width;
	}

	void SetTextDown(bool down) {
		this.textColor = down?textColorDown:textColorUp;
		this.dX =  down?(upDX+downDX):(upDX);
		this.dY =  down?(upDY+downDY):(upDY);
	}

	void SetText(string& text)
	{
		this.text=text;
	}

	void SetVisible(bool visible){
		GUIElement::SetVisible(visible);
	}

	void SetFocused(bool state){
		GUIElement::SetFocused(state);
	}

	int GetId()
	{
		return id;
	}

	string@ GetText()
	{
		return text;
	}

	int GetFont()
	{
		return font;
	}

	uint GetTextColor()
	{
		return textColor;
	}

	bool IsVisible()
	{
		return GUIElement::IsVisible();
	}

	IGUIElementTextOpt@ CallbackMouseMove(IGUIElementCallbackMouseMove@ callback) { @callbackMouseMove=callback; return this; }
	IGUIElementTextOpt@ CallbackInit(IGUIElementCallbackInit@ callback) { @callbackInit=callback; return this; }
	IGUIElementTextOpt@ CallbackDraw(IGUIElementCallbackDraw@ callback) { @callbackDraw=callback; return this; }
	IGUIElementTextOpt@ CallbackMouseDown(IGUIElementCallbackMouseDown@ callback) { @callbackMouseDown=callback; return this; }
	IGUIElementTextOpt@ CallbackMouseClick(IGUIElementCallbackMouseClick@ callback) { @callbackMouseClick=callback; return this; }


	string text;
	int font;
	
	int dX;
	int dY;
	int upDX;
	int upDY;
	int downDX;
	int downDY;
	uint textColor;
	uint textColorUp;
	uint textColorFocused;
	uint textColorDown;
	int textFlags;
}

//cebula
class GUIElementImage : GUIElement, IGUIElementImageOpt
{
	GUIElementImage()
	{
		this.id = -1;
	}

	GUIElementImage(int id, string@ sprName, int x, int y)
	{
		InitImage(id, sprName, PT_ART_INTRFACE, x, y);
	}

	GUIElementImage(int id, int patch, string@ sprName, int x, int y)
	{
		InitImage(id, sprName, patch, x, y);
	}	

	GUIElementImage(string@ sprName, int patch, int x, int y)
	{
		InitImage(0, sprName, patch, x, y);
	}	

	void InitImage(int id, string@ sprName, int patch, int x, int y)
	{
		GUIElement::InitGUIElement(x, y, 0, 0);

		this.id=id;
		if(@sprName!=null){
			this.patch = patch;
			image.Load(sprName, patch);
			this.elementWidth  = image.Width;
			this.elementHeight = image.Height;
			if(image.Id==0) Message("ERROR: Ubable to load: "+sprName+".");
		}

		this.posX = x;
		this.posY = y;
		
		collisionTransparent = true;
		this.visible=true;
	}

	void Draw(int screenX, int screenY)
	{
		if(absolutePosition) {
			screenX = 0;
			screenY = 0;
		}

		if(visible)
		{
			if(this.image.Id!=0) DrawSprite(this.image.Id,-1,screenX+posX,screenY+posY,0); 
		}
	}

	IGUIElementImageOpt@ Position(int x, int y)
	{
		return cast<IGUIElementImageOpt>(GUIElement::Position(x, y));
	}

	IGUIElementImageOpt@ Position(int x, int y, int w, int h)
	{
		return cast<IGUIElementImageOpt>(GUIElement::Position(x, y, w, h));
	}

	IGUIElementImageOpt@ Position(string& iniKey)
	{
		return cast<IGUIElementImageOpt>(GUIElement::Position(iniKey));
	}

	IGUIElementImageOpt@ AbsolutePosition(bool absolutePosition)
	{
		return cast<IGUIElementImageOpt>(GUIElement::AbsolutePosition(absolutePosition));
	}

	IGUIElementImageOpt@ Visible(bool visible)
	{
		return cast<IGUIElementImageOpt>(GUIElement::Visible(visible));
	}

	void SetPosX(int x)
	{
		this.posX = x;
	}

	void SetPosY(int y)
	{
		this.posY = y;
	}

	void SetVisible(bool visible){
		GUIElement::SetVisible(visible);
	}

	void SetFocused(bool state){
		GUIElement::SetFocused(state);
	}


	int GetPosX()
	{
		return posX;
	}

	int GetPosY()
	{
		return posY;
	}

	int GetImageWidth()
	{
		return image.Width;
	}

	int GetImageHeight()
	{
		return image.Height;
	}

	bool IsCollision(int screenX, int screenY, int mouseX, int mouseY)
	{
		return GUIElement::IsCollision(screenX, screenY, mouseX, mouseY);
	}

	bool IsVisible()
	{
		return GUIElement::IsVisible();
	}

	IGUIElementImageOpt@ CallbackInit(IGUIElementCallbackInit@ callback) { @callbackInit=callback; return this; }
	IGUIElementImageOpt@ CallbackDraw(IGUIElementCallbackDraw@ callback) { @callbackDraw=callback; return this; }
	IGUIElementImageOpt@ CallbackMouseDown(IGUIElementCallbackMouseDown@ callback) { @callbackMouseDown=callback; return this; }
	IGUIElementImageOpt@ CallbackMouseClick(IGUIElementCallbackMouseClick@ callback) { @callbackMouseClick=callback; return this; }


	Sprite image;
	int patch;
}


class GUIElementButton : GUIElement, IGUIElementButtonOpt
{
	IGUIElementButtonOpt@ CallbackInit(IGUIElementCallbackInit@ callback) { @callbackInit=callback; return this; }
	IGUIElementButtonOpt@ CallbackDraw(IGUIElementCallbackDraw@ callback) { @callbackDraw=callback; return this; }
	IGUIElementButtonOpt@ CallbackMouseDown(IGUIElementCallbackMouseDown@ callback) { @callbackMouseDown=callback; return this; }
	IGUIElementButtonOpt@ CallbackMouseClick(IGUIElementCallbackMouseClick@ callback) { @callbackMouseClick=callback; return this; }


	GUIElementButton(int x, int y)
	{
		@ButtonText = GUIElementText();
		InitGUIElement(x, y, 0, 0);
	}

	void Draw(int screenX, int screenY)
	{
		if(absolutePosition) {
			screenX = 0;
			screenY = 0;
		}

		if(visible)
		{
			isDown=MousePressed[MOUSE_CLICK_LEFT];

			if(isDown)
			{
				if(not (downSprite is null)) downSprite.Draw(screenX, screenY);
				ButtonText.SetTextDown(true);
			}
			else 
			{
				if(not (upSprite is null)) upSprite.Draw(screenX, screenY);
				ButtonText.SetTextDown(false);
			}
			ButtonText.Draw(screenX, screenY);

			if(not (callbackDraw is null)) callbackDraw.OnDraw(this.id);
		}
	}

	IGUIElementButtonOpt@ Position(int x, int y)
	{
		GUIElement::Position(x, y);
		UpdateelementsPositions();
		return this;
	}

	IGUIElementButtonOpt@ Position(int x, int y, int w, int h)
	{
		GUIElement::Position(x, y, w, h);
		UpdateelementsPositions();
		return this;
	}

	IGUIElementButtonOpt@ Position(string& iniKey)
	{
		GUIElement::Position(iniKey);
		UpdateelementsPositions();
		return this;
	}

	IGUIElementButtonOpt@ AbsolutePosition(bool absolutePosition)
	{
		return cast<IGUIElementButtonOpt>(GUIElement::AbsolutePosition(absolutePosition));
	}

	IGUIElementButtonOpt@ Visible(bool visible)
	{
		return cast<IGUIElementButtonOpt>(GUIElement::Visible(visible));
	}

	IGUIElementButtonOpt@ Text(string@ text)
	{
		int font = FONT_FALLOUT;
		uint color = COLOR_SAND;
		uint downColor = COLOR_DRED;
		int flags = FT_CENTERY | FT_CENTERX;
		return Text(text, font, color, downColor, flags);
	}

	IGUIElementButtonOpt@ Text(string@ text, int font, uint color)
	{
		return Text(text, font, color, color, FT_CENTERX|FT_CENTERY);
	}

	IGUIElementButtonOpt@ Text(string@ text, int font, uint color, int flags)
	{
		uint downColor = COLOR_DRED;
		return Text(text, font, color, downColor, flags);
	}

	IGUIElementButtonOpt@ Text(string@ text, int font, uint color, uint downColor, int flags)
	{
		@ButtonText = GUIElementText(0, text, posX, posY, elementWidth, elementHeight, font, color, downColor, flags);
		return this; 
	}

	IGUIElementButtonOpt@ TextShift(int deltaX, int deltaY, int deltaDownX, int deltaDownY)
	{
		ButtonText.SetTextShift(deltaX,deltaY,deltaDownX,deltaDownY);
		return this;
	}

	IGUIElementButtonOpt@ TextWidth(int width)
	{
		ButtonText.SetTextWidth(width);
		return this;
	}

	IGUIElementButtonOpt@ UpPic(string@ sprName)
	{
		@upSprite = @GUIElementImage(id, sprName, posX, posY);
		this.elementWidth = upSprite.image.Width;
		this.elementHeight = upSprite.image.Height;
		return cast<IGUIElementButtonOpt>(this);
	}	

	IGUIElementButtonOpt@ DownPic(string@ sprName)
	{
		@downSprite = @GUIElementImage(id, sprName, posX, posY);
		this.elementWidth = downSprite.image.Width;
		this.elementHeight = downSprite.image.Height;
		return cast<IGUIElementButtonOpt>(this);
	}

	IGUIElementButtonOpt@ ClickableZone(int width, int height)
	{
		this.elementWidth = width;
		this.elementHeight = height;

		return this;
	}
	
	
	IGUIElementButtonOpt@ ClickableZone(int x, int y, int width, int height)
	{
		this.posX = x;
		this.posY = y;

		this.elementWidth = width;
		this.elementHeight = height;

		return this;
	}

	void SetVisible(bool visible){
		GUIElement::SetVisible(visible);
	}

	void SetFocused(bool state){
		GUIElement::SetFocused(state);
	}

	// private functions
	void UpdateelementsPositions()
	{
		if(@upSprite!= null)
		{
			upSprite.posX = posX;
			upSprite.posY = posY;
		}
		if(@downSprite!= null)
		{
			downSprite.posX = posX;
			downSprite.posY = posY;
		}
		if(@ButtonText!= null)
		{
			ButtonText.posX = posX;
			ButtonText.posY = posY;
		}
	}

	string getText()
	{
		return ButtonText.GetText();
	}

	bool IsVisible()
	{
		return GUIElement::IsVisible();
	}
	void Hide()
	{
		if(this.posX!=-1000000) this.last_posX=this.posX;
		if(this.posY!=-1000000) this.last_posY=this.posY;
		GUIElement::Position(-1000000,-1000000);
		GUIElement::SetVisible(false);
		UpdateelementsPositions();
	}
	
	void Show()
	{
		GUIElement::Position(this.last_posX,this.last_posY);
		GUIElement::SetVisible(true);
		UpdateelementsPositions();
	}
	GUIElementImage @upSprite;
	GUIElementImage @downSprite;
	GUIElementText @ButtonText;
	bool isDown;
	int last_posX;
	int last_posY;
}

class GUIElementEditBox : GUIElement, IGUIElementEditBoxOpt
{

	GUIElementEditBox(int x, int y)
	{
		InitEditBox(0, x, y);
	}


	void InitEditBox(int id, int x, int y)
	{

		this.passwordChar = "*";
		this.visibleText = "";
		this.password = false;
		this.numeric = false;
		this.noinput = false;

		GUIElement::InitGUIElement(x, y, 0, 0);

		this.id=id;
		this.posX = x;
		this.posY = y;
		this.elementWidth = 0;
		this.elementHeight = 0;

		this.dX = 0;
		this.dY = 0; 
		this.upDX = 0;
		this.upDY = 0; 
		this.downDX = 0;
		this.downDY = 0;

		this.text=""; 

		this.firsTime = true;

		this.lMargin = 0;
		this.rMargin = 0;
		this.uMargin = 0;
		this.dMargin = 0;

		this.font = FONT_FALLOUT;
		this.textColor = COLOR_TEXT;
		this.textColorUp = COLOR_DGREEN;
		this.textColorDown = COLOR_TEXT;
		this.textFlags = 0;
		this.inputMaxLen = 100;
		
		collisionTransparent = true;
		this.visible=true;
	}

	void Draw(int screenX, int screenY)
	{
		if(absolutePosition) {
			screenX = 0;
			screenY = 0;
		}
		
		if(visible)
		{
			if(@PicBackground != null) PicBackground.Draw(screenX + posX, screenY + posY);
			if(isFocused) textColor = textColorDown;
			else textColor = textColorUp;
			if(!isFocused || noinput) DrawText(visibleText, screenX+posX+dX+lMargin, screenY+posY+dY+uMargin, elementWidth-rMargin, elementHeight-dMargin, textColor, font, textFlags);
			else if((__FullSecond/10)%2==0) DrawText(visibleText+".", screenX+posX+dX+lMargin, screenY+posY+dY+uMargin, elementWidth-rMargin, elementHeight-dMargin, textColor, font, textFlags);
			else DrawText(visibleText+"!", screenX+posX+dX+lMargin, screenY+posY+dY+uMargin, elementWidth-rMargin, elementHeight-dMargin, textColor, font, textFlags);
		}
	}
		
	bool isNumberKey(uint8 key)
	{
		if (key>=DIK_1 && key<=DIK_0)
		{
			return true;
		}
		else if (key==DIK_NUMPAD0)
		{
			return true;
		}
		else if (key==DIK_NUMPAD1)
		{
			return true;
		}
		else if (key==DIK_NUMPAD2)
		{
			return true;
		}
		else if (key==DIK_NUMPAD3)
		{
			return true;
		}
		else if (key==DIK_NUMPAD4)
		{
			return true;
		}
		else if (key==DIK_NUMPAD5)
		{
			return true;
		}
		else if (key==DIK_NUMPAD6)
		{
			return true;
		}
		else if (key==DIK_NUMPAD7)
		{
			return true;
		}
		else if (key==DIK_NUMPAD8)
		{
			return true;
		}
		else if (key==DIK_NUMPAD9)
		{
			return true;
		}

		return false;
	}

	bool KeyPress(uint8 key, string& keyText)
	{
		uint8 letter=0;
		
		if(key==DIK_ESCAPE) return false;
		if(noinput) return true;
		if(numeric)
		{
			if(key!=DIK_BACK && key!=DIK_NUMPADENTER && key!=DIK_RETURN && (not isNumberKey(key))) 
				return false;
		}

		bool result=false;
		if(key!=DIK_RETURN) ProcessKey(key,keyText,text);

		if(text.length()>inputMaxLen) 
		{
			text.rawResize(inputMaxLen);
			visibleText.rawResize(inputMaxLen);
		}
		
				
		if(password)
		{
			if(firsTime) 
			{
				firsTime = false;
				visibleText.rawResize(0); // To delate start password Text
			}
			if(key==DIK_BACK)
			{
				if(visibleText.length()>0) visibleText.rawResize(visibleText.length()-1);
			}
			else 
			{
				visibleText="";
				for(uint i=0; i<text.length(); i++)
					visibleText+=passwordChar;
			}
		}
		else 
			visibleText=text;
		
		if(@KeyPressCallback != null) return KeyPressCallback.OnKeyPress( key, keyText );

		return false;
	}

	IGUIElementEditBoxOpt@ Position(int x, int y)
	{
		return cast<IGUIElementEditBoxOpt>(GUIElement::Position(x, y));
	}

	IGUIElementEditBoxOpt@ Position(int x, int y, int w, int h)
	{
		return cast<IGUIElementEditBoxOpt>(GUIElement::Position(x, y, w, h));
	}

	IGUIElementEditBoxOpt@ Position(string& iniKey)
	{
		return cast<IGUIElementEditBoxOpt>(GUIElement::Position(iniKey));
	}
	
	IGUIElementEditBoxOpt@ AbsolutePosition(bool absolutePosition)
	{
		return cast<IGUIElementEditBoxOpt>(GUIElement::AbsolutePosition(absolutePosition));
	}
	
	IGUIElementEditBoxOpt@ Text(string@ text)
	{
		return Text(text, FONT_FALLOUT, COLOR_TEXT);
	}

	IGUIElementEditBoxOpt@ Text(string@ text, int font, uint color)
	{
		return Text(text, font, color, 0);
	}

	IGUIElementEditBoxOpt@ Text(string@ text, int font, uint color, int flags)
	{
		return Text(text, font, color, color, flags);
	}

	IGUIElementEditBoxOpt@ Text(string@ text, int font, uint color, uint downColor, int flags)
	{
		if(text is null) this.text="";
		else this.text=text; 

		this.font = font;
		this.textColor = color;
		this.textColorUp = color;
		this.textColorDown = downColor;
		this.textFlags = flags;
		return VisibleText(text);
	}
	
	IGUIElementEditBoxOpt@ Visible(bool visible)
	{
		return cast<IGUIElementEditBoxOpt>(GUIElement::Visible(visible));
	}

	IGUIElementEditBoxOpt@ TextBoxSize(int width, int height)
	{
		this.elementWidth = width;
		this.elementHeight = height;

		return this;
	}

	IGUIElementEditBoxOpt@ TextOptions(int font, uint color)
	{
		return TextOptions(font, color, color, 0);
	}

	IGUIElementEditBoxOpt@ TextOptions(int font, uint color, int flags)
	{
		return TextOptions(font, color, color, flags);
	}

	IGUIElementEditBoxOpt@ TextOptions(int font, uint color, uint colorDown, int flags)
	{
		this.font = font;
		this.textColor = color;
		this.textColorUp = color;
		this.textColorDown = colorDown;
		this.textFlags = flags;

		return this;
	}

	IGUIElementEditBoxOpt@ TextColor(uint color)
	{
		this.textColor = color;
		return this;
	}

	IGUIElementEditBoxOpt@ VisibleText(string@ text)
	{
		this.visibleText = text;
		return this;
	}

	IGUIElementEditBoxOpt@ BackgroundPic(string@ sprName)
	{
		@PicBackground = @GUIElementImage(1, sprName, 0, 0);
		this.elementWidth = PicBackground.GetImageWidth();
		this.elementHeight = PicBackground.GetImageHeight();
		return this;
	}

	IGUIElementEditBoxOpt@ MaxLen(int maxLen)
	{
		this.inputMaxLen = maxLen;
		return this;
	}

	IGUIElementEditBoxOpt@ EditBoxSize(int width, int height) 
	{
        this.elementWidth = width;
		this.elementHeight = height;

		return this;
    }

	IGUIElementEditBoxOpt@ LeftMargin(int lMargin)
	{
		this.lMargin = lMargin;
		return this;
	}

	IGUIElementEditBoxOpt@ RightMargin(int rMargin)
	{
		this.rMargin = rMargin;
		return this;
	}

	IGUIElementEditBoxOpt@ UpMargin(int uMargin)
	{
		this.uMargin = uMargin;
		return this;
	}

	IGUIElementEditBoxOpt@ DownMargin(int dMargin)
	{
		this.dMargin = dMargin;
		return this;
	}

	IGUIElementEditBoxOpt@ Margins(int lMargin, int rMargin, int uMargin, int dMargin)
	{
		this.lMargin = lMargin;
		this.rMargin = rMargin;
		this.uMargin = uMargin;
		this.dMargin = dMargin;
		return this;
	}

	IGUIElementEditBoxOpt@ PasswordMode(bool isPasswordMode)
	{
		this.password = isPasswordMode;
		return this;
	}
	
	IGUIElementEditBoxOpt@ PasswordChar(string@ passChar)
	{
		this.passwordChar = passChar;
		return this;
	}

	IGUIElementEditBoxOpt@ NumericMode(bool isNumericMode)
	{
		this.numeric = isNumericMode;
		return this;
	}  

	
	string@ getText()
	{
		return text;
	}


	void setVisible(bool visible){
		GUIElement::SetVisible(visible);
	}

	void setFocused(bool state){
		GUIElement::SetFocused(state);
	}
	
	void NoInput(bool var){
		noinput=var;
	}

	int getId()
	{
		return id;
	}

	bool isVisible()
	{
		return GUIElement::IsVisible();
	}

	IGUIElementEditBoxOpt@ CallbackMouseMove(IGUIElementCallbackMouseMove@ callback) { @MouseMoveCallback=callback; return this; }
	IGUIElementEditBoxOpt@ CallbackInit(IGUIElementCallbackInit@ callback) { @InitCallback=callback; return this; }
	IGUIElementEditBoxOpt@ CallbackDraw(IGUIElementCallbackDraw@ callback) { @DrawCallback=callback; return this; }
	IGUIElementEditBoxOpt@ CallbackMouseDown(IGUIElementCallbackMouseDown@ callback) { @MouseDownCallback=callback; return this; }
	IGUIElementEditBoxOpt@ CallbackMouseClick(IGUIElementCallbackMouseClick@ callback) { @MouseClickCallback=callback; return this; }
	IGUIElementEditBoxOpt@ CallbackKeyPress(IGUIElementCallbackKeyPress@ callback){ @KeyPressCallback=callback; return this; }

	string text;
	string visibleText;
	string passwordChar;
	bool password;
	bool numeric;
	bool noinput;
	GUIElementImage @PicBackground;
	int font;
	uint inputMaxLen;
	bool firsTime;
		
	int dX;
	int dY;
	int upDX;
	int upDY;
	int downDX;
	int downDY;
	uint textColor;
	uint textColorUp;
	uint textColorFocused;
	uint textColorDown;
	int textFlags;
	uint lMargin;
	uint rMargin;
	uint uMargin;
	uint dMargin;
}

void SetScreenPos(int screenIndex, int posX, int posY)
{
	if(screenIndex==0) return;
	if(GetScreen(screenIndex) is null) return;
	
	GUIScreen@ screen=GetScreen(screenIndex);
	screen.Position(posX,posY);
}

IGUIElementEditBoxOpt@ GUI_AddEditBox(int screenIndex)
{
	int zero = 0;
	return GUI_AddEditBox(screenIndex, zero, zero);
}

IGUIElementEditBoxOpt@ GUI_AddEditBox(int screenIndex, int x, int y)
{
	if(screenIndex==0) return null;
	if(GetScreen(screenIndex) is null) CreateScreen(screenIndex,null);
	GUIScreen@ screen=GetScreen(screenIndex);
	
	IGUIElementOpt@ element;
	@element = GUIElementEditBox(x, y);  

	screen.elements.insertLast(@element);
	@screen=GetActiveScreen(screenIndex);
	if(@screen!=null)
	{
		if(@screen.elements !=null)
		{
			screen.elements.insertLast(@element);
		}
	}
	
	return cast<IGUIElementEditBoxOpt@>(element);
}

void SetPipBoyCallbackShow(IGUIScreenCallbackShow@ callback)
{
	if(GetScreen(CLIENT_SCREEN_PIP_BOY) is null) return;
	GUIScreen@ screen=GetScreen(CLIENT_SCREEN_PIP_BOY);
	screen.SetCallbackShow(callback);
}

