//
// FOnline: 2238
// Rotators
//
// combat.fos
//

// 21-08-2010 05:09
// 2238

// 23-07-2013 Cubik:
// poprawione obliczanie min-max dmg od bonusow crafconych broni
// naprawiony bug z niewlasciwym wyliczaniem DT/DR armorow od bonusow (wyliczane sa w dll-ce Kilgora)
// bonusy armorow przetwarzane w combat.fos: BONUS_ARMOR_CRIT_CHANCE, BONUS_ARMOR_CRIT_POWER
// pozostaÅ‚e bonusy armorow przetwarzane sa w dll-ce Kilgora
#define BURN_DAMAGE               ( Random(7,15) ) // Fire stuffy
#define MAX_BURN_STACK           (10) //for adjust, default 12
#define MAX_BURN_DURATION      (5) //for adjust, default 3
#define ADD_BURN_STACK         (2) //for adjust, default 4

#include "_basetypes.fos"
#include "_macros.fos"
#include "backend_h.fos"
#include "combat_msg.fos"
#include "critical_table.fos"
#include "critical_failures.fos"
#include "logging_h.fos"
#include "npc_ai.fos"
#include "utils_h.fos"
#include "mapdata_h.fos"
#include "MsgStr.h"
#include "combat_h.fos"
#include "_npc_pids.fos"
#include "blood_h.fos"
#include "follower.fos"

import void AffectPoison(Critter& cr, int value) from "poison";
import void AffectRadiation(Critter& cr, int value) from "radiation";
import void PlaySound(Critter& cr, string& soundName) from "media";
import void PostDamage(Critter& cr) from "main";
import void QuakeScreen(Map& map) from "effects";
import void WearItem(Critter& cr, Item& item, int wearCount) from "repair";
import void _weapon_perk(Item& item, bool firstTime) from "item_level";
import void _armor_perk(Item& item, bool firstTime) from "item_level";
import void VerboseActionCombat(Critter& cr, string& text) from "utils";

import void MolotovBlast( Map& map, uint16 hexX, uint16 hexY, uint16 firePid, uint ownerId ) from "fire_hexes";

class AttackStruct
{
    Critter@   Attacker = null;
    Item@      RealWeapon = null;
    uint16     Hx = 0;
    uint16     Hy = 0;
    uint8      Aim = HIT_LOCATION_UNCALLED;
    bool       AimHead = false;
    bool       IsBurst = false;
    bool       BloodyMess = false;
    bool       CombatMessage = false;
    bool       IsUnarmed = false;
    int        WeaponPerk = -1;
    uint8      WeaponSubtype = 0;
    int        DmgMin = 0;
    int        DmgMax = 0;
    int        DmgType = 0;
    int        BonusDmg = 0;
    int        DmgMul = 2;
    int        DRMod = 0;
    int        DMMod = 1;
    int        DDMod = 1;
    uint       TargetId = 0;
    bool       TargetHit = false;
    bool       ShowHitAnimForce = false;
    ProtoItem@ Ammo = null;
    bool       SilentDeathEffect = false;
    bool       InYourFaceEffect = false;
    uint16     ammoPid;
    uint16     weaponPid;
    int8       weaponMode; // for swing/thrust melee weapons

    void set_Aim(uint8 aim)
    {
        Aim = aim;
        AimHead = aim == HIT_LOCATION_HEAD || aim == HIT_LOCATION_EYES;
    }

    uint8 get_Aim()
    {
        return Aim;
    }


}

int SelectArmorBonus(Item@ armor, int Int_Val_ArmorBonus)
{
    return 0;
}



void CombatAttack(Critter& cr, Critter& target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo)   // Export
{

	if(_MapHasMode(cr.GetMap(), MAP_MODE_NO_PVE))
    {
        cr.Say(SAY_NETMSG, "Can't Attack here.");
        return;
    }
    uint8 use = _WeaponModeUse(weaponMode);
    //if(cr.IsPlayer())
    //{
        //Log(" Use mode = " + use);
        //Log(" attack.WeaponSubtype [WS_UNARMED==1] = " + attack.WeaponSubtype);
    //}
    uint8 aim = _WeaponModeAim(weaponMode);

    if(aim != HIT_LOCATION_NONE && aim != HIT_LOCATION_UNCALLED)
        PlaySound(cr, "ICSXXXX1.ACM");           // should be (?) client-side, move when possible

    Item@ realWeapon = _CritGetItemHand(cr);
    Map@  map = cr.GetMap();
    int   wpnMaxDist = _WeaponMaxDist(weapon, use);
    int   skillNum = _WeaponSkill(weapon, use);
    if(skillNum == SK_THROWING)
    {
        wpnMaxDist = 5 + cr.Param[ST_STRENGTH];
        wpnMaxDist += 6 * (cr.Param[PE_HEAVE_HO]);
		if(cr.Param[PE_HEAVE_HO]>0 && cr.Param[PE_SHARPSHOOTER]>0)
			wpnMaxDist += 5;
    }
    int    skillVal = cr.Param[skillNum]; // skillVal wykorzystane pozniej jako: baseToHit = skillVal; oraz WearItem(cr, realWeapon, (MAX_SKILL_VAL - MIN(skillVal,200)) / 6);

    if(valid(realWeapon) && (realWeapon.Proto.ProtoId == PID_NEEDLER_PISTOL)) skillVal = MAX(cr.Param[SK_SMALL_GUNS], cr.Param[SK_DOCTOR]);  //25-07-2013 Cubik: podczas uzywania Needler pistola pod uwage bedzie brany max ze skilli SG i Doc do celnosci i psucia sie pistola


    uint8  weaponSubtype = (skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS /*|| skillNum == SK_DOCTOR*/) ? WS_GUN : ((skillNum == SK_THROWING) ? WS_THROWING : (skillNum == SK_UNARMED) ? WS_MELEE : WS_UNARMED);
    bool   isRanged = (weaponSubtype == WS_THROWING || weaponSubtype == WS_GUN);
    bool   isUnarmed = weapon.Weapon_IsUnarmed;
    bool   isHthAttack = (weaponSubtype == WS_MELEE || weaponSubtype == WS_UNARMED);
    uint16 ammoRound = _WeaponRound(weapon, use);
    bool   wpnIsRemoved = _WeaponRemove(weapon, use);
    uint16 hx = cr.HexX;
    uint16 hy = cr.HexY;
    uint16 tx = target.HexX;
    uint16 ty = target.HexY;
    uint16 weapPid = weapon.ProtoId;
    uint16 ammoPid = 0;
    if(valid(ammo))
        ammoPid = ammo.ProtoId;
    bool isBurst = (ammoRound > 1); // will suffice for now
	
	if(valid(realWeapon) && realWeapon.Val3 == WP_LEG_BBB && ammoRound>1) ammoRound += 1;
	if(valid(realWeapon) && realWeapon.Val4 == WP_LEG_BBB && ammoRound>1) ammoRound += 1;
	if(valid(realWeapon) && realWeapon.Val5 == WP_LEG_BBB && ammoRound>1) ammoRound += 1;
	if(valid(realWeapon) && realWeapon.Val6 == WP_LEG_BBB && ammoRound>1) ammoRound += 1;
	if(valid(realWeapon) && realWeapon.Val7 == WP_LEG_BBB && ammoRound>1) ammoRound += 1;
	if(valid(realWeapon) && realWeapon.Val8 == WP_LEG_BBB && ammoRound>1) ammoRound += 1;
	if(valid(realWeapon) && realWeapon.Val2 == WP_LEG_BBB && ammoRound>1) ammoRound += 1;
	
	if(cr.Param[PE_BONUS_RANGED_DAMAGE]>1 && cr.Param[PE_MORE_RANGED_DAMAGE]>0 && ammoRound>1)
		ammoRound += 1;
    if(isBurst)
        aim = HIT_LOCATION_UNCALLED;
    int              dmgType = _WeaponDmgType(weapon, use);
	if(cr.Param[PE_PYROMANIAC]>1 && dmgType == DAMAGE_PLASMA)
		dmgType = DAMAGE_FIRE;
	int normaldmg = 0;
	if(dmgType==DAMAGE_NORMAL)
		normaldmg = 5;
    bool             isGrenade = weaponSubtype == WS_THROWING && (dmgType != DAMAGE_NORMAL || dmgType != DAMAGE_LASER);   // like in fo2
    bool             isFlamethrower = (weapPid == PID_FLAMER) || (weapPid == PID_IMPROVED_FLAMETHROWER) || (weapPid == PID_FIRE_GECKO_FLAME_WEAPON || (weapPid == PID_NAPALM)) || (weapPid == PID_PLASMA_FLAMER) || (weapPid == PID_FIRE_SMG);
	if((weapPid == PID_PLASMA_SMG || weapPid == PID_PLASMA_GATLING) && cr.Param[PE_PYROMANIAC]>1)
		isFlamethrower = true;
    bool             isRocket = (ammoPid == PID_EXPLOSIVE_ROCKET) || (ammoPid == PID_40MM_GRENADE) || (ammoPid == PID_ROCKET_AP) || (ammoPid == PID_EL_ROCKET) || (ammoPid == PID_RAD_ROCKET) || (ammoPid == PID_40MM_GRENADE_FIRE) || (ammoPid == PID_40MM_GRENADE_ICE);
	if(cr.Param[PE_WRECKER]>0 && !isRocket)
		{
		cr.Say(SAY_NETMSG, "Can't use it");
		return;
		}
	if(cr.Param[PE_WRECKER]>0 && (ammoPid == PID_40MM_GRENADE_FIRE) || (ammoPid == PID_40MM_GRENADE_ICE))
		{
		cr.Say(SAY_NETMSG, "this ammo, killing me");
		cr.ParamBase[ST_CURRENT_HP] -= Random(50,100);
		if(cr.ParamBase[ST_CURRENT_HP] < 0)
			cr.ToDead(ANIM2_DEAD_EXPLODE, cr);
		}
    bool             isExplodeRocket = (ammoPid == PID_EXPLOSIVE_ROCKET) || (ammoPid == PID_40MM_GRENADE);
    bool             isShotgun = weapon.Weapon_Caliber == 11;
    bool             isBozar = weapPid == PID_BOZAR || (weapPid == PID_M16) || (weapPid == PID_M16_SKIN);
    bool             isLSW = (weapPid == PID_LIGHT_SUPPORT_WEAPON) || (weapPid == PID_LASER_LSW);
	
	bool             isAlien = (weapPid == PID_FIRE_SMG) || (weapPid == PID_TESLA_GATLING) || (weapPid == PID_LASER_LSW) || (weapPid == PID_ELECTRO_RIFLE) || (weapPid == PID_SNIPER_RIFLE_MK2) || (weapPid == PID_SUPER_DUPER_SLEDGE) || (weapPid == PID_AUTOAIM_ROCKET) || (weapPid == PID_PLASMA_FLAMER);
	
	if(isAlien && cr.Param[PE_ALIEN] == 0)
		{
		cr.Say(SAY_NETMSG, "Can't use it");
		return;
		}
	if(!isAlien && cr.Param[PE_ALIEN] > 0)
		{
		cr.Say(SAY_NETMSG, "Can't use it");
		return;
		}

    if(ammoPid == PID_SHOTGUN_SHELLS_EMP) dmgType=DAMAGE_EMP; // jesli uzywane ammo typu EMP to zmien dmtype broni
    if(ammoPid == PID_SHOTGUN_DRAGON_BREATH_SHELLS) dmgType=DAMAGE_FIRE; // jesli uzywane ammo typu EMP to zmien dmtype broni
	
	if(ammoPid == PID_40MM_GRENADE_ICE) dmgType=DAMAGE_PLASMA; // jesli uzywane ammo typu EMP to zmien dmtype broni
	if(ammoPid == PID_40MM_GRENADE_FIRE) dmgType=DAMAGE_FIRE; // jesli uzywane ammo typu EMP to zmien dmtype broni

    bool             eyeDamage = cr.Damage[DAMAGE_EYE] != 0;
    int              weaponPerk = weapon.Weapon_Perk;
    bool             crIsPlayer = cr.IsPlayer();
    bool             isHit = false;
    bool             isCritical = false;
    bool             hitRandomly = false;
    uint             critfailFlags = 0;
    Critter@         realTarget;
    bool             isSneak = false;
    bool             useNormal = false;   // Used to change target during RunFlyEffect
    bool             useHex = false;      // Used to change end hex of RunFlyEffect, i.e. for thrown weapons and rockets.
    Critter@         normalTarget;        // Used as a target for weapon animations;

    int CriticalChance = 0; //01-08-2013 cubik: szansa na krytyczny strzal, wykorzsystywana w AttackDamage() do wyliczania ilosci krytycznych strzalow w burst

    array<CombatRes> results;

    int              acmod = 0;   // Used many times

    // Begin turn based combat
    if(!map.IsTurnBased() && map.IsTurnBasedAvailability())
        map.BeginTurnBased(cr);
    // Always unsneak
    int checkassasin = Random(0,100);
    if(cr.Param[PE_ASSASIN] != 0 && checkassasin < 10)
    {
    if(cr.Param[MODE_HIDE] != 0)
    {
        if(!cr.IsPlayer() || (cr.IsPlayer() && cr.GetAccess() == ACCESS_CLIENT))
            cr.ParamBase[MODE_HIDE] = 0;
        isSneak = true;
    }
    }
    else if(cr.Param[PE_ASSASIN] != 0 && checkassasin > 10)
    { cr.Say(SAY_NETMSG, "Still Sneaking"); isSneak = true;}
    else
    {
    if(cr.Param[MODE_HIDE] != 0)
    {
        if(!cr.IsPlayer() || (cr.IsPlayer() && cr.GetAccess() == ACCESS_CLIENT))
            cr.ParamBase[MODE_HIDE] = 0;
        isSneak = true;
    }
    }

    if(!target.IsPlayer() || (target.IsPlayer() && target.GetAccess() == ACCESS_CLIENT))
        target.ParamBase[MODE_HIDE] = 0;

    cr.SetDir(GetDirection(hx, hy, tx, ty));

    // Fast Shot random aim
    if(cr.Param[TRAIT_FAST_SHOT] != 0 && !isBurst && valid(weapon) && _WeaponAim(weapon, use) && !_WeaponIsHtHAttack(weapon, use))
    {
        uint roll = Random(1,100);
        if ( roll > 95 )
            aim = HIT_LOCATION_EYES;
        else if ( roll > 85 )
            aim = HIT_LOCATION_HEAD;
        else if ( roll > 70 )
            aim = (HAS_CHANCE(50) ? HIT_LOCATION_LEFT_ARM : HIT_LOCATION_RIGHT_ARM);
        else if ( roll > 55 )
            aim = HIT_LOCATION_GROIN;
        else if ( roll > 35 )
            aim = (HAS_CHANCE(50) ? HIT_LOCATION_LEFT_LEG : HIT_LOCATION_RIGHT_LEG);
        else
            aim = HIT_LOCATION_UNCALLED;
    }

    // Now we change aim, if applicable
    if(aim == HIT_LOCATION_EYES && valid(cr) && (cr.Dir + 3) % 6 != target.Dir)
        aim = HIT_LOCATION_HEAD;
    else if(aim == HIT_LOCATION_EYES && valid(target))
    {
        Item@ helmet = target.GetItem(0, SLOT_HEAD);
        if(valid(helmet) && helmet.Proto.Armor_Perk == HELMET_PERK_PROTECT_EYES)
            aim = HIT_LOCATION_HEAD;
    }


    if(cr.Param[TO_BATTLE] < int(__TimeoutBattle))
        _SetTimeout(cr, TO_BATTLE, __TimeoutBattle);
    if(target.Param[TO_BATTLE] < int(__TimeoutBattle))
        _SetTimeout(target, TO_BATTLE, __TimeoutBattle);

    // Update leaderboard stats
    if(crIsPlayer)
    {
        if(weaponSubtype == WS_GUN)
            AddScore(cr, SCORE_SHOOTER, 1);
        //else if(skillNum == SK_MELEE_WEAPONS || skillNum == SK_THROWING)
        else if(skillNum == SK_UNARMED || skillNum == SK_THROWING)
            AddScore(cr, SCORE_MELEE, 1);
        else if(skillNum == SK_UNARMED)
            AddScore(cr, SCORE_UNARMED, 1);
    }

    // Npc attack text
    if(!crIsPlayer)
        AI_TrySayCombatText(cr, COMBAT_TEXT_ATTACK);

    // Add event, always
    target.EventAttacked(cr);

    // Essential part starts here


    // Fill the main attack structure
    AttackStruct attack;
    @attack.Attacker = cr;
    @attack.RealWeapon = realWeapon;
    attack.Hx = hx;
    attack.Hy = hy;
    attack.set_Aim(aim);
    attack.IsBurst = isBurst;
    attack.BloodyMess = cr.Param[TRAIT_BLOODY_MESS] != 0;
    attack.CombatMessage = true;
    attack.IsUnarmed = (weaponSubtype == WS_UNARMED);
    attack.WeaponPerk = (isUnarmed && weapon.Weapon_UnarmedArmorPiercing) ? WEAPON_PERK_PENETRATE : weaponPerk;
    attack.WeaponSubtype = weaponSubtype;
    attack.DmgMin = _WeaponDmgMin(weapon, use);
    attack.DmgMax = _WeaponDmgMax(weapon, use);
    attack.DmgType = dmgType;
    attack.BonusDmg = 0;
    int bonusrange = 0;
	 if(valid(realWeapon) && realWeapon.Val3 == WP_SCOPED) bonusrange += 4;
    if(valid(realWeapon) && realWeapon.Val4 == WP_SCOPED) bonusrange += 4;
    if(valid(realWeapon) && realWeapon.Val5 == WP_SCOPED) bonusrange += 4;
    if(valid(realWeapon) && realWeapon.Val6 == WP_SCOPED) bonusrange += 4;
    if(valid(realWeapon) && realWeapon.Val7 == WP_SCOPED) bonusrange += 4;
    if(valid(realWeapon) && realWeapon.Val8 == WP_SCOPED) bonusrange += 4;
	
	
    if(valid(realWeapon))
    {
        wpnMaxDist += bonusrange;
    }
    wpnMaxDist += cr.Param[PE_DEATHCLAW];
	
	if(valid(realWeapon) && realWeapon.Val3 == WP_LEG_SNIPER) wpnMaxDist *= 2;
	if(valid(realWeapon) && realWeapon.Val4 == WP_LEG_SNIPER) wpnMaxDist *= 2;
	if(valid(realWeapon) && realWeapon.Val5 == WP_LEG_SNIPER) wpnMaxDist *= 2;
	if(valid(realWeapon) && realWeapon.Val6 == WP_LEG_SNIPER) wpnMaxDist *= 2;
	if(valid(realWeapon) && realWeapon.Val7 == WP_LEG_SNIPER) wpnMaxDist *= 2;
	if(valid(realWeapon) && realWeapon.Val8 == WP_LEG_SNIPER) wpnMaxDist *= 2;
	if(valid(realWeapon) && realWeapon.Val2 == WP_LEG_SNIPER) wpnMaxDist *= 2;
	
	if(cr.Param[PE_HEAVE_HO]>0 && cr.Param[PE_SHARPSHOOTER]>0 && !attack.IsUnarmed)
		wpnMaxDist += 5;
	
	if(wpnMaxDist < 2 && isBurst)
	{
	if(target.IsPlayer())
            {
			if(cr.IsPlayer())
			{
			uint16 year=0, month=0, day=0, dayofweek=0, hour=0, minute=0, second=0;
			GetGameTime( __FullSecond, year, month, day, dayofweek, hour, minute, second );
			file f;
			f.open("logs/hexbot.txt", "w");
			f.writeString(day + "." + month + " " + cr.Name + " more likely using hexbot on: " + target.Name);
			f.close();
			}
			}
	
	}
	
    attack.weaponMode=weaponMode;
    attack.weaponPid=weapon.ProtoId;

    //Log(" weaponPid = " + weapon.ProtoId);


    // baseToHit used for all targets, adjusted for distance and other target-dependent qualities every time it is necessary
    int baseToHit = skillVal;
    if(eyeDamage)
        baseToHit -= 25;

        if(cr.Param[TRAIT_ONE_HANDER] != 0)
            baseToHit += (FLAG(weapon.Flags, ITEM_TWO_HANDS) ? -100 : 20);
        int handlingStrength = cr.Param[ST_STRENGTH];
        int reqStrength = weapon.Weapon_MinStrength;
        if(cr.Param[PE_WEAPON_HANDLING] != 0)
            handlingStrength += 2;
        if(cr.Param[PE_SOLDIER] == 1)
            handlingStrength += 1;
        if(handlingStrength < reqStrength)
            baseToHit -= (reqStrength - handlingStrength) * 20;

        if(cr.Param[PE_SOLDIER]== 1 )
            baseToHit +=1;


    @attack.Ammo = ammo;
    uint8 crDir = cr.Dir;
    uint8 tDir  = target.Dir;

    if(isSneak && cr.Param[PE_SILENT_DEATH] != 0 && (crDir == tDir || ((crDir + 1) % 6) == tDir || ((crDir + 5) % 6) == tDir) &&
       !isGrenade &&
       (weaponSubtype != WS_GUN || realWeapon.Proto.Weapon_Anim1 == ANIM1_PISTOL || COMBAT_WEAPON_ALLOWS_SD(realWeapon))
       )
        attack.SilentDeathEffect = true;


    if(isHthAttack)
    {
        attack.DmgMin += cr.Param[ST_MELEE_DAMAGE] * 0.75;
        attack.DmgMax += cr.Param[ST_MELEE_DAMAGE] * 0.75;
    }
	uint bonusbrd = 0;
		if(valid(realWeapon) && realWeapon.Val3 == WP_BRD) bonusbrd +=3;
        if(valid(realWeapon) && realWeapon.Val4 == WP_BRD) bonusbrd +=3;
        if(valid(realWeapon) && realWeapon.Val5 == WP_BRD) bonusbrd +=3;
        if(valid(realWeapon) && realWeapon.Val6 == WP_BRD) bonusbrd +=3;
        if(valid(realWeapon) && realWeapon.Val7 == WP_BRD) bonusbrd +=3;
        if(valid(realWeapon) && realWeapon.Val8 == WP_BRD) bonusbrd +=3;
	if(target.Param[BUFF_RAIDER] > 0 && cr.Param[ST_NPC_BOSS] != 0)
		bonusbrd += 5 * target.Param[BUFF_RAIDER];
	
    if(weaponSubtype == WS_GUN && !isShotgun)
        attack.BonusDmg += cr.Param[PE_BONUS_RANGED_DAMAGE] * 2 + cr.Param[PE_MORE_RANGED_DAMAGE] * 3 + cr.Param[PE_SOLDIER] + cr.Param[BUFF_RAIDER] + bonusbrd;
		
	
    attack.DmgMul = 2;

    // Ammo
    if(valid(ammo))
    {
        attack.DRMod = ammo.Ammo_DrMod;
        attack.DMMod = ammo.Ammo_DmgMult;
        attack.DDMod = ammo.Ammo_DmgDiv;
        if(attack.DMMod == 0)
            attack.DMMod = 1;
        if(attack.DDMod == 0)
            attack.DDMod = 1;
    }

    // To check if the original target was hit:
    attack.TargetId = target.Id;
    int bonusaccu = 0;
	if(valid(realWeapon) && realWeapon.Val3 == WP_LONG_RANGE) bonusaccu += 20;
    if(valid(realWeapon) && realWeapon.Val4 == WP_LONG_RANGE) bonusaccu += 20;
    if(valid(realWeapon) && realWeapon.Val5 == WP_LONG_RANGE) bonusaccu += 20;
    if(valid(realWeapon) && realWeapon.Val6 == WP_LONG_RANGE) bonusaccu += 20;
    if(valid(realWeapon) && realWeapon.Val7 == WP_LONG_RANGE) bonusaccu += 20;
    if(valid(realWeapon) && realWeapon.Val8 == WP_LONG_RANGE) bonusaccu += 20;
	if(target.IsPlayer() && !attack.Attacker.IsPlayer())
		bonusaccu -= 2 * target.Param[PE_PVE_DODGER];
    // Here we are deciding the real toHit;
    int toHit = baseToHit + bonusaccu;
    toHit -= isHthAttack ? (GetHitAim(aim) / 2) : GetHitAim(aim);

    // Range considerations, we are storing everything for some later use
    int distmod1 = 2;   // Used for initial weapon bonus
    int distmod2 = 0;   // Minimal distance
    bool havelongrange = false;
        //Item@ RealWeapon = _CritGetItemHand(cr);
		if(valid(realWeapon) && realWeapon.Val3 == WP_LONG_RANGE) havelongrange = true;
        if(valid(realWeapon) && realWeapon.Val4 == WP_LONG_RANGE) havelongrange = true;
        if(valid(realWeapon) && realWeapon.Val5 == WP_LONG_RANGE) havelongrange = true;
        if(valid(realWeapon) && realWeapon.Val6 == WP_LONG_RANGE) havelongrange = true;
        if(valid(realWeapon) && realWeapon.Val7 == WP_LONG_RANGE) havelongrange = true;
        if(valid(realWeapon) && realWeapon.Val8 == WP_LONG_RANGE) havelongrange = true;
    if(havelongrange)
        distmod1 = 4;

    if(cr.Param[PE_SOLDIER] == 1)
        distmod1 +=1;
    if(cr.Param[PE_SOLDIER] == 1)
        distmod2 +=1;

    int perception = cr.Param[ST_PERCEPTION];
    int dist = GetDistantion(hx, hy, target.HexX, target.HexY);
    int acc = dist;
    int accloss = (crIsPlayer ? (perception - 2) * distmod1 : (perception * distmod1));
    int sharpshooter = 2 * cr.Param[PE_SHARPSHOOTER] + 2 * cr.Param[PE_TACTICAL] + 2 * cr.Param[PE_TACTICAL2];

    // +++ the following is to be copypasted many times, in fact it should be an inline function but AngelScript won't allow that... Yet
    if(!isHthAttack)
    {
        if(dist < distmod2)
            acc += distmod2;
        else
            acc -= accloss;
        if(-2 * perception > acc)
            acc = -2 * perception;
        acc -= sharpshooter;
        if(acc > 0 && eyeDamage)
            acc *= 3;
        acc *= -4 - cr.Param[PE_SOLDIER];
        toHit += acc;
        int blockers = map.GetCrittersPath(hx, hy, tx, ty, 0.0f, dist, FIND_LIFE, null);
        if(!target.IsKnockout())
            blockers--;
        toHit -= 10 * blockers + cr.Param[PE_SOLDIER];
    }
    acmod = target.GetAC(attack.AimHead);
    if(valid(ammo))
        acmod += ammo.Ammo_AcMod;
		
	acmod -= attack.Attacker.Param[ST_PERCEPTION]*5;
    if(acmod > 0)
        toHit -= acmod;
    if(target.IsKnockout())
        toHit += 40 + cr.Param[PE_SOLDIER];
    if(target.GetMultihex() > 0)
        toHit += 15 + cr.Param[PE_SOLDIER];
    int noHex = 0;
    int IYF = 0;
    Item@ targetWeapon = _CritGetItemHand(target);
    bool checkface =(!valid(targetWeapon) && dist == 1) ||
                             (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON &&
                              (targetWeapon.Proto.Weapon_Skill_0 == SK_UNARMED) &&
                              _WeaponMaxDist(targetWeapon.Proto, 0) >= uint(dist));
    if(target.Param[PE_IN_YOUR_FACE] > 0 && checkface  && dist == 1)
        IYF = 50;
	
    toHit = CLAMP(toHit, 5 + cr.Param[PE_SOLDIER] , 95 + cr.Param[PE_SOLDIER] + normaldmg - noHex - IYF);

    // Override tohit chance by a defender perk?
    bool in_your_face_valid = false;
    if(target.Param[PE_IN_YOUR_FACE] > 0 && checkface  && dist < 3  && target.IsPlayer())
    {
        Item@ targetWeapon = _CritGetItemHand(target);
        in_your_face_valid = (!valid(targetWeapon) && dist == 1) ||
                             (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON &&
                              (targetWeapon.Proto.Weapon_Skill_0 == SK_UNARMED) &&
                              _WeaponMaxDist(targetWeapon.Proto, 0) >= uint(dist));

        if(in_your_face_valid)
            toHit = MAX(toHit, 50 + cr.Param[PE_SOLDIER] - noHex);
    }

    // Main hit roll
    int margin = toHit - Random(1, 100);

    if(margin < 0)     // If missed
    {
        attack.InYourFaceEffect = in_your_face_valid;
        // Not setting isHit, we try a critical failure
        if(cr.Param[MODE_INVULNERABLE] == 0)
        {
            isCritical = ((((-margin) / 10) + ((valid(realWeapon) && realWeapon.IsDeteriorable() && !_CritHasExtMode(cr, MODE_EXT_NO_DETERIORATION)) ? ((20 * realWeapon.Deterioration) / MAX_DETERIORATION) : 0)) >= Random(1, 100));
            // Basic jinxed behaviour (upgrade to a critical failure if anyone is jinxed and a coinflip is passed)
            if(!isCritical)
                isCritical = (Random(0, 1) == 0 &&
                              (cr.Param[TRAIT_JINXED] != 0  || target.Param[TRAIT_JINXED] != 0));
            if(isCritical)
            {
                int roll = Random(1, 100) - 5 * (cr.Param[ST_LUCK] - 5);
                if(roll <= 20)
                    roll = 0 + cr.Param[PE_SOLDIER];
                else if(roll <= 50)
                    roll = 1 + cr.Param[PE_SOLDIER];
                else if(roll <= 75)
                    roll = 2 + cr.Param[PE_SOLDIER];
                else if(roll <= 95)
                    roll = 3 + cr.Param[PE_SOLDIER];
                else
                    roll = 4;

                critfailFlags = CriticalFailureTable[5 * weapon.Weapon_CriticalFailture + roll];
                if(critfailFlags == 0)
                    isCritical = false;
                hitRandomly = FLAG(critfailFlags, MF_HIT_RANDOMLY);
            }
        }
    }
    else     // If hit
    {
        isHit = true;
        //if(isHthAttack && cr.Param[PE_SLAYER] != 0)
            //isCritical = true;
        if(attack.SilentDeathEffect)
            isCritical = true;
        else
        {
            int bonuscrit = 0;
			if(valid(realWeapon) && realWeapon.Val3 == WP_MORE_CRIT) bonuscrit += 8;
            if(valid(realWeapon) && realWeapon.Val4 == WP_MORE_CRIT) bonuscrit += 8;
            if(valid(realWeapon) && realWeapon.Val5 == WP_MORE_CRIT) bonuscrit += 8;
            if(valid(realWeapon) && realWeapon.Val6 == WP_MORE_CRIT) bonuscrit += 8;
            if(valid(realWeapon) && realWeapon.Val7 == WP_MORE_CRIT) bonuscrit += 8;
            if(valid(realWeapon) && realWeapon.Val8 == WP_MORE_CRIT) bonuscrit += 8;
			int critsyg = 4;
			if(cr.Param[PE_BETTER_CRITICALS]>0 && cr.Param[PE_HIT_THE_GAPS]>0 && cr.Param[PE_RIGHT_BETWEEN_THE_EYES]>0 && cr.Param[PE_SPRAY_AND_PRAY]>0)
				critsyg = 5;
			
            int chance = cr.Param[ST_CRITICAL_CHANCE] + (GetHitAim(aim) * (20 + critsyg * cr.Param[ST_LUCK])) / 100 + bonuscrit;
			if(chance>100)
				chance=100;
			if(target.Param[ST_STRENGTH]>19)
				chance -= 25;
			if(chance>100)
				chance=100;
           // Item@ usedArmor = _GetCritterArmor(target, attack.AimHead);
			Item@ usedArmor = target.GetItem(0, SLOT_ARMOR);
			Item@ usedHelmet = target.GetItem(0, SLOT_HEAD);
    
                int addchance = 0;
				if(attack.AimHead && valid(usedHelmet))
					addchance = usedHelmet.Proto.Armor_CMCritChance;
				if(!attack.AimHead && valid(usedArmor)) 
					addchance = usedArmor.Proto.Armor_CMCritChance;
                if(attack.AimHead && cr.Param[PE_RIGHT_BETWEEN_THE_EYES] != 0 && valid(usedHelmet))
                    addchance /= 10;
                if(!attack.AimHead && cr.Param[PE_HIT_THE_GAPS] != 0 && valid(usedArmor))
                    addchance /= 5;
				if(target.Param[PE_LEADER]>0)
					chance = chance / 2;
                chance += addchance;
                //Log("*szansa na criticala przed dodaniem ujemnego bonusa z armora: " + chance);
				if(valid(usedArmor) && usedArmor.Val3 == AP_FTG && valid(usedArmor) && cr.Param[PE_HUNTER] == 0 ) chance -= 20;
                if(valid(usedArmor) && usedArmor.Val4 == AP_FTG && valid(usedArmor) && cr.Param[PE_HUNTER] == 0 ) chance -= 20;
                if(valid(usedArmor) && usedArmor.Val5 == AP_FTG && valid(usedArmor) && cr.Param[PE_HUNTER] == 0 ) chance -= 20;
                if(valid(usedArmor) && usedArmor.Val6 == AP_FTG && valid(usedArmor) && cr.Param[PE_HUNTER] == 0 ) chance -= 20;
                if(valid(usedArmor) && usedArmor.Val7 == AP_FTG && valid(usedArmor) && cr.Param[PE_HUNTER] == 0 ) chance -= 20;
                if(valid(usedArmor) && usedArmor.Val8 == AP_FTG && valid(usedArmor) && cr.Param[PE_HUNTER] == 0 ) chance -= 20;
				if(target.Param[PE_MAN_OF_STEEL]>0 && target.Param[PE_IRON_GRIP]>0 && target.Param[PE_STONEWALL]>0 && target.Param[PE_QUICK_RECOVERY]>0 )
					chance -= 30;
				
			if(valid(usedArmor) && usedArmor.Val3 == AP_LEG_ANTY_CRIT && valid(usedArmor) && cr.Param[PE_HUNTER] == 0) chance -= 30;
            if(valid(usedArmor) && usedArmor.Val4 == AP_LEG_ANTY_CRIT && valid(usedArmor) && cr.Param[PE_HUNTER] == 0) chance -= 30;
            if(valid(usedArmor) && usedArmor.Val5 == AP_LEG_ANTY_CRIT && valid(usedArmor) && cr.Param[PE_HUNTER] == 0) chance -= 30;
            if(valid(usedArmor) && usedArmor.Val6 == AP_LEG_ANTY_CRIT && valid(usedArmor) && cr.Param[PE_HUNTER] == 0) chance -= 30;
            if(valid(usedArmor) && usedArmor.Val7 == AP_LEG_ANTY_CRIT && valid(usedArmor) && cr.Param[PE_HUNTER] == 0) chance -= 30;
            if(valid(usedArmor) && usedArmor.Val8 == AP_LEG_ANTY_CRIT && valid(usedArmor) && cr.Param[PE_HUNTER] == 0) chance -= 30;
			if(valid(usedArmor) && usedArmor.Val2 == AP_LEG_ANTY_CRIT && valid(usedArmor) && cr.Param[PE_HUNTER] == 0) chance -= 30;
			
			if(attack.DmgType == DAMAGE_LASER)
				chance += 5;

                //Log("*szansa na criticala po dodaniu ujemnego bonusa z armora: " + chance);
           if(!target.IsPlayer())
				chance += cr.Param[PE_PVE_BRUTE];
			
			if(target.Param[BUFF_SPIDER]>0 && cr.Param[ST_NPC_BOSS] != 0)
				chance = 10 * target.Param[BUFF_SPIDER];
			if(cr.Param[PE_EMP_IMPLANT]>1)
				chance = 0;
            isCritical = (Random(0, 100) <= chance);
            CriticalChance = chance;
			if(cr.Param[PE_MASTER]>0 && attack.WeaponSubtype==WS_MELEE ||  attack.WeaponSubtype == WS_UNARMED)
				isCritical = true;
        }

        //if(!isCritical && weaponSubtype == WS_GUN && cr.Param[PE_SNIPER] != 0)
           // isCritical = (Random(1, 10) <= cr.Param[ST_LUCK]);
        if(!isCritical && isUnarmed)
            isCritical = Random(0, 100) <= weapon.Weapon_UnarmedCriticalBonus;
    }

    if(hitRandomly)
    {
        Critter@ randomTarget = ChooseRandomTarget(map, cr, target, wpnMaxDist);
        if(valid(randomTarget))
        {
            @realTarget = randomTarget;
            tx = realTarget.HexX;
            ty = realTarget.HexY;
            attack.set_Aim(HIT_LOCATION_UNCALLED);
            realTarget.ParamBase[MODE_HIDE] = 0;           // done here to allow combat notifications later
            NotifyOops(cr, target, realTarget, results);
        }
    }
    else
        @realTarget = target;

    // Initial animations
    cr.Action(ACTION_USE_WEAPON, (((!isHit && isCritical && !hitRandomly) ? 1 : 0) << 8) | (aim << 4) | use, realWeapon);

    // Animations are now played, and we're updating the hit randomly status now
    bool changedTarget = (hitRandomly && (@realTarget != null));

    LogAttack(map, cr, target, weapon, ammo, aim, isBurst, ammoRound, (valid(realWeapon) ? realWeapon.AmmoCount : ammoRound), isHit, isCritical, critfailFlags);

    // Commencing critical failures
    if(!isHit && isCritical && (!hitRandomly  || @realTarget == null))
    {
        CriticalFailure(cr, weapon, use, ammo, critfailFlags, results);
        return;
    }

    // Commencing attack, various instances
    bool criticalHit = isHit && isCritical;

    if(isHthAttack)       // UNARMED AND MELEE ATTACK
    {
        if(isHit)
        {
            ApplyDamage(attack, realTarget, 1, criticalHit, true, results, 0);
        }
        else
        {
            if(changedTarget)
                ApplyDamage(attack, realTarget, 1, false, false, results, 0);
            else
                NotifyMiss(cr, results);
        }
    }
    else if((weaponSubtype == WS_GUN) && !isBurst && !isRocket && !isFlamethrower)       // single shot, normal
    {
        if(isHit || changedTarget)
        {
            ApplyDamage(attack, realTarget, 1, criticalHit, !changedTarget, results, 0);
        }
        else         // standard miss here
        {
            array<Critter@> critsLine;
            attack.set_Aim(HIT_LOCATION_UNCALLED);
            map.GetCrittersPath(hx, hy, tx, ty, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, critsLine);
            int  bl = 0;
            bool anyHit = false;
            for(int i = 0, j = critsLine.length(); (i < j) && !anyHit; i++)
            {
                if(critsLine[i].Id == realTarget.Id)
                {
                    bl++;
                    continue;
                }                                                                      // skip the primary target

                // adjust tohit
                dist = GetDistantion(hx, hy, critsLine[i].HexX, critsLine[i].HexY);
                acc = dist;
                toHit = baseToHit;
                if(dist < distmod2)
                    acc += distmod2;
                else
                    acc -= accloss;
                if(-2 * perception > acc)
                    acc = -2 * perception;
                acc -= sharpshooter;
                if(acc > 0 && eyeDamage)
                    acc *= 3;
                acc *= -4;
                toHit += acc;
                acmod = critsLine[i].GetAC(false);
				acmod -= attack.Attacker.Param[ST_PERCEPTION]*5;
                if(valid(ammo))
                    acmod += ammo.Ammo_AcMod;
                if(acmod > 0)
                    toHit -= acmod;
                toHit -= 10 * bl;
                if(critsLine[i].IsKnockout())
                    toHit += 40 + cr.Param[PE_SOLDIER];
                else
                    bl++;
                if(critsLine[i].GetMultihex() > 0)
                    toHit += 15 + cr.Param[PE_SOLDIER];
        if(target.Param[PE_IN_YOUR_FACE] > 0 && checkface  && dist == 1  && target.IsPlayer())
        IYF = 50;
                toHit = CLAMP(toHit, 5 + cr.Param[PE_SOLDIER], 95 + cr.Param[PE_SOLDIER] + normaldmg - noHex - IYF);
                toHit /= 3;               // after clamp
                if(Random(1, 100) <= toHit)
                {
                    NotifyOops(cr, target, critsLine[i], results);
                    @normalTarget = critsLine[i];
                    useNormal = true;
                    ApplyDamage(attack, normalTarget, 1, false, false, results, 0);
                    anyHit = true;
                }
            }
            if(!anyHit)
                NotifyMiss(cr, results);
        }
    }
    else if(isFlamethrower)       // FLAME ATTACK
    {
        // Adjust toHit if random hit
        if(changedTarget)
        {
            dist = GetDistantion(hx, hy, tx, ty);
            acc = dist;
            toHit = baseToHit;
            if(dist < distmod2)
                acc += distmod2;
            else
                acc -= accloss;
            if(-2 * perception > acc)
                acc = -2 * perception + cr.Param[PE_SOLDIER];
            acc -= sharpshooter;
            if(acc > 0 && eyeDamage)
                acc *= 3;
            acc *= -4;
            toHit += acc;
            acmod = realTarget.GetAC(false);
			acmod -= attack.Attacker.Param[ST_PERCEPTION]*5;
            if(valid(ammo))
                acmod += ammo.Ammo_AcMod;
            if(acmod > 0)
                toHit -= acmod;
            if(realTarget.IsKnockout())
                toHit += 40 + cr.Param[PE_SOLDIER];
            if(realTarget.GetMultihex() > 0)
                toHit += 15 + cr.Param[PE_SOLDIER];
            int blockers = map.GetCrittersPath(hx, hy, tx, ty, 0.0f, dist, FIND_LIFE, null);
            if(!realTarget.IsKnockout())
                blockers--;
            toHit -= 10 * blockers + cr.Param[PE_SOLDIER];
        if(target.Param[PE_IN_YOUR_FACE] > 0 && checkface  && dist == 1  && target.IsPlayer())
        IYF = 50;
            toHit = CLAMP(toHit, 5 + cr.Param[PE_SOLDIER], 95 + cr.Param[PE_SOLDIER] + normaldmg  - noHex - IYF);
        }

        // Critical hit bonus, toHit can be increased over 100
        if(criticalHit)
            toHit += 20 + cr.Param[PE_SOLDIER];

        // Proceed with the flame attack
        array<Critter@> critsHit(0);
        array<uint>     critsHitBullets(0);
        int len_ = 0;

        if(Random(1, 100) <= toHit)
        {
            critsHit.resize(1);
            @critsHit[0] = realTarget;
            critsHitBullets.resize(1);
            critsHitBullets[0] += 1;
            len_++;
        }

        array<Critter@> lineCentral;
        map.GetCrittersPath(hx, hy, tx, ty, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, lineCentral);
        int             bl;

        bool            threeLines = true;

        for(int lineCount = 0, lineMax = (threeLines ? 1 : 3); lineCount < lineMax; lineCount++)
        {
            // Central line of fire
            bl = 0;           // No blockers
            for(int i = 0, j = lineCentral.length(); i < j; i++)
            {
                // Adjust tohit
                toHit = baseToHit - 10 * bl;
                dist = GetDistantion(hx, hy, lineCentral[i].HexX, lineCentral[i].HexY);
                acc = dist;
                if(dist < distmod2)
                    acc += distmod2;
                else
                    acc -= accloss;
                if(-2 * perception > acc)
                    acc = -2 * perception + cr.Param[PE_SOLDIER];
                acc -= sharpshooter;
                if(acc > 0 && eyeDamage)
                    acc *= 3 + cr.Param[PE_SOLDIER];
                acc *= -4 + cr.Param[PE_SOLDIER];
                toHit += acc;
                acmod = lineCentral[i].GetAC(false);
				acmod -= attack.Attacker.Param[ST_PERCEPTION]*5;
                if(valid(ammo))
                    acmod += ammo.Ammo_AcMod;
                if(acmod > 0)
                    toHit -= acmod;
                if(lineCentral[i].IsKnockout())
                    toHit += 40 + cr.Param[PE_SOLDIER];
                else
                    bl++;
                if(lineCentral[i].GetMultihex() > 0)
                    toHit += 15 + cr.Param[PE_SOLDIER];
        if(target.Param[PE_IN_YOUR_FACE] > 0 && checkface  && dist == 1  && target.IsPlayer())
        IYF = 50;
                toHit = CLAMP(toHit, 5 + cr.Param[PE_SOLDIER], 95 + cr.Param[PE_SOLDIER] + normaldmg  - noHex - IYF);
                if(Random(1, 100) <= toHit)
                {
                    int crIndex = FindCritterInArray(critsHit, lineCentral[i]);
                    if(crIndex == -1)
                    {
                        critsHit.resize(len_ + 1);
                        @critsHit[len_] = lineCentral[i];
                        critsHitBullets.resize(len_ + 1);
                        crIndex = len_;
                        len_++;
                    }
                    critsHitBullets[crIndex] += 1;
                }
            }
            // Central line of fire end
        }

        if(threeLines)
        {
            uint8  leftDir = GetOffsetDir(hx, hy, tx, ty, 89.0f);
            uint16 sx = hx;
            uint16 sy = hy;
            uint16 ex = tx;
            uint16 ey = ty;

            map.MoveHexByDir(sx, sy, leftDir, 1);
            map.MoveHexByDir(ex, ey, leftDir, 1);

            array<Critter@> lineLeft;
            map.GetCrittersPath(sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, FIND_LIFE_AND_KO, lineLeft);
            int             leftStart = 0;
            int             leftLen = lineLeft.length();
            while((leftStart < leftLen) && (GetDistantion(hx, hy, lineLeft[leftStart].HexX, lineLeft[leftStart].HexY)) < 3)
                leftStart++;

            for(int i = leftStart, j = leftLen; i < j; i++)
            {
                // Adjust tohit
                dist = GetDistantion(hx, hy, lineLeft[i].HexX, lineLeft[i].HexY);
                bl = map.GetCrittersPath(hx, hy, lineLeft[i].HexX, lineLeft[i].HexY, 0.0f, dist, FIND_LIFE, null) - 1;
                toHit = baseToHit - 10 * bl;
                acc = dist;
                if(dist < distmod2)
                    acc += distmod2;
                else
                    acc -= accloss;
                if(-2 * perception > acc)
                    acc = -2 * perception + cr.Param[PE_SOLDIER];
                acc -= sharpshooter;
                if(acc > 0 && eyeDamage)
                    acc *= 3+ cr.Param[PE_SOLDIER];
                acc *= -4 + cr.Param[PE_SOLDIER];
                toHit += acc + cr.Param[PE_SOLDIER];
                acmod = lineLeft[i].GetAC(false);
				acmod -= attack.Attacker.Param[ST_PERCEPTION]*5;
                if(valid(ammo))
                    acmod += ammo.Ammo_AcMod;
                if(acmod > 0)
                    toHit -= acmod;
                if(lineLeft[i].IsKnockout())
                    toHit += 40 + cr.Param[PE_SOLDIER];
                if(lineLeft[i].GetMultihex() > 0)
                    toHit += 15 + cr.Param[PE_SOLDIER];
        if(target.Param[PE_IN_YOUR_FACE] > 0 && checkface  && dist == 1 && target.IsPlayer())
        IYF = 50;
                toHit = CLAMP(toHit, 5 + cr.Param[PE_SOLDIER], 95 + cr.Param[PE_SOLDIER] + normaldmg  - noHex - IYF);
                if(Random(1, 100) <= toHit)
                {
                    int crIndex = FindCritterInArray(critsHit, lineLeft[i]);
                    if(crIndex == -1)
                    {
                        critsHit.resize(len_ + 1);
                        @critsHit[len_] = lineLeft[i];
                        critsHitBullets.resize(len_ + 1);
                        crIndex = len_;
                        len_++;
                    }
                    critsHitBullets[crIndex] += 1;
                }
            }             // Left line end

            uint8 rightDir = GetOffsetDir(hx, hy, tx, ty, -89.0f);
            sx = hx;
            sy = hy;
            ex = tx;
            ey = ty;

            map.MoveHexByDir(sx, sy, rightDir, 1);
            map.MoveHexByDir(ex, ey, rightDir, 1);

            array<Critter@> lineRight;
            map.GetCrittersPath(sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, FIND_LIFE_AND_KO, lineRight);
            int             rightStart = 0;
            int             rightLen = lineRight.length();
            while((rightStart < rightLen) && (GetDistantion(hx, hy, lineRight[rightStart].HexX, lineRight[rightStart].HexY)) < 3)
                rightStart++;
            for(int i = rightStart, j = rightLen; i < j; i++)
            {
                // Adjust tohit
                dist = GetDistantion(hx, hy, lineRight[i].HexX, lineRight[i].HexY);
                bl = map.GetCrittersPath(hx, hy, lineRight[i].HexX, lineRight[i].HexY, 0.0f, dist, FIND_LIFE, null) - 1;
                toHit = baseToHit - 10 * bl;
                acc = dist;
                if(dist < distmod2)
                    acc += distmod2;
                else
                    acc -= accloss;
                if(-2 * perception > acc)
                    acc = -2 * perception;
                acc -= sharpshooter;
                if(acc > 0 && eyeDamage)
                    acc *= 3 + cr.Param[PE_SOLDIER];
                acc *= -4 + cr.Param[PE_SOLDIER];
                toHit += acc;
                acmod = lineRight[i].GetAC(false);
				acmod -= attack.Attacker.Param[ST_PERCEPTION]*5;
                if(valid(ammo))
                    acmod += ammo.Ammo_AcMod;
                if(acmod > 0)
                    toHit -= acmod;
                if(lineRight[i].IsKnockout())
                    toHit += 40 + cr.Param[PE_SOLDIER];
                if(lineRight[i].GetMultihex() > 0)
                    toHit += 15 + cr.Param[PE_SOLDIER];
        if(target.Param[PE_IN_YOUR_FACE] > 0 && checkface  && dist == 1 && target.IsPlayer())
        IYF = 50;
                toHit = CLAMP(toHit, 5 + cr.Param[PE_SOLDIER], 95 + cr.Param[PE_SOLDIER] + normaldmg  - noHex - IYF);
                if(Random(1, 100) <= toHit)
                {
                    int crIndex = FindCritterInArray(critsHit, lineRight[i]);
                    if(crIndex == -1)
                    {
                        critsHit.resize(len_ + 1);
                        @critsHit[len_] = lineRight[i];
                        critsHitBullets.resize(len_ + 1);
                        crIndex = len_;
                        len_++;
                    }
                    critsHitBullets[crIndex] += 1;
                }
            }     // Right line end
        }         // Three lines end

        for(int i = 0, j = len_; i < j; i++)
        {
            ApplyDamage(attack, critsHit[i], 1, (realTarget.Id == critsHit[i].Id) && criticalHit, (!_IsTrueNpc(cr) && !changedTarget) || (_IsTrueNpc(cr) && critsHit[i].Id == target.Id), results, CriticalChance);
        }

        if(!changedTarget && !attack.TargetHit)
            NotifyMiss(cr, results);
    }
    else if(((weaponSubtype == WS_GUN) && isBurst) || (isFlamethrower && isBurst))       // BURST FIRE
    {
        // Adjust toHit if random hit
        if(changedTarget)
        {
            dist = GetDistantion(hx, hy, tx, ty);
            acc = dist;
            toHit = baseToHit;
            if(dist < distmod2)
                acc += distmod2;
            else
                acc -= accloss;
            if(-2 * perception > acc)
                acc = -2 * perception + cr.Param[PE_SOLDIER];
            acc -= sharpshooter;
            if(acc > 0 && eyeDamage)
                acc *= 3 + cr.Param[PE_SOLDIER];
            acc *= -4 + cr.Param[PE_SOLDIER];
            toHit += acc;
            acmod = realTarget.GetAC(false);
			acmod -= attack.Attacker.Param[ST_PERCEPTION]*5;
            if(valid(ammo))
                acmod += ammo.Ammo_AcMod;
            if(acmod > 0)
                toHit -= acmod;
            if(realTarget.IsKnockout())
                toHit += 40 + cr.Param[PE_SOLDIER];
            if(realTarget.GetMultihex() > 0)
                toHit += 15 + cr.Param[PE_SOLDIER];
            int blockers = map.GetCrittersPath(hx, hy, tx, ty, 0.0f, dist, FIND_LIFE, null);
            if(!realTarget.IsKnockout())
                blockers--;
            toHit -= 10 * blockers + cr.Param[PE_SOLDIER];
        if(target.Param[PE_IN_YOUR_FACE] > 0 && checkface  && dist == 1)
        IYF = 50;
            toHit = CLAMP(toHit, 5 + cr.Param[PE_SOLDIER], 95 + cr.Param[PE_SOLDIER] + normaldmg  - noHex - IYF);
        }

        // Critical hit bonus, toHit can be increased over 95
        if(criticalHit)
            toHit += 20;

        // Proceed with the burst attack
        uint rounds = ammoRound;
        if(valid(realWeapon) && realWeapon.AmmoCount < rounds)
            rounds = realWeapon.AmmoCount;
		if(valid(realWeapon) && isFlamethrower && realWeapon.AmmoCount >= rounds)
			rounds = 1;
		if(valid(realWeapon) && isFlamethrower && realWeapon.AmmoCount < rounds)	
			{
			cr.Say(SAY_NETMSG, "not enough ammo.");
			return;
			}
        array<Critter@> critsHit(0);
        array<uint>     critsHitBullets(0);

        int len_ = 0;
        int volleyRounds = MAX((rounds / 6), 1);

        int curRounds = 0;
        for(int i = 0; i < volleyRounds; i++)
        {
            if(Random(1, 100) <= toHit)
                curRounds++;
        }

        if(curRounds != 0)
        {
            critsHit.resize(1);
            critsHitBullets.resize(1);
            @critsHit[0] = realTarget;
            critsHitBullets[0] = curRounds;
            len_++;
        }
        volleyRounds -= curRounds;

        array<Critter@> lineCentral;
        map.GetCrittersPath(hx, hy, tx, ty, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, lineCentral);

        // This never happens
        if(lineCentral.length() == 0)
        {
          //  Log("ERR: lineCentral.length()==0");
          //  Log("  " + hx + "," + hy + "," + tx + "," + ty + "," + wpnMaxDist + (changedTarget ? "changed" : "original"));
          //  Log("  attacker " + cr.HexX + "," + cr.HexY);
          //  Log("  target: " + target.HexX + "," + target.HexY + "," + GetDistantion(cr.HexX, cr.HexY, target.HexX, target.HexY) + "," + target.Cond);
         //   Log("  realTarget: " + realTarget.HexX + "," + realTarget.HexY + "," + GetDistantion(cr.HexX, cr.HexY, realTarget.HexX, realTarget.HexY) + "," + realTarget.Cond);
        }

        int bl = 0;
        curRounds = 0;
        for(int i = 0, j = lineCentral.length(); (i < j) && (volleyRounds > 0); i++)
        {
            if(lineCentral[i].Id == realTarget.Id)
            {
                bl++;
                continue;
            }                                                                      // skip the primary target, but add blocker
            // Adjust tohit
            toHit = baseToHit - 10 * bl;
            dist = GetDistantion(hx, hy, lineCentral[i].HexX, lineCentral[i].HexY);
            acc = dist;
            if(dist < distmod2)
                acc += distmod2 + cr.Param[PE_SOLDIER];
            else
                acc -= accloss;
            if(-2 * perception > acc)
                acc = -2 * perception + cr.Param[PE_SOLDIER];
            acc -= sharpshooter;
            if(acc > 0 && eyeDamage)
                acc *= 3 + cr.Param[PE_SOLDIER];
            acc *= -4 + cr.Param[PE_SOLDIER];
            toHit += acc;
            acmod = lineCentral[i].GetAC(false);
			acmod -= attack.Attacker.Param[ST_PERCEPTION]*5;
            if(valid(ammo))
                acmod += ammo.Ammo_AcMod;
            if(acmod > 0)
                toHit -= acmod;
            toHit = CLAMP(toHit, 5 + cr.Param[PE_SOLDIER], 95  + normaldmg + cr.Param[PE_SOLDIER]);
            if(lineCentral[i].IsKnockout())
                toHit += 40 + cr.Param[PE_SOLDIER];
            else
                bl++;
            if(lineCentral[i].GetMultihex() > 0)
                toHit += 15 + cr.Param[PE_SOLDIER];

            curRounds = 0;
            for(int k = 0; k < volleyRounds; ++k)
            {
                if(Random(1, 100) <= toHit)
                    curRounds++;
            }
            volleyRounds -= curRounds;

            if(curRounds > 0)
            {
                int crIndex = FindCritterInArray(critsHit, lineCentral[i]);
                if(crIndex == -1)
                {
                    critsHit.resize(len_ + 1);
                    @critsHit[len_] = lineCentral[i];
                    critsHitBullets.resize(len_ + 1);
                    critsHitBullets[len_] = 0;
                    crIndex = len_;
                    len_++;
                }
                critsHitBullets[crIndex] += curRounds;
            }
        }

        // Now we are shooting the rest of the bullets (=rounds-MAX(1,rounds/6))
        bool threeLines = (GetDistantion(hx, hy, lineCentral[0].HexX, lineCentral[0].HexY) > 1) && (!isShotgun) && (!isBozar) && (!isLSW);   // target not adjacent and weapon not shotgun-like

        // Already shot: MAX(rounds/6,1);
        for(int lineCount = 0, lineMax = (threeLines ? 1 : 3); lineCount < lineMax; lineCount++)
        {
            // Rounds for central stack
            if(lineCount == 0)
            {
                volleyRounds = rounds - (((rounds + 1) / 3) + (rounds / 3));         // Second voller along the central line, always
                volleyRounds -= MAX(rounds / 6, 1);
            }
            else
            {
                if(lineCount == 1)
                    volleyRounds = (rounds + 1) / 3;           // Left line
                else
                    volleyRounds = rounds / 3;                 // Right line
            }

            if(volleyRounds == 0)
                continue;     // No rounds left

            // Central line
            bl = 0;           // No blockers
            for(int i = 0, j = lineCentral.length(); (i < j) && (volleyRounds > 0); i++)
            {
                // Adjust tohit
                toHit = baseToHit - 10 * bl;
                dist = GetDistantion(hx, hy, lineCentral[i].HexX, lineCentral[i].HexY);
                acc = dist;
                if(dist < distmod2)
                    acc += distmod2;
                else
                    acc -= accloss;
                if(-2 * perception > acc)
                    acc = -2 * perception;
                acc -= sharpshooter;
                if(acc > 0 && eyeDamage)
                    acc *= 3;
                acc *= -4;
                toHit += acc;
                acmod = lineCentral[i].GetAC(false);
				acmod -= attack.Attacker.Param[ST_PERCEPTION]*5;
                if(valid(ammo))
                    acmod += ammo.Ammo_AcMod;
                if(acmod > 0)
                    toHit -= acmod;
                if(lineCentral[i].IsKnockout())
                    toHit += 40;
                if(lineCentral[i].GetMultihex() > 0)
                    toHit += 15;
        if(target.Param[PE_IN_YOUR_FACE] > 0 && checkface  && dist == 1  && target.IsPlayer())
        IYF = 50;
                toHit = CLAMP(toHit, 5 + cr.Param[PE_SOLDIER], 95  + normaldmg + cr.Param[PE_SOLDIER] - noHex - IYF);
                bl++;

                curRounds = 0;
                for(int k = 0; k < volleyRounds; ++k)
                {
                    if(Random(1, 100) <= toHit)
                        curRounds++;
                }
                volleyRounds -= curRounds;

                if(curRounds > 0)
                {
                    int crIndex = FindCritterInArray(critsHit, lineCentral[i]);
                    if(crIndex == -1)
                    {
                        critsHit.resize(len_ + 1);
                        @critsHit[len_] = lineCentral[i];
                        critsHitBullets.resize(len_ + 1);
                        critsHitBullets[len_] = 0;
                        crIndex = len_;
                        len_++;
                    }
                    critsHitBullets[crIndex] += curRounds;
                }
            }
            // Central line end
        }
        int shotline = 1;
        if(threeLines)
        {
            // Rounds for the left stack
            volleyRounds = (rounds + 1) / 3;
            if(volleyRounds > 0)             // Real left
            {


                uint8  leftDir = GetOffsetDir(hx, hy, tx, ty, 89.0f);
                uint16 sx = hx;
                uint16 sy = hy;
                uint16 ex = tx;
                uint16 ey = ty;

                map.MoveHexByDir(sx, sy, leftDir, shotline);
                map.MoveHexByDir(ex, ey, leftDir, shotline);

                array<Critter@> lineLeft;
                map.GetCrittersPath(sx, sy, ex, ey, 0.0f, wpnMaxDist - shotline, FIND_LIFE_AND_KO, lineLeft);
                int             leftStart = 0;
                int             leftLen = lineLeft.length();
                while((leftStart < leftLen) && (GetDistantion(hx, hy, lineLeft[leftStart].HexX, lineLeft[leftStart].HexY)) < 3)
                    leftStart++;

                for(int i = leftStart, j = leftLen; (i < j) && (volleyRounds > 0); i++)
                {
                    // Adjust tohit
                    dist = GetDistantion(hx, hy, lineLeft[i].HexX, lineLeft[i].HexY);
                    bl = map.GetCrittersPath(hx, hy, lineLeft[i].HexX, lineLeft[i].HexY, 0.0f, dist, FIND_LIFE, null) - 1;
                    toHit = baseToHit - 10 * bl;
                    acc = dist;
                    if(dist < distmod2)
                        acc += distmod2;
                    else
                        acc -= accloss;
                    if(-2 * perception > acc)
                        acc = -2 * perception + cr.Param[PE_SOLDIER];
                    acc -= sharpshooter + cr.Param[PE_SOLDIER];
                    if(acc > 0 && eyeDamage)
                        acc *= 3 + cr.Param[PE_SOLDIER];
                    acc *= -4 + cr.Param[PE_SOLDIER];
                    toHit += acc + cr.Param[PE_SOLDIER];
                    acmod = lineLeft[i].GetAC(false);
					acmod -= attack.Attacker.Param[ST_PERCEPTION]*5;
                    if(valid(ammo))
                        acmod += ammo.Ammo_AcMod;
                    if(acmod > 0)
                        toHit -= acmod + cr.Param[PE_SOLDIER];
                    if(lineLeft[i].IsKnockout())
                        toHit += 40 + cr.Param[PE_SOLDIER];
                    if(lineLeft[i].GetMultihex() > 0)
                        toHit += 15 + cr.Param[PE_SOLDIER];
        if(target.Param[PE_IN_YOUR_FACE] > 0 && checkface  && dist == 1  && target.IsPlayer())
        IYF = 50;
                    toHit = CLAMP(toHit, 5 + cr.Param[PE_SOLDIER], 95  + normaldmg + cr.Param[PE_SOLDIER] - noHex - IYF);

                    curRounds = 0;
                    for(int k = 0; k < volleyRounds; ++k)
                    {
                        if(Random(1, 100) <= toHit)
                            curRounds++;
                    }
                    volleyRounds -= curRounds;

                    if(curRounds > 0)
                    {
                        int crIndex = FindCritterInArray(critsHit, lineLeft[i]);
                        if(crIndex == -1)
                        {
                            critsHit.resize(len_ + shotline);
                            @critsHit[len_] = lineLeft[i];
                            critsHitBullets.resize(len_ + shotline);
                            critsHitBullets[len_] = 0;
                            crIndex = len_;
                            len_++;
                        }
                        critsHitBullets[crIndex] += curRounds;
                    }
                }
            }             // Left line end


            // Rounds for the right stack
            volleyRounds = (rounds) / 3;

            if(volleyRounds > 0)
            {
                uint8  rightDir = GetOffsetDir(hx, hy, tx, ty, -89.0f);

                uint16 sx = hx;
                uint16 sy = hy;
                uint16 ex = tx;
                uint16 ey = ty;

                map.MoveHexByDir(sx, sy, rightDir, shotline);
                map.MoveHexByDir(ex, ey, rightDir, shotline);

                array<Critter@> lineRight;
                map.GetCrittersPath(sx, sy, ex, ey, 0.0f, wpnMaxDist - shotline, FIND_LIFE_AND_KO, lineRight);
                int             rightStart = 0;
                int             rightLen = lineRight.length();
                while((rightStart < rightLen) && (GetDistantion(hx, hy, lineRight[rightStart].HexX, lineRight[rightStart].HexY)) < 3)
                    rightStart++;
                for(int i = rightStart, j = rightLen; (i < j) && (volleyRounds > 0); i++)
                {
                    // Adjust tohit
                    dist = GetDistantion(hx, hy, lineRight[i].HexX, lineRight[i].HexY);
                    bl = map.GetCrittersPath(hx, hy, lineRight[i].HexX, lineRight[i].HexY, 0.0f, dist, FIND_LIFE, null) - 1;
                    toHit = baseToHit - 10 * bl;
                    acc = dist;
                    if(dist < distmod2)
                        acc += distmod2 + cr.Param[PE_SOLDIER];
                    else
                        acc -= accloss;
                    if(-2 * perception > acc)
                        acc = -2 * perception + cr.Param[PE_SOLDIER];
                    acc -= sharpshooter;
                    if(acc > 0 && eyeDamage)
                        acc *= 3 + cr.Param[PE_SOLDIER];
                    acc *= -4 + cr.Param[PE_SOLDIER];
                    toHit += acc + cr.Param[PE_SOLDIER];
                    acmod = lineRight[i].GetAC(false);
					acmod -= attack.Attacker.Param[ST_PERCEPTION]*5;
                    if(valid(ammo))
                        acmod += ammo.Ammo_AcMod;
                    if(acmod > 0)
                        toHit -= acmod;
                    if(lineRight[i].IsKnockout())
                        toHit += 40+ cr.Param[PE_SOLDIER];
                    if(lineRight[i].GetMultihex() > 0)
                        toHit += 15+ cr.Param[PE_SOLDIER];
        if(target.Param[PE_IN_YOUR_FACE] > 0 && checkface  && dist == 1  && target.IsPlayer())
        IYF = 50;
                    toHit = CLAMP(toHit, 5 + cr.Param[PE_SOLDIER], 95 + cr.Param[PE_SOLDIER]  + normaldmg - noHex - IYF);

                    curRounds = 0;
                    for(int k = 0; k < volleyRounds; ++k)
                    {
                        if(Random(1, 100) <= toHit)
                            curRounds++;
                    }
                    volleyRounds -= curRounds;

                    if(curRounds > 0)
                    {
                        int crIndex = FindCritterInArray(critsHit, lineRight[i]);
                        if(crIndex == -1)
                        {
                            critsHit.resize(len_ + shotline);
                            @critsHit[len_] = lineRight[i];
                            critsHitBullets.resize(len_ + shotline);
                            critsHitBullets[len_] = 0;
                            crIndex = len_;
                            len_++;
                        }
                        critsHitBullets[crIndex] += curRounds;
                    }
                }
            }             // Right line end
        }

        for(int i = 0, j = len_; i < j; i++)
        {
            ApplyDamage(attack, critsHit[i], critsHitBullets[i], (realTarget.Id == critsHit[i].Id) && criticalHit, (!_IsTrueNpc(cr) && !changedTarget) || (_IsTrueNpc(cr) && critsHit[i].Id == target.Id), results, CriticalChance);
        }

        if(!changedTarget && !attack.TargetHit)
            NotifyMiss(cr, results);
    }
    // Burst attack end

    else if(isRocket || (weaponSubtype == WS_THROWING))   // ROCKETS, THROWING
    {
        bool exploding = isRocket || isGrenade;

        if(isHit || changedTarget)
        {
            if(exploding)
                CommenceExplosion(attack, map, tx, ty, realTarget, weapPid, criticalHit, realTarget.Id, isRocket, results, isExplodeRocket);
            else
                ApplyDamage(attack, realTarget, 1, criticalHit, !changedTarget, results, 0);
        }
        else
        {
            // Miss with missiles
            attack.set_Aim(HIT_LOCATION_UNCALLED);

            if(weaponSubtype == WS_THROWING)
                sharpshooter = 0;
            uint16          bx = 0;
            uint16          by = 0;
            uint16          pbx = 0;
            uint16          pby = 0;
            array<Critter@> critsLine;
            map.GetCrittersPath(hx, hy, tx, ty, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, critsLine, pbx, pby, bx, by);

            int  bl = 0;
            bool anyHit = false;
            for(int i = 0, j = critsLine.length(); (i < j) && !anyHit; i++)
            {
                if(critsLine[i].Id == realTarget.Id)
                {
                    bl++;
                    continue;
                }                                                                      // skip the primary target

                // Adjust tohit
                dist = GetDistantion(hx, hy, critsLine[i].HexX, critsLine[i].HexY);
                acc = dist;
                toHit = baseToHit;
                if(dist < distmod2)
                    acc += distmod2;
                else
                    acc -= accloss;
                if(-2 * perception > acc)
                    acc = -2 * perception+ cr.Param[PE_SOLDIER];
                acc -= sharpshooter;
                if(acc > 0 && eyeDamage)
                    acc *= 3+ cr.Param[PE_SOLDIER];
                acc *= -4+ cr.Param[PE_SOLDIER];
                toHit += acc;
                acmod = critsLine[i].GetAC(false);
				acmod -= attack.Attacker.Param[ST_PERCEPTION]*5;
                if(valid(ammo))
                    acmod += ammo.Ammo_AcMod;
                if(acmod > 0)
                    toHit -= acmod;
                toHit -= 10 * bl;
                if(critsLine[i].IsKnockout())
                    toHit += 40+ cr.Param[PE_SOLDIER];
                else
                    bl++;
                if(critsLine[i].GetMultihex() > 0)
                    toHit += 15+ cr.Param[PE_SOLDIER];
                toHit = CLAMP(toHit, 5+ cr.Param[PE_SOLDIER], 95+ cr.Param[PE_SOLDIER]  + normaldmg - noHex);
                toHit /= 3;               // After clamp
                if(Random(1, 100) <= toHit)
                {
                    tx = critsLine[i].HexX;
                    ty = critsLine[i].HexY;
                    @normalTarget = critsLine[i];
                    anyHit = true;
                }
            }

            if(anyHit)
            {
                NotifyOops(cr, target, normalTarget, results);
                useNormal = true;

                if(exploding)
                    CommenceExplosion(attack, map, tx, ty, normalTarget, weapPid, false, realTarget.Id, isRocket, results, isExplodeRocket);
                else
                    ApplyDamage(attack, normalTarget, 1, false, false, results, 0);
            }
            else
            {
                useHex = true;
                NotifyMiss(cr, results);
                if(isGrenade)
                {
                    tx = realTarget.HexX;
                    ty = realTarget.HexY;
                    int newdist = GetDistantion(hx, hy, tx, ty) + 1;
                    map.MoveHexByDir(tx, ty, Random(0, 5), Random(1, newdist / 2));
                    newdist = GetDistantion(hx, hy, tx, ty);
                    map.GetCrittersPath(hx, hy, tx, ty, 0.0f, newdist, FIND_LIFE, null, tx, ty, bx, by);
                }
                else
                {
                    if(isRocket)
                    {
                        tx = bx;
                        ty = by;
                        int newdist = GetDistantion(hx, hy, tx, ty) + 1;
                        map.MoveHexByDir(tx, ty, Random(0, 5), Random(1, newdist / 2));
                        newdist = GetDistantion(hx, hy, tx, ty);
                        map.GetCrittersPath(hx, hy, tx, ty, 0.0f, newdist, FIND_LIFE, null, tx, ty, bx, by);
                    }
                    else
                    {
                        tx = pbx;
                        ty = pby;
                    }
                }

                if(exploding)
                    CommenceExplosion(attack, map, tx, ty, null, weapPid, false, realTarget.Id, isRocket, results, isExplodeRocket);
            }
        }         // Miss
    }


    // Send combat messages
    FlushResults(results);

    // Stuff like animations and effects

    // Shoot
    if(_WeaponEffect(weapon, use) != 0)
    {
        if(useHex)
            map.RunFlyEffect(_WeaponEffect(weapon, use), cr, null, hx, hy, tx, ty);      // yeah, the target can be null (see: grenades, rocket launcher)
        else
            map.RunFlyEffect(_WeaponEffect(weapon, use), cr, (useNormal ? normalTarget : realTarget), hx, hy, tx, ty);
    }

    if(ammoRound > 0 && valid(realWeapon) && cr.Param[MODE_UNLIMITED_AMMO] == 0 && dmgType != DAMAGE_FIRE && cr.Param[PE_WRECKER]==0)
    {
        if(realWeapon.AmmoCount <= ammoRound)
            realWeapon.AmmoCount = 0;
        else
            realWeapon.AmmoCount -= ammoRound;
        realWeapon.Update();
    }
	
	if(ammoRound > 0 && valid(realWeapon) && cr.Param[MODE_UNLIMITED_AMMO] == 0 && dmgType == DAMAGE_FIRE && cr.Param[PE_WRECKER]==0)
    {
        if(!isBurst)
		{
		if(realWeapon.AmmoCount <= ammoRound)
            realWeapon.AmmoCount = 0;
        else
            realWeapon.AmmoCount -= ammoRound;
        realWeapon.Update();
		}
		else
		{
		int ammo_charge = 0;
		switch(weapPid)
		{
		case PID_FIRE_SMG: ammo_charge = 15; break;
		case PID_PLASMA_SMG: ammo_charge = 15; break;
		case PID_PLASMA_GATLING: ammo_charge = 10; break;
		}
		if(realWeapon.AmmoCount <= ammo_charge)
            realWeapon.AmmoCount = 0;
        else
            realWeapon.AmmoCount -= ammo_charge;
		}
    }

    if(valid(realWeapon))//cebula
    {
        if(realWeapon.IsDeteriorable() && !_CritHasExtMode(cr, MODE_EXT_NO_DETERIORATION))
            WearItem(cr, realWeapon, CLAMP((cr.Param[realWeapon.Proto.Weapon_Skill_0] - cr.Param[ST_PERCEPTION]*10)/10,1,100000));

        // One time weapon, erase current and push next (if exist)
        if(wpnIsRemoved && cr.Param[MODE_UNLIMITED_AMMO] == 0)
        {
            bool placeOnHex = (skillNum == SK_THROWING && !isGrenade);
            if(realWeapon.IsStackable())
            {
                // Place on hex
                if(placeOnHex)
                    map.AddItem(tx, ty, weapPid, 1);

                // Remove one item
                if(realWeapon.GetCount() > 1)
                    realWeapon.SetCount(realWeapon.GetCount() - 1);
                else
                    DeleteItem(realWeapon);
            }
            else
            {
                MoveItem(realWeapon, 0, map, tx, ty);
            }
        }
    }

    // Npc miss text
    if(!attack.TargetHit)
    {
        if(!target.IsPlayer())
            AI_TrySayCombatText(target, COMBAT_TEXT_MISS);
        target.Action(ACTION_DODGE, 0, null);       // Todo: type front/back
    }
}





void ApplyDamage(AttackStruct& attack, Critter& target, int rounds, bool isCritical, bool intentionally, array<CombatRes>& results, int CriticalChance)
{
    Item@ usedArmor = _GetCritterArmor(target, attack.AimHead);

    int      dmgMul = attack.DmgMul;
    int      bt = target.Param[ST_BODY_TYPE];
    int      IsTownRole = target.Param[ST_NPC_ROLE];    // W warunku IsTown Powinno dodawaÄ‡ EXP do mobÃ³w, jeÅ›li ich ST_NPC_ROLE = 200..202 worldremaker
    int     eff = 0;
    int     msgEff = 0;
	int dmgmulti = 100;
    int      weaponPerk = attack.WeaponPerk;
    Critter@ attacker = attack.Attacker;
    bool     validAttacker = valid(attacker);
    Map@     map = target.GetMap();
    bool     isBloodyMess = attack.BloodyMess;
    bool     isCombatText = attack.CombatMessage;
    Item@    realWeapon = attack.RealWeapon;
	int     aim = attack.Aim;
    int     extraMessage = 0;
    int     extraMessageSelf = 0;
    bool     isShotgun = (valid(attack.Ammo) && (attack.Ammo.Ammo_Caliber == 11));
    //bool     isFireGeckoShell = (valid(attack.Ammo) && (attack.Ammo.ProtoId == PID_SHOTGUN_DRAGON_BREATH_SHELLS));
    uint16   ammoPid = attack.ammoPid;
    if(valid(attack.Ammo)) ammoPid = attack.Ammo.ProtoId;

    bool     isBanhammer = (valid(realWeapon) ? realWeapon.Proto.ProtoId==PID_BAN_HAMMER : false);
    bool     isHolySpear = (valid(realWeapon) ? realWeapon.Proto.ProtoId==PID_HOLY_SPEAR : false);
    //bool     isWeaponBetterCriticals = (valid(realWeapon) ? realWeapon.Proto.ProtoId==PID_TURBO_PLASMA_RIFLE : false);

    bool     targetIsPlayer = target.IsPlayer();
    bool     attackerIsPlayer = (valid(attacker) ? attacker.IsPlayer() : false);
    bool     attackerIsPaszczur = (valid(attacker) ? attacker.GetProtoId()==NPC_PID_PASHTSHUUR : false);
    uint16   weapPid = attack.weaponPid;

    bool     isSwingThrustWeapon = (valid(realWeapon) ? (weapPid == 517 || weapPid == 160 || weapPid == 236 || weapPid == 530 || weapPid == 9676 || weapPid == 4 || weapPid == 116 || weapPid == 383 || weapPid == 6 || weapPid == 399 || weapPid == 115 || weapPid == 319 || weapPid == 622 || weapPid == 522 || weapPid == 600 || weapPid == 610 || weapPid == 289 || weapPid == 25599  ) : false);
    bool     isThrustThrowWeapon = (valid(realWeapon) ? (weapPid == 9916 || weapPid == 618 || weapPid == 320 || weapPid == 280 || weapPid == 7 || weapPid == 25583 ) : false);
			bool slow = false;
			bool knockdowneff = false;
			bool APdrain = false;
			bool weapondropeff = false;
			bool deatheff = false;
			bool bypasseff = false;
			bool koeff = false;
			bool weapondestroyeff = false;
			uint criple = 0;
			string criteff = "";
    //bool     isPrimitiveWeapon = (valid(realWeapon) ? (weapPid == PID_SPIKED_KNUCKLES || weapPid == PID_BRASS_KNUCKLES || weapPid == PID_LOUISVILLE_SLUGGER || weapPid == PID_SLEDGEHAMMER || weapPid == PID_WRENCH || weapPid == PID_WAKIZASHI_BLADE || weapPid == PID_SWITCHBLADE || weapPid == PID_SHIV || weapPid == PID_LIL_JESUS_WEAPON || weapPid == PID_COMBAT_KNIFE || weapPid == PID_ROCK || weapPid == PID_SPEAR || weapPid == PID_CLUB || weapPid == PID_KNIFE || weapPid == PID_CROWBAR) : false);


    array<int>  _dmgMul;
    _dmgMul.resize(rounds);
    for(int i = 0; i < rounds; i++)
    {
        _dmgMul[i] = dmgMul;
    }



    //#################################################
    //### IMPLEMENTACJA melee attack swing i thrust ###
    //#################################################
    uint8 use=_WeaponModeUse(attack.weaponMode);
    bool isSwing=false;
    bool isThrust=false;
    //if(attackerIsPlayer)
    //{
        //Log(" Use mode = " + use);
        //Log(" attack.WeaponSubtype [WS_UNARMED==1] = " + attack.WeaponSubtype);
    //}


    if (isThrustThrowWeapon)  // bronie, ktore maja zamienione primary_attack mode swing na thrust
    {
        if (use == MODE_PRIMARY_ATTACK)
        {
            isSwing=false;
            isThrust=true;
        }
    }

    if (isSwingThrustWeapon) // BRONIE MELEE posiadajace swing/thrust
    {
        if (use == MODE_PRIMARY_ATTACK)
        {
            isSwing=true;
            isThrust=false;
        }

        if (use == MODE_SECONDARY_ATTACK)
        {
            isSwing=false;
            isThrust=true;
        }
    }

    if(target.IsDead() || !valid(map))
        return;

    if(validAttacker && intentionally && target.Id != attack.TargetId)
        target.EventAttacked(attacker);

    // check if hit
    if(target.Id == attack.TargetId)
        attack.TargetHit = true;

    // Check no PvP
    if(targetIsPlayer && (attackerIsPlayer || (valid(attacker) && _IsFollower(attacker))) && validAttacker && attacker.GetAccess() == ACCESS_CLIENT &&
       (_MapHasMode(map, MAP_MODE_NO_PVP) || attacker.Param[MODE_NO_PVP] != 0 || target.Param[MODE_NO_PVP] != 0) && attack.Ammo.ProtoId != PID_HN_HEAL_NEEDLER_CARTRIDGE)
    {
        if(validAttacker)
            attacker.Say(SAY_NETMSG, "No PvP.");
        target.Say(SAY_NETMSG, "No PvP.");
        return;
    }

    if(target.Param[MODE_HIDE] != 0 && target.IsPlayer() && (target.GetAccess() == ACCESS_CLIENT))
        target.ParamBase[MODE_HIDE] = 0;

    if(target.Param[TO_BATTLE] < int(__TimeoutBattle))
        _SetTimeout(target, TO_BATTLE, __TimeoutBattle);
	int extraroll = 0;
	if(ammoPid == PID_40MM_GRENADE_ICE)  {target.ParamBase[ST_SLOW] += Random(10,50 - target.Param[ST_INTELLECT]); VerboseActionCombat(target, "Slowed");}
    if(target.Param[MODE_INVULNERABLE] != 0)
        isCritical = false;
    else
    if(isCritical || rounds>1)  // CRITICAL EFFECT
    {
        int aim_ = aim;
        if(aim_ == HIT_LOCATION_NONE)
            aim_ = HIT_LOCATION_UNCALLED;
        aim_--;


        float roll = Random(0, 50);

        //if(isWeaponBetterCriticals)
            //roll += 10;  // +30 dla testÃ³w
		if(attack.DmgType == DAMAGE_PLASMA)
			roll += 5; //05-03-2014 Cubil: bonus bazowy do broni do crit rolla

       // if(target.Param[PE_MAN_OF_STEEL] > 0)
           // roll -= 15;
        roll += attacker.Param[ST_LUCK];
        if(valid(usedArmor))
        {
            uint spray = 0;
			Item@ armorek = target.GetItem(0, SLOT_ARMOR);
			if(valid(armorek))
                spray = armorek.Proto.Armor_CMCritPower;
				
			if(attacker.Param[PE_SPRAY_AND_PRAY] > 0)
				spray = spray * 0.2;
				
			roll += spray;
			if(valid(armorek) && armorek.Val3 == AP_HEAVY && attacker.Param[PE_HUNTER] == 0) roll -= 20;
            if(valid(armorek) && armorek.Val4 == AP_HEAVY && attacker.Param[PE_HUNTER] == 0) roll -= 20;
            if(valid(armorek) && armorek.Val5 == AP_HEAVY && attacker.Param[PE_HUNTER] == 0) roll -= 20;
            if(valid(armorek) && armorek.Val6 == AP_HEAVY && attacker.Param[PE_HUNTER] == 0) roll -= 20;
            if(valid(armorek) && armorek.Val7 == AP_HEAVY && attacker.Param[PE_HUNTER] == 0) roll -= 20;
            if(valid(armorek) && armorek.Val8 == AP_HEAVY && attacker.Param[PE_HUNTER] == 0) roll -= 20;
			
			if(valid(armorek) && armorek.Val3 == AP_LEG_ANTY_CRIT && attacker.Param[PE_HUNTER] == 0) roll -= 60;
            if(valid(armorek) && armorek.Val4 == AP_LEG_ANTY_CRIT && attacker.Param[PE_HUNTER] == 0) roll -= 60;
            if(valid(armorek) && armorek.Val5 == AP_LEG_ANTY_CRIT && attacker.Param[PE_HUNTER] == 0) roll -= 60;
            if(valid(armorek) && armorek.Val6 == AP_LEG_ANTY_CRIT && attacker.Param[PE_HUNTER] == 0) roll -= 60;
            if(valid(armorek) && armorek.Val7 == AP_LEG_ANTY_CRIT && attacker.Param[PE_HUNTER] == 0) roll -= 60;
            if(valid(armorek) && armorek.Val8 == AP_LEG_ANTY_CRIT && attacker.Param[PE_HUNTER] == 0) roll -= 60;
			if(valid(armorek) && armorek.Val2 == AP_LEG_ANTY_CRIT && attacker.Param[PE_HUNTER] == 0) roll -= 60;

        }

        if(validAttacker)
        {
		
            if(attacker.Param[PE_BETTER_CRITICALS] > 0)        // +20 with ranged
                if(attack.WeaponSubtype == WS_GUN || attack.WeaponSubtype == WS_THROWING)
					extraroll += 25;
			extraroll += 10*attacker.Param[WE_CE];	
			roll += 10*attacker.Param[WE_CP];			
			for(int i = 0; i < 9; i++)
			{
			if(attacker.Param[PE_RANDOM]>0 && attacker.Param[PARAM_CLASS_1 + i]==27) extraroll += 20;
			if(attacker.Param[PE_RANDOM]>0 && attacker.Param[PARAM_CLASS_1 + i]==28) extraroll -= 20;
			}
			for(int i = 0; i < 9; i++)
			{
			if(attacker.Param[PE_RANDOM]>0 && attacker.Param[PARAM_CLASS_1 + i]==29) roll += 10;
			if(attacker.Param[PE_RANDOM]>0 && attacker.Param[PARAM_CLASS_1 + i]==30) roll -= 10;
			}
			if(target.Param[ST_STRENGTH]>19)
				extraroll -= 25;
			if(target.Param[ST_PERCEPTION]>19)
				extraroll += 25;
            if(attacker.Param[TRAIT_HEAVY_HANDED] > 0)        // -20 with hth
                    extraroll -= 20;
			if(attacker.Param[PE_MASTER] > 0)        // -20 with hth
                if( attack.WeaponSubtype==WS_MELEE ||  attack.WeaponSubtype == WS_UNARMED)
                    extraroll += attacker.Param[ST_STRENGTH];
            if(attacker.Param[PE_HTH_CRITICALS] > 0)           // +25 with hth/melee
                if(attack.WeaponSubtype == WS_MELEE || attack.WeaponSubtype == WS_UNARMED)
                    extraroll += 33;
            if(attack.SilentDeathEffect)
                extraroll += 10;
			if(attacker.Param[PE_CYBORG] > 0) roll += attacker.Param[ST_LUCK];
            if(attacker.Param[PE_HUNTER] > 0)
                roll += attacker.Param[ST_CRITICAL_CHANCE] + target.Param[ST_CRITICAL_CHANCE];
			uint16 rangefov = 20 + 3 * attacker.Param[ST_PERCEPTION] + 6 * attacker.Param[PE_SHARPSHOOTER] + 11 * attacker.Param[PE_TACTICAL] + 11 * attacker.Param[PE_TACTICAL2];
			if(attacker.Param[PE_HUNTER]>0)
				rangefov += attacker.Param[ST_CRITICAL_CHANCE];
			rangefov /= 10;
			if(attacker.Param[PE_HUNTER]>0)
				roll += rangefov;
			if(attacker.Param[PE_MORE_CRITICALS]>0 && attacker.Param[PE_EVEN_MORE_CRITICALS]>0 && attacker.Param[PE_GAIN_LUCK]>0)
				roll += 10;
			if(attacker.Param[PE_AGRO2] > 1)
                roll += 40;
            if(attacker.Param[PE_AGRO] > 0)
                extraroll += 5;
            if(attacker.Param[PE_AGRO2] > 0)
                extraroll += 5 * attacker.Param[PE_AGRO2];
            if(target.Param[PE_DERMAL_IMPACT] > 1)
                extraroll -= 10;
			
            if(attacker.Param[TRAIT_FAST_SHOT] > 0)        // +20 with ranged
                    extraroll -= 35;
			if(valid(realWeapon) && realWeapon.Val3 == WP_BETTER_CRIT) roll += 10;
            if(valid(realWeapon) && realWeapon.Val4 == WP_BETTER_CRIT) roll += 10;
            if(valid(realWeapon) && realWeapon.Val5 == WP_BETTER_CRIT) roll += 10;
            if(valid(realWeapon) && realWeapon.Val6 == WP_BETTER_CRIT) roll += 10;
            if(valid(realWeapon) && realWeapon.Val7 == WP_BETTER_CRIT) roll += 10;
            if(valid(realWeapon) && realWeapon.Val8 == WP_BETTER_CRIT) roll += 10;
			
			if(valid(realWeapon) && realWeapon.Val3 == WP_LEG_BH) roll += attacker.Param[ST_CRITICAL_CHANCE] + target.Param[ST_CRITICAL_CHANCE];
			if(valid(realWeapon) && realWeapon.Val4 == WP_LEG_BH) roll += attacker.Param[ST_CRITICAL_CHANCE] + target.Param[ST_CRITICAL_CHANCE];
			if(valid(realWeapon) && realWeapon.Val5 == WP_LEG_BH) roll += attacker.Param[ST_CRITICAL_CHANCE] + target.Param[ST_CRITICAL_CHANCE];
			if(valid(realWeapon) && realWeapon.Val6 == WP_LEG_BH) roll += attacker.Param[ST_CRITICAL_CHANCE] + target.Param[ST_CRITICAL_CHANCE];
			if(valid(realWeapon) && realWeapon.Val7 == WP_LEG_BH) roll += attacker.Param[ST_CRITICAL_CHANCE] + target.Param[ST_CRITICAL_CHANCE];
			if(valid(realWeapon) && realWeapon.Val8 == WP_LEG_BH) roll += attacker.Param[ST_CRITICAL_CHANCE] + target.Param[ST_CRITICAL_CHANCE];
			if(valid(realWeapon) && realWeapon.Val2 == WP_LEG_BH) roll += attacker.Param[ST_CRITICAL_CHANCE] + target.Param[ST_CRITICAL_CHANCE];


        }
        int bonehead = 0;
        if(target.Param[TRAIT_BONEHEAD] != 0 && (aim == HIT_LOCATION_HEAD || aim == HIT_LOCATION_EYES))
            extraroll -= 25;
        if(target.Param[PE_DEATHCLAW] != 0 && (aim != HIT_LOCATION_HEAD || aim != HIT_LOCATION_EYES))
            extraroll -= 20;
		if(attacker.Param[PE_SOLDIER] > 0)
			extraroll += 1;
		if(target.Param[PE_MAN_OF_STEEL] > 0)
			extraroll -= 25;
		if(target.Param[PE_MAN_OF_STEEL]>0 && target.Param[PE_IRON_GRIP]>0 && target.Param[PE_STONEWALL]>0 && target.Param[PE_QUICK_RECOVERY]>0 )
			extraroll -= 30;
		int distmodcrit = 0;
		bool havelongrange = false;
        //Item@ RealWeapon = _CritGetItemHand(cr);
		if(valid(realWeapon) && realWeapon.Val3 == WP_LONG_RANGE) havelongrange = true;
        if(valid(realWeapon) && realWeapon.Val4 == WP_LONG_RANGE) havelongrange = true;
        if(valid(realWeapon) && realWeapon.Val5 == WP_LONG_RANGE) havelongrange = true;
        if(valid(realWeapon) && realWeapon.Val6 == WP_LONG_RANGE) havelongrange = true;
        if(valid(realWeapon) && realWeapon.Val7 == WP_LONG_RANGE) havelongrange = true;
        if(valid(realWeapon) && realWeapon.Val8 == WP_LONG_RANGE) havelongrange = true;
		if(attacker.Param[PE_SNIPER] > 0 && aim != HIT_LOCATION_NONE && aim != HIT_LOCATION_TORSO && aim != HIT_LOCATION_UNCALLED)
			{
			distmodcrit = 1;
				if(havelongrange)
					distmodcrit = 2;
			int dys = 0;
			dys = GetDistantion(attacker.HexX, attacker.HexY, target.HexX, target.HexY);
			roll += dys * distmodcrit;
			
			}
		
		//Log("1: " + roll + "ext: " + extraroll);
		if(extraroll != 0)
		{
			roll = roll/100;
			roll *= 100 + extraroll;
		//	Log("2: " + roll + "ext: " + extraroll);	
		}	
		//if(attacker.GetAccess() > ACCESS_CLIENT && attacker.IsPlayer())
			//{
			//attacker.Say(SAY_NETMSG, "ExtraRoll: " + extraroll);
		///	attacker.Say(SAY_NETMSG, "Roll: " + roll);
		//	}
		int crit_roll = 0;
        if(roll <= 25)
            crit_roll = 0 + attacker.Param[PE_SOLDIER] ;
        else if(roll <= 60)
            crit_roll = 1;
        else if(roll <= 100)
            crit_roll = 2;
        else if(roll <= 125)
            crit_roll = 3;
        else if(roll <= 170)
            crit_roll = 4;
        else if(roll > 170)
            crit_roll = 5;
		if(attacker.Param[PE_TIGER] > 1)           // +25 with hth/melee
                if(attack.WeaponSubtype == WS_MELEE || attack.WeaponSubtype == WS_UNARMED)
                    crit_roll++;
		if(attacker.Param[PE_MASTER]>0 && attack.WeaponSubtype==WS_MELEE ||  attack.WeaponSubtype == WS_UNARMED)
			crit_roll++;
        if(crit_roll<0)
        crit_roll = 0;
        if(crit_roll>5)
        crit_roll = 5;

		if(valid(realWeapon) && realWeapon.Val3 == WP_FROZEN) {target.ParamBase[ST_SLOW] += Random(1,8); VerboseActionCombat(target, "Slowed");}
        if(valid(realWeapon) && realWeapon.Val4 == WP_FROZEN) {target.ParamBase[ST_SLOW] += Random(1,8); VerboseActionCombat(target, "Slowed");}
        if(valid(realWeapon) && realWeapon.Val5 == WP_FROZEN) {target.ParamBase[ST_SLOW] += Random(1,8); VerboseActionCombat(target, "Slowed");}
        if(valid(realWeapon) && realWeapon.Val6 == WP_FROZEN) {target.ParamBase[ST_SLOW] += Random(1,8); VerboseActionCombat(target, "Slowed");}
        if(valid(realWeapon) && realWeapon.Val7 == WP_FROZEN) {target.ParamBase[ST_SLOW] += Random(1,8); VerboseActionCombat(target, "Slowed");}
        if(valid(realWeapon) && realWeapon.Val8 == WP_FROZEN) {target.ParamBase[ST_SLOW] += Random(1,8); VerboseActionCombat(target, "Slowed");}
       
        if(isCritical)
        {
            eff = 0;
            int  stat = 0;
            int  statMod = 0;
			string criteff = "";
			
            uint cMessage = 0;
            uint cFailureMessage = 0;
			
			bool upgraded_crits = attacker.Param[PE_DRAGON2]>1 && Random(1,20)==1;
			uint maxslow = 1;
			
			if(upgraded_crits)
			maxslow = 2;
			
		switch(aim)
		{
		case HIT_LOCATION_EYES:
		switch(crit_roll)
			{
			case 0:
			dmgmulti += Random(85,100);
			break;
			case 1:
			if(Random(1,5)==1)
			slow = true;
			dmgmulti += Random(135,150);
			break;
			case 2:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			dmgmulti += Random(155,170);
			break;
			case 3:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			dmgmulti += Random(155,210);
			break;
			case 4:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			if(Random(1,5)==1)
			criple = 5;
			dmgmulti += Random(220,235);
			break;
			case 5:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			if(Random(1,5)==1)
			criple = 5;
			if(Random(1,5)==1)
			koeff = true;
			dmgmulti += Random(235,250);
			break;
			}
		break;
		case HIT_LOCATION_HEAD:
		switch(crit_roll)
			{
			case 0:
			dmgmulti += Random(60,75);
			break;
			case 1:
			if(Random(1,5)==1)
			slow = true;
			dmgmulti += Random(110,125);
			break;
			case 2:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			dmgmulti += Random(145,160);
			break;
			case 3:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			dmgmulti += Random(175,190);
			break;
			case 4:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			if(Random(1,5)==1)
			bypasseff = true;
			dmgmulti += Random(210,225);
			break;
			case 5:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			if(Random(1,5)==1)
			bypasseff = true;
			if(Random(1,5)==1)
			koeff = true;
			dmgmulti += Random(220,235);
			break;
			}
		break;
		case HIT_LOCATION_GROIN:
		switch(crit_roll)
			{
			case 0:
			dmgmulti += Random(35,50);
			break;
			case 1:
			if(Random(1,5)==1)
			slow = true;
			dmgmulti += Random(85,100);
			break;
			case 2:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			dmgmulti += Random(135,150);
			break;
			case 3:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			dmgmulti += Random(160,175);
			break;
			case 4:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			if(Random(1,5)==1)
			deatheff = true;
			dmgmulti += Random(185,200);
			break;
			case 5:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			if(Random(1,5)==1)
			deatheff = true;
			if(Random(1,5)==1)
			koeff = true;
			dmgmulti += Random(195,210);
			break;
			}
		break;
		case HIT_LOCATION_LEFT_LEG:
		case HIT_LOCATION_RIGHT_LEG:
		switch(crit_roll)
			{
			case 0:
			if(Random(1,5)==1)
			dmgmulti += Random(15,30);
			break;
			case 1:
			if(Random(1,5)==1)
			slow = true;
			dmgmulti += Random(45,60);
			break;
			case 2:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			dmgmulti += Random(60,75);
			break;
			case 3:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			dmgmulti += Random(65,80);
			break;
			case 4:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			if(Random(1,5)==1)
			criple = aim==HIT_LOCATION_LEFT_LEG ? 3 : 4;
			dmgmulti += Random(95,110);
			break;
			case 5:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			if(Random(1,5)==1)
			criple = aim==HIT_LOCATION_LEFT_LEG ? 3 : 4;
			if(Random(1,5)==1)
			koeff = true;
			dmgmulti += Random(115,130);
			break;
			}
		break;
		case HIT_LOCATION_LEFT_ARM:
		case HIT_LOCATION_RIGHT_ARM:
		switch(crit_roll)
			{
			case 0:
			dmgmulti += Random(10,25);
			break;
			case 1:
			if(Random(1,5)==1)
			slow = true;
			dmgmulti += Random(30,45);
			break;
			case 2:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			APdrain = true;
			dmgmulti += Random(85,100);
			break;
			case 3:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			APdrain = true;
			if(Random(1,5)==1)
			weapondropeff = true;
			dmgmulti += Random(100,115);
			break;
			case 4:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			APdrain = true;
			if(Random(1,5)==1)
			weapondropeff = true;
			criple = aim==HIT_LOCATION_LEFT_ARM ? 1 : 2;
			dmgmulti += Random(120,135);
			break;
			case 5:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			APdrain = true;
			if(Random(1,5)==1)
			weapondropeff = true;
			if(Random(1,5)==1)
			criple = aim==HIT_LOCATION_LEFT_ARM ? 1 : 2;
			if(Random(1,5)==1)
			weapondestroyeff = true;
			dmgmulti += Random(135,150);
			break;
			}
		break;
		default:
		switch(crit_roll)
			{
			case 0:
			dmgmulti += Random(0,15);
			break;
			case 1:
			dmgmulti += Random(20,35);
			break;
			case 2:
			if(Random(1,5)==1)
			slow = true;
			dmgmulti += Random(35,50);
			break;
			case 3:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			dmgmulti += Random(50,65);
			break;
			case 4:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			APdrain = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			dmgmulti += Random(75,90);
			break;
			case 5:
			if(Random(1,5)==1)
			slow = true;
			if(Random(1,5)==1)
			APdrain = true;
			if(Random(1,5)==1)
			knockdowneff = true;
			if(Random(1,5)==1)
			deatheff = true;
			dmgmulti += Random(95,110);
			break;
			}
		break;
		}
		if(attack.WeaponSubtype!=WS_MELEE ||  attack.WeaponSubtype != WS_UNARMED)
		{
			if(valid(realWeapon) && realWeapon.Val3 == WP_MCD) dmgmulti += Random(5,40);
            if(valid(realWeapon) && realWeapon.Val4 == WP_MCD) dmgmulti += Random(5,40);
            if(valid(realWeapon) && realWeapon.Val5 == WP_MCD) dmgmulti += Random(5,40);
            if(valid(realWeapon) && realWeapon.Val6 == WP_MCD) dmgmulti += Random(5,40);
            if(valid(realWeapon) && realWeapon.Val7 == WP_MCD) dmgmulti += Random(5,40);
            if(valid(realWeapon) && realWeapon.Val8 == WP_MCD) dmgmulti += Random(5,40);
		}
		else
		{
			if(valid(realWeapon) && realWeapon.Val3 == WP_SPIKED) dmgmulti += Random(10,60);
            if(valid(realWeapon) && realWeapon.Val4 == WP_SPIKED) dmgmulti += Random(10,60);
            if(valid(realWeapon) && realWeapon.Val5 == WP_SPIKED) dmgmulti += Random(10,60);
            if(valid(realWeapon) && realWeapon.Val6 == WP_SPIKED) dmgmulti += Random(10,60);
            if(valid(realWeapon) && realWeapon.Val7 == WP_SPIKED) dmgmulti += Random(10,60);
            if(valid(realWeapon) && realWeapon.Val8 == WP_SPIKED) dmgmulti += Random(10,60);
		}
		
		if(slow)
			{
            target.ParamBase[ST_SLOW] += 40 * maxslow - target.Param[ST_INTELLECT]*2;
            criteff += "Slowed";
			}
			int chipshot = 0;
			if(valid(realWeapon) && realWeapon.Val3 == WP_CHIP_SHOT) chipshot += 20;
            if(valid(realWeapon) && realWeapon.Val4 == WP_CHIP_SHOT) chipshot += 20;
            if(valid(realWeapon) && realWeapon.Val5 == WP_CHIP_SHOT) chipshot += 20;
            if(valid(realWeapon) && realWeapon.Val6 == WP_CHIP_SHOT) chipshot += 20;
            if(valid(realWeapon) && realWeapon.Val7 == WP_CHIP_SHOT) chipshot += 20;
            if(valid(realWeapon) && realWeapon.Val8 == WP_CHIP_SHOT) chipshot += 20;
            extraMessage = cMessage;
            int phoenix = 0;
            
            int agro = 0;

            bool haveenhknockout = false;
            if(valid(realWeapon) && realWeapon.Val2 == WP_LEG_KO) haveenhknockout = true;
            if(haveenhknockout)
                {
                koeff = true;
				if(criteff != "")
					criteff += " and Knockout";
				else criteff += "Knockout";
                }
            bool haveknock = false;
			 if(valid(realWeapon) && realWeapon.Val3 == WP_KNOCKBACK) haveknock = true;
            if(valid(realWeapon) && realWeapon.Val4 == WP_KNOCKBACK) haveknock = true;
            if(valid(realWeapon) && realWeapon.Val5 == WP_KNOCKBACK) haveknock = true;
            if(valid(realWeapon) && realWeapon.Val6 == WP_KNOCKBACK) haveknock = true;
            if(valid(realWeapon) && realWeapon.Val7 == WP_KNOCKBACK) haveknock = true;
            if(valid(realWeapon) && realWeapon.Val8 == WP_KNOCKBACK) haveknock = true;
            if(haveknock && target.Param[PE_STONEWALL] == 0)
                {
                knockdowneff = true;
                if(criteff != "")
					criteff += " and Knockback";
				else criteff += "Knockback";
                }
			if(haveknock && target.Param[PE_STONEWALL] != 0 && Random(1, 100) <= target.Param[ST_STRENGTH]*5 + 15 - agro + phoenix - 25 * attacker.Param[PE_HUNTER] - 100 * target.Param[PE_SOLDIER] - chipshot)
                {
                knockdowneff = true;
                if(criteff != "")
					criteff += " and Knockback";
				else criteff += "Knockback";
                }
            
            if(target.Param[MODE_NO_KNOCK] != 0)
                knockdowneff = false;
            else
            if(knockdowneff && target.Param[PE_STONEWALL] != 0 && Random(1, 100) <= target.Param[ST_STRENGTH]*5 + 15 - agro + phoenix - 25 * attacker.Param[PE_HUNTER] - 100 * target.Param[PE_SOLDIER] - chipshot)
                knockdowneff = false;
            if(koeff && target.Param[PE_STONEWALL] != 0 && Random(1, 100) <= (target.Param[ST_ENDURANCE]*7 - agro + phoenix - 25 * attacker.Param[PE_HUNTER] - 100 * target.Param[PE_SOLDIER]  - chipshot ))
                koeff = false;
            if(koeff && target.Param[PE_STONEWALL] == 0 && Random(1, 100) <= target.Param[ST_ENDURANCE] - agro + phoenix - 25 * attacker.Param[PE_HUNTER] - 100 * target.Param[PE_SOLDIER]  - chipshot)
                koeff = false;
            if(Random(1,100) < target.Param[ST_STRENGTH]*5 - agro + phoenix  - 25 * attacker.Param[PE_HUNTER] - 100 * target.Param[PE_SOLDIER] )
            {
            if(criple == 1)
                    criple = 0;
            if(criple == 2)
                    criple = 0;
            }

            if(Random(1,100) < target.Param[ST_LUCK]*5 - agro + phoenix  - 25 * attacker.Param[PE_HUNTER] - 100 * target.Param[PE_SOLDIER] )
            {
            if(criple == 3)
                    criple = 0;
                if(criple == 3)
                    criple = 0;
            }

            if(target.Param[PE_IRON_GRIP] != 0)
            {
                if(criple != 5)
					criple = 0;
            }

            if(target.Param[MODE_NO_LOOSE_LIMBS] != 0)
            {
                criple = 0;
            }

            if(weapondropeff && target.Param[MODE_NO_DROP] != 0 || (target.Param[PE_IRON_GRIP] > 0 ))
            {
                weapondropeff = false;
            }
            else if(weapondropeff && Random(1, 100) <= target.Param[ST_STRENGTH]*5 - agro + phoenix  - 25 * attacker.Param[PE_HUNTER] - 20 * target.Param[PE_SOLDIER] )
            {
                weapondropeff = false;
            }
            if(validAttacker && attackerIsPlayer)
                AddScore(attacker, SCORE_SNIPER, 1);
        }
    }
    // isCritical end
    bool haveenhknockout = false;
	if(valid(realWeapon) && realWeapon.Val3 == WP_LEG_KO) haveenhknockout = true;
            if(valid(realWeapon) && realWeapon.Val4 == WP_LEG_KO) haveenhknockout = true;
            if(valid(realWeapon) && realWeapon.Val5 == WP_LEG_KO) haveenhknockout = true;
            if(valid(realWeapon) && realWeapon.Val6 == WP_LEG_KO) haveenhknockout = true;
            if(valid(realWeapon) && realWeapon.Val7 == WP_LEG_KO) haveenhknockout = true;
            if(valid(realWeapon) && realWeapon.Val8 == WP_LEG_KO) haveenhknockout = true;

    if(validAttacker && (haveenhknockout))
    {
        //Log("Bron melee z perkiem Knockback");
        if(Random(1, 20) <= (attacker.Param[ST_STRENGTH]) - 8)
        {
            koeff = true;
            if(criteff != "")
					criteff += " and Knockout";
				else criteff += "Knockout";
        }
    }
    bool haveknock = false;
		if(valid(realWeapon) && realWeapon.Val3 == WP_KNOCKBACK) haveknock = true;
            if(valid(realWeapon) && realWeapon.Val4 == WP_KNOCKBACK) haveknock = true;
            if(valid(realWeapon) && realWeapon.Val5 == WP_KNOCKBACK) haveknock = true;
            if(valid(realWeapon) && realWeapon.Val6 == WP_KNOCKBACK) haveknock = true;
            if(valid(realWeapon) && realWeapon.Val7 == WP_KNOCKBACK) haveknock = true;
            if(valid(realWeapon) && realWeapon.Val8 == WP_KNOCKBACK) haveknock = true;

    if(validAttacker && (haveknock))
    {
        //Log("Bron melee z perkiem Knockback");
        if(Random(1, 20) <= (attacker.Param[ST_STRENGTH]) - 8)
        {
            knockdowneff = true;
            if(criteff != "")
					criteff += " and Knockback";
				else criteff += "Knockback";
        }
    }

    // not messaged
    Item@ armorek = target.GetItem(0, SLOT_ARMOR);
    // Heavy Handed Param
	
    if(validAttacker && attacker.Param[TRAIT_HEAVY_HANDED] > 0)
	if(attack.WeaponSubtype==WS_MELEE ||  attack.WeaponSubtype == WS_UNARMED)
    {
        int heavyHandedStrengthMalus = 0;
		
		if(valid(realWeapon) && realWeapon.Val3 == WP_SMASHER) heavyHandedStrengthMalus += 5;
        if(valid(realWeapon) && realWeapon.Val4 == WP_SMASHER) heavyHandedStrengthMalus += 5;
        if(valid(realWeapon) && realWeapon.Val5 == WP_SMASHER) heavyHandedStrengthMalus += 5;
        if(valid(realWeapon) && realWeapon.Val6 == WP_SMASHER) heavyHandedStrengthMalus += 5;
        if(valid(realWeapon) && realWeapon.Val7 == WP_SMASHER) heavyHandedStrengthMalus += 5;
        if(valid(realWeapon) && realWeapon.Val8 == WP_SMASHER) heavyHandedStrengthMalus += 5;
		
		if(valid(armorek) && armorek.Val3 == AP_STONEWALL) heavyHandedStrengthMalus += -10;
        if(valid(armorek) && armorek.Val4 == AP_STONEWALL) heavyHandedStrengthMalus += -10;
        if(valid(armorek) && armorek.Val5 == AP_STONEWALL) heavyHandedStrengthMalus += -10;
        if(valid(armorek) && armorek.Val6 == AP_STONEWALL) heavyHandedStrengthMalus += -10;
        if(valid(armorek) && armorek.Val7 == AP_STONEWALL) heavyHandedStrengthMalus += -10;
        if(valid(armorek) && armorek.Val8 == AP_STONEWALL) heavyHandedStrengthMalus += -10;
	//	Log("" + get_ST(attacker));
		
		uint hthsyg = 0;
		if(attacker.Param[PE_GAIN_STRENGTH]>0 && attacker.Param[PE_IN_YOUR_FACE]>0 && attacker.Param[PE_BONUS_HTH_DAMAGE_II]>0)
			heavyHandedStrengthMalus += 5;
		//Log("" + heavyHandedStrengthMalus);
		//Log("" + attacker.Param[ST_STRENGTH]);
		if(Random(1, 40) <= (get_ST(attacker) + heavyHandedStrengthMalus + attacker.Param[PE_SOLDIER]))
        {
			knockdowneff = true;
			if(criteff != "")
					criteff += " and Knockback";
				else criteff += "Knockback";
		
		}
		else if(Random(1, 30) <= (get_ST(attacker) + heavyHandedStrengthMalus + attacker.Param[PE_SOLDIER]))
        {
			APdrain = true;
			target.ParamBase[ST_CURRENT_AP] -= 100;
			attacker.ParamBase[ST_CURRENT_AP] += 100;
            if(criteff != "")
					criteff += " and AP Drain";
				else criteff += "AP Drain";
		
		}
        else if(Random(1, 20) <= (get_ST(attacker) + heavyHandedStrengthMalus + attacker.Param[PE_SOLDIER]))
        {
			target.ParamBase[ST_SLOW] += 3;
            if(criteff != "")
					criteff += " and Slowed";
				else criteff += "Slowed";
            
        }
    }



    // ############################################################################################
    // ########################## POCZATEK kalkulacji damage ######################################
    // ############################################################################################
    int dmgType = attack.DmgType;
    int totalDmg = 0;
	int flat_damage = attack.Attacker.Param[ST_INTELLECT];
    if(valid(attack))
    {
        if(ammoPid == PID_SHOTGUN_SHELLS_EMP) dmgType=DAMAGE_EMP; // jesli uzywane ammo typu EMP to zmien dmtype broni
        if(ammoPid == PID_SHOTGUN_DRAGON_BREATH_SHELLS && target.Param[PE_BOSS]==0)
        {
        dmgType=DAMAGE_FIRE;
        }      
		if(ammoPid == PID_40MM_GRENADE_ICE) dmgType=DAMAGE_PLASMA;
		if(ammoPid == PID_40MM_GRENADE_FIRE) dmgType=DAMAGE_FIRE;// jesli uzywane ammo typu FIRE to zmien dmtype broni
		if(attacker.Param[PE_PYROMANIAC]>1 && dmgType==DAMAGE_PLASMA && attacker.Param[PE_FIRE_FIGHTER]>0)
			dmgType=DAMAGE_FIRE;
        //Log("ammoPid= " + ammoPid);
    }
	
	

    // #############################################
    // ## Obliczenia melee attack swing i thrust  ##
    // #############################################
    if(isSwing) // dziala podobnie jak ammo JHP wg oryginalnej formuly
    {
        //if((targetDT == 0) && (targetDR < 15))   // ustawianie wyzszej DR dla "golasow" dla zredukowania bardzo duzych wartosci damage
        //{
        //  targetDR=15;
        //}

        //dmgMul*=5;
        //targetDR+=59;
        //targetDR=CLAMP(targetDR,0,100);
        //targetDT/=0.15;
    }

    if(isThrust)  // dziala podobnie jak ammo AP wg oryginalnej formuly
    {
        attack.DMMod = 4;
        attack.DDMod = 5;
        attack.DRMod = -40;

        //targetDR-=40;
        //targetDR=CLAMP(targetDR,0,100);
        //targetDT/=2;
    }
    // swing:thrust END
	bool ammo_upgrade = false;
	if(valid(realWeapon) && realWeapon.Val3 == WP_AMMO) { attack.DMMod = attack.DMMod * 8 + attack.DDMod; attack.DDMod = attack.DDMod *= 8;}
    if(valid(realWeapon) && realWeapon.Val4 == WP_AMMO) { attack.DMMod = attack.DMMod * 8 + attack.DDMod; attack.DDMod = attack.DDMod *= 8;}
    if(valid(realWeapon) && realWeapon.Val5 == WP_AMMO) { attack.DMMod = attack.DMMod * 8 + attack.DDMod; attack.DDMod = attack.DDMod *= 8;}
    if(valid(realWeapon) && realWeapon.Val6 == WP_AMMO) { attack.DMMod = attack.DMMod * 8 + attack.DDMod; attack.DDMod = attack.DDMod *= 8;}
    if(valid(realWeapon) && realWeapon.Val7 == WP_AMMO) { attack.DMMod = attack.DMMod * 8 + attack.DDMod; attack.DDMod = attack.DDMod *= 8;}
    if(valid(realWeapon) && realWeapon.Val8 == WP_AMMO) { attack.DMMod = attack.DMMod * 8 + attack.DDMod; attack.DDMod = attack.DDMod *= 8;}
	
	
	
	if(valid(realWeapon) && realWeapon.Val3 == WP_DESTROYER && (dmgType == DAMAGE_NORMAL || dmgType == DAMAGE_FIRE || dmgType == DAMAGE_EXPLODE)) { attack.DRMod -= 5;  }
    if(valid(realWeapon) && realWeapon.Val4 == WP_DESTROYER && (dmgType == DAMAGE_NORMAL || dmgType == DAMAGE_FIRE || dmgType == DAMAGE_EXPLODE)) { attack.DRMod -= 5; }
    if(valid(realWeapon) && realWeapon.Val5 == WP_DESTROYER && (dmgType == DAMAGE_NORMAL || dmgType == DAMAGE_FIRE || dmgType == DAMAGE_EXPLODE)) { attack.DRMod -= 5; }
    if(valid(realWeapon) && realWeapon.Val6 == WP_DESTROYER && (dmgType == DAMAGE_NORMAL || dmgType == DAMAGE_FIRE || dmgType == DAMAGE_EXPLODE)) { attack.DRMod -= 5; }
    if(valid(realWeapon) && realWeapon.Val7 == WP_DESTROYER && (dmgType == DAMAGE_NORMAL || dmgType == DAMAGE_FIRE || dmgType == DAMAGE_EXPLODE)) { attack.DRMod -= 5; }
    if(valid(realWeapon) && realWeapon.Val8 == WP_DESTROYER && (dmgType == DAMAGE_NORMAL || dmgType == DAMAGE_FIRE || dmgType == DAMAGE_EXPLODE)) { attack.DRMod -= 5; }
	
	if(attacker.Param[PE_SHARPSHOOTER]>0 && aim != HIT_LOCATION_TORSO && aim != HIT_LOCATION_UNCALLED) { attack.DRMod -= Random(1,10); }
    int targetDR = 0;
    int targetDT = 0;
	if(!attack.AimHead)
	{
	switch(dmgType)
		{
		case DAMAGE_NORMAL: targetDR = target.Param[ST_NORMAL_RESIST]; targetDT = target.Param[ST_NORMAL_ABSORB]; break;
		case DAMAGE_LASER: targetDR = target.Param[ST_LASER_RESIST]; targetDT = target.Param[ST_LASER_ABSORB]; break;
		case DAMAGE_FIRE: targetDR = target.Param[ST_FIRE_RESIST]; targetDT = target.Param[ST_FIRE_ABSORB]; break;
		case DAMAGE_PLASMA: targetDR = target.Param[ST_PLASMA_RESIST]; targetDT = target.Param[ST_PLASMA_ABSORB]; break;
		case DAMAGE_EXPLODE: targetDR = target.Param[ST_EXPLODE_RESIST]; targetDT = target.Param[ST_EXPLODE_ABSORB]; break;
		case DAMAGE_ELECTR: targetDR = target.Param[ST_ELECTRO_RESIST]; targetDT = target.Param[ST_ELECTRO_ABSORB]; break;
		case DAMAGE_EMP: targetDR = target.Param[ST_EMP_RESIST]; targetDT = target.Param[ST_EMP_ABSORB]; break;
		}
	}
	else
	{
	switch(dmgType)
		{
		case DAMAGE_NORMAL: targetDR = target.Param[ST_HEAD_NORMAL]; targetDT = target.Param[ST_NORMAL_ABSORB]; break;
		case DAMAGE_LASER: targetDR = target.Param[ST_HEAD_LASER]; targetDT = target.Param[ST_LASER_ABSORB]; break;
		case DAMAGE_FIRE: targetDR = target.Param[ST_HEAD_FIRE]; targetDT = target.Param[ST_FIRE_ABSORB]; break;
		case DAMAGE_PLASMA: targetDR = target.Param[ST_HEAD_PLASMA]; targetDT = target.Param[ST_PLASMA_ABSORB]; break;
		case DAMAGE_EXPLODE: targetDT = target.Param[ST_EXPLODE_ABSORB]; break;
		case DAMAGE_ELECTR: targetDR = target.Param[ST_HEAD_ELECTRO]; targetDT = target.Param[ST_ELECTRO_ABSORB]; break;
		case DAMAGE_EMP: targetDR = target.Param[ST_HEAD_EMP]; targetDT = target.Param[ST_EMP_ABSORB]; break;
		}
	}

    int partialBypassChance = GetPartialBypassChance(target, attack.AimHead);
    int partialBypassedRounds = 0;
  //  int armorDR = target.GetArmorDR(dmgType, attack.AimHead);
 //   int armorDT = target.GetArmorDT(dmgType, attack.AimHead);

    int partialBypassDR = targetDR/4;
    int partialBypassDT = targetDT/4;
    bool havepenetrate = false;
	if(valid(realWeapon) && realWeapon.Val3 == WP_PENETRATE) havepenetrate = true;
    if(valid(realWeapon) && realWeapon.Val4 == WP_PENETRATE) havepenetrate = true;
    if(valid(realWeapon) && realWeapon.Val5 == WP_PENETRATE) havepenetrate = true;
    if(valid(realWeapon) && realWeapon.Val6 == WP_PENETRATE) havepenetrate = true;
    if(valid(realWeapon) && realWeapon.Val7 == WP_PENETRATE) havepenetrate = true;
    if(valid(realWeapon) && realWeapon.Val8 == WP_PENETRATE) havepenetrate = true;
    if(bypasseff && dmgType != DAMAGE_EMP)
    {
        targetDT = 0; // bylo /5
        targetDR /= 2; // bylo /5
        if(criteff != "")
					criteff += " and Bypass";
				else criteff += "Bypass";
    }
    else if(havepenetrate)
        targetDT /= 5;
    else if(COMBAT_AMMO_AP(attack.Ammo))
        targetDT /= attack.Ammo.Ammo_DTDiv;
    else if(isThrust)
        targetDT /= 2;



    if(validAttacker && attacker.Param[TRAIT_FINESSE] != 0)
    {
        if(dmgType == DAMAGE_LASER || dmgType == DAMAGE_ELECTR || dmgType == DAMAGE_PLASMA)
        {
            targetDR += 15;
            partialBypassDR += 15;
        }
        else
        {
            targetDR += 30;
            partialBypassDR += 30;
        }
    }
    targetDR += attack.DRMod;   // Always
    partialBypassDR += attack.DRMod;




    partialBypassDR = MIN(partialBypassDR, targetDR);
    targetDR = CLAMP(targetDR, 0, 100);
    partialBypassDR = CLAMP(partialBypassDR, 0, 100);
    partialBypassDT = MIN(partialBypassDT, targetDT);

    int bonusmindmg = 0;
		if(valid(realWeapon) && realWeapon.Val3 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        if(valid(realWeapon) && realWeapon.Val4 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        if(valid(realWeapon) && realWeapon.Val5 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        if(valid(realWeapon) && realWeapon.Val6 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        if(valid(realWeapon) && realWeapon.Val7 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        if(valid(realWeapon) && realWeapon.Val8 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        int bonusmaxdmg = 0;
		 if(valid(realWeapon) && realWeapon.Val3 == WP_ATTACK) bonusmaxdmg +=19;
        if(valid(realWeapon) && realWeapon.Val4 == WP_ATTACK) bonusmaxdmg +=19;
        if(valid(realWeapon) && realWeapon.Val5 == WP_ATTACK) bonusmaxdmg +=19;
        if(valid(realWeapon) && realWeapon.Val6 == WP_ATTACK) bonusmaxdmg +=19;
        if(valid(realWeapon) && realWeapon.Val7 == WP_ATTACK) bonusmaxdmg +=19;
        if(valid(realWeapon) && realWeapon.Val8 == WP_ATTACK) bonusmaxdmg +=19;
		
		if(valid(realWeapon) && realWeapon.Val3 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val4 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val5 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val6 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val7 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val8 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val2 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }

    int dmgMin =  attack.DmgMin + attack.BonusDmg + attack.DmgMin * bonusmindmg/100;
    ;
    int dmgMax =  attack.DmgMax + attack.BonusDmg + attack.DmgMax * bonusmaxdmg/100;
    ;
    int rawDmg;

    //dmgMul *= attack.DMMod;
    int dmgDiv = 2 * attack.DDMod;



    for(int i = 0; i < rounds; i++)
    {
        //if(isPrimitiveWeapon)
        rawDmg = Random(dmgMin, dmgMax);

        //else
        //rawDmg=0;
		if(attack.Attacker.Param[ST_LUCK] > 19)
			{
			int critmol = 1;
			if(isCritical)
				critmol = 2;
			rawDmg *= 0.25;
            flat_damage += rawDmg * critmol;
			//flat_damage = flat_damage * dmgmulti;
		//	flat_damage = flat_damage/100;
			rawDmg *= 4;
			rawDmg *= 0.75;
			
			
			}
        _dmgMul[i] *= attack.DMMod;
        rawDmg *= _dmgMul[i];

        rawDmg /= dmgDiv;
        if(!bypasseff && partialBypassChance > 0 && Random(1, 100) <= partialBypassChance)
        {
            rawDmg -= partialBypassDT;
            rawDmg -= (rawDmg * partialBypassDR) / 100;
            partialBypassedRounds++;
        }
        else
        {
            rawDmg -= targetDT;
            rawDmg -= (rawDmg * targetDR) / 100;
        }
        if(rawDmg > 0)
            totalDmg += rawDmg;
    }

    //if(attackerIsPlayer)
    //{
    //  Log("dmg = " + totalDmg);
    //  Log("-------------------");
     //&& attack.RealWeapon.Proto.ProtoId != PID_FIRE_HEX

    if(validAttacker)
    {
		Item@ targetarmor = target.GetItem(0, SLOT_ARMOR);
		bool make_flat = true;
		bool             isFlamethrower = (weapPid == PID_FLAMER) || (weapPid == PID_IMPROVED_FLAMETHROWER) || (weapPid == PID_FIRE_GECKO_FLAME_WEAPON || (weapPid == PID_NAPALM)) || (weapPid == PID_PLASMA_FLAMER) || (weapPid == PID_FIRE_SMG);
		int damage_reduction = 0;
		
		if(valid(targetarmor) && targetarmor.Val3 == AP_LETHAL ) make_flat = false;
        if(valid(targetarmor) && targetarmor.Val4 == AP_LETHAL ) make_flat = false;
        if(valid(targetarmor) && targetarmor.Val5 == AP_LETHAL ) make_flat = false;
        if(valid(targetarmor) && targetarmor.Val6 == AP_LETHAL ) make_flat = false;
        if(valid(targetarmor) && targetarmor.Val7 == AP_LETHAL ) make_flat = false;
        if(valid(targetarmor) && targetarmor.Val8 == AP_LETHAL ) make_flat = false;
        if(attack.Attacker.Param[PE_LIVING_ANATOMY] != 0 &&  !(bt == BT_ALIEN || bt == BT_ROBOT))
            flat_damage += 15;  			// Yes, pulse grenade works
		if(attack.Attacker.Param[TRAIT_CHEM_RESISTANT]!=0 && attack.Attacker.Param[TO_JET] > 0) flat_damage += 10;
        if(attack.Attacker.Param[PE_PYROMANIAC] != 0 && dmgType == DAMAGE_FIRE && target.Param[PE_BOSS]==0 && isFlamethrower)
            dmgmulti += (attack.Attacker.Param[PE_PYROMANIAC] * 30);
		if(attack.Attacker.Param[PE_PYROMANIAC] != 0 && dmgType == DAMAGE_FIRE && target.Param[PE_BOSS]==0 && !isFlamethrower)
            dmgmulti += (attack.Attacker.Param[PE_PYROMANIAC] * 15);
		if(attack.Attacker.Param[PE_PYROMANIAC] > 1 && (weapPid == PID_PLASMA_SMG || weapPid == PID_PLASMA_GATLING) )
			dmgmulti += 300;
		if(attack.Attacker.Param[PE_PHOENIX_IMPLANTS] > 1 && dmgType == DAMAGE_FIRE && target.Param[PE_BOSS]==0 && isFlamethrower)
            dmgmulti += 25;
		if(attack.Attacker.Param[PE_PHOENIX_IMPLANTS] > 1 && dmgType == DAMAGE_FIRE && target.Param[PE_BOSS]==0 && !isFlamethrower)
            dmgmulti += 10;
        if(attack.Attacker.Param[TRAIT_FAST_SHOT] != 0)
            flat_damage += 5;
        if(attack.Attacker.Param[TRAIT_HEAVY_HANDED] != 0 && attack.IsUnarmed)
            flat_damage += 2;
		if(valid(realWeapon) && realWeapon.Val3 == WP_SLAYER) flat_damage += 7;
        if(valid(realWeapon) && realWeapon.Val4 == WP_SLAYER) flat_damage += 7;
        if(valid(realWeapon) && realWeapon.Val5 == WP_SLAYER) flat_damage += 7;
        if(valid(realWeapon) && realWeapon.Val6 == WP_SLAYER) flat_damage += 7;
        if(valid(realWeapon) && realWeapon.Val7 == WP_SLAYER) flat_damage += 7;
        if(valid(realWeapon) && realWeapon.Val8 == WP_SLAYER) flat_damage += 7;
        //druto
		
        if((attack.Attacker.Param[TRAIT_ONE_HANDER] != 0 && (valid(realWeapon) && !FLAG(realWeapon.Flags, ITEM_TWO_HANDS)) && !realWeapon.IsStackable()) || attack.Attacker.Param[TRAIT_ONE_HANDER] != 0 && attack.Attacker.Param[PE_MUTANT] != 0)
            dmgmulti += 15;
        if(attack.Attacker.Param[TRAIT_KAMIKAZE] != 0)
            dmgmulti += 15;
        if(attack.Attacker.Param[PE_KILLER] != 0 && Random(1,100)<=attack.Attacker.Param[ST_AGILITY])
            dmgmulti += 100;
        if(attack.Attacker.Param[PE_ASSASIN] != 0 && attack.Attacker.Param[MODE_HIDE] == 0)
            damage_reduction += 250;
        if(attack.Attacker.Param[PE_CLAW2] > 1)
            dmgmulti += 10;
        if(attack.Attacker.Param[PE_SOLDIER] != 0)
            flat_damage += 1;
        int targetBt = target.Param[ST_BODY_TYPE];
        if(!target.IsPlayer())
        {
            switch(targetBt)
            {
                case BT_MEN:
                case BT_WOMEN:
                case BT_CHILDREN:
                dmgmulti += attack.Attacker.Param[PE_PVE_SLAYER_HUMAN]; break;
                case BT_SUPER_MUTANT:
                case BT_GHOUL:
                dmgmulti += attack.Attacker.Param[PE_PVE_SLAYER_MUTANT]; break;
				case BT_ROBOT:
                dmgmulti += attack.Attacker.Param[PE_PVE_SLAYER_ROBOT]; break;
				default:
                dmgmulti += attack.Attacker.Param[PE_PVE_SLAYER_DESERT]; break;
            }
        }
        if(!target.IsPlayer())
            flat_damage += attack.Attacker.Param[PE_PVE_BRD] * 2;

        if(target.IsPlayer() && !attack.Attacker.IsPlayer())
            damage_reduction += target.Param[PE_PVE_THOUGNESS]*10;
		if(!target.IsPlayer() && target.Param[ST_NPC_BOSS] != 0) //15% less damage deal to bosses
			{
            damage_reduction +=  attack.Attacker.Param[BUFF_MELCHIOR] * 150;
			dmgmulti += 30 * attack.Attacker.Param[BUFF_ALIEN];
			}
		
		if(attack.Attacker.Param[ST_NPC_BOSS] != 0) //15% more damage deal to boss slayers
			{
            dmgmulti += (target.Param[BUFF_ROBOT] * 15);
			if(make_flat)
			totalDmg += 30 * target.Param[BUFF_DEATHCLAW];
			}
		
		
        if(target.IsPlayer())
            {
            if(IsCompanion(attack.Attacker))
				damage_reduction += 750;
            if(IsMerc(attack.Attacker))
				damage_reduction += 250;
            if(_IsSlave(attack.Attacker))
            	damage_reduction += 500;
            }
		if(!target.IsPlayer())
            {
			Critter@ master = GetCritter(attack.Attacker.Param[FV_MASTER]);
			if(valid(master))
				{
            if(IsCompanion(attack.Attacker))
				dmgmulti += master.Param[PE_PVE_COMMANDER]*3;
            if(IsMerc(attack.Attacker))
				dmgmulti += master.Param[PE_PVE_COMMANDER]*3;
            if(_IsSlave(attack.Attacker))
            	dmgmulti += master.Param[PE_PVE_COMMANDER]*3;
				}
            }
        if(attack.Attacker.Param[PE_PARAMEDIC] > 0)
            damage_reduction += 500;
		if(target.Param[PE_MUTANT] > 0)
            damage_reduction += 150;
		if(target.Param[PE_LIFEGIVER] > 2)
            damage_reduction += 50;
		if(target.Param[ST_ENDURANCE] > 19)
            damage_reduction += 50;
		if(target.IsPlayer() && !attack.Attacker.IsPlayer())
			damage_reduction += target.Param[ST_CHARISMA]*10;

		
		if(!target.IsPlayer() && attack.Attacker.IsPlayer())
			dmgmulti += attack.Attacker.Param[ST_CHARISMA];
		//if(attack.Attacker.IsPlayer())
		//	Log("ch " + attack.Attacker.Param[ST_CHARISMA]);
        damage_reduction += target.Param[ST_ENDURANCE];
		if(valid(targetarmor) && targetarmor.Val3 == AP_DEF_BELT ) damage_reduction += 20;
        if(valid(targetarmor) && targetarmor.Val4 == AP_DEF_BELT ) damage_reduction += 20;
        if(valid(targetarmor) && targetarmor.Val5 == AP_DEF_BELT ) damage_reduction += 20;
        if(valid(targetarmor) && targetarmor.Val6 == AP_DEF_BELT ) damage_reduction += 20;
        if(valid(targetarmor) && targetarmor.Val7 == AP_DEF_BELT ) damage_reduction += 20;
        if(valid(targetarmor) && targetarmor.Val8 == AP_DEF_BELT ) damage_reduction += 20;
		//if(attack.Attacker.IsPlayer())
		//Log("" + totalDmg * (float((damage_reduction/1000))));
	//	if(attack.Attacker.IsPlayer())
		//	Log("before multi " + totalDmg);
		totalDmg = (totalDmg * dmgmulti)/100;
	//	if(attack.Attacker.IsPlayer())
	//		Log("after multi " + totalDmg);
		totalDmg = (totalDmg * (1000 - damage_reduction))/1000;
	//	if(attack.Attacker.IsPlayer())
	//		Log("after reduction " + totalDmg);
		//Log("Dmg: " + totalDmg + " Flat_bonus: " + flat_damage);
		if(attack.Attacker.Param[PE_WEAPON_HANDLING] > 0)
			flat_damage *= 1.25;
		if(attack.Attacker.Param[PE_WRECKER] > 0)
			flat_damage *= 2;
		if(attack.Attacker.Param[PE_WRECKER] > 0) flat_damage += attack.Attacker.Param[ST_STRENGTH];
		if(flat_damage > 0)
			{
			if(!make_flat)
			totalDmg += flat_damage * 0.25;
			else totalDmg += flat_damage;
		//	Log("Dmg: " + totalDmg + " Flat_bonus: " + flat_damage);
			}
		
		if(target.Param[ST_INTELLECT] > 19 && dmgType == DAMAGE_ELECTR)
            totalDmg = 0;
    }

    //if(!isPrimitiveWeapon) totalDmg=0;


    // 0x00000001 - knockout
    // 0x00000002 - knockdown
    // 0x00000004 - crippled left leg
    // 0x00000008 - crippled right leg
    // 0x00000010 - crippled left arm
    // 0x00000020 - crippled right arm
    // 0x00000040 - blinded
    // 0x00000080 - death
    // 0x00000400 !- on fire - triggers the 'flamedance' animation, but not if the hit is fatal (probably a bug)
    // 0x00000800 - bypass armor
    // 0x00004000 !- dropped weapon (doesn't work)
    // 0x00008000 - lose next turn

    // Code for dropping weapon, adapted from critical failures

    if(weapondropeff)
    {
        Item@ realWeaponTarget = _CritGetItemHand(target);
        if(valid(realWeaponTarget))
        {
            if(realWeaponTarget.IsStackable())
            {
                Item@ dropped = map.AddItem(target.HexX, target.HexY, realWeaponTarget.GetProtoId(), 1);
                if(realWeaponTarget.GetCount() > 1)
                    realWeaponTarget.SetCount(realWeaponTarget.GetCount() - 1);
                else
                    DeleteItem(realWeaponTarget);
                VerboseActionCombat(target, "Weapon Drop");
                if(!target.IsPlayer())
                {
                    NpcPlane@ plane = CreatePlane();
                    array<NpcPlane@> crPlanes(0);

                    if(target.GetPlanes(crPlanes) > 0)
                        plane.Priority = crPlanes[0].Priority + 1;
                    else
                        plane.Priority = 70;

                    plane.Type = AI_PLANE_PICK;
                    plane.Pick_HexX = dropped.HexX;
                    plane.Pick_HexY = dropped.HexY;
                    plane.Pick_Pid = dropped.GetProtoId();
                    plane.Pick_UseItemId = 0;
                    plane.Pick_ToOpen = false;
                    plane.Identifier = PLANE_PICK_DROPPED_WPN;
                    plane.IdentifierExt = dropped.Id;
                    plane.Run = true;
                    target.AddPlane(plane);
                    SetLvar(dropped.Id, LIVAR_npc_wpn_owner, target.Id);
                }
            }
            else
            {
                MoveItem(realWeaponTarget, 0, map, target.HexX, target.HexY);
                if(!target.IsPlayer())
                {
                    NpcPlane@ plane = CreatePlane();
                    array<NpcPlane@> crPlanes(0);

                    if(target.GetPlanes(crPlanes) > 0)
                        plane.Priority = crPlanes[0].Priority + 1;
                    else
                        plane.Priority = 70;

                    plane.Type = AI_PLANE_PICK;
                    plane.Pick_HexX = realWeaponTarget.HexX;
                    plane.Pick_HexY = realWeaponTarget.HexY;
                    plane.Pick_Pid = realWeaponTarget.GetProtoId();
                    plane.Pick_UseItemId = 0;
                    plane.Pick_ToOpen = false;
                    plane.Identifier = PLANE_PICK_DROPPED_WPN;
                    plane.IdentifierExt = realWeaponTarget.Id;
                    plane.Run = true;
                    target.AddPlane(plane);
                    SetLvar(realWeaponTarget.Id, LIVAR_npc_wpn_owner, target.Id);
                }
            }
        }
    }



    bool isOffGame = false;
    bool isKo = false;
    bool knockDown = false;
    bool knockOut = false;
    bool isDead = false;
    bool loseTurn = false;
    bool isBelow = false;
    int  knockDmg = totalDmg;

    if(target.Param[MODE_INVULNERABLE] != 0)
        eff = 0;
    else
    {
        eff = eff & (~target.Param[MODE_NEGATE_CRIT_EFF]);
        msgEff = msgEff & (~target.Param[MODE_NEGATE_CRIT_EFF]);
    }
    // Knock down
    if(knockdowneff)
    {
        //Log("Flaga jest HF_KNOCKDOWN");
        isKo = true;
        knockDown = true;
        if(criteff != "")
					criteff += " and Knockback";
				else criteff += "Knockback";
    }
    //else if((dmgType == DAMAGE_EXPLODE) && (totalDmg > 9))
    else
    if((dmgType == DAMAGE_EXPLODE) && (totalDmg > 9) && valid(realWeapon) && realWeapon.Proto.ProtoId!=PID_DYNACORD) //25-07-2013 Cubik: dynacord nie bedzie przewracal, miny, plastiki i dynamit beda wywracac
    {
        if(target.Param[PE_STONEWALL] != 0)
        {
            /*
                ST-5 *20 > random(1, 105) vs explosion/shotgun KD roll changed to ST-2 *10 > random(1, 100) roll
                meaning chance to avoid such KD changed for chars with 10 -> 6 ST from 95%, 76%, 57%, 38%, 19% into 80%, 70%, 60%, 50%, 40%
            */
            if((target.Param[ST_STRENGTH]-2)*10+ target.Param[PE_SOLDIER]>Random(1,100)) // szansa na unikniecie KD od wybuchu, dla ST=10 szansa =80% na unik
            {
                isKo = false;
            }
            else
            {
                isKo = true;
            }
        }
        else
        {
            isKo = true;
        }
    }
    else
    if(isShotgun && rounds > 1)
    {
        //if(Random(1,100)<70) // 70% szansy na KD od bursta z shotguna
        {
            if(target.Param[PE_STONEWALL] != 0)
            {
                /*
                    ST-5 *20 > random(1, 105) vs explosion/shotgun KD roll changed to ST-2 *10 > random(1, 100) roll
                    meaning chance to avoid such KD changed for chars with 10 -> 6 ST from 95%, 76%, 57%, 38%, 19% into 80%, 70%, 60%, 50%, 40%
                */
                if((target.Param[ST_STRENGTH]-2)*10+ target.Param[PE_SOLDIER]>Random(1,100)) // szansa na unikniecie KD od shotguna, dla ST=10 szansa =80% na unik
                {
                    isKo = false;
                }
                else
                {
                    if(GetDistantion(attack.Attacker.HexX, attack.Attacker.HexY, target.HexX, target.HexY) <= 10 && Random(1, 10) <= int(rounds))
                    isKo = true;
                }
            }
            else
            {
                if(GetDistantion(attack.Attacker.HexX, attack.Attacker.HexY, target.HexX, target.HexY) <= 10 && Random(1, 10) <= int(rounds))
                isKo = true;
            }
        }
    }
    else
    if(isBanhammer || isHolySpear)
    {
        isOffGame = true;
        isKo = true;
    }
	bool upgraded_crits = attacker.Param[PE_DRAGON2]>1 && Random(1,20)==1;
    // Clipped LLeg
    if(criple == 3)
    {
        target.ParamBase[DAMAGE_LEFT_LEG] = 1;
		if(upgraded_crits) target.ParamBase[DAMAGE_RIGHT_LEG] = 1;
        if(criteff != "")
					criteff += " and Cripple";
				else criteff += "Cripple";
        }
    // Clipped RLeg
    if(criple == 4)
    {
        target.ParamBase[DAMAGE_RIGHT_LEG] = 1;
		if(upgraded_crits) target.ParamBase[DAMAGE_LEFT_LEG] = 1;
        if(criteff != "")
					criteff += " and Cripple";
				else criteff += "Cripple";
        }
    // Clipped LArm
    if(criple == 1)
    {
        target.ParamBase[DAMAGE_LEFT_ARM] = 1;
		if(upgraded_crits) target.ParamBase[DAMAGE_RIGHT_ARM] = 1;
        if(criteff != "")
					criteff += " and Cripple";
				else criteff += "Cripple";
        }
    // Clipped RArm
    if(criple == 2)
    {
        target.ParamBase[DAMAGE_RIGHT_ARM] = 1;
		if(upgraded_crits) target.ParamBase[DAMAGE_LEFT_ARM] = 1;
		if(criteff != "")
					criteff += " and Cripple";
				else criteff += "Cripple";
        }
    // Blinded
    if(criple == 5)
    {
        target.ParamBase[DAMAGE_EYE] = 1;
		if(upgraded_crits) _SetTimeout(target, TO_SK_DOCTOR, REAL_SECOND(45));
        if(criteff != "")
					criteff += " and Blinded";
				else criteff += "Blinded";
        }

    // Lose turn
   /* if(FLAG(eff, HF_LOST_NEXT_TURN))
    {
        isKo = true;
        loseTurn = true;
        VerboseActionCombat(target, "Lost Turn");
    }*/

    // Knock out
    if(koeff)
    {
        //Log("Flaga jest HF_KNOCKOUT");
        isKo = true;
        knockOut = true;
        loseTurn = false;       // Overridden
        if(criteff != "")
					criteff += " and Knockout";
				else criteff += "Knockout";
    }

    // Instant death
    if(deatheff)
            {
            totalDmg = totalDmg + 100;
            if(criteff != "")
					criteff += " and Death";
				else criteff += "Death";
            }
	if(APdrain)
            {
			target.ParamBase[ST_CURRENT_AP] -= Random(2,4) * 100;
			if(criteff != "")
					criteff += " and AP Drain";
				else criteff += "AP Drain";
			}
	if(weapondestroyeff)
            {
			if(realWeapon.IsStackable())
			{
            if(realWeapon.GetCount() > 1)
                realWeapon.SetCount(realWeapon.GetCount() - 1);
			}
			else
			{
			Item@ realWeaponTarget = _CritGetItemHand(target);
			int wearProcent = Random(100,2500);
			if(valid(realWeaponTarget))
				{
				realWeaponTarget.Deterioration += wearProcent;
				realWeaponTarget.BrokenCount += wearProcent/100;
				realWeaponTarget.Update();
				}
			}
            if(criteff != "")
					criteff += " and Weapon Destroy";
				else criteff += "Weapon Destroy";
            }

	if(criteff != "")
		{
		
		VerboseActionCombat(target,criteff);
		}
    if(totalDmg > 0)
    {
        if(target.Param[MODE_INVULNERABLE] == 0)
        {

            /*********************************************************
             CHARGING TARGET'S TESLA ARMOR BASED ON RECIEVED EW DAMAGE
            **********************************************************/
            if(attack.DmgType == DAMAGE_LASER || attack.DmgType == DAMAGE_PLASMA || attack.DmgType == DAMAGE_ELECTR || attack.DmgType == DAMAGE_EMP)
            {
                Item@ targetsArmor = target.GetItem(0, SLOT_ARMOR);
                if(valid(targetsArmor) && targetsArmor.GetProtoId() == PID_TESLA_ARMOR)
                {
                    int recharge = totalDmg/4;
                    if(recharge > 0 && targetsArmor.Charge < targetsArmor.Proto.Misc_ChargeMax  && attackerIsPlayer)
                    {
                        targetsArmor.Charge += recharge;
                        if(targetsArmor.Charge > targetsArmor.Proto.Misc_ChargeMax)
                            targetsArmor.Charge = targetsArmor.Proto.Misc_ChargeMax;
                        targetsArmor.Update();
                        target.Say(SAY_NETMSG, "Charging armor with "+recharge+" charges.");
                        target.Say(SAY_NETMSG, "Charges: "+targetsArmor.Charge+"/"+targetsArmor.Proto.Misc_ChargeMax+".");
                    }
                }
            }
            //END
            //reflecting mk1
            uint16[] MetalArmor =
    {
        PID_METAL_ARMOR_MK_II
    };
            Item@ armorku = target.GetItem(0, SLOT_ARMOR);
            Item@ armorkuk = attacker.GetItem(0, SLOT_ARMOR);
            /*if(valid(armorku) && Present(armorku.GetProtoId(), MetalArmor) && target.IsPlayer())
            {
            bool reflectingOn = true;
            int reflecting = DAMAGE_LASER;
            int reflectingDmg = totalDmg * 0.8;
            switch(attack.DmgType)
            {
            case DAMAGE_LASER:
                {
                reflecting = DAMAGE_LASER;
                reflectingDmg = totalDmg * 0.8;
                break;
                }
            case DAMAGE_ELECTR:
                {
                reflecting = DAMAGE_ELECTR;
                reflectingDmg = totalDmg * 0.5;
                break;
                }
            case DAMAGE_NORMAL:
                {
                reflecting = DAMAGE_NORMAL;
                reflectingDmg = totalDmg * 0.1;
                break;
                }
            default:
                {
                reflectingOn = false;
                break;
                }
            }
            if(reflectingOn)
            {
            InjureCritter(attacker, reflectingDmg, reflecting, 0, 0);
            attacker.Say(SAY_NETMSG, "Metal Armor reflect damage.");
            target.Say(SAY_NETMSG, "Metal Armor reflect damage.");
            }
            */
            //}
            target.ParamBase[ST_CURRENT_HP] -= totalDmg;
            if(target.Param[ST_CURRENT_HP] < 1)
            {
                int deadHitPoints = target.Param[PE_DEAD_MAN_WALKING] > 0 ? __DeadHitPoints : __DeadHitPoints / 2;
                if(target.Param[ST_CURRENT_HP] > deadHitPoints && IsHumanoid(target) && target.Param[MODE_NO_KNOCK] == 0)
                {
                    isKo = true;
                    isBelow = true;
                }
                else
                    isDead = true;
            }
        }
        // Add leaderboard score
        if(attack.IsUnarmed && validAttacker && attackerIsPlayer)
            AddScore(attacker, SCORE_UNARMED_DAMAGE, totalDmg);
    }

    bool attackFront = true;
    uint dir = GetDirection(attack.Hx, attack.Hy, target.HexX, target.HexY);
    if((dir == target.Dir || ((dir + 1) % 6) == target.Dir || ((dir + 5) % 6) == target.Dir))
        attackFront = false;






    int   armorDr = 0;
	if(!attack.AimHead)
	{
	switch(dmgType)
		{
		case DAMAGE_NORMAL: targetDR = target.Param[ST_NORMAL_RESIST]; targetDT = target.Param[ST_NORMAL_ABSORB]; break;
		case DAMAGE_LASER: targetDR = target.Param[ST_LASER_RESIST]; targetDT = target.Param[ST_LASER_ABSORB]; break;
		case DAMAGE_FIRE: targetDR = target.Param[ST_FIRE_RESIST]; targetDT = target.Param[ST_FIRE_ABSORB]; break;
		case DAMAGE_PLASMA: targetDR = target.Param[ST_PLASMA_RESIST]; targetDT = target.Param[ST_PLASMA_ABSORB]; break;
		case DAMAGE_EXPLODE: targetDR = target.Param[ST_EXPLODE_RESIST]; targetDT = target.Param[ST_EXPLODE_ABSORB]; break;
		case DAMAGE_ELECTR: targetDR = target.Param[ST_ELECTRO_RESIST]; targetDT = target.Param[ST_ELECTRO_ABSORB]; break;
		case DAMAGE_EMP: targetDR = target.Param[ST_EMP_RESIST]; targetDT = target.Param[ST_EMP_ABSORB]; break;
		}
	}
	else
	{
	switch(dmgType)
		{
		case DAMAGE_NORMAL: targetDR = target.Param[ST_HEAD_NORMAL]; targetDT = target.Param[ST_NORMAL_ABSORB]; break;
		case DAMAGE_LASER: targetDR = target.Param[ST_HEAD_LASER]; targetDT = target.Param[ST_LASER_ABSORB]; break;
		case DAMAGE_FIRE: targetDR = target.Param[ST_HEAD_FIRE]; targetDT = target.Param[ST_FIRE_ABSORB]; break;
		case DAMAGE_PLASMA: targetDR = target.Param[ST_HEAD_PLASMA]; targetDT = target.Param[ST_PLASMA_ABSORB]; break;
		case DAMAGE_EXPLODE: targetDT = target.Param[ST_EXPLODE_ABSORB]; break;
		case DAMAGE_ELECTR: targetDR = target.Param[ST_HEAD_ELECTRO]; targetDT = target.Param[ST_ELECTRO_ABSORB]; break;
		case DAMAGE_EMP: targetDR = target.Param[ST_HEAD_EMP]; targetDT = target.Param[ST_EMP_ABSORB]; break;
		}
	}
    Item@ armor_ = _GetCritterArmor(target, attack.AimHead);


    if(valid(armor_) && targetIsPlayer)
    {
        if(attackerIsPaszczur)
        {
            WearItem(target, armor_, ((100 - armorDr) * rounds + 2 * totalDmg) / 3);
        }
        else
            WearItem(target, armor_, rounds);
    }

    // 30-08-2013 Cubik: Banhammer effect - kick player from game
    if(isOffGame)
    {
        if(target.IsPlayer()) target.Disconnect();
    }

    // Dead
    if(isDead)
    {
        bool burst = attack.IsBurst;
        uint anim2Dead = 0;

        if(target.IsKnockout())
        {
            if(target.Anim2Knockout == ANIM2_IDLE_PRONE_FRONT)
                anim2Dead = ANIM2_DEAD_PRONE_FRONT;
            else
                anim2Dead = ANIM2_DEAD_PRONE_BACK;
        }
        else
        {
            if(attackFront)
                anim2Dead = ANIM2_DEAD_FRONT;
            else
                anim2Dead = ANIM2_DEAD_BACK;

            switch(dmgType)
            {
            case DAMAGE_UNCALLED:
                break;
            case DAMAGE_NORMAL:
                if(burst)
                {
                    if(isCritical || isBloodyMess)
                        anim2Dead = ANIM2_DEAD_BLOODY_BURST;
                    else
                        anim2Dead = ANIM2_DEAD_BURST;
                }
                else
                {
                    if(isCritical || isBloodyMess)
                        anim2Dead = ANIM2_DEAD_BLOODY_SINGLE;
                }
                break;
            case DAMAGE_LASER:
                anim2Dead = ANIM2_DEAD_LASER;
                break;
            case DAMAGE_FIRE:
                if(isCritical || isBloodyMess)
                {
                    if(isBloodyMess || Random(0, 3) == 0)
                        anim2Dead = ANIM2_DEAD_BURN_RUN;
                    else
                        anim2Dead = ANIM2_DEAD_BURN;
                }
                else
                    anim2Dead = ANIM2_DEAD_BURN;
                break;
            case DAMAGE_PLASMA:
                anim2Dead = ANIM2_DEAD_FUSED;
                break;
            case DAMAGE_ELECTR:
                if(Random(0, 1) == 0)
                    anim2Dead = ANIM2_DEAD_PULSE;
                else
                    anim2Dead = ANIM2_DEAD_PULSE_DUST;
                break;
            case DAMAGE_EXPLODE:
                anim2Dead = ANIM2_DEAD_EXPLODE;
                break;
            default:
                break;
            }
            if(target.Param[MODE_SPECIAL_DEAD] != 0)
            {
                target.SetDir(0);
                anim2Dead = ANIM2_DEAD_EXPLODE;
            }
        }
        //if(target.IsPlayer() && attacker.Param[PE_KILLER] > 0)
        //  attacker.ParamBase[ST_CURRENT_AP] += 20;
        if(targetIsPlayer && target.GetMap().GetProtoId() != MAP_Arena)
            AddScore(target, SCORE_ZOMBY, 1);
        if(validAttacker && attackerIsPlayer && attacker.GetMap().GetProtoId() != MAP_Arena)
        {
            AddScore(attacker, SCORE_KILLER, 1);
            if(targetIsPlayer && attacker.GetIp() != target.GetIp())
            {
                AddScore(attacker, SCORE_MANIAC, 1);
            }
            else if(target.Id == attack.TargetId)
                target.AddEnemyInStack(attacker.Id);
        }

        if(validAttacker && !attackerIsPlayer)
            attacker.EraseEnemyFromStack(target.Id);
			
		if(anim2Dead == ANIM2_DEAD_BURST && target.Param[ST_CURRENT_HP] <= -100)
            target.ToDead(ANIM2_DEAD_BLOODY_BURST, attacker);
        else
            target.ToDead(anim2Dead, attacker);	
        if(valid(attacker))
        {
            // OLD VERSION
            /*
            if(bt != BT_MEN && bt != BT_WOMEN && bt != BT_SUPER_MUTANT && bt != BT_GHOUL && bt != BT_CHILDREN && bt != BT_BRAHMIN || !IsTown(map))
                attacker.ParamBase[ST_EXPERIENCE] += target.Param[ST_KILL_EXPERIENCE];
            attacker.ParamBase[KILL_BEGIN + bt]++;
            if(target.IsNpc())
                LogExperience(attacker, target.Param[ST_KILL_EXPERIENCE], valid(realWeapon) ? realWeapon.Proto.Weapon_Skill_0 : SK_UNARMED, "Kill", target.GetProtoId()); // may cause errors with spear
            */
            //_OLD VERSION_
			int spree = 0;
		if(valid(realWeapon) && realWeapon.Val3 == WP_KILLING  && valid(attacker) && attacker.IsPlayer()) spree += getSpree(attacker.Param[ST_ACTION_POINTS],3);
		if(valid(realWeapon) && realWeapon.Val4 == WP_KILLING && valid(attacker)&& attacker.IsPlayer()) spree += getSpree(attacker.Param[ST_ACTION_POINTS],3);
		if(valid(realWeapon) && realWeapon.Val5 == WP_KILLING && valid(attacker)&& attacker.IsPlayer()) spree += getSpree(attacker.Param[ST_ACTION_POINTS],3);
		if(valid(realWeapon) && realWeapon.Val6 == WP_KILLING && valid(attacker)&& attacker.IsPlayer()) spree += getSpree(attacker.Param[ST_ACTION_POINTS],3);
		if(valid(realWeapon) && realWeapon.Val7 == WP_KILLING && valid(attacker)&& attacker.IsPlayer()) spree += getSpree(attacker.Param[ST_ACTION_POINTS],3);
		if(valid(realWeapon) && realWeapon.Val8 == WP_KILLING && valid(attacker)&& attacker.IsPlayer()) spree += getSpree(attacker.Param[ST_ACTION_POINTS],3);

		

		if(valid(attacker)&& attacker.IsPlayer() )
		if(target.IsNpc() && attacker.Param[PE_KILLER] > 0)
			spree += getSpree(attacker.Param[ST_ACTION_POINTS],3);

		if(valid(attacker) && attacker.IsPlayer())
		if(attacker.Trait[TRAIT_BLOODY_MESS] > 0)
			spree += getSpree(attacker.Param[ST_ACTION_POINTS],3);
			
		if(target.IsPlayer() && attacker.Param[PE_KILLER] > 0 && valid(attacker) && attacker.IsPlayer())
		{
			spree = attacker.Param[ST_ACTION_POINTS];
			attacker.ParamBase[ST_CURRENT_HP] = attacker.Param[ST_MAX_LIFE];
		}
		
		if(spree>0)
		{
			array<uint> spreedata = { spree, attacker.Id };
			CreateTimeEvent(AFTER(REAL_MS(100)), "e_KillingSpree", spreedata, true);
			//Log("spree : " + spree);
		//	attacker.ParamBase[ST_CURRENT_AP] += spree * 100;
		//	attacker.ParamBase[ST_CURRENT_AP] -= 1;
		//	attacker.ParamBase[ST_CURRENT_AP] += 1; //fix
		//	Log("AP FINAL FIX : " + attacker.ParamBase[ST_CURRENT_AP]);
		}
            //_NEW VERSION_
            if(IsTown(map))
            {
				Item@ armorexp = _GetCritterArmor(attack.Attacker, attack.AimHead);
                if((bt != BT_MEN && bt != BT_WOMEN && bt != BT_SUPER_MUTANT && bt != BT_GHOUL && bt != BT_CHILDREN && bt != BT_BRAHMIN)
                || ( IsTownRole == 200 || IsTownRole == 201 || IsTownRole == 202 || IsTownRole == 203))
					{
                    attacker.ParamBase[ST_EXPERIENCE] += target.Param[ST_KILL_EXPERIENCE]*(GetGvar(GVAR_experience_multipler_kill))*(GetGvar(GVAR_experience_multipler));
					
					if(valid(realWeapon)  && !realWeapon.IsStackable())
                        {
                        realWeapon.Val0 += target.Param[ST_KILL_EXPERIENCE]*(GetGvar(GVAR_experience_multipler_kill))*(GetGvar(GVAR_experience_multipler));
						realWeapon.Val0 *= 1 + ((attacker.Param[ST_LUCK] * 3)/100);
                        realWeapon.Update();
                        _weapon_perk(realWeapon, false);
                        }
                        if(valid(armorexp))
                        {
                        armorexp.Val0 += target.Param[ST_KILL_EXPERIENCE]*(GetGvar(GVAR_experience_multipler_kill))*(GetGvar(GVAR_experience_multipler));
                        armorexp.Update();
                        _armor_perk(armorexp, false);
                        }
					}
            }
            else
            {
                // VERSION3 - all alive players who see killed critter and are grouped by follow tags
                if(attackerIsPlayer)
                {
                    array<Critter@> playersToShare;
                    int             cnt = 0;
                    int             exp = 0;
                    int             expDiv = 0;

                    //players who see killed critter
                    cnt = target.GetCritters(true, FIND_LIFE | FIND_ONLY_PLAYERS, playersToShare);
                    if(cnt > 0)
                    {
                        //filter players who are following me or my leader
                        Critter@ myLeader = attacker.GetFollowLeader();
                        for(int i=0; i < cnt; ++i)
                        {
							
                            ++expDiv;
                            //player is attacker
                            if(playersToShare[i].Id == attacker.Id)
                                continue;

                            //player is followed by attacker
                            if(valid(myLeader) && playersToShare[i].Id == myLeader.Id)
                                continue;

                            Critter@ tmpLeader = playersToShare[i].GetFollowLeader();
                            //player is following attacker
                            if(valid(tmpLeader) && attacker.Id == tmpLeader.Id)
                                continue;

                            //player is following attacker's leader
                            if(valid(tmpLeader) && valid(myLeader) && tmpLeader.Id == myLeader.Id)
                                continue;

                            //no match - remove player from array
                            playersToShare.removeAt(i);
                            --i;
                            --cnt;
                            --expDiv;
                        }

                        if(expDiv > 0)
							{
                            exp = target.Param[ST_KILL_EXPERIENCE]/expDiv;
							Item@ armorexp = _GetCritterArmor(attack.Attacker, attack.AimHead);
                        //Item@ weaponexp = attack.Attacker.GetItem(0, SLOT_HAND1);
                        if(valid(realWeapon)  && !realWeapon.IsStackable())
                        {
                        realWeapon.Val0 += target.Param[ST_KILL_EXPERIENCE]*(GetGvar(GVAR_experience_multipler_kill))*(GetGvar(GVAR_experience_multipler));
                        realWeapon.Update();
                        _weapon_perk(realWeapon, false);
                        }
                        if(valid(armorexp))
                        {
                        armorexp.Val0 += target.Param[ST_KILL_EXPERIENCE]*(GetGvar(GVAR_experience_multipler_kill))*(GetGvar(GVAR_experience_multipler));
                        armorexp.Update();
                        _armor_perk(armorexp, false);
                        }
							}
                        else
                            exp = 0;
                        Item@ armorexp = _GetCritterArmor(attack.Attacker, attack.AimHead);
                        //Item@ weaponexp = attack.Attacker.GetItem(0, SLOT_HAND1);
                        if(valid(realWeapon)  && !realWeapon.IsStackable())
                        {
                        realWeapon.Val0 += target.Param[ST_KILL_EXPERIENCE]*(GetGvar(GVAR_experience_multipler_kill))*(GetGvar(GVAR_experience_multipler));
                        realWeapon.Update();
                        _weapon_perk(realWeapon, false);
                        }
                        if(valid(armorexp)  && !realWeapon.IsStackable())
                        {
                        armorexp.Val0 += target.Param[ST_KILL_EXPERIENCE]*(GetGvar(GVAR_experience_multipler_kill))*(GetGvar(GVAR_experience_multipler));
                        armorexp.Update();
                        _armor_perk(armorexp, false);
                        }
                        if(exp > 0)
                        {
                            for(int i=0; i < expDiv; ++i)
                            {
							Item@ sharedweapon = playersToShare[i].GetItem(0, SLOT_HAND1);
							Item@ sharedarmor = playersToShare[i].GetItem(0, SLOT_ARMOR);
                                if(playersToShare[i].Id == attacker.Id && expDiv > 1)
									{
                                    playersToShare[i].ParamBase[ST_EXPERIENCE] += exp*1.25*(GetGvar(GVAR_experience_multipler_kill))*(GetGvar(GVAR_experience_multipler));  
									if(valid(sharedweapon)  && !sharedweapon.IsStackable())
									{
									sharedweapon.Val0 += exp*1.25*(GetGvar(GVAR_experience_multipler_kill))*(GetGvar(GVAR_experience_multipler));
									sharedweapon.Update();
									_weapon_perk(sharedweapon, false);
									}
									if(valid(sharedarmor)  && !sharedarmor.IsStackable())
									{
									sharedarmor.Val0 += exp*1.25*(GetGvar(GVAR_experience_multipler_kill))*(GetGvar(GVAR_experience_multipler));
									sharedarmor.Update();
									_armor_perk(sharedarmor, false);
									}
									}
									//killer gets 25% bonus exp when in group
                                else
									{
                                    playersToShare[i].ParamBase[ST_EXPERIENCE] += exp*(GetGvar(GVAR_experience_multipler_kill))*(GetGvar(GVAR_experience_multipler));
									if(valid(sharedweapon)  && !sharedweapon.IsStackable())
									{
									sharedweapon.Val0 += exp*1.25*(GetGvar(GVAR_experience_multipler_kill))*(GetGvar(GVAR_experience_multipler));
									sharedweapon.Update();
									_weapon_perk(sharedweapon, false);
									}
									if(valid(sharedarmor)  && !sharedarmor.IsStackable())
									{
									sharedarmor.Val0 += exp*1.25*(GetGvar(GVAR_experience_multipler_kill))*(GetGvar(GVAR_experience_multipler));
									sharedarmor.Update();
									_armor_perk(sharedarmor, false);
									}
									}
                            }
                        }
                    }
                }
                else
                {
					Item@ armorexp = _GetCritterArmor(attack.Attacker, attack.AimHead);
                        //Item@ weaponexp = attack.Attacker.GetItem(0, SLOT_HAND1);
                        if(valid(realWeapon)  && !realWeapon.IsStackable())
                        {
                        realWeapon.Val0 += target.Param[ST_KILL_EXPERIENCE]*(GetGvar(GVAR_experience_multipler_kill))*(GetGvar(GVAR_experience_multipler));
                        realWeapon.Update();
                        _weapon_perk(realWeapon, false);
                        }
                        if(valid(armorexp)  && !realWeapon.IsStackable())
                        {
                        armorexp.Val0 += target.Param[ST_KILL_EXPERIENCE]*(GetGvar(GVAR_experience_multipler_kill))*(GetGvar(GVAR_experience_multipler));
                        armorexp.Update();
                        _armor_perk(armorexp, false);
                        }
                    attacker.ParamBase[ST_EXPERIENCE] += target.Param[ST_KILL_EXPERIENCE]*(GetGvar(GVAR_experience_multipler_kill))*(GetGvar(GVAR_experience_multipler));
                }

                // _VERSION3_

            }


            if(target.IsPlayer())
            {
                attacker.ParamBase[KILL_BEGIN + BT_PLAYER]++;       // Player kill counter
            }

            attacker.ParamBase[KILL_BEGIN + bt]++;   // Everything else

            if(target.IsNpc())
                LogExperience(attacker, target.Param[ST_KILL_EXPERIENCE]*(GetGvar(GVAR_experience_multipler_kill))*(GetGvar(GVAR_experience_multipler)), valid(realWeapon) ? realWeapon.Proto.Weapon_Skill_0 : SK_UNARMED, "Kill", target.GetProtoId()); // may cause errors with spear
            //_NEW VERSION_
        }

        
    }
    else
    if(isKo)
    {
        //Log("isKo = True");
        int  maxAp = target.Param[ST_ACTION_POINTS];
        int  currentAp = target.Param[ST_CURRENT_AP];
        int  targetAp = currentAp;
        bool quick = target.Param[PE_QUICK_RECOVERY] > 0;
		bool upgraded_crits = attacker.Param[PE_DRAGON2]>1;
        if(loseTurn)
        {
            targetAp = quick ? -maxAp / 3 : -maxAp;
            target.ParamBase[ST_MOVE_AP] = 0;
        }

        if(knockOut)
            {
			uint apdiv = 1;
			if(upgraded_crits && Random(1,20)==1)
				apdiv = 2;
             targetAp = quick ? -Random(5, (25 - target.Param[ST_AGILITY])*apdiv) / 3 : -Random(10, (30 - target.Param[ST_AGILITY])*apdiv);
            VerboseActionCombat(target, "Knockout");
            }

        if(knockDown && !(target.IsKnockout() && map.IsTurnBased()))
			{
			uint apdiv = 1;
			if(upgraded_crits && Random(1,20)==1)
				apdiv = 2;
            targetAp -= quick ? 1*apdiv : 3*apdiv;
			}
        if((isBelow || knockOut || knockDown || dmgType == DAMAGE_EXPLODE || isShotgun ) && !target.IsKnockout() && target.Param[MODE_NO_KNOCK] == 0)
        {
            //Log("jest knockOut albo knockDown");
            int knockDist = knockDmg;
            //Log("knockDist = " + knockDist);
            bool haveknockbackperk = false;
			if(valid(realWeapon) && realWeapon.Val3 == WP_KNOCKBACK) haveknockbackperk = true;
            if(valid(realWeapon) && realWeapon.Val4 == WP_KNOCKBACK) haveknockbackperk = true;
            if(valid(realWeapon) && realWeapon.Val5 == WP_KNOCKBACK) haveknockbackperk = true;
            if(valid(realWeapon) && realWeapon.Val6 == WP_KNOCKBACK) haveknockbackperk = true;
            if(valid(realWeapon) && realWeapon.Val7 == WP_KNOCKBACK) haveknockbackperk = true;
            if(valid(realWeapon) && realWeapon.Val8 == WP_KNOCKBACK) haveknockbackperk = true;
            if((dmgType == DAMAGE_EXPLODE || attack.WeaponSubtype == WS_MELEE || haveknockbackperk) && target.IsCanWalk())
            {
                //Log(" bron jest WS_MELEE");
                if(haveknockbackperk)
                    knockDist /= 5;
                else
                    knockDist /= 10;
                if(target.Param[PE_STONEWALL] != 0)
                    knockDist /= 2;
                knockDist--;
//Log("knockDist = " + knockDist);
                if(knockDist > 10)
                    knockDist = 10;
                uint16 knockHx = attack.Hx;
                uint16 knockHy = attack.Hy;
                if(knockDist > 0)
                {
                    map.GetHexCoordWall(target.HexX, target.HexY, knockHx, knockHy, 180.0f, knockDist);
                    target.ToKnockout(KNOCKOUT_ANIM2_DEFAULT(attackFront), 0, knockHx, knockHy);
                }
                else
                    target.ToKnockout(KNOCKOUT_ANIM2_DEFAULT(attackFront), 0, target.HexX, target.HexY);
            }
            else
                target.ToKnockout(KNOCKOUT_ANIM2_DEFAULT(attackFront), 0, target.HexX, target.HexY);
        }
        if(targetAp < currentAp)
            target.ParamBase[ST_CURRENT_AP] = 100 * targetAp;
    }

    // Damage
    else if(!(target.IsKnockout() || FLAG(target.Param[MODE_EXT], MODE_EXT_NO_HIT_ANIM)))
    {
        // Animate hit
        if(attack.ShowHitAnimForce)
            target.Action(ACTION_DAMAGE_FORCE, attackFront ? 0 : 1, null);
        else
            target.Action(ACTION_DAMAGE, attackFront ? 0 : 1, null);

        // Npc hit message
        if(isCombatText && dmgType != DAMAGE_UNCALLED && !targetIsPlayer)
        {
            switch(aim)
            {
            case HIT_LOCATION_NONE:
            case HIT_LOCATION_UNCALLED:
            case HIT_LOCATION_TORSO:
                AI_TrySayCombatText(target, COMBAT_TEXT_HIT_TORSO);
                break;
            case HIT_LOCATION_EYES:
                AI_TrySayCombatText(target, COMBAT_TEXT_HIT_EYES);
                break;
            case HIT_LOCATION_HEAD:
                AI_TrySayCombatText(target, COMBAT_TEXT_HIT_HEAD);
                break;
            case HIT_LOCATION_LEFT_ARM:
                AI_TrySayCombatText(target, COMBAT_TEXT_HIT_LEFT_ARM);
                break;
            case HIT_LOCATION_RIGHT_ARM:
                AI_TrySayCombatText(target, COMBAT_TEXT_HIT_RIGHT_ARM);
                break;
            case HIT_LOCATION_GROIN:
                AI_TrySayCombatText(target, COMBAT_TEXT_HIT_GROIN);
                break;
            case HIT_LOCATION_RIGHT_LEG:
                AI_TrySayCombatText(target, COMBAT_TEXT_HIT_RIGHT_LEG);
                break;
            case HIT_LOCATION_LEFT_LEG:
                AI_TrySayCombatText(target, COMBAT_TEXT_HIT_LEFT_LEG);
                break;
            default:
                break;
            }
        }
    }

    bool isAimed = (aim != HIT_LOCATION_NONE) && (aim != HIT_LOCATION_TORSO) && (aim != HIT_LOCATION_UNCALLED);

    uint mainMsg = CMSG_HIT;
    uint length = 4;

    if(isCritical)
    {
        mainMsg += 2;
        length += 2;
    }
    if(isDead)
    {
        mainMsg += 4;
        // if(isCritical) length-=1;
    }
    if(isAimed)
    {
        mainMsg += 1;
        length += 1;
    }

    array<uint> sendEff(length);
    sendEff[0] = mainMsg;
    sendEff[1] = target.Id;
    sendEff[2] = (valid(attacker))?attacker.Id:0;
    uint now = 3;
//Log("SENDEFF "+sendEff[0]+" "+sendEff[1]+" "+sendEff[2]);
    if(isAimed)
    {
        sendEff[now] = aim;
        now++;
    }

    sendEff[now] = totalDmg;
    now++;

    if(isCritical)
    {
        sendEff[now] = msgEff;
        now++;
        sendEff[now] = extraMessage;
    }

    Critter@[] source = { target };
    array<Critter@> crits;

    if(@target.GetMap() != null)
    {
        target.GetMap().GetCrittersSeeing(source, true, FIND_ALL | FIND_ONLY_PLAYERS, crits);

        for(int i = 0, j = crits.length(); i < j; i++)
            if(crits[i].Id != target.Id)
                AddEff(crits[i], sendEff, results);
    }
    if(isCritical)
        sendEff[now] = extraMessage + 1500;              // men_player - men_npc

    AddEff(target, sendEff, results);

    // Poisoning and irradiating:
    if(validAttacker)
    {
 if(valid(realWeapon) && realWeapon.Val3 == WP_POISON && target.Param[PE_BOSS]==0) AffectPoison(target, Random(10, 40));
    if(valid(realWeapon) && realWeapon.Val4 == WP_POISON && target.Param[PE_BOSS]==0) AffectPoison(target, Random(10, 40));
    if(valid(realWeapon) && realWeapon.Val5 == WP_POISON && target.Param[PE_BOSS]==0) AffectPoison(target, Random(10, 40));
    if(valid(realWeapon) && realWeapon.Val6 == WP_POISON && target.Param[PE_BOSS]==0) AffectPoison(target, Random(10, 40));
    if(valid(realWeapon) && realWeapon.Val7 == WP_POISON && target.Param[PE_BOSS]==0) AffectPoison(target, Random(10, 40));
    if(valid(realWeapon) && realWeapon.Val8 == WP_POISON && target.Param[PE_BOSS]==0) AffectPoison(target, Random(10, 40));

    int lifesteal = 0;
	if(valid(realWeapon) && realWeapon.Val3 == WP_LIFE_STEAL) lifesteal += totalDmg/4;
    if(valid(realWeapon) && realWeapon.Val4 == WP_LIFE_STEAL) lifesteal += totalDmg/4;
    if(valid(realWeapon) && realWeapon.Val5 == WP_LIFE_STEAL) lifesteal += totalDmg/4;
    if(valid(realWeapon) && realWeapon.Val6 == WP_LIFE_STEAL) lifesteal += totalDmg/4;
    if(valid(realWeapon) && realWeapon.Val7 == WP_LIFE_STEAL) lifesteal += totalDmg/4;
    if(valid(realWeapon) && realWeapon.Val8 == WP_LIFE_STEAL) lifesteal += totalDmg/4;
	
	if(attacker.Param[PE_VAMPIRE]>0 && (attack.WeaponSubtype==WS_MELEE ||  attack.WeaponSubtype == WS_UNARMED)) lifesteal += totalDmg/4;
	
	if(attacker.Param[PE_KILLER] > 0) lifesteal += totalDmg/10;
	
	if(attacker.Param[ST_POISONING_LEVEL] > 0)
		lifesteal = lifesteal * HEAL_REDUCE;
	if(attackerIsPlayer)
    attacker.ParamBase[ST_CURRENT_HP] += lifesteal;
    if(attacker.Param[ST_CURRENT_HP] > attacker.Param[ST_MAX_LIFE])
                attacker.ParamBase[ST_CURRENT_HP] = attacker.Param[ST_MAX_LIFE];
    BloodCreateByDamage(target, totalDmg, dmgType);
    if(ammoPid==PID_RAD_ROCKET && target.Param[PE_BOSS]==0 && attacker.IsPlayer())
        AffectRadiation(target, Random(300, 750));
        if(valid(realWeapon) && (ammoPid == PID_HN_NEEDLER_CARTRIDGE) && target.Param[PE_BOSS]==0)
        {
            AffectPoison(target, Random(40, 100));
        }
        else
        if(valid(realWeapon) && (ammoPid == PID_HN_AP_NEEDLER_CARTRIDGE) && target.Param[PE_BOSS]==0)
        {
            AffectPoison(target, Random(1, 5));
        }

        else
        if(valid(realWeapon) && (ammoPid == PID_HN_HEAL_NEEDLER_CARTRIDGE)  && attackerIsPlayer)
        {
            int ileleczy = 0;
            if(target.Param[PE_PRIEST]==0)
            ileleczy = Random(25,130) * (1 + attacker.Param[PE_PRIEST]);
            else ileleczy = Random(25,130) * (1 + target.Param[PE_PRIEST]);
			if(target.Param[ST_POISONING_LEVEL] > 0)
				ileleczy = ileleczy * HEAL_REDUCE;
            target.ParamBase[ST_CURRENT_HP] += ileleczy;
			if(attacker.Param[PE_HEALER]>0 && attacker.Param[PE_MEDIC]>0 && attacker.Param[PE_LIVING_ANATOMY]>0)
				attacker.ParamBase[ST_CURRENT_HP] += ileleczy/2;
            target.Say(SAY_NETMSG, "You got heal for " + ileleczy + " Hit points");
            attacker.Say(SAY_NETMSG, "You heal " + target.Name + " for " + ileleczy+ " Hit points");
			if(target.IsPlayer())
				attacker.ParamBase[WE_RANKED_GAME] += ileleczy;
            if(target.Param[ST_CURRENT_HP] > target.Param[ST_MAX_LIFE])
                target.ParamBase[ST_CURRENT_HP] = target.Param[ST_MAX_LIFE];
        }
        else
        if(valid(realWeapon) && (realWeapon.Proto.ProtoId == PID_PASHTSHUUR_SPIKE) && target.Param[PE_BOSS]==0)
        {
            AffectPoison(target, Random(1, 5));
        }
        else
        {
            int poison = attacker.Param[ST_TOXIC];
            int radiation = attacker.Param[ST_RADIOACTIVE];
            if(poison != 0 || radiation != 0)
            {
                if(Random(2, 21) > target.Param[ST_LUCK])
                {
                    if(poison > 0 && target.Param[PE_BOSS]==0)
                        AffectPoison(target, Random(poison / 3, poison));
                    if(radiation > 0)
                        AffectRadiation(target, Random(radiation / 3, radiation));
                }
            }
            else
            {
                int attackerBt = attacker.Param[ST_BODY_TYPE];
                if(attackerBt == BT_RADSCORPION || attackerBt == BT_FLOATER || attackerBt == BT_ALIEN || attackerBt == BT_CENTAUR && target.Param[PE_BOSS]==0)
                {
                    if(Random(2, 21) > target.Param[ST_LUCK])
                    {
                        if(attackerBt == BT_RADSCORPION)
                            AffectPoison(target, Random(3, 15));
                        else if(attackerBt == BT_FLOATER)
                            AffectPoison(target, Random(10, 40));
                        else if(attackerBt == BT_ALIEN)
                            AffectRadiation(target, Random(10, 40));
                        else if(attackerBt == BT_CENTAUR)
                        {
                            AffectPoison(target, Random(10, 20));
                            AffectRadiation(target, Random(10, 20));
                        }
                    }
                }
            }
        }
    }
	if(attack.DmgType == DAMAGE_EXPLODE && target.Param[PE_IRON_GRIP] == 0)
		{
		if(Random(75,250) < totalDmg)
			{
			switch(Random(1,4))
				{
				case 1: target.ParamBase[DAMAGE_LEFT_ARM] = 1; break;
				case 2: target.ParamBase[DAMAGE_RIGHT_ARM] = 1; break;
				case 3: target.ParamBase[DAMAGE_LEFT_LEG] = 1; break;
				case 4: target.ParamBase[DAMAGE_RIGHT_LEG] = 1; break;
				}
			}
		}
		
	if(attack.DmgType == DAMAGE_ELECTR && attack.Attacker.Id != NPC_DAMAGE)
		{
		target.ParamBase[ARMOR_WEAKER] += 2;
		}
	if(attack.DmgType == DAMAGE_FIRE && attack.Attacker.IsPlayer())
	{	
		if(valid(realWeapon) && (realWeapon.Proto.ProtoId != PID_SOLAR_SCORCHER))
			target.ParamBase[ST_BURN_STACK] = Random(1,10);
		if(valid(realWeapon) && (realWeapon.Proto.ProtoId == PID_SOLAR_SCORCHER))
			target.ParamBase[ST_BURN_STACK] = 1;
		target.ParamBase[ST_BURN_LAST_ENEMY_ID] = attack.Attacker.Id;
		target.AddTimeEvent("cte_Burn",GetBurnDuration(target),CTE_BURN);
	}
	if(attacker.IsPlayer() && target.IsPlayer() && attacker.ParamBase[ST_NPC_ROLE] > 203)
	{
		attacker.ParamBase[WE_RANKED_GAME] += totalDmg;
		target.ParamBase[WE_RANKED_GAME] -= totalDmg;
	
	}
    LogDamage(map, attacker, target, realWeapon, attack.Ammo, aim, attack.IsBurst, totalDmg, isCritical, eff, rounds);
    PostDamage(target);
}


void CommenceExplosion(AttackStruct& attack, Map@ map, uint16 tx, uint16 ty, Critter@ target, uint weapPid, bool isCritical, uint intentionallyId, bool isRocket, array<CombatRes>& results, bool isExplodeRocket)
{
    uint radius = 2;
    if(isRocket) radius = isExplodeRocket?4:3;


    if(weapPid == PID_DYNACORD || weapPid == PID_EL_ROCKET_LAUNCHER)
        radius = 4;
    //nowy wybuch molotova z fire_hexes - worldremaker 26.03.2017
    if(weapPid==PID_MOLOTOV_COCKTAIL  || attack.ammoPid == PID_40MM_GRENADE_FIRE)
    {
        MolotovBlast( map, tx, ty, PID_FIRE_HEX, ( valid( attack.Attacker ) ? attack.Attacker.Id : 0 ) );
        map.RunEffect(PID_EXPLODE_FIRE_BIG, tx, ty, 2);
    }
	else if((weapPid==PID_PLASMA_GRENADE && attack.Attacker.Param[PE_PYROMANIAC]>1))
	{
		MolotovBlast( map, tx, ty, PID_FIRE_HEX, ( valid( attack.Attacker ) ? attack.Attacker.Id : 0 ) );
        map.RunEffect(PID_EXPLODE_FIRE_BIG, tx, ty, 2);
	}
    else if(weapPid == PID_FRAG_GRENADE || weapPid == PID_HOLY_HAND_GRENADE)
        map.RunEffect(PID_EXPLODE_FIRE_SMALL, tx, ty, 2);
    else if(weapPid == PID_PULSE_GRENADE || weapPid == PID_SHOCK_GRENADE)
        map.RunEffect(PID_EXPLODE_EMP, tx, ty, 2);
    else if((weapPid == PID_PLASMA_GRENADE || weapPid == PID_FAKE_PLASMA_GRENADE && attack.Attacker.Param[PE_PYROMANIAC]!=2)  || attack.ammoPid == PID_40MM_GRENADE_ICE)
        map.RunEffect(PID_EXPLODE_PLASMA, tx, ty, 2);
    else if(isRocket && weapPid != PID_EL_ROCKET_LAUNCHER && attack.ammoPid != PID_40MM_GRENADE_ICE)
        map.RunEffect(PID_EXPLODE_ROCKET, tx, ty, 1);
    else if(weapPid == PID_DYNACORD)
        map.RunEffect(PID_EXPLODE_FIRE_BIG, tx, ty, 3);
    else if(weapPid == PID_EL_ROCKET_LAUNCHER)
        map.RunEffect(PID_EXPLODE_EMP, tx, ty, 4);
    else if(weapPid == PID_BOSS_RIFLE)
        map.RunEffect(PID_EXPLODE_EMP, tx, ty, 2);
    else
		{
		if(attack.DmgType == DAMAGE_EXPLODE)
			map.RunEffect(PID_EXPLODE_FIRE_BIG, tx, ty, 2);
		else return;
		}
    // Explosion sound. this could use some rework./
    string     soundName = "WHN1XXX1.ACM";
    ProtoItem@ proto = GetProtoItem(weapPid);
    if(valid(proto))
        soundName.rawSet( 2, proto.Weapon_SoundId_0 );
    map.PlaySound(soundName, tx, ty, 50);

    array<Critter@> critsHit;
    map.GetCrittersHex(tx, ty, radius, FIND_LIFE_AND_KO, critsHit);
    bool            validTarget = valid(target);
    uint            targetId = 0;
    bool            intentionally = (valid(attack.Attacker) && !_IsTrueNpc(attack.Attacker)) || targetId == intentionallyId;

    if(validTarget)
    {
        targetId = target.Id;
        int CriticalChance;
        if(isCritical) CriticalChance=100;
        ApplyDamage(attack, target, 1, isCritical, intentionally, results, CriticalChance);
        // tutaj juÅ¼ powinno byc tak, Å¼e zaczyna typa palic i chuj
        if(weapPid==PID_MOLOTOV_COCKTAIL || attack.ammoPid == PID_40MM_GRENADE_FIRE  || (weapPid==PID_PLASMA_GRENADE && attack.Attacker.Param[PE_PYROMANIAC]>1))
        {
            target.ParamBase[ST_BURN_STACK]+=ADD_BURN_STACK;
            if(target.Param[ST_BURN_STACK]>MAX_BURN_STACK) target.ParamBase[ST_BURN_STACK]=MAX_BURN_STACK;
            target.ParamBase[ST_BURN_LAST_ENEMY_ID]=attack.Attacker.Id;
            //target.AddTimeEvent("cte_Burn",GetBurnDuration(target),CTE_BURN);
        }
    }

    attack.Hx = tx;
    attack.Hy = ty;

    for(int i = 0, j = critsHit.length(); i < j; i++)
        if(!validTarget || targetId != critsHit[i].Id)
            {
             ApplyDamage(attack, critsHit[i], 1, false, intentionally, results, 0);
            // no i jesli jest typ lezy na nokaucie to ma go grzebac jak wikinga :D burn baby, burn kurwa
            if(weapPid==PID_MOLOTOV_COCKTAIL  || attack.ammoPid == PID_40MM_GRENADE_FIRE  || (weapPid==PID_PLASMA_GRENADE && attack.Attacker.Param[PE_PYROMANIAC]>1))
            {
                map.GetCrittersHex(tx, ty, radius, FIND_LIFE_AND_KO, critsHit);
                critsHit[i].ParamBase[ST_BURN_STACK]+=ADD_BURN_STACK;
                if(critsHit[i].Param[ST_BURN_STACK]>MAX_BURN_STACK) critsHit[i].ParamBase[ST_BURN_STACK]=MAX_BURN_STACK;
                critsHit[i].ParamBase[ST_BURN_LAST_ENEMY_ID]=attack.Attacker.Id;
                //critsHit[i].AddTimeEvent("cte_Burn",GetBurnDuration(critsHit[i]),CTE_BURN);
            }
            }
}

void CommenceExplosionEx(Critter@ attacker, Map@ map, uint16 tx, uint16 ty, Critter@ target, uint weapPid, bool isCritical, uint intentionallyId, bool isRocket, bool isExplodeRocket)   // export
{
    array<CombatRes> results;
    AttackStruct     attack;
    @attack.Attacker = attacker;
    attack.Aim = HIT_LOCATION_UNCALLED;
    ProtoItem@ proto = GetProtoItem(weapPid);
    int bonusmindmg = 0;
    Item@ realWeapon = _CritGetItemHand(attacker);
	  if(valid(realWeapon) && realWeapon.Val3 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        if(valid(realWeapon) && realWeapon.Val4 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        if(valid(realWeapon) && realWeapon.Val5 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        if(valid(realWeapon) && realWeapon.Val6 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        if(valid(realWeapon) && realWeapon.Val7 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        if(valid(realWeapon) && realWeapon.Val8 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        int bonusmaxdmg = 0;
		if(valid(realWeapon) && realWeapon.Val3 == WP_ATTACK) bonusmaxdmg +=19;
        if(valid(realWeapon) && realWeapon.Val4 == WP_ATTACK) bonusmaxdmg +=19;
        if(valid(realWeapon) && realWeapon.Val5 == WP_ATTACK) bonusmaxdmg +=19;
        if(valid(realWeapon) && realWeapon.Val6 == WP_ATTACK) bonusmaxdmg +=19;
        if(valid(realWeapon) && realWeapon.Val7 == WP_ATTACK) bonusmaxdmg +=19;
        if(valid(realWeapon) && realWeapon.Val8 == WP_ATTACK) bonusmaxdmg +=19;
		
		if(valid(realWeapon) && realWeapon.Val3 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val4 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val5 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val6 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val7 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val8 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val2 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
    attack.DmgMin = _WeaponDmgMin(proto, 0) + _WeaponDmgMin(proto, 0) * bonusmindmg/100;
    attack.DmgMax = _WeaponDmgMax(proto, 0) + _WeaponDmgMax(proto, 0) * bonusmaxdmg/100;
    attack.DmgType = _WeaponDmgType(proto, 0);
    attack.WeaponPerk = proto.Weapon_Perk;

    CommenceExplosion(attack, map, tx, ty, target, weapPid, isCritical, intentionallyId, isRocket, results, isExplodeRocket);
    FlushResults(results);
}

void CommenceExplosionHexEx(Critter@ attacker, Map@ map, uint16 tx, uint16 ty, Critter@ target, uint weapPid, Item@ usedWeapon, uint ammoPid, bool isCritical, uint intentionallyId, bool isRocket, bool isExplodeRocket)   // export
{
    array<CombatRes> results;
    AttackStruct     attack;
    @attack.Attacker = attacker;
    attack.Aim = HIT_LOCATION_UNCALLED;
    @attack.RealWeapon = usedWeapon;
    ProtoItem@ proto = GetProtoItem(weapPid);

    attack.DmgMin = _WeaponDmgMin(proto, 0);
    attack.DmgMax = _WeaponDmgMax(proto, 0);
    attack.DmgType = _WeaponDmgType(proto, 0);
    attack.WeaponPerk = proto.Weapon_Perk;
    if(ammoPid > 0)
        attack.ammoPid = ammoPid;

    CommenceExplosion(attack, map, tx, ty, target, weapPid, isCritical, intentionallyId, isRocket, results, isExplodeRocket);
    FlushResults(results);
}

void CommenceDischargeEx(Critter@ attacker, Map@ map, uint16 tx, uint16 ty, uint dmgRad, uint dmgMin, uint dmgMax, int effChance, uint rechargeVal, bool tesla)   //export
{
    array<CombatRes> results;

    AttackStruct     attack;
    @attack.Attacker = attacker;
    attack.Aim = HIT_LOCATION_UNCALLED;
    attack.DmgMin = dmgMin;
    attack.DmgMax = dmgMax;
    attack.DmgType = DAMAGE_ELECTR;
    if(!tesla)
    attack.DmgType = DAMAGE_EXPLODE;
    uint radius = dmgRad;
    uint16 stepX = attacker.HexX;
    uint16 stepY = attacker.HexY;

    //drawing effects
    //map.MoveHexByDir(stepX, stepY, 4, 1);
    //for(uint8 stepDir = 0; stepDir < 6; stepDir++)
    //{
    //    map.MoveHexByDir(stepX, stepY, stFepDir, 1);
    //    map.RunEffect(PID_EXPLODE_EMP, stepX, stepY, 0);
    //}
    for(uint rad = 1; rad <= radius; rad++)
    {
  // for(uint rad = radius; rad <= radius; ++rad)
    //{
    stepX = attacker.HexX;
    stepY = attacker.HexY;
        map.MoveHexByDir(stepX, stepY, 4, rad);
        for(uint8 stepDir = 0; stepDir < radius; stepDir++)
        {
            for(uint step = 0; step < rad; step++)
            {
                map.MoveHexByDir(stepX, stepY, stepDir, 1);
                //if(Random(1, 100) < effChance)
                if(tesla)
                map.RunEffect(PID_EXPLODE_EMP, stepX, stepY, 0);
                if(!tesla)
                map.RunEffect(PID_EXPLODE_FIRE_BIG, stepX, stepY, 0);
            }
        }
   // }
    }
    if(tesla)
    map.PlaySound("was1xxx" + Random(1, 2), tx, ty, 50);
    if(!tesla)
    {
    map.PlaySound(Random(0, 1) == 0 ? "WHN1XXX1.ACM" : "WHN1XXX2.ACM");
    QuakeScreen(map);
    }
    //getting critters in range
    array<Critter@> crits;
    uint foundCritters = map.GetCrittersHex(tx, ty, radius, FIND_LIFE_AND_KO, crits);
    for(uint c = 0; c < foundCritters; c++)
    {
        if(crits[c].Id == attacker.Id)
        {
            crits.removeAt(c);
            foundCritters--;
            break;
        }

    }

    uint recharge = (foundCritters>0)?rechargeVal/foundCritters:0;

    //commencing attack
    bool intentionally = true;
    for(uint c = 0; c < foundCritters; c++)
    {
        map.RunEffect(PID_EXPLODE_EMP, crits[c].HexX, crits[c].HexY, 0);
        ApplyDamage(attack, crits[c], 1, false, intentionally, results, 0);

        Item@ usedArmor = crits[c].GetItem(0, SLOT_ARMOR);
        if(!valid(usedArmor) || usedArmor.GetProtoId() != PID_TESLA_ARMOR)
        {
            crits.removeAt(c);
            --foundCritters;
            --c;
        }
    }

    //charging affected armors
    if(foundCritters > 0 && recharge > 0)
    {
        for(uint c = 0; c < foundCritters; c++)
        {
            if(crits[c].IsLife())
            {
                Item@ usedArmor = crits[c].GetItem(0, SLOT_ARMOR);
                if(valid(usedArmor) || usedArmor.GetProtoId() == PID_TESLA_ARMOR )
                {
                    usedArmor.Charge += recharge;
                    if(usedArmor.Charge > usedArmor.Proto.Misc_ChargeMax)
                        usedArmor.Charge = usedArmor.Proto.Misc_ChargeMax;
                    usedArmor.Update();
                    crits[c].Say(SAY_NETMSG, "Charging armor with "+recharge+" charges.");
                    crits[c].Say(SAY_NETMSG, "Charges: "+usedArmor.Charge+"/"+usedArmor.Proto.Misc_ChargeMax+".");
                }
            }
        }
    }
    if(!tesla)
    attacker.ToDead(ANIM2_DEAD_EXPLODE, null);
    FlushResults(results);
}

void CriticalFailure(Critter& cr, ProtoItem& weapon, uint8 weaponUse, ProtoItem@ ammo, uint eff, array<CombatRes>& results)
{
    // 0x00000100 hit self
    // 0x00100000 weapon exploded

    // 0x00000200 lost rest of ammo
    // 0x00000400 fired dud shot
    // 0x00000800 hurt self
    // 0x00001000 hit randomly
    // 0x00002000 crippled random limb
    // 0x00040000 on fire NOT USED NOW, TODO?

    // 0x00200000 weapon destroyed
    // 0x00400000 weapon dropped
    // 0x00800000 lost next turn
    // 0x02000000 knocked down

    AttackStruct attack;

    int   totalDmg = 0;
    bool  tookDamage = false;
    Item@ realWeapon = _CritGetItemHand(cr);
    bool  wpnIsRemoved = _WeaponRemove(weapon, weaponUse);
    Map@  map = cr.GetMap();

    if(cr.Param[MODE_NO_DROP] != 0)
        UNSETFLAG(eff, MF_WEAPON_DROPPED);

    if(FLAG(eff, MF_HIT_SELF) || FLAG(eff, MF_WEAPON_EXPLODED))        // Only one bullet because burst weapons do not have the ability
    {
        bool validAmmo = valid(ammo);
        uint16 ammoPid = 0;
        uint16 weapPid = 0;
        if(validAmmo)
            ammoPid = ammo.ProtoId;

        if(valid(weapon))
            weapPid = weapon.ProtoId;

        int  dmgType = _WeaponDmgType(weapon, weaponUse);
        if(ammoPid == PID_SHOTGUN_SHELLS_EMP) dmgType=DAMAGE_EMP; // jesli uzywane ammo typu EMP to zmien dmtype broni
        if(ammoPid == PID_SHOTGUN_DRAGON_BREATH_SHELLS) dmgType=DAMAGE_FIRE; // jesli uzywane ammo typu FIRE to zmien dmtype broni
        int  targetDT = 0;
        int  targetDR = 0;
	uint8 aim = _WeaponModeAim(weaponUse);
	if(!attack.AimHead)
	{
	switch(dmgType)
		{
		case DAMAGE_NORMAL: targetDR = cr.Param[ST_NORMAL_RESIST]; targetDT = cr.Param[ST_NORMAL_ABSORB]; break;
		case DAMAGE_LASER: targetDR = cr.Param[ST_LASER_RESIST]; targetDT = cr.Param[ST_LASER_ABSORB]; break;
		case DAMAGE_FIRE: targetDR = cr.Param[ST_FIRE_RESIST]; targetDT = cr.Param[ST_FIRE_ABSORB]; break;
		case DAMAGE_PLASMA: targetDR = cr.Param[ST_PLASMA_RESIST]; targetDT = cr.Param[ST_PLASMA_ABSORB]; break;
		case DAMAGE_EXPLODE: targetDR = cr.Param[ST_EXPLODE_RESIST]; targetDT = cr.Param[ST_EXPLODE_ABSORB]; break;
		case DAMAGE_ELECTR: targetDR = cr.Param[ST_ELECTRO_RESIST]; targetDT = cr.Param[ST_ELECTRO_ABSORB]; break;
		case DAMAGE_EMP: targetDR = cr.Param[ST_EMP_RESIST]; targetDT = cr.Param[ST_EMP_ABSORB]; break;
		}
	}
	else
	{
	switch(dmgType)
		{
		case DAMAGE_NORMAL: targetDR = cr.Param[ST_HEAD_NORMAL]; targetDT = cr.Param[ST_NORMAL_ABSORB]; break;
		case DAMAGE_LASER: targetDR = cr.Param[ST_HEAD_LASER]; targetDT = cr.Param[ST_LASER_ABSORB]; break;
		case DAMAGE_FIRE: targetDR = cr.Param[ST_HEAD_FIRE]; targetDT = cr.Param[ST_FIRE_ABSORB]; break;
		case DAMAGE_PLASMA: targetDR = cr.Param[ST_HEAD_PLASMA]; targetDT = cr.Param[ST_PLASMA_ABSORB]; break;
		case DAMAGE_EXPLODE: targetDT = cr.Param[ST_EXPLODE_ABSORB]; break;
		case DAMAGE_ELECTR: targetDR = cr.Param[ST_HEAD_ELECTRO]; targetDT = cr.Param[ST_ELECTRO_ABSORB]; break;
		case DAMAGE_EMP: targetDR = cr.Param[ST_HEAD_EMP]; targetDT = cr.Param[ST_EMP_ABSORB]; break;
		}
	}
        Item@ armor_ = _GetCritterArmor(cr, attack.AimHead);




        int  partialBypassChance = GetPartialBypassChance(cr, false);
      //  int  armorDT = cr.GetArmorDT(dmgType, false);
       // int  armorDR = cr.GetArmorDR(dmgType, false);

        int  partialBypassDR = targetDR  / 4;
        int  partialBypassDT = targetDT / 4;

        if(weapon.Weapon_Perk == WEAPON_PERK_PENETRATE)
            targetDT /= 2;
        else if(validAmmo && COMBAT_AMMO_AP(ammo))
            targetDT /= validAmmo ? ammo.Ammo_DTDiv : 1;

        if(cr.Param[TRAIT_FINESSE] != 0)
        {
            if(dmgType == DAMAGE_LASER || dmgType == DAMAGE_ELECTR || dmgType == DAMAGE_PLASMA)
            {
                targetDR += 15;
                partialBypassDR += 15;
            }
        else
            {
                targetDR += 30;
                partialBypassDR += 30;
            }
        }
        targetDR += validAmmo ? ammo.Ammo_DrMod : 0;
        partialBypassDR += validAmmo ? ammo.Ammo_DrMod : 0;
        targetDR = CLAMP(targetDR, 0, 100);

        partialBypassDR = MIN(partialBypassDR, targetDR);
        targetDR = CLAMP(targetDR, 0, 100);
        partialBypassDR = CLAMP(partialBypassDR, 0, 100);
        partialBypassDT = MIN(partialBypassDT, targetDT);
        Item@ realWeapon = _CritGetItemHand(cr);
        int bonusmindmg = 0;
		        if(valid(realWeapon) && realWeapon.Val3 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        if(valid(realWeapon) && realWeapon.Val4 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        if(valid(realWeapon) && realWeapon.Val5 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        if(valid(realWeapon) && realWeapon.Val6 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        if(valid(realWeapon) && realWeapon.Val7 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        if(valid(realWeapon) && realWeapon.Val8 == WP_BONUS_DAMAGE) bonusmindmg +=24;
        int bonusmaxdmg = 0;
		if(valid(realWeapon) && realWeapon.Val3 == WP_ATTACK) bonusmaxdmg +=19;
        if(valid(realWeapon) && realWeapon.Val4 == WP_ATTACK) bonusmaxdmg +=19;
        if(valid(realWeapon) && realWeapon.Val5 == WP_ATTACK) bonusmaxdmg +=19;
        if(valid(realWeapon) && realWeapon.Val6 == WP_ATTACK) bonusmaxdmg +=19;
        if(valid(realWeapon) && realWeapon.Val7 == WP_ATTACK) bonusmaxdmg +=19;
        if(valid(realWeapon) && realWeapon.Val8 == WP_ATTACK) bonusmaxdmg +=19;
		
		if(valid(realWeapon) && realWeapon.Val3 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val4 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val5 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val6 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val7 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val8 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
		if(valid(realWeapon) && realWeapon.Val2 == WP_LEG_BRD) { bonusmaxdmg +=50; bonusmindmg +=50; }
        int dmgMin = _WeaponDmgMin(weapon, weaponUse) + _WeaponDmgMin(weapon, weaponUse) * bonusmindmg/100;

        int dmgMax = _WeaponDmgMax(weapon, weaponUse) + _WeaponDmgMax(weapon, weaponUse) * bonusmaxdmg/100;
        int dmgMul = validAmmo ? ammo.Ammo_DmgMult : 1;   // Technically, should be *2
        int dmgDiv = validAmmo ? ammo.Ammo_DmgDiv : 1;    // Technically, should be *2
        int bonusbrd = 0;
		if(valid(realWeapon) && realWeapon.Val3 == WP_BRD) bonusbrd +=2;
        if(valid(realWeapon) && realWeapon.Val4 == WP_BRD) bonusbrd +=2;
        if(valid(realWeapon) && realWeapon.Val5 == WP_BRD) bonusbrd +=2;
        if(valid(realWeapon) && realWeapon.Val6 == WP_BRD) bonusbrd +=2;
        if(valid(realWeapon) && realWeapon.Val7 == WP_BRD) bonusbrd +=2;
        if(valid(realWeapon) && realWeapon.Val8 == WP_BRD) bonusbrd +=2;
		bool             isShotgun = weapon.Weapon_Caliber == 11;
		if(!isShotgun)
        totalDmg = Random(dmgMin, dmgMax) + 2 * cr.Param[PE_BONUS_RANGED_DAMAGE] + cr.Param[PE_MORE_RANGED_DAMAGE] * 3 + cr.Param[PE_CLAW2] * 2 + cr.Param[PE_CLAW] + cr.Param[PE_SOLDIER] + bonusbrd  + cr.Param[BUFF_RAIDER];
		if(isShotgun)
		totalDmg = Random(dmgMin, dmgMax);

        totalDmg *= dmgMul;
        totalDmg /= dmgDiv;

        if(Random(1, 100) <= partialBypassChance)
        {
            totalDmg -= partialBypassDT;
            totalDmg -= (totalDmg * partialBypassDR) / 100;
        }
        else
        {
            totalDmg -= targetDT;
            totalDmg -= (totalDmg * targetDR) / 100;
        }
        int dragon = 0;
        if(totalDmg < 0)
            totalDmg = 0;
        int bt = cr.Param[ST_BODY_TYPE];
        // The damage perks are used even in this case!
        if(cr.Param[PE_LIVING_ANATOMY] != 0 &&  !(bt == BT_ALIEN || bt == BT_ROBOT))
            totalDmg += 15;

        if(cr.Param[TRAIT_HEAVY_HANDED] != 0 && weapon.Weapon_IsUnarmed)
            totalDmg += 5;
        if((cr.Param[TRAIT_ONE_HANDER] != 0 && (valid(realWeapon) || FLAG(realWeapon.Flags, ITEM_TWO_HANDS)))|| cr.Param[TRAIT_ONE_HANDER] != 0 && cr.Param[PE_MUTANT] != 0)
            totalDmg += 5;
        tookDamage = true;
    }

    uint16 ammoRound = _WeaponRound(weapon, weaponUse);
    if(ammoRound > 0 && valid(realWeapon) && cr.Param[MODE_UNLIMITED_AMMO] == 0 && cr.Param[PE_WRECKER]==0)
    {
        if(realWeapon.AmmoCount <= ammoRound || FLAG(eff, MF_LOST_REST_OF_AMMO))
            realWeapon.AmmoCount = 0;
        else
            realWeapon.AmmoCount -= ammoRound;
        realWeapon.Update();
    }

    if(cr.Param[MODE_NO_DROP] != 0 || (cr.Param[PE_IRON_GRIP] > 0 && Random(1, 10) <= cr.Param[ST_STRENGTH] - 5))
        UNSETFLAG(eff, MF_WEAPON_DROPPED);
    if(cr.Param[MODE_NO_LOOSE_LIMBS] != 0)
        UNSETFLAG(eff, MF_CRIPPLED_RANDOM_LIMB);
    if(cr.Param[PE_STONEWALL] > 0)
        if(FLAG(eff, MF_KNOCKED_DOWN) && Random(0, 10) <= cr.Param[ST_ENDURANCE] - 3)
            UNSETFLAG(eff, MF_KNOCKED_DOWN);

    if(FLAG(eff, MF_WEAPON_DROPPED) && valid(realWeapon))
    {
        if(realWeapon.IsStackable())
        {
            Item@ dropped = map.AddItem(cr.HexX, cr.HexY, weapon.ProtoId, 1);
            if(realWeapon.GetCount() > 1)
                realWeapon.SetCount(realWeapon.GetCount() - 1);
            else
                DeleteItem(realWeapon);

            if(!cr.IsPlayer())
            {
                NpcPlane@ plane = CreatePlane();
                array<NpcPlane@> crPlanes(0);

                if(cr.GetPlanes(crPlanes) > 0)
                    plane.Priority = crPlanes[0].Priority + 1;
                else
                    plane.Priority = 70;

                plane.Type = AI_PLANE_PICK;
                plane.Pick_HexX = dropped.HexX;
                plane.Pick_HexY = dropped.HexY;
                plane.Pick_Pid = dropped.GetProtoId();
                plane.Pick_UseItemId = 0;
                plane.Pick_ToOpen = false;
                plane.Identifier = PLANE_PICK_DROPPED_WPN;
                plane.IdentifierExt = dropped.Id;
                plane.Run = true;
                cr.AddPlane(plane);
                SetLvar(dropped.Id, LIVAR_npc_wpn_owner, cr.Id);
            }
        }
        else
        {
            MoveItem(realWeapon, 0, map, cr.HexX, cr.HexY);
            if(!cr.IsPlayer())
            {
                NpcPlane@ plane = CreatePlane();

                array<NpcPlane@> crPlanes(0);

                if(cr.GetPlanes(crPlanes) > 0)
                    plane.Priority = crPlanes[0].Priority + 1;
                else
                    plane.Priority = 70;

                plane.Type = AI_PLANE_PICK;
                plane.Pick_HexX = realWeapon.HexX;
                plane.Pick_HexY = realWeapon.HexY;
                plane.Pick_Pid = realWeapon.GetProtoId();
                plane.Pick_UseItemId = 0;
                plane.Pick_ToOpen = false;
                plane.Identifier = PLANE_PICK_DROPPED_WPN;
                plane.IdentifierExt = realWeapon.Id;
                plane.Run = true;
                cr.AddPlane(plane);
                SetLvar(realWeapon.Id, LIVAR_npc_wpn_owner, cr.Id);
            }
        }
    }

    if((FLAG(eff, MF_WEAPON_DESTROYED) || FLAG(eff, MF_WEAPON_EXPLODED)) && valid(realWeapon))
    {

        if(realWeapon.IsStackable())
        {
            if(realWeapon.GetCount() > 1)
                realWeapon.SetCount(realWeapon.GetCount() - 1);
        }
        else
			{
			//UNSETFLAG(realWeapon.BrokenFlags, BI_BROKEN);
			int wearProcent = Random(100,2500);
			/*
			int oldstatus = MAX_DETERIORATION * realWeapon.Deterioration;
			int oldstatus2 = realWeapon.BrokenCount;
			int newstatus = CLAMP(wearProcent,0,100);
			int newstatus2 = CLAMP(oldstatus2 - wearProcent,0,100);*/
			realWeapon.Deterioration += wearProcent;
			realWeapon.BrokenCount += wearProcent/100;
			//if(realWeapon.Deterioration > realWeapon.BrokenCount)
			//	realWeapon.Deterioration = realWeapon.BrokenCount;
			//if(realWeapon.Deterioration > 10000)
			//	SETFLAG(realWeapon.BrokenFlags, BI_BROKEN);
			realWeapon.Update();
			}
	}
 

    if(FLAG(eff, MF_HURT_SELF))
    {
        totalDmg += Random(5, 200);
        tookDamage = true;
    }

    if(FLAG(eff, MF_LOST_NEXT_TURN))
    {
        cr.ParamBase[ST_CURRENT_AP] = (cr.Param[PE_QUICK_RECOVERY] > 0 ? (-100 * cr.Param[ST_ACTION_POINTS]) / 3 : -100 * cr.Param[ST_ACTION_POINTS]);
        cr.ParamBase[ST_MOVE_AP] = 0;
    }

    if(FLAG(eff, MF_KNOCKED_DOWN) && !cr.IsKnockout())
        cr.ToKnockout(KNOCKOUT_ANIM2_DEFAULT(true), cr.Param[PE_QUICK_RECOVERY] != 0 ? 1 : 3, cr.HexX, cr.HexY);
	
    if(FLAG(eff, MF_CRIPPLED_RANDOM_LIMB))
    {
        switch(Random(1, 4))
        {
        case 1:
            //druto
            if(cr.Param[PE_IRON_GRIP] == 0 || Random(1, 10) > cr.Param[ST_LUCK] - 5)
                cr.ParamBase[DAMAGE_LEFT_LEG] = 1;
            else
                UNSETFLAG(eff, MF_CRIPPLED_RANDOM_LIMB);
            break;
        case 2:
            if(cr.Param[PE_IRON_GRIP] == 0 || Random(1, 10) > cr.Param[ST_LUCK] - 5)
                cr.ParamBase[DAMAGE_RIGHT_LEG] = 1;
            else
                UNSETFLAG(eff, MF_CRIPPLED_RANDOM_LIMB);
            break;
        case 3:
            if(cr.Param[PE_IRON_GRIP] == 0 || Random(1, 10) > cr.Param[ST_STRENGTH])
                cr.ParamBase[DAMAGE_LEFT_ARM] = 1;
            else
                UNSETFLAG(eff, MF_CRIPPLED_RANDOM_LIMB);
            break;
        case 4:
            if(cr.Param[PE_IRON_GRIP] == 0 || Random(1, 10) > cr.Param[ST_STRENGTH])
                cr.ParamBase[DAMAGE_RIGHT_ARM] = 1;
            else
                UNSETFLAG(eff, MF_CRIPPLED_RANDOM_LIMB);
            break;
        default:
            break;
        }
    }

    if(FLAG(eff, MF_WEAPON_EXPLODED))
        map.RunEffect(PID_EXPLODE_FIRE_SMALL, cr.HexX, cr.HexY, 2);

    if(totalDmg > 0)
        cr.ParamBase[ST_CURRENT_HP] -= totalDmg;

    uint[] allEff = { CMSG_CRIT_MISS, cr.Id, 0, eff };


    if(tookDamage)
    {
        allEff.resize(5);
        allEff[4] = totalDmg;
        allEff[0] = CMSG_CRIT_MISS_DAMAGE;
    }

    if(cr.Param[ST_CURRENT_HP] < 1)
    {
        int deadHitPoints = cr.Param[PE_DEAD_MAN_WALKING] > 0 ? __DeadHitPoints : __DeadHitPoints / 2;
        if(cr.Param[ST_CURRENT_HP] > deadHitPoints && IsHumanoid(cr) && cr.Param[MODE_NO_KNOCK] == 0)
        {
            if(!cr.IsKnockout())
                cr.ToKnockout(KNOCKOUT_ANIM2_DEFAULT(true), 0, cr.HexX, cr.HexY);
        }
        else
        {
            uint anim2Dead = ANIM2_DEAD_FRONT;
            if(cr.IsKnockout())
            {
                if(cr.Anim2Knockout == ANIM2_IDLE_PRONE_FRONT)
                    anim2Dead = ANIM2_DEAD_PRONE_FRONT;
                else
                    anim2Dead = ANIM2_DEAD_PRONE_BACK;
            }
            cr.ToDead(anim2Dead, null);
            allEff[2] |= MF_WAS_KILLED;
        }
    }

    Critter@[] him = { cr };
    array<Critter@> crits;
    cr.GetMap().GetCrittersSeeing(him, true, FIND_ALL | FIND_ONLY_PLAYERS, crits);
    for(int i = 0, j = crits.length(); i < j; i++)
        AddEff(crits[i], allEff, results);

    FlushResults(results);
}


void InjureCritter(Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId, Item@ realWeapon)   // Export
{
    if(dmgType > DAMAGE_EXPLODE)
    {
       // Log("Invalid damage type.");
        return;
    }

    Critter@ attacker = null;
    if(attackerId != 0)
        @attacker = GetCritter(attackerId);
    else @attacker = GetCritter(cr.Id);

    AttackStruct attack;
    @attack.Attacker = attacker;

    uint16 hx = cr.HexX;
    uint16 hy = cr.HexY;
    Map@   map = cr.GetMap();
    if(valid(map))
        map.MoveHexByDir(hx, hy, (dir + 3) % 6, 1);
    Item@ bron = _CritGetItemHand(attacker);
    attack.Hx = hx;
    attack.Hy = hy;
    attack.set_Aim(HIT_LOCATION_UNCALLED);
    attack.IsBurst = false;
    attack.BloodyMess = false;
    attack.CombatMessage = false;
    attack.WeaponPerk = 0;
    attack.WeaponSubtype = 0;
    attack.DmgMin = dmg;
    attack.DmgMax = dmg;
    attack.DmgType = dmgType;
    attack.BonusDmg = 0;
    attack.DmgMul = 2;
    attack.DRMod = 0;
    attack.DMMod = 1;
    attack.DDMod = 1;
    attack.TargetId = cr.Id;
    attack.ShowHitAnimForce = true;
    @attack.RealWeapon = realWeapon;

    array<CombatRes> results;
    ApplyDamage(attack, cr, 1, false, true, results, 0);

    FlushResults(results);
}

void InjureCritter(Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId)   // Export
{
    if(dmgType > DAMAGE_EXPLODE)
    {
      //  Log("Invalid damage type.");
        return;
    }

    Critter@ attacker = null;
    if(attackerId != 0)
        @attacker = GetCritter(attackerId);
    else @attacker = GetCritter(cr.Id);

    AttackStruct attack;
    @attack.Attacker = attacker;

    uint16 hx = cr.HexX;
    uint16 hy = cr.HexY;
    Map@   map = cr.GetMap();
    if(valid(map))
        map.MoveHexByDir(hx, hy, (dir + 3) % 6, 1);
    Item@ bron = _CritGetItemHand(attacker);
    attack.Hx = hx;
    attack.Hy = hy;
    attack.set_Aim(HIT_LOCATION_UNCALLED);
    attack.IsBurst = false;
    attack.BloodyMess = false;
    attack.CombatMessage = false;
    attack.WeaponPerk = 0;
    attack.WeaponSubtype = 0;
    attack.DmgMin = dmg;
    attack.DmgMax = dmg;
    attack.DmgType = dmgType;
    attack.BonusDmg = 0;
    attack.DmgMul = 2;
    attack.DRMod = 0;
    attack.DMMod = 1;
    attack.DDMod = 1;
    attack.TargetId = cr.Id;
    attack.ShowHitAnimForce = true;

    array<CombatRes> results;
    ApplyDamage(attack, cr, 1, false, true, results, 0);

    FlushResults(results);
}

int FindCritterInArray(array<Critter@>& crits, Critter& cr)
{
    uint crId = cr.Id;
    for(uint i = 0, j = crits.length(); i < j; i++)
        if(crits[i].Id == crId)
            return i;
    return -1;
}

uint GetAimApCost(int hitLocation)
{
    switch(hitLocation)
    {
    case HIT_LOCATION_NONE:
        break;
    case HIT_LOCATION_UNCALLED:
        break;
    case HIT_LOCATION_TORSO:
        return __ApCostAimTorso;
    case HIT_LOCATION_EYES:
        return __ApCostAimEyes;
    case HIT_LOCATION_HEAD:
        return __ApCostAimHead;
    case HIT_LOCATION_LEFT_ARM:
    case HIT_LOCATION_RIGHT_ARM:
        return __ApCostAimArms;
    case HIT_LOCATION_GROIN:
        return __ApCostAimGroin;
    case HIT_LOCATION_RIGHT_LEG:
    case HIT_LOCATION_LEFT_LEG:
        return __ApCostAimLegs;
    default:
        break;
    }
    return 0;
}

uint GetHitAim(int hitLocation)
{
    switch(hitLocation)
    {
    case HIT_LOCATION_NONE:
        break;
    case HIT_LOCATION_UNCALLED:
        break;
    case HIT_LOCATION_TORSO:
        return __HitAimTorso;
    case HIT_LOCATION_EYES:
        return __HitAimEyes;
    case HIT_LOCATION_HEAD:
        return __HitAimHead;
    case HIT_LOCATION_LEFT_ARM:
    case HIT_LOCATION_RIGHT_ARM:
        return __HitAimArms;
    case HIT_LOCATION_GROIN:
        return __HitAimGroin;
    case HIT_LOCATION_RIGHT_LEG:
    case HIT_LOCATION_LEFT_LEG:
        return __HitAimLegs;
    default:
        break;
    }
    return 0;
}


// Used by AI
int RawToHit(Critter& cr, Critter& target, ProtoItem@ weapon, uint8 weaponUse, ProtoItem@ ammo)   // export
{
    int skillNum = valid(weapon) ? _WeaponSkill(weapon, weaponUse) : SK_UNARMED;
    int toHit = cr.Param[skillNum];
    int weaponPerk = valid(weapon) ? weapon.Weapon_Perk : 0;
    int blockers = 0;
    int dist = GetDistantion(cr.HexX, cr.HexY, target.HexX, target.HexY);
    if(skillNum != SK_UNARMED)
    {
        // Ranged attack modifiers
        int distmod1 = 2;       // Used for initial weapon bonus
        int distmod2 = 0;       // Minimal distance
        bool havelongrange = false;
        Item@ realWeapon = _CritGetItemHand(cr);
		
		if(valid(realWeapon) && realWeapon.Val3 == WP_LONG_RANGE) havelongrange = true;
        if(valid(realWeapon) && realWeapon.Val4 == WP_LONG_RANGE) havelongrange = true;
        if(valid(realWeapon) && realWeapon.Val5 == WP_LONG_RANGE) havelongrange = true;
        if(valid(realWeapon) && realWeapon.Val6 == WP_LONG_RANGE) havelongrange = true;
        if(valid(realWeapon) && realWeapon.Val7 == WP_LONG_RANGE) havelongrange = true;
        if(valid(realWeapon) && realWeapon.Val8 == WP_LONG_RANGE) havelongrange = true;

        if(havelongrange)
            distmod1 = 4;

        int perception = cr.Param[ST_PERCEPTION];
        int acc = dist;

        if(dist < distmod2)
            acc += distmod2;
        else
        {
            if(cr.IsPlayer())
                acc -= (perception - 2) * distmod1;
            else
                acc -= perception * distmod1;
        }

        if(-2 * perception > acc)
            acc = -2 * perception;

        acc -= 2 * cr.Param[PE_SHARPSHOOTER];
        acc -= 2 * cr.Param[PE_TACTICAL];
        acc -= 2 * cr.Param[PE_TACTICAL2];
        if(acc >= 0)
        {
            if(cr.Damage[DAMAGE_EYE] != 0)
                acc *= -12;
            else
                acc *= -4;
        }
        else
            acc *= -4;

        toHit += acc;
        Map@ map = cr.GetMap();
        blockers = map.GetCrittersPath(cr.HexX, cr.HexY, target.HexX, target.HexY, 0.0f, dist, FIND_LIFE, null);
        if(!target.IsKnockout())
            blockers--;
        toHit -= 10 * blockers;
    }     // Range modifiers end

    if(valid(weapon))
    {
        if(!(weapon.Weapon_IsUnarmed) && cr.Param[TRAIT_ONE_HANDER] != 0)
            toHit += (FLAG(weapon.Flags, ITEM_TWO_HANDS) ? -100 : 20);

        int handlingStrength = cr.Param[ST_STRENGTH];
        int reqStrength = weapon.Weapon_MinStrength;
        if(cr.Param[PE_WEAPON_HANDLING] != 0)
            handlingStrength += 2;
        if(handlingStrength < reqStrength)
            toHit -= (reqStrength - handlingStrength) * 20;
        if(cr.Param[PE_AGRO2] > 0)
            toHit += 25;
		if(cr.Param[PE_SNIPER] > 0) toHit += cr.Param[ST_PERCEPTION];
			
    Item@ realWeapon = _CritGetItemHand(cr);
	if(valid(realWeapon) && realWeapon.Val3 == WP_LONG_RANGE) toHit += 20;
    if(valid(realWeapon) && realWeapon.Val4 == WP_LONG_RANGE) toHit += 20;
    if(valid(realWeapon) && realWeapon.Val5 == WP_LONG_RANGE) toHit += 20;
    if(valid(realWeapon) && realWeapon.Val6 == WP_LONG_RANGE) toHit += 20;
    if(valid(realWeapon) && realWeapon.Val7 == WP_LONG_RANGE) toHit += 20;
    if(valid(realWeapon) && realWeapon.Val8 == WP_LONG_RANGE) toHit += 20;
    }

    int acmod = target.GetAC(false);
	acmod -= cr.Param[ST_PERCEPTION]*5;
    if(valid(ammo))
        acmod += ammo.Ammo_AcMod;
    if(acmod > 0)
        toHit -= acmod;

    if(cr.Damage[DAMAGE_EYE] != 0)
        toHit -= 25;

    if(target.IsKnockout())
        toHit += 40;
    if(target.GetMultihex() > 0)
        toHit += 15;

    return toHit;
}


void NotifyOops(Critter@ cr, Critter@ t1, Critter@ t2, array<CombatRes>& results)
{
    // if(t2==null) pass "cr critically missed and hit randomly."
    // otherwise pass "Oops! t2 was hit instead of t1!"
    if(!valid(t2))
    {
        uint[] allEff = { CMSG_HIT_RANDOMLY, cr.Id, 0 };
        Critter@[] him = { cr };
        array<Critter@> crits;
        cr.GetMap().GetCrittersSeeing(him, true, FIND_ALL | FIND_ONLY_PLAYERS, crits);
        for(int i = 0, j = crits.length(); i < j; i++)
            AddEff(crits[i], allEff, results);
    }
    else
    {
        uint[] allEff = { CMSG_OOPS, t1.Id, t2.Id };
        Critter@[] them = { t1, t2 };
        array<Critter@> crits;
        t1.GetMap().GetCrittersSeeing(them, true, FIND_ALL | FIND_ONLY_PLAYERS, crits);
        for(int i = 0, j = crits.length(); i < j; i++)
            AddEff(crits[i], allEff, results);
    }
}

void NotifyMiss(Critter@ cr, array<CombatRes>& results)
{
    uint[] allEff = { CMSG_MISS, cr.Id, 0 };
    Critter@[] him = { cr };
    array<Critter@> crits;
    cr.GetMap().GetCrittersSeeing(him, true, FIND_ALL | FIND_ONLY_PLAYERS, crits);
    for(int i = 0, j = crits.length(); i < j; i++)
        AddEff(crits[i], allEff, results);
}

Critter@ ChooseRandomTarget(Map& map, Critter& cr, Critter& target, uint wpnMaxDist)
{
    array<Critter@> crits;
    uint16          hx = cr.HexX;
    uint16          hy = cr.HexY;
    uint            n = map.GetCrittersHex(hx, hy, wpnMaxDist, FIND_LIFE_AND_KO, crits);
    if(n == 0)
        return null;          // Should never happen
    uint   start = Random(0, n - 1);
    uint16 bx = 0;
    uint16 by = 0;
    uint16 pbx = 0;
    uint16 pby = 0;
    for(uint i = start; i < n; i++)
    {
        if(!valid(crits[i]))
            continue;
        if(crits[i].Id == cr.Id || crits[i].Id == target.Id)
            continue;
        // Wallcheck:
        map.GetCrittersPath(hx, hy, crits[i].HexX, crits[i].HexY, 0.0f, 0, FIND_LIFE_AND_KO, null, pbx, pby, bx, by);
        if(bx == crits[i].HexX && by == crits[i].HexY)
            return crits[i];
    }
    for(uint i = 0; i < start; i++)
    {
        if(!valid(crits[i]))
            continue;
        if(crits[i].Id == cr.Id || crits[i].Id == target.Id)
            continue;
        // Wallcheck:
        map.GetCrittersPath(hx, hy, crits[i].HexX, crits[i].HexY, 0.0f, 0, FIND_LIFE_AND_KO, null, pbx, pby, bx, by);
        if(bx == crits[i].HexX && by == crits[i].HexY)
            return crits[i];
    }

    return null;
}

int GetPartialBypassChance(Critter& target, bool aimHead)
{
    Item@ armor = _GetCritterArmor(target, aimHead);
    if(!valid(armor))
        return 0;
    int deterPercent = (100 * armor.Deterioration) / MAX_DETERIORATION;
    if(!armor.IsDeteriorable() || _CritHasExtMode(target, MODE_EXT_NO_DETERIORATION) || deterPercent <= 50)
        return 0;
    return ((deterPercent - 50) * 100) / 50;
}

int AddCritRollWeapon(Item@ realWeapon)
{
    int _roll=0;
    if(valid(realWeapon))
    {
        if(realWeapon.Proto.ProtoId==PID_TURBO_PLASMA_RIFLE) _roll = 5;
        if(realWeapon.Proto.ProtoId==PID_PLASMA_RIFLE) _roll = 5;
    }
    return _roll;
}

void AffectBurn(Critter& cr, int value) // Fire Hexes start
{
    if(cr.IsDead()) return;

    uint[] indexes;
    uint[] durations;
    bool isActive=cr.GetTimeEvents(CTE_BURN,indexes,durations,null)!=0;
    int count=cr.Param[ST_BURN_STACK];
        if(count==0) return;
    cr.ParamBase[ST_BURN_STACK]=CLAMP(count,0,MAX_BURN_STACK);
    count=cr.Param[ST_BURN_STACK];
    //cr.ParamBase[ST_BURN_STACK]=0;

    if(isActive) // Try hurry event, if new stage aviable
    {
        if(count==0)
        {
            cr.EraseTimeEvents(CTE_BURN);
        }
        else
        {
            uint oldDuration=durations[0];
            uint newDuration=GetBurnDuration(cr);
            if(newDuration<oldDuration) cr.ChangeTimeEvent(indexes[0],newDuration,0);
        }
    }
    else // Try start new event
    {
        cr.AddTimeEvent("cte_Burn",GetBurnDuration(cr),CTE_BURN);
    }

}

uint cte_Burn(Critter& cr, int identifier, uint& rate)
{
    if(cr.IsDead()) cr.ParamBase[ST_BURN_STACK]=0;
    int count=cr.Param[ST_BURN_STACK];
    cr.ParamBase[ST_BURN_STACK]=CLAMP(count,0,MAX_BURN_STACK);
	uint damage = BURN_DAMAGE;
	Critter@ attacker = GetCritter(cr.Param[ST_BURN_LAST_ENEMY_ID]);
	if(attacker.Param[PE_PYROMANIAC] > 0)
	damage += 7 * attacker.Param[PE_PYROMANIAC];
	if(attacker.Param[PE_DRAGON2] > 1)
		damage += 7;
	
    count=cr.Param[ST_BURN_STACK];
    if(count > 0)
    {
		if(cr.Param[ST_CURRENT_HP] > -10)
			cr.ParamBase[ST_CURRENT_HP] -= damage;
        cr.ParamBase[ST_BURN_STACK]-=1;
    }
    return GetBurnDuration(cr);
}

uint GetBurnDuration(Critter& cr)
{
    int duration;
    int count=cr.Param[ST_BURN_STACK];
    if(count==0) return 0;
    duration=count*MAX_BURN_DURATION;
    if(duration<=0) cr.EraseTimeEvents(CTE_BURN);;
    return duration;
}

uint getSpree(int AP, uint div)
{
	if(div==3)
		{
		switch(AP)
			{
			case 0:
			case 1:
			case 2:
			return 0;
			case 3:
			case 4:
			return 1;
			case 5:
			case 6:
			case 7:
			case 8:
			return 2;
			case 9:
			case 10:
			return 3;
			case 11:
			case 12:
			case 13:
			case 14:
			return 4;
			case 15:
			case 16:
			return 5;
			case 17:
			case 18:
			case 19:
			return 6;
			case 20:
			case 21:
			return 7;
			case 22:
			case 23:
			case 24:
			case 25:
			return 8;
			case 26:
			case 27:
			return 9;
			case 28:
			case 29:
			case 30:
			case 31:
			return 10;
			case 32:
			case 33:
			return 11;
			case 34:
			case 35:
			case 36:
			case 37:
			return 12;
			default:
			if(AP<0)
				return 0;
			if(AP>37)
				return 13;
			}
		}
	if(div==0)
		return AP;
		
	return 5;

}
uint e_KillingSpree(array<uint>@ spreedata)
{
	int spree = spreedata[0];
	Critter@ attacker = GetCritter(spreedata[1]);
	if(!valid(attacker) || !valid(attacker.GetMap()) )
		return 0;
			spree *= 100;
	
			if(spree+attacker.ParamBase[ST_CURRENT_AP]>=attacker.Param[ST_ACTION_POINTS]*100)
				{
			//	Log("AP BEFORE : " + attacker.ParamBase[ST_CURRENT_AP]);
				attacker.ParamBase[ST_CURRENT_AP] = attacker.Param[ST_ACTION_POINTS]*100;
			//	Log("AP AFTER : " + attacker.ParamBase[ST_CURRENT_AP]);
				}
			else
				{
			//	Log("AP BEFORE : " + attacker.ParamBase[ST_CURRENT_AP]);
				attacker.ParamBase[ST_CURRENT_AP] += spree;
			//	Log("AP AFTER : " + attacker.ParamBase[ST_CURRENT_AP]);

				}
			CreateTimeEvent(AFTER(REAL_MS(100)), "e_fake_ap", spreedata, false);
		return 0;
}

uint e_fake_ap(array<uint>@ spreedata)
{
	int spree = spreedata[0];
	Critter@ attacker = GetCritter(spreedata[1]);
	if(!valid(attacker) || !valid(attacker.GetMap()) )
		return 0;
	attacker.ParamBase[ST_CURRENT_AP] -= 1;
	//Log("AP FINAL : " + attacker.ParamBase[ST_CURRENT_AP]);
	CreateTimeEvent(AFTER(REAL_MS(100)), "e_back_ap", spreedata, false);
	return 0;
}

uint e_back_ap(array<uint>@ spreedata)
{
	int spree = spreedata[0];
	Critter@ attacker = GetCritter(spreedata[1]);
	if(!valid(attacker) || !valid(attacker.GetMap()) )
		return 0;
	attacker.ParamBase[ST_CURRENT_AP] += 1;
	//Log("AP FINAL fix : " + attacker.ParamBase[ST_CURRENT_AP]);
	return 0;
}

uint get_ST(Critter& cr)
{
	int val = cr.ParamBase[ST_STRENGTH];
	Item@ armorek = cr.GetItem(0, SLOT_ARMOR);

			
	if(cr.Param[TRAIT_SKILLED]>0) val += 1; //gifted
	if(cr.Param[PE_GAIN_STRENGTH]>0) val += cr.Param[PE_GAIN_STRENGTH] * 2; //perk
	
	if(cr.Param[PE_IMP_STRENGTH]>0) val += cr.Param[PE_IMP_STRENGTH];//implant
	if(cr.Param[TRAIT_BRUISER]>0) val += 4; //trait
	if(cr.Param[PE_DEATHCLAW]>0) val += 3; //perk
	if(cr.Param[PE_SOLDIER]>0) val += 1; //perk
	if(cr.Param[WE_ST]>0) val += cr.Param[WE_ST]; //war
	
	if(cr.Param[TRAIT_CHEM_RESISTANT]>0 && cr.Param[TO_JET] > 0) val += 3; //drug cannibal
	if(cr.Param[TRAIT_CHEM_RESISTANT]==0 && cr.Param[TO_BUFFOUT] > 0) val += 2; //drug
	if(cr.Param[TRAIT_CHEM_RESISTANT]==0 && cr.Param[TO_JET] > 0) val -= 2; //drug
	if(cr.Param[TRAIT_CHEM_RESISTANT]==0 && cr.Param[TO_VOODOO] > 0) val -= 2; //drug
	if(cr.Param[TRAIT_CHEM_RESISTANT]==0 && cr.Param[TO_PSYCHO] > 0) val += 1; //drug

			if(valid(armorek) && armorek.Val3 == AP_GAIN_ST) val += 2;
            if(valid(armorek) && armorek.Val4 == AP_GAIN_ST) val += 2;
            if(valid(armorek) && armorek.Val5 == AP_GAIN_ST) val += 2;
            if(valid(armorek) && armorek.Val6 == AP_GAIN_ST) val += 2;
            if(valid(armorek) && armorek.Val7 == AP_GAIN_ST) val += 2;
            if(valid(armorek) && armorek.Val8 == AP_GAIN_ST) val += 2;
			
			if(valid(armorek) && armorek.Val2 == AP_LEG_GIFTED) val += 2;
			if(valid(armorek) && armorek.Val3 == AP_LEG_GIFTED) val += 2;
            if(valid(armorek) && armorek.Val4 == AP_LEG_GIFTED) val += 2;
            if(valid(armorek) && armorek.Val5 == AP_LEG_GIFTED) val += 2;
            if(valid(armorek) && armorek.Val6 == AP_LEG_GIFTED) val += 2;
            if(valid(armorek) && armorek.Val7 == AP_LEG_GIFTED) val += 2;
            if(valid(armorek) && armorek.Val8 == AP_LEG_GIFTED) val += 2;
	
	if(cr.Param[ST_LEADER_BONUS] == 5)
		{
		val += cr.Param[ST_LEADERS];
		}
	if(cr.Param[ST_RADIATION_LEVEL] > 630)
		val--;
	if(cr.Param[ST_RADIATION_LEVEL] > 810)
		val--;	
	if(cr.Param[ST_RADIATION_LEVEL] > 1170)
		val--;	
	if(cr.Param[ST_RADIATION_LEVEL] > 1620)
		val--;	
	return CLAMP(val, 1, 50);
}