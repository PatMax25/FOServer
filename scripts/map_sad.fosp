                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

int week_patch=1;
int doubleloot=1;
bool dropchance(float chance)
{
	if(chance==0)
	return false;
	if(Random(0,100)<chance)
	return true;
	
	return false;
	
}

bool can_tc_modoc=false;
bool can_tc_klamath=false;
bool can_tc_gecko=false;
bool can_tc_bh=false;
bool can_tc_redding=false;
bool can_tc_den=false;
bool can_tc_necro=false;
bool can_tc_reno=false;

uint when_tc_modoc=0;
uint when_tc_klamath=0;
uint when_tc_gecko=0;
uint when_tc_bh=0;
uint when_tc_redding=0;
uint when_tc_den=0;
uint when_tc_necro=0;
uint when_tc_reno=0;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

shared class Entire
{
	int Number;
	uint16 HexX;
	uint16 HexY;
	uint8 Direction;
};

uint ParseEntires(Map&map,array<Entire>&entires,int number)
{
	uint oldCount=entires.length();
	uint count=map.CountEntire(number);
	entires.resize(oldCount+count);
	
	for(uint i=0;i<count;i++)
	{
		Entire@ent=entires[oldCount+i];
		if(map.GetEntireCoords(number,i,ent.HexX,ent.HexY,ent.Direction)==false)
		return 0;
		ent.Number=number;
	}
	
	return count;
}

bool IsEntireFree(uint mappid,int number)
{
	Map@map=GetMapByPid(mappid,0);
	return IsEntireFree(map,number);
}

bool IsEntireFree(Map&map,int number)
{
	uint16 x,y;
	x=0;
	y=0;
	return GetEntireFreeHex(map,number,x,y);
}

bool GetEntireFreeHex(Map&map,int number,uint16&hx,uint16&hy,uint skip=0)
{
	uint count=map.CountEntire(number); 
	
	for(uint i=skip;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy)&&map.IsHexPassed(hx,hy))
		return true;
	}
	
	if(hx==0||hy==0||hx>=map.GetWidth()-1||hy>=map.GetHeight()-1)
	return false; 
	
	for(uint i=0;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy))
		{
			for(int x=-1;x<=1;x++)
			{
				for(int y=-1;y<=1;y++)
				{
					if(x==0&&y==0)
					continue;
					if(__MapHexagonal)
					{
						if((hx%2)==1&&((x==-1&&y==1)||(x==1&&y==1)))
						continue;
						if((hx%2)==0&&((x==-1&&y==-1)||(x==1&&y==-1)))
						continue;
					}
					
					if(map.IsHexPassed(hx+x,hy+y))
					{
						hx+=x;
						hy+=y;
						return true;
					}
				}
			}
		}
	}
	return false;
}

bool GetNearEntire(Map&map,int number,uint16&hx,uint16&hy)
{
	uint16 hxBase=hx;
	uint16 hyBase=hy;
	
	array<Entire>entires;
	uint count=ParseEntires(map,entires,number);
	if(count==0)
	return false;
	
	hx=entires[0].HexX;
	hy=entires[0].HexY;
	for(uint i=1;i<count;i++)
	{
		Entire@ent=entires[i];
		if(GetDistantion(hxBase,hyBase,ent.HexX,ent.HexY)<GetDistantion(hxBase,hyBase,hx,hy))
		{
			hx=ent.HexX;
			hy=ent.HexY;
		}
	}
	
	return true;
}                                                                                                                                                                                                                                                                                                                                                                                                                      

import Location@GetLocationOf(Critter&critter)from"utils";
import string GetLocationName(uint locId)from"utils";
import string GetLocationName(Location@loc)from"utils";
import bool ReadPids(array<int>&out pids,bool removeinvalid)from"utils";
import void ReadDefines(string@fileName,dictionary&items,array<string>@defines)from"utils";
import bool ParseDefine(const string&in line,string&out spid,int&out id)from"utils";
import int SkipWhitespaces(const string&in str,int start)from"utils";
import int SkipNonWhitespaces(const string&in str,int start)from"utils";
import bool IsParameterTag(string&str)from"utils";
import string GetParameterString(array<string@>@arr,string&parameter)from"utils";
import int GetIndexOfString(array<string@>@arr,string&str)from"utils";
import string GetConcatenatedString(array<string@>@arr,uint startindex,int stopindex)from"utils";
import string GetConditionOfCritter(Critter@cr)from"utils";
import string GetExtConditionOfCritter(Critter@cr)from"utils";
import uint GetAllOnlinePlayers(array<Critter@>&out players)from"utils";
import uint GetAuthenticatedPlayers(array<Critter@>&out players)from"utils";
import uint GetAuthenticatedPlayers(array<Critter@>&out players,bool ignorePriviledges)from"utils";
import uint GetNumberOfPlayersOnline()from"utils";
import void SetTurnBasedAvailability(Location@loc)from"utils";
import bool IsGuarded(Map@map)from"utils";
import bool IsPublic(Map@map)from"utils";
import bool IsEncounterMap(Map@map)from"utils";
import bool IsTown(Map@map)from"utils";
import bool IsDungeon(Map@map)from"utils";
import bool IsBaseControl(Map@map)from"utils";

import uint GetMapType(Map@map)from"utils";
import void LockDoor(uint x,uint y,Map@map,uint complexity,uint lockid)from"utils";
import void UnlockDoor(uint x,uint y,Map@map)from"utils";
import void ClearContainer(Item@container)from"utils";
import void MoveItemsCritterToCont(Critter&crFrom,Item&contTo,uint specid)from"utils";
import string GetCritterInfo(Critter&cr)from"utils";
import bool AddExpTeam(Critter&critter,int xp)from"utils";
import void ClearEnemyStack(Critter&critter)from"utils";
import void ClearEnemyStacksOnMap(Map@map)from"utils";
import bool IsCurrentEnemy(Critter&cr,uint targetId)from"utils";
import string@GetSafePlayerName(uint id)from"utils";
import string GetSafePlayerName(uint id,string&onSuccess,string&onError)from"utils";
import IDateTime@GetCurrentDateTime()from"utils";
import string GetCurrentDateTimeString()from"utils";
import string GetCurrentDateTimeString(bool date,bool time)from"utils";
import Critter@GetMostSkilled(array<Critter@>@group,int skill)from"utils";
import string GetAuthString(Critter&player)from"utils";
import string GetAuthString(int accesslevel)from"utils";
import bool CanRequestHelp(Critter&player)from"utils";
import void SetRequestedHelp(Critter&player)from"utils";
import void SetRequestedHelp(Critter&player,int minutes)from"utils";
import Critter@GetOnlineGM()from"utils";
import void Preprocess(Critter&player,string&commandString)from"utils";
import bool IsHumanoid(Critter@cr)from"utils";
import uint GetGroupIndex(Critter&cr)from"utils";
import uint GetGroupIndex(int st)from"utils";
import void SetGroupIndex(Critter&cr,uint val)from"utils";
import uint GetGroupRank(Critter&cr)from"utils";
import void SetGroupRank(Critter&cr,uint val)from"utils";
import uint GetGroupMode(Critter&cr)from"utils";
import void SetGroupMode(Critter&cr,uint val)from"utils";
import void SetGroupInfo(Critter&cr,uint faction,uint rank,uint mode)from"utils";
import void SetGroupInfoPack(Critter&cr,uint packInfo)from"utils";
import void ClearEvents(Critter&cr)from"utils";

import int GetGvar(uint gvar)from"utils";
import void SetGvar(uint gvar,uint value)from"utils";
import int GetLLvar(Location&location,uint llvar)from"utils";
import int GetLLvar(uint locationId,uint llvar)from"utils";
import void SetLLvar(Location&location,uint llvar,uint value)from"utils";
import int GetLMvar(Map&map,uint llvar)from"utils";
import int GetLMvar(uint mapId,uint llvar)from"utils";
import void SetLMvar(Map&map,uint llvar,uint value)from"utils";
import int GetLIvar(Item&item,uint llvar)from"utils";
import int GetLIvar(uint itemId,uint llvar)from"utils";
import void SetLIvar(Item&item,uint llvar,uint value)from"utils";
import int GetLvar(Critter&critter,uint lvar)from"utils";
import int GetLvar(uint id,uint lvar)from"utils";
import void SetLvar(Critter&critter,uint lvar,uint value)from"utils";
import void SetLvar(uint id,uint lvar,uint value)from"utils";
import int GetUvar(uint uvar,uint key,uint index)from"utils";
import void SetUvar(uint uvar,uint key,uint index,uint value)from"utils";

import uint GetContainerValue(Item@container)from"utils";
import uint BaseItemValue(uint pid,bool ammo)from"utils";
import uint BaseItemValue(uint pid,uint broken,uint det,bool ammo)from"utils";
import uint BaseItemValue(Item@item)from"utils";
import uint BaseItemValue(Item@item,uint proc)from"utils";
import uint BaseSingleItemValue(Item@item)from"utils";
import uint BaseSingleItemValue(Item@item,uint proc)from"utils";

import void SetBloodType(Critter@cr)from"utils";
import string GetBloodType(Critter@cr)from"utils";
import string GetBloodRandom()from"utils";

import void LogCommandUsage(Critter&player,string&commandString)from"utils";
import void DropTimeouts(Critter&cr)from"utils";

import bool HasItem(Critter@cr,uint pid)from"utils";
import bool HasSomeWeapon(Critter@cr)from"utils";
import uint GetBestWeaponSkill(Critter@cr)from"utils";
import void GiveBag(uint bag,Critter@cr)from"utils";
import void SetQuestGarbager(uint time,uint playerid,uint locid,uint var,uint val)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,uint factionRank,uint factionMode,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,array<int>params,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,array<int>params,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,uint factionRank,uint factionMode,bool isMob,uint level)from"utils";
import void AddScore(Critter@cr,uint score,uint points)from"utils";

import bool ReloadWeapon(Critter&cr)from"utils";
import Item@GetRadio(Critter&cr)from"utils";
import Item@GetRepairTool(Critter&cr)from"utils";
import Item@GetEquippedItem(Critter&cr,uint Pid)from"utils";
import Item@GetEquippedItem(Critter&cr,array<uint>&Pids)from"utils";
import Item@GetEquippedItemByType(Critter&cr,uint ItemType)from"utils"; 

import bool SkillRoll(Critter@cr,int skill,int bonus)from"utils";
import int SkillCheck(Critter&cr,int skill,int skillused,Item@item,int bonus)from"utils";
import string SkillName(uint8 skill)from"utils";
import void ChangeCrTypeSafe(Critter&cr,uint8 crType)from"utils";

import bool Pickable(Item@item)from"utils";

import void TransferItemsToContOnMap(Critter&cr,Map@map,int entid,int contpid,int itemtypes)from"utils";
import void TransferItemsFromContOnMap(Critter&cr,Map@map,int entid,int contpid)from"utils";

import string IpToString(uint ip)from"utils";

import void VerboseAction(Critter&cr,string&text)from"utils";
import void VerboseAction(Critter&cr,Critter&target,string&text)from"utils";
import void VerboseExperience(Critter&cr,int xpDiff,int levelDiff)from"utils";

import void SetChosenActions(Critter&cr,array<int>&actions)from"utils";

import void HexLine(uint16 x0,uint16 y0,uint16 x1,uint16 y1,array<uint16>@xList,array<uint16>@yList)from"utils";
import void HexCircle(uint16 x0,uint16 y0,uint16 radius,array<uint16>@xList,array<uint16>@yList)from"utils";

import void StartPersonalDataCleanup()from"utils";

import bool IsPersonalData(Location&location,string&name)from"utils";
import bool GetPersonalData(Location&location,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Location&location,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Location&location,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Location&location,string&name)from"utils";

import bool IsPersonalData(Map&map,string&name)from"utils";
import bool GetPersonalData(Map&map,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Map&map,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Map&map,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Map&map,string&name)from"utils";

import bool IsPersonalData(Critter&critter,string&name)from"utils";
import bool GetPersonalData(Critter&critter,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Critter&critter,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Critter&critter,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Critter&critter,string&name)from"utils";

import bool IsPersonalData(Item&item,string&name)from"utils";
import bool GetPersonalData(Item&item,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Item&item,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Item&item,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Item&item,string&name)from"utils";

import bool FindPreferredGridApprox(Map&map,uint16&hx,uint16&hy)from"utils";           

import bool StrToInt(string@s,uint64&inout val)from"strtoint";
import bool StrToInt(string@s,uint&inout val)from"strtoint";
import bool StrToInt(string@s,uint16&inout val)from"strtoint";
import bool StrToInt(string@s,uint8&inout val)from"strtoint";
import bool StrToInt(string@s,int64&inout val)from"strtoint";
import bool StrToInt(string@s,int16&inout val)from"strtoint";
import bool StrToInt(string@s,int8&inout val)from"strtoint";    

import int FindInArray(array<int>&arr,int value)from"utils";
import int FindInArray(array<uint>&arr,uint value)from"utils";
import int FindInArray(array<uint16>&arr,uint16 value)from"utils";
import int FindInArray(array<uint8>&arr,uint8 value)from"utils";
import bool FindInArray(array<int>&arr,int id,int&index)from"utils";
import bool FindInArray(array<uint>&arr,uint id,int&index)from"utils";
import bool FindInArray(array<uint8>&arr,uint8 id,int&index)from"utils";
import int FindInArray(array<string>&arr,string&value)from"utils";
import int FindInArray(array<string@>@arr,string&value)from"utils";
import bool Present(int what,array<int>&where)from"utils";
import bool Present(uint what,array<uint>&where)from"utils";
import bool Present(uint16 what,array<uint16>&where)from"utils";
import bool Present(string&what,array<string>&where)from"utils";
import bool Present(string&what,array<string@>@where)from"utils";

import uint CreateLocationForGroup(Critter&player,uint16 pid,uint16 worldX,uint16 worldY,array<Critter@>&)from"utils";
import bool FindFirstFreeHex(Map@map,uint16&x,uint16&y,uint8 dir,uint16 maxSteps)from"utils";
import bool FindNearestFreeHex(Map&map,uint16&x,uint16&y,uint radius)from"utils";

import bool GetItemCoordinates(Item&item,uint&mapID,uint16&x,uint16&y)from"utils";
import bool ItemOnHex(uint16 pid,Map@map,uint16 x,uint16 y)from"utils";

import void PrintCallstack()from"utils";
import void PrintCallstack(int level)from"utils";

import bool LocationHasCritters(Location&loc,uint findType)from"utils";
import uint LocationGetCritters(Location&loc,uint findType,array<Critter@>@critters)from"utils";
import uint LocationGetPlayersAndFollowers(Location&loc,uint findType,array<Critter@>@critters)from"utils";
import uint MapGetPlayersAndFollowers(Map&map,uint findType,array<Critter@>@critters)from"utils";
import uint CritterGetPlayersAndFollowers(Critter&critter,bool lookOnMe,uint findType,array<Critter@>@critters)from"utils";
import bool LocationHasItems(Location&loc,uint16 protoId)from"utils";
import uint LocationGetItems(Location&loc,uint16 protoId,array<Item@>@items)from"utils";
import void LocationDeleteItems(Location&loc,uint16 protoId)from"utils";

import bool IsDisposableEncounter(Location@loc)from"utils";

import bool IsT4Item(Item&item)from"utils";
import bool IsT3Item(Item&item)from"utils";
import uint16 AddT3Item()from"utils";
import uint16 AddT4Item()from"utils";
import uint16 AddImplant()from"utils";
import uint16 AddT4BP()from"utils";
import uint16 AddRareAmmo()from"utils";
import uint16 AddTypicalAmmo()from"utils";

import void SetDeterioration(Item&item)from"utils";  

shared class CPosition
{
	uint x;
	uint y;
	uint dir;
};

shared interface IRect
{
	bool IsWithin(Critter&cr);
};

shared class Rect:IRect
{
	uint x1;
	uint y1;
	uint x2;
	uint y2;
	
	Rect(uint x1,uint y1,uint x2,uint y2)
	{
		this.x1=x1;
		this.y1=y1;
		this.x2=x2;
		this.y2=y2;
	}
	
	bool IsWithin(Critter&cr)
	{
		return((cr.HexX>=this.x1&&cr.HexX<=this.x2)&&(cr.HexY>=this.y1&&cr.HexY<=this.y2));
	}
};

shared interface IDateTime
{
	uint16 get_Year();
	uint16 get_Month();
	uint16 get_DayOfWeek();
	uint16 get_Day();
	uint16 get_Hour();
	uint16 get_Minute();
	uint16 get_Second();
	uint16 get_Milliseconds();
	string@ToString();
};                                           

import void AddElevator(IElevator@elevator)from"elevators";
import void HandleElevator(IElevator@elevator,Critter&critter,bool)from"elevators";    

class CFloor
{
	uint MapId;
	uint8 EntireNum;
	uint16 HexX;
	uint16 HexY;
	CFloor(uint mapId,uint8 num)
	{
		this.MapId=mapId;
		this.EntireNum=num;
		Map@map=GetMap(mapId);
		map.GetEntireCoords(EntireNum,0,HexX,HexY);
	}
};

shared interface IElevatorOnMove
{
	bool OnMove(Critter@,uint&);
};

shared interface IElevator
{
	void Transit(Critter&player,uint floor);
	IElevator@AddFloor(uint mapId,uint8 entireNum);
	bool IsInside(Critter&player);
	void AddPlayer(Critter&player);
	void RemovePlayer(Critter@player);
	uint GetCurrentLevel(Critter&player);
	void PlaySound(Critter&player,int floor);
	void Debug(Critter&player);
	void SetOnMove(IElevatorOnMove@callback);
	uint get_Type();
};

class CElevator:IElevator
{
	array<CFloor>floors; 
	
	array<uint>players;
	
	uint type;
	IElevatorOnMove@onmove;
	uint get_Type(){return type;}    
	
	CElevator(uint type)
	{
		this.type=type;
		@onmove=null;
		
	}                   
	
	uint GetDescriptor(Critter&cr)
	{
		return((uint((GetCurrentLevel(cr))&0xFFFF)<<16)|(type)&0xFFFF);
	}  
	
	uint Floors()
	{
		return floors.length();
	}            
	
	uint GetCurrentLevel(Critter&player)
	{
		for(uint i=0,j=floors.length();i<j;i++)
		{
			if(floors[i].MapId==player.GetMapId())
			return i;
		}
		return 0;
	}  
	
	bool IsInside(Critter&player)
	{
		
		for(uint i=0;i<players.length();i++)
		{
			
			if(players[i]==player.Id)
			return true;
		}
		return false;
	}   
	
	void AddPlayer(Critter&player)
	{
		for(uint i=0;i<players.length();i++)
		{
			
			if(players[i]==player.Id)
			return;
		}
		players.insertLast(player.Id);
	}  
	
	void RemovePlayer(Critter@player)
	{
		for(uint i=0;i<players.length();i++)
		{
			if(players[i]==player.Id)
			{
				players.removeAt(i);
				return;
			}
		}
		
	}  
	
	void Transit(Critter&player,uint floor)
	{
		
		this.RemovePlayer(player);
		if((@onmove!=null)&&!onmove.OnMove(player,floor))
		return;
		CFloor@dest=floors[floor];
		
		if(player.GetMapId()!=dest.MapId)
		{
			Map@map=GetMap(dest.MapId);
			map.PlaySound("elv1_2.acm",dest.HexX,dest.HexY,100);
			player.TransitToMap(dest.MapId,dest.EntireNum);
		}
	}
	void PlaySound(Critter&player,int floornum)
	{
		CFloor@floor=floors[floornum];
		Map@map=GetMap(floor.MapId);
		map.PlaySound("elevator.acm",floor.HexX,floor.HexY,10);
	}  
	
	IElevator@AddFloor(uint mapId,uint8 entireNum)
	{
		{;};
		floors.insertLast(CFloor(mapId,entireNum));
		return this;
	}
	
	void Debug(Critter&player)
	{
		player.Say((11),"=== Elevator ===");
		for(uint i=0;i<floors.length();i++)
		{
			player.Say((11),""+i+", "+floors[i].MapId+"/"+floors[i].EntireNum);
		}
	} 
	
	void SetOnMove(IElevatorOnMove@callback)
	{
		@onmove=callback;
	}
};      

class CPidElevator:IElevator
{
	array<CPidFloor>floors; 
	
	array<uint>players;
	
	uint type;
	IElevatorOnMove@onmove;
	uint get_Type(){return type;}    
	
	CPidElevator(uint type)
	{
		this.type=type;
		@onmove=null;
		
	}  
	
	uint GetDescriptor(Critter&cr)
	{
		return((uint((GetCurrentLevel(cr))&0xFFFF)<<16)|(type)&0xFFFF);
	}  
	
	uint Floors()
	{
		return floors.length();
	}  
	
	uint GetCurrentLevel(Critter&player)
	{
		for(uint i=0,j=floors.length();i<j;i++)
		{
			if(floors[i].MapPid==player.GetMapProtoId())
			return i;
		}
		return 0;
	}  
	
	bool IsInside(Critter&player)
	{
		
		for(uint i=0;i<players.length();i++)
		{
			
			if(players[i]==player.Id)
			return true;
		}
		return false;
	}   
	
	void AddPlayer(Critter&player)
	{
		for(uint i=0;i<players.length();i++)
		{
			
			if(players[i]==player.Id)
			return;
		}
		players.insertLast(player.Id);
	}  
	
	void RemovePlayer(Critter@player)
	{
		for(uint i=0;i<players.length();i++)
		{
			if(players[i]==player.Id)
			{
				players.removeAt(i);
				return;
			}
		}
		
	}  
	
	void Transit(Critter&player,uint floor)
	{
		
		this.RemovePlayer(player);
		if((@onmove!=null)&&!onmove.OnMove(player,floor))
		return;
		CPidFloor@dest=floors[floor];
		
		if(player.GetMapProtoId()!=dest.MapPid)
		{
			Location@loc=GetLocationOf(player);
			if((@loc!=null))
			{
				Map@destinationMap=loc.GetMap(dest.MapPid);
				if((@destinationMap!=null))
				player.TransitToMap(destinationMap.Id,dest.EntireNum);
			}
		}
	}
	void PlaySound(Critter&player,int floornum)
	{
		CPidFloor@floor=floors[floornum];
		Location@loc=GetLocationOf(player);
		if((@loc!=null))
		{
			Map@map=loc.GetMap(floor.MapPid);
			map.PlaySound("elevator.acm",floor.HexX,floor.HexY,10);
		}
	}  
	
	IElevator@AddFloor(uint mapId,uint8 entireNum)
	{
		{;};
		floors.insertLast(CPidFloor(mapId,entireNum));
		return this;
	}
	
	void Debug(Critter&player)
	{
		player.Say((11),"=== Elevator ===");
		for(uint i=0;i<floors.length();i++)
		{
			player.Say((11),""+i+", "+floors[i].MapPid+"/"+floors[i].EntireNum);
		}
	} 
	
	void SetOnMove(IElevatorOnMove@callback)
	{
		@onmove=callback;
	}
};

class CPidFloor
{
	uint MapPid;
	uint8 EntireNum;
	uint16 HexX;
	uint16 HexY;
	CPidFloor(uint mapId,uint8 num)
	{
		Map@map=GetMap(mapId);
		this.MapPid=map.GetProtoId();
		this.EntireNum=num;
		map.GetEntireCoords(EntireNum,0,HexX,HexY);
	}
};                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

bool dbInitTable(string@,string@){return true;}
bool dbLog(string@,string@){return true;}                   

void InitDBLogs(){}

void LogExperience(Critter&cr,int amount){}
void LogExperience(Critter&cr,int amount,string@info){}
void LogExperience(Critter&cr,int amount,int skill){}
void LogExperience(Critter&cr,int amount,int skill,string@info){}
void LogExperience(Critter&cr,int amount,int skill,int param){}
void LogExperience(Critter&cr,int amount,int skill,string@info,int param){}
void LogQuestExperience(Critter&cr,int amount,string@info){}
void LogQuestExperience(Critter&cr,int amount,int skill,string@info){}
void LogAttack(Map@map,Critter&cr,Critter&target,ProtoItem&weapon,ProtoItem@ammo,uint8 aim,bool isBurst,uint ammoRound,uint weaponRound,bool isHit,bool isCritical,uint critfailFlags){}
void LogDamage(Map@map,Critter@attacker,Critter&target,Item@weapon,ProtoItem@ammo,uint8 aim,bool isBurst,uint damage,bool isCritical,uint eff,uint rounds){}
void LogGathering(Critter&,uint16,int){}                                     

import void MultihexSpawned(Item&item)from"multihex";
import void MultihexDeleted(Item&item)from"multihex";

import uint GetMHexes(Item@item,array<Item@>@mHexes)from"multihex";
import bool IsMultihex(Item@item)from"multihex";
import bool IsMultihexBlocked(Item@item)from"multihex";
import void MultihexClose(Item@item)from"multihex";
import void MultihexOpen(Item@item)from"multihex";                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   

int GetRootMapData(Map&map,uint index)
{
	return map.GetLocation().GetMapByIndex(0).GetData(index);
}  

void SetRootMapData(Map&map,uint index,int val)
{
	map.GetLocation().GetMapByIndex(0).SetData(index,val);
}   

int GetRootMapData(Location&loc,uint index)
{
	return loc.GetMapByIndex(0).GetData(index);
}  

void SetRootMapData(Location&loc,uint index,int val)
{
	loc.GetMapByIndex(0).SetData(index,val);
}    

import void TryPickupContainer(Critter&cr,Item&locker)from"movable_container";
import void TryRotateContainer(Critter&cr,Item&locker)from"movable_container";
import bool IsCarTrunk(Item@item)from"car";

bool UseItemOnLocker(Critter&cr,Item&locker,Item&item)
{
	return true;
}

bool UseSkillOnLocker(Critter&cr,Item&locker,int skill)
{
	Map@map=cr.GetMap();
	if(!(@map!=null))
	{
		cr.SayMsg((11),(3),(10202));
		return true;
	}
	
	if(skill==(-1))
	{
		return HandleLocker(cr,map,locker,false);
	}
	else if(skill==(210))
	{
		if(locker.GetType()==(8)&&(((locker.LockerCondition)&((0x01)))!=0))
		{
			LockerClose(locker);
			OnClose(locker);
			
		}
		else
		cr.SayMsg((11),(3),(10202));
	}
	else if(skill==(209))
	{     
		
		Map@map=cr.GetMap();
		
		if(map.GetProtoId()==(221)&&IsCarTrunk(locker))
		{
			cr.Say((11),"You can't lockpick car trunk here.");
			return true;
		}
		
		if(IsCarTrunk(locker)&&((map.GetData((10))&((0x00000100)))!=0))
		{
			cr.Say((11),"Find the key!");
			return true;
		}
		
		if(cr.Timeout[(234)]>0)
		{
			cr.SayMsg((11),(3),(3401));
			return true;
		}
		
		if(locker.LockerId==0||(((locker.LockerCondition)&((0x01)))!=0))
		{
			cr.SayMsg((11),(3),(10202));
			return true;
		}
		
		if(locker.GetType()==(8)&&locker.GetScriptId()>0)
		if(GetScriptName(locker.GetScriptId())=="item_spawner_container@item_init")
		if(locker.LockerComplexity>100)
		locker.LockerComplexity=100; 
		
		int base=cr.Param[(209)]-locker.LockerComplexity;
		uint8 mode=0;
		uint16 activePid=cr.GetSlotProto((1),mode).ProtoId;
		Item@lockpicks=cr.GetItem(0,(1));
		if((@lockpicks!=null)&&lockpicks.Proto.Misc_ToolSkillNum==(209))
		{
			base+=lockpicks.Proto.Misc_ToolSkillBonus;
			if(Random(0,30)==0)
			cr.DeleteItem(lockpicks.GetProtoId(),1);
		}   
		
		base=(((base)>(95))?(95):(((base)<(0))?(0):(base)));  
		
		if(base>=Random(1,100))
		{
			if(locker.Proto.Container_Changeble&&!LockerOpen(locker))
			Log("ERR: something wrong with this locker: "+locker.MapId+","+locker.HexX+","+locker.HexY+" pid "+locker.GetProtoId());
			locker.LockerId=0;
			locker.LockerComplexity=0;
			
			if(locker.GetType()==(8))
			cr.ShowContainer(null,locker,locker.Proto.GroundLevel?(2):(1));
			cr.ParamBase[(76)]+=50*(GetGvar((62001)));
			LogExperience(cr,50*(GetGvar((62001))),(209),"Locker",locker.GetProtoId());
			AddScore(cr,(19),1);
		}           
		
		else
		{
			cr.SayMsg((11),(3),(3440));
		}
		
		cr.TimeoutBase[(234)]=((__FullSecond)+(((((275-cr.Param[(209)])/15)*__TimeMultiplier)+cr.Param[(395)])));
	}
	else if(skill==(212))
	{
		if(cr.IsPlayer()&&cr.GetAccess()>=(2))
		cr.Say((11),"Complexity: "+locker.LockerComplexity+", id: "+locker.LockerId);
		
		TryPickupContainer(cr,locker);
	}
	else if(skill==(213))
	{
		TryRotateContainer(cr,locker);
	}
	else
	{
		cr.SayMsg((11),(3),(10202));
	}
	return true;
}

bool HandleLocker(Critter&cr,Map@map,Item&locker,bool disregardKey)
{
	if(locker.GetType()==(9))
	{
		bool not_auto_door=false;
		
		uint mapProtoId=map.GetProtoId();
		if(
		((mapProtoId==(105)||mapProtoId==(103))&&
		(locker.HexX==192&&locker.HexY==210)||
		(locker.HexX==202&&locker.HexY==188))||
		
		((mapProtoId==(578))&&
		(locker.HexX==201&&locker.HexY==278)||
		(locker.HexX==204&&locker.HexY==291)||
		(locker.HexX==198&&locker.HexY==291))
		)
		
		{
			not_auto_door=true;
			
		}
		else
		{
			not_auto_door=false;
			
		}  
		
		if(!locker.Proto.Container_Changeble)
		{
			cr.SayMsg((11),(3),(10202));
			return true;
		} 
		
		if((((locker.LockerCondition)&((0x01)))!=0))
		{
			if(DoorIsBlocked(locker))
			{
				cr.SayMsg((11),(3),(10211));
				return true;
			}
		} 
		
		if(!(((locker.LockerCondition)&((0x01)))!=0)&&locker.LockerId!=0&&
		!(((locker.LockerCondition)&((0x08)))!=0)&&!IsKeyAviable(cr,locker.LockerId)&&!((cr.Param[(534)]&((0x00002000)))!=0)&&!disregardKey)
		{
			cr.SayMsg((11),(3),(10100));
			LockerBudge(locker);
			return true;
		} 
		
		if((((locker.LockerCondition)&((0x01)))!=0))
		{
			LockerClose(locker);
			OnClose(locker);
		}
		else
		{
			if(IsMultihex(locker))
			{
				if(IsMultihexBlocked(locker))
				{
					cr.Say((11),"Something or someone is blocking the door.");
					LockerBudge(locker);
					return true;
				}
				;
			} 
			
			LockerOpen(locker);
			if(IsAutoDoor(locker))
			OnOpenAutoDoor(locker,not_auto_door);
			else
			OnOpenDoor(locker,not_auto_door);
		}
	}
	else if(locker.GetType()==(8))
	{
		
		if(!(((locker.LockerCondition)&((0x01)))!=0)&&locker.LockerId!=0&&
		!(((locker.LockerCondition)&((0x08)))!=0)&&!IsKeyAviable(cr,locker.LockerId)&&!disregardKey)
		{
			cr.SayMsg((11),(3),(10100));
			LockerBudge(locker);
			return true;
		} 
		
		if(locker.Proto.Container_Changeble)
		{
			
			if((((locker.LockerCondition)&((0x01)))!=0))
			{ 
				
				cr.ShowContainer(null,locker,locker.Proto.GroundLevel?(2):(1));
			}
			else
			{
				LockerOpen(locker);
				OnOpenContainer(locker);
				cr.ShowContainer(null,locker,locker.Proto.GroundLevel?(2):(1));
			}
		}
		
		else
		{
			cr.ShowContainer(null,locker,locker.Proto.GroundLevel?(2):(1));
		}
	}
	return true;
}

bool IsKeyAviable(Critter&cr,uint lockerId)
{
	if(lockerId==0)
	return true;
	if((0x80000000|(cr.Id))==lockerId||(0x40000000|(cr.Id))==lockerId)
	return true;
	array<Item@>keys;
	for(uint i=0,j=cr.GetItemsByType((7),keys);i<j;i++)
	if(keys[i].LockerId==lockerId)
	return true;
	if(((cr.Param[(534)]&((0x00002000)))!=0))
	return true;
	return false;
}

uint GetKeyId(Critter&cr,uint lockerId)
{
	if(lockerId==0||(0x80000000|(cr.Id))==lockerId||(0x40000000|(cr.Id))==lockerId)
	return 0;
	array<Item@>keys;
	for(uint i=0,j=cr.GetItemsByType((7),keys);i<j;i++)
	if(keys[i].LockerId==lockerId)
	return keys[i].Id;
	return 0;
}

void SwitchState(Item&locker)
{ 
	
	if(locker.GetType()==(9)||locker.GetType()==(8))
	{
		
		if(locker.Proto.Container_Changeble)
		{
			
			if((((locker.LockerCondition)&((0x01)))!=0))
			LockerClose(locker);
			else
			LockerOpen(locker);
		}
	}
}      

bool IsAutoDoor(Item&door)
{
	uint pid=door.GetProtoId(); 
	
	return(pid==3387||pid==3388||pid==3389||pid==3390||pid==3391||pid==3392
	
	||pid==3337
	
	||pid==2018||pid==2019
	
	||pid==2151||pid==2152||pid==2153
	
	||pid==2421||pid==2470
	
	||pid==2195);
	
}   

bool IsOpenableContainer(uint pid)
{            
	
	ProtoItem@proto=GetProtoItem(pid);
	return proto.Container_Changeble;
}   

bool IsLockableContainer(uint pid)
{
	ProtoItem@proto=GetProtoItem(pid);
	return proto.Container_Changeble||pid==42||pid==43||pid==44||
	(pid>=128&&pid<=139)||
	(pid>=188&&pid<=189)||
	pid==245||
	(pid>=367&&pid<=370)||
	pid==501||pid==502||
	(pid>=197&&pid<=204)|| 
	
	pid==22139||pid==22140||
	pid==22442||pid==22447||
	pid==22567||pid==22568||
	pid==22990||pid==22121||
	(pid>=197&&pid<=204)||
	(pid>=66&&pid<=70)||
	(pid>=181&&pid<=187)||
	(pid>=22142&&pid<=22146)||
	(pid>=22148&&pid<=22150)||
	pid==22174||pid==22262||
	pid==22312||pid==22313||
	pid==22399||pid==22400||
	pid==22413||pid==22634||
	(pid>=22829&&pid<=22832)||
	pid==25197; 
	
}   

bool DoorIsBlocked(Item@door)
{
	if(!(@door!=null))
	return false;
	
	uint16 doorX=0;
	uint16 doorY=0;
	Map@doorMap=door.GetMapPosition(doorX,doorY);
	
	if(!(@doorMap!=null))
	return false;
	
	if(IsMultihex(door))
	{
		return IsMultihexBlocked(door);
	}
	else
	{
		if(!doorMap.IsHexPassed(doorX,doorY))
		return true;
	}
	return false;
}   

void OnOpenAutoDoor(Item@targetItem,bool not_auto_door)
{
	if(targetItem.Val5!=0)
	EraseTimeEvent(targetItem.Val5); 
	
	if(not_auto_door==false)
	targetItem.Val5=CreateTimeEvent(((__FullSecond)+(((Random(10,20))*__TimeMultiplier))),"e_CloseDoor",targetItem.Id,true);
}   

void OnOpenDoor(Item@targetItem,bool not_auto_door)
{
	if(targetItem.Val5!=0)
	EraseTimeEvent(targetItem.Val5);
	
	Map@map=GetMap(targetItem.MapId);
	if((@map!=null)&&
	(map.GetLocation().IsTown()||
	map.GetLocation().IsDungeon()||
	map.GetLocation().IsTCTown()||
	map.GetLocation().IsReplication()))
	{
		if(not_auto_door==false)
		targetItem.Val5=CreateTimeEvent(((__FullSecond)+(((Random(3,6))*__TimeMultiplier*60))),"e_CloseDoor",targetItem.Id,true);
	}
}   

void OnClose(Item@targetItem)
{
	if(targetItem.Val5!=0)
	EraseTimeEvent(targetItem.Val5);
}

void OnOpenContainer(Item@targetItem)
{
	if(targetItem.Val5!=0)
	EraseTimeEvent(targetItem.Val5);
	targetItem.Val5=CreateTimeEvent(((__FullSecond)+(((Random(3,6))*__TimeMultiplier*60))),
	"e_CloseDoor",targetItem.Id,true);
}   

uint e_CloseDoor(array<uint>@values)
{
	uint __nowZZZ=GetTick();
	Item@item=GetItem(values[0]);
	if(!(@item!=null))
	return 0;
	uint16 x=0,y=0;
	Map@map=item.GetMapPosition(x,y);
	if(!(@map!=null))
	return 0;  
	
	if(item.GetType()==(9)&&DoorIsBlocked(item))
	return((3)*__TimeMultiplier); 
	
	if(item.GetScriptId()>0)
	if(GetScriptName(item.GetScriptId())=="lockers@lockthedoor")
	lockthedoor(item,true);
	
	LockerClose(item);
	item.Val5=0;
	uint __endZZZ=GetTick();if(__endZZZ-__nowZZZ>40) Log("I am being executed for a very long time! ("+(__endZZZ-__nowZZZ)+" ms)");
	return 0;
}

bool LockerClose(Item&item)
{
	if(!item.LockerClose())
	return false;
	if(!item.Proto.Container_Changeble)
	return false;
	if(IsMultihex(item))
	MultihexClose(item);
	Map@map=GetMap(item.MapId);
	if(!(@map!=null))
	return true;
	string sound=item.GetType()==(9)?"SCDOORSA.ACM":"ICCNTNRA.ACM";
	sound.rawSet(7,item.Proto.SoundId);
	map.PlaySound(sound,item.HexX,item.HexY,(15));
	return true;
}

bool LockerOpen(Item&item)
{
	if(!item.LockerOpen())
	return false;
	if(!item.Proto.Container_Changeble)
	return false;
	if(IsMultihex(item))
	MultihexOpen(item);
	Map@map=GetMap(item.MapId);
	if(!(@map!=null))
	return true;
	string sound=item.GetType()==(9)?"SODOORSA.ACM":"IOCNTNRA.ACM";
	sound.rawSet(7,item.Proto.SoundId);
	map.PlaySound(sound,item.HexX,item.HexY,(15));
	return true;
}

void LockerBudge(Item&item)
{
	Map@map=GetMap(item.MapId);
	if(!(@map!=null))
	return;
	string sound=item.GetType()==(9)?"SLDOORSA.ACM":"ILCNTNRA.ACM";
	sound.rawSet(7,item.Proto.SoundId);
	map.PlaySound(sound,item.HexX,item.HexY,(15));
}

void lockthedoor(Item&door,bool firstTime)
{
	uint16 lockerComplex;
	
	door.Val8=(400);
	
	if(firstTime)
	{
		if(door.Val0<=0||door.Val1<=0
		||door.Val0>250||door.Val1>250
		||door.Val0>door.Val1)
		{
			lockerComplex=Random(150,200);
		}
		else
		{
			lockerComplex=Random(door.Val0,door.Val1);
		}
		door.LockerId=Random(98989,989898);
		door.LockerComplexity=lockerComplex;
	}
}

bool IsMovableLocker(uint16 pid)
{
	return pid==(652)||pid==(654)
	||pid==(658)||pid==(662)
	||pid==(660)||pid==(664)
	||pid==(666)||pid==(656)
	||pid==(650);
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

import bool AddMiscPlane(Critter&npc,uint priority,uint waitMinute,string@funcName)from"npc_planes";
import bool AddMiscPlane(Critter&npc,uint priority,int identifier,uint identifierExt,uint waitSecond,string@funcName)from"npc_planes";
import bool AddWalkPlane(Critter&npc,uint priority,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)from"npc_planes";
import bool AddWalkPlane(Critter&npc,uint priority,int identifier,uint identifierExt,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)from"npc_planes";
import bool AddAttackPlane(Critter&npc,uint priority,Critter&target)from"npc_planes";
import bool AddAttackPlane(Critter&npc,uint priority,uint critId)from"npc_planes";
import bool AddAttackPlane(Critter&npc,uint priority,Critter&target,int minHp)from"npc_planes";
import bool AddAttackPlane(Critter&npc,uint priority,uint critId,int minHp)from"npc_planes";
import bool AddAttackPlane(Critter&npc,uint priority,Critter&target,bool run)from"npc_planes";
import bool AddPickPlane(Critter&npc,uint priority,uint16 hexX,uint16 hexY,uint16 protoId,uint useItemId,bool toOpen)from"npc_planes";
import bool AddPickPlane(Critter&npc,uint priority,Item@item,uint useItemId,bool toOpen)from"npc_planes";
import bool AddPickPlane(Critter&npc,uint priority,Item@item,uint useItemId,bool toOpen,bool run)from"npc_planes";
import bool AddHealCritterPlane(Critter&npc,uint priority,Critter@target,bool run)from"npc_planes";
import bool AddDoctorCritterPlane(Critter&npc,uint priority,Critter@target,bool run)from"npc_planes";

import uint EraseAttackPlane(Critter&npc,uint priority,Critter&target)from"npc_planes";
import uint EraseAttackPlane(Critter&npc,uint priority,uint critId)from"npc_planes";                                                                                             

shared interface IBroadcastBuffer
{
	string GetString();
	
	void SetType(int type);
	int GetType();
	void SetTime(int time);
	int GetTime();
	void SetSetup(int setup);
	int GetSetup();
	void SetMessage(string message);
	void AppendMessage(string message);
	string GetMessage();
	void SetData(array<int>data);
	
	void SetStart(int time);
	void ResetStart();
	
	void SetLifetime(int lifetime);
	
	void SetFilters(int filters);
	void SetFilter(int filter);
	void SetFilter(int filter,int data);
	void UnsetFilter(int filter);
	bool Filter(int filter);
	bool CheckFilters(Critter@player);
	
	bool Send(Critter@player);
	uint SendToAll();
	
	void SetGM(int id);
	void UnsetGM();
	
	void ToDelete();
};  

import void UpdateBroadcast()from"broadcast";

import IBroadcastBuffer@AddBroadcastBuffer(int type,int time,int setup,string&message,array<int>&data,int lifetime,int flags)from"broadcast";
import void DumpBroadcastBuffer(Critter@player)from"broadcast";
import uint FindBroadcastBufferByType(int type,array<IBroadcastBuffer@>&buf)from"broadcast";
import uint FindBroadcastBufferByGM(int id,array<IBroadcastBuffer@>&buf)from"broadcast"; 

import IBroadcastBuffer@Broadcast_Message(string&message,int time,int filters,bool send)from"broadcast";
import IBroadcastBuffer@Broadcast_Message(string&message,int time,int filters)from"broadcast";
import IBroadcastBuffer@Broadcast_Message(string&message,int&time)from"broadcast";
import IBroadcastBuffer@Broadcast_Message(string&message,bool send)from"broadcast";
import IBroadcastBuffer@Broadcast_Message(string&message)from"broadcast"; 

import void Broadcast_TownControl_Set(string&message,int location,int time,int faction)from"broadcast";
import void Broadcast_TownControl_Set(int location,int time,int faction,Critter&player)from"broadcast";
import void Broadcast_TownControl_Stop(int location)from"broadcast"; 

import IBroadcastBuffer@Broadcast_Influence(int location,int time,string&message)from"broadcast"; 

import uint Broadcast_RequestHelp(Critter@player,string&message)from"broadcast";
import void Broadcast_CheckRequestHelpBuffer(Critter@gm)from"broadcast";
import void Broadcast_DumpRequestHelpBuffer(Critter@gm)from"broadcast"; 

import void baseControl(string msg,int mapId,uint time)from"broadcast";
import void baseControlRadio(string msg,uint time,int mapId,uint factionId)from"broadcast"; 

import void ServerEventMSG(uint time,string msg)from"broadcast"; 

import IBroadcastBuffer@GetEventCountDownBuffer(int location,int type)from"broadcast";
import void ServerEventCNTSet(string message,uint location,uint type,uint time)from"broadcast";
import void ServerEventCNTSet(uint location,uint type,uint time)from"broadcast";
import void ServerEventCNTStop(uint location,uint type)from"broadcast";                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

const string@FD_Result2String(int res)
{
	if(res==(0))
	return"FD_RESULT_SUCCESS";
	else if(res==(1))
	return"FD_RESULT_ALREADY_EXISTS";
	else if(res==(2))
	return"FD_RESULT_NOT_FOUND";
	else if(res==(3))
	return"FD_RESULT_ANY_DATA_ERROR";
	else if(res==(4))
	return"FD_RESULT_INVALID_ARGUMENT";
	else if(res==(5))
	return"FD_RESULT_LVAR_ERROR";
	else if(res==(6))
	return"FD_RESULT_DB_NOT_FOUND";
	else if(res==(7))
	return"FD_RESULT_DB_FULL";
	else if(res==(8))
	return"FD_RESULT_DB_EMPTY";
	else
	return"FD_Result: Unknown error code";
}      

import bool IsBigFaction(uint faction)from"factions";
import bool IsTheSameFaction(uint player1Id,uint player2Id)from"factions";
import void _Resign(uint playerId)from"factions"; 

import int RegisterFaction(uint id,const string@name,bool playerDriven)from"factions";
import int RegisterFaction(const string@name,bool playerDriven,uint&out id)from"factions";

import bool RemoveFaction(uint faction)from"factions"; 

import bool GetFactionNameStr(uint faction,string&out name)from"factions";
import bool GetFactionId(const string@name,uint&out id)from"factions"; 

import bool IsFactionNameFree(const string&)from"factions";
import bool IsFactionNameValid(const string&)from"factions";

import bool IsGang(uint faction)from"factions";

import uint16 GetFactionRadioChannel(uint faction)from"factions";
import void SetFactionRadioChannel(uint faction,uint16 channel)from"factions"; 

import int AddPlayer(uint faction,uint id)from"factions";
import int AddPlayer(uint faction,uint id,uint playerFaction)from"factions";
import int AddPlayer(uint faction,uint id,uint playerFaction,uint rank)from"factions";
import int AddPlayer(uint faction,uint id,uint playerFaction,uint rank,uint status)from"factions"; 

import int RemovePlayer(uint faction,uint id)from"factions"; 

import int GetFaction(uint faction,uint id)from"factions";
import int GetStatus(uint faction,uint id)from"factions";
import int GetRank(uint faction,uint id)from"factions";
import bool IsMember(uint faction,Critter&cr)from"factions";
import bool IsMemberOffline(uint faction,uint id)from"factions";
import bool StoredInDB(uint faction,uint id)from"factions";
import uint GetRecordsCount(uint faction)from"factions";
import uint GetMembersCount(uint faction)from"factions";
import uint GetMembers(uint faction,array<uint>&ids)from"factions";
import uint GetLeaderId(uint faction)from"factions";
import void SetLeaderId(uint faction,uint id)from"factions";
import uint GetClaimId(uint faction)from"factions";
import void SetClaimId(uint faction,uint id)from"factions";
import uint GetLeaderTime(uint faction)from"factions";
import void SetLeaderTime(uint faction,uint time)from"factions";
import uint GetClaimTime(uint faction)from"factions";
import void SetClaimTime(uint faction,uint time)from"factions";
import uint GetFactionLocationId(uint faction)from"factions";
import bool GetFactionLocation(uint faction,uint&out locId,uint&out pid,uint&out x,uint&out y)from"factions";

import void GetFactionLocationCoords(uint faction,uint&out x,uint&out y)from"factions";

import uint GetFactionScore(uint faction)from"factions";
import void ModifyFactionScore(uint faction,int amount)from"factions";
import void UpdateLastUsed(uint faction)from"factions";
import uint GetFactionsCount()from"factions"; 

import int GetPrevId(uint faction,uint currId,bool members,uint&out prevId)from"factions";
import int GetNextId(uint faction,uint currId,bool members,uint&out nextId)from"factions";
import int GetFirstId(uint faction,bool members,uint&out id)from"factions"; 

import int ModifyRank(uint faction,uint id,uint newRank)from"factions";
import int ModifyStatus(uint faction,uint id,uint newStatus)from"factions";
import int ModifyFaction(uint faction,uint id,uint newFaction)from"factions"; 

import int InvitePlayer(uint faction,uint playerId)from"factions";
import int ConfirmInvitation(uint faction,uint playerId)from"factions";
import int AddMember(uint faction,uint playerId)from"factions";
import int AddMember(uint faction,uint playerId,bool applyModifiers)from"factions";
import int ChangeRank(uint faction,uint playerId,uint newRank)from"factions";
import int ExpelMember(uint faction,uint playerId)from"factions";
import int ExpelMember(uint faction,uint playerId,bool applyModifiers)from"factions";

import uint GetPlayerFaction(uint playerId)from"factions";
import uint GetPlayerRank(uint playerId)from"factions"; 

import void AddFactionNews(uint faction,uint master,uint slave,uint type)from"factions";
import bool GetFactionNews(uint faction,uint index,uint&out master,uint&out slave,uint&out type,uint16&out year,uint8&out month,uint8&out day,uint8&out hour,uint8&out minute)from"factions";
import uint GetFactionNewsCount(uint faction)from"factions"; 

import uint CheckFactionBaseCoords(uint x,uint y)from"factions";

import bool SaveFactionData(uint faction)from"factions";
import bool FactionExists(uint faction)from"factions"; 

import uint GetFactionLog(uint faction,bool fullLog,array<string>&strings,uint begin,uint end)from"factions";   

import void InitFactions()from"factions";
import void UpdateFactionsInfo(Critter&cr)from"factions";
import IFaction@GetFaction(int)from"factions";
import IFaction@GetFaction(const string&)from"factions";
import IFaction@GetFactionByIdx(int idx)from"factions";
import void UpdateGroupVars(Critter&player)from"factions";     

shared interface IFaction
{
	int get_Id()const;
	string get_Name()const;
	int get_StringId()const;
	string get_Database()const;
	int get_UpdateSeq()const;
	void set_UpdateSeq(int);
	
	int GetStatus(int id)const;
	void SetStatus(int id,int status);
	int GetRank(int id)const;
	void SetRank(int id,int rank);
	void settag(int index,int tag,int r,int g,int b);
	int get_tag(int index);
	int get_b(int index);
	int get_r(int index);
	int get_g(int index);  
	
	int GetMembers(array<uint>&)const;
	int GetRecords(array<uint>&)const;  
	
	void AddKnownFaction(int);   
	
	int GetKnownFactions(array<int>&)const;
	void Remove();
};             

import bool IsNight()from"world_common";
import bool IsDay()from"world_common";
import bool IsMorning()from"world_common";
import bool IsAfternoon()from"world_common";
import bool IsEvening()from"world_common";
import bool IsHospital(Map@map)from"world_common";
import bool IsCave(Map@map)from"world_common";
import bool IsMine(Map@map)from"world_common";
import bool IsJail(Map@map)from"world_common";
import bool IsBase(Map@map)from"world_common";
import bool IsTent(Map@map)from"world_common";
import bool IsWarzone(Map@map)from"world_common";          

void item_init(Item&item,bool firstTime)
{    
	
	item.SetEvent((4),"_UseSkill");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _Campfire(Item&item,bool firstTime)
{
	item.SetScript("map_tent@_RegenItem");
}

void _Primitive(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillPrimitive");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _Advanced(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillAdvanced");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _Tobacco(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillTobacco");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _Raiders(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillRaiders");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _SierraAmmo(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillSierraAmmo");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _SierraMed(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillSierraMed");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _VCMed(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillVCMed");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}  

void _Rotgut(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillRotgut");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _NukaCola(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillNukaCola");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _Beer(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillBeer");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _HiTechPA(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillHiTechPA");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _HiTechSG(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillHiTechSG");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _HiTechBG(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillHiTechBG");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _HiTechEN(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillHiTechEN");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _EnergyCells(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillEnergyCells");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _AdvFoundry(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillAdvFoundry");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _Foundry(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillFoundry");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _HiTechAmmo(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillHiTechAmmo");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _Extended(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillExtended");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _CloseCombat(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillCloseCombat");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
}

void _PowderAmmo(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_UseSkillPowderAmmo");
	item.SetEvent((5),"_Drop");
	item.SetEvent((6),"_Move");
} 

void _Drop(Item&item,Critter&cr)
{
	DeleteItem(item);
}

void _Move(Item&item,Critter&cr,uint8 fromSlot)
{
	DeleteItem(item);
}

bool _UseSkillPrimitive(Item&item,Critter&player,int skill)
{
	if(skill==(-1))
	{
		
		player.DropTimers();
		GiveWorkbench(player,(571));
		player.ShowScreen((9),0,"");
		return true;
	}
	
	return false;
} 

bool _UseSkillSierraAmmo(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		if(GetGlobalVar((1160))==3)
		{
			
			player.DropTimers();    
			
			GiveWorkbench(player,(9914));
			player.ShowScreen((9),0,"");
			return true;
		}
		else
		player.Say((11),"This terminal controls the Ammo Repair Facility in the next room. You could use it to start some production, but the power input is low.");
	}
	
	return false;
} 

bool _UseSkillSierraMed(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		if(GetGlobalVar((1160))==2)
		{
			
			player.DropTimers();
			
			GiveWorkbench(player,(4608));
			player.ShowScreen((9),0,"");
			return true;
		}
		else
		{
			player.Say((11),"This is the main Medicine Lab terminal. It looks like you could start producing some advanced medicines and drugs using it, but the current power input is too low for that.");
			return false;
		}
	}
	return false;
} 

bool _UseSkillVCMed(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		player.Animate((1),(28),item,true,true);
		
		player.DropTimers();
		
		GiveWorkbench(player,(4608));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
} 

bool _UseSkill(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		
		player.DropTimers();
		
		GiveWorkbench(player,(157));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
} 

bool _UseSkillAdvanced(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		player.Animate((1),(28),item,true,true);
		
		player.DropTimers();
		
		GiveWorkbench(player,(9914));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
} 

bool _UseSkillTobacco(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		
		player.DropTimers();
		
		GiveWorkbench(player,(22116));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
} 

bool _UseSkillRaiders(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		
		player.DropTimers();
		GiveWorkbench(player,(157));    
		
		GiveWorkbench(player,(9914));
		
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
}  

bool _UseSkillRotgut(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		player.Animate((1),(28),item,true,true);
		
		player.DropTimers();
		
		GiveWorkbench(player,(22117));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
}

bool _UseSkillNukaCola(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		player.Animate((1),(28),item,true,true);
		
		player.DropTimers();
		
		GiveWorkbench(player,(22114));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
}

bool _UseSkillBeer(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		player.Animate((1),(28),item,true,true);
		
		player.DropTimers();
		
		GiveWorkbench(player,(22115));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
}

bool _UseSkillHiTechPA(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		player.Animate((1),(28),item,true,true);
		
		player.DropTimers();
		
		GiveWorkbench(player,(22096));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
}

bool _UseSkillHiTechSG(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		player.Animate((1),(28),item,true,true);
		
		player.DropTimers();
		
		GiveWorkbench(player,(22098));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
}

bool _UseSkillHiTechBG(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		player.Animate((1),(28),item,true,true);
		
		player.DropTimers();
		
		GiveWorkbench(player,(22100));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
}

bool _UseSkillHiTechEN(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		player.Animate((1),(28),item,true,true);
		
		player.DropTimers();
		
		GiveWorkbench(player,(22102));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
}

bool _UseSkillEnergyCells(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		player.Animate((1),(28),item,true,true);
		
		player.DropTimers();
		
		GiveWorkbench(player,(22104));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
}

bool _UseSkillAdvFoundry(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		player.Animate((1),(28),item,true,true);
		
		player.DropTimers();
		
		GiveWorkbench(player,(22106));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
}

bool _UseSkillFoundry(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		player.Animate((1),(28),item,true,true);
		
		player.DropTimers();
		
		GiveWorkbench(player,(22108));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
}

bool _UseSkillHiTechAmmo(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		player.Animate((1),(28),item,true,true);
		
		player.DropTimers();
		
		GiveWorkbench(player,(22109));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
}

bool _UseSkillExtended(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		player.Animate((1),(28),item,true,true);
		
		player.DropTimers();
		
		GiveWorkbench(player,(22110));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
}

bool _UseSkillCloseCombat(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		player.Animate((1),(28),item,true,true);
		
		player.DropTimers();
		
		GiveWorkbench(player,(22111));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
}

bool _UseSkillPowderAmmo(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		player.Animate((1),(28),item,true,true);
		
		player.DropTimers();
		
		GiveWorkbench(player,(22112));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
} 

void GiveWorkbench(Critter&player,uint pid)
{
	if(player.CountItem(pid)>0)
	return;
	Item@workbench=player.AddItem(pid,1);
	
	workbench.SetScript("item_init");
	workbench.PicInv=uint16(-1);
	workbench.Info=uint8(-1);
	workbench.SortValue=uint16(-1);
	workbench.Update();
	
}

void RemoveWorkbench(Critter&player,uint pid)
{
	if(player.CountItem(pid)>0)
	player.DeleteItem(pid,player.CountItem(pid));
}

void RemoveWorkbenches(Critter&player)
{
	RemoveWorkbench(player,(157));
	RemoveWorkbench(player,(571));
	RemoveWorkbench(player,(1864));
	RemoveWorkbench(player,(3167));
	RemoveWorkbench(player,(4608));
	RemoveWorkbench(player,(1865));
	RemoveWorkbench(player,(9913));
	RemoveWorkbench(player,(9914));
	RemoveWorkbench(player,(22116));
	RemoveWorkbench(player,(22117));
	RemoveWorkbench(player,(22114));
	RemoveWorkbench(player,(22115));
	RemoveWorkbench(player,(22096));
	RemoveWorkbench(player,(22097));
	RemoveWorkbench(player,(22098));
	RemoveWorkbench(player,(22099));
	RemoveWorkbench(player,(22100));
	RemoveWorkbench(player,(22101));
	RemoveWorkbench(player,(22102));
	RemoveWorkbench(player,(22103));
	RemoveWorkbench(player,(22104));
	RemoveWorkbench(player,(22105));
	RemoveWorkbench(player,(22106));
	RemoveWorkbench(player,(22107));
	RemoveWorkbench(player,(22108));
	RemoveWorkbench(player,(22109));
	RemoveWorkbench(player,(22110));
	RemoveWorkbench(player,(22111));
	RemoveWorkbench(player,(22112));
	RemoveWorkbench(player,(22113));
}

void t_Workbench(Critter&player,Scenery&trigger,bool entered,uint8 dir)
{
	if(!entered)
	{
		RemoveWorkbenches(player);
		player.DropTimers();
	}
}

void t_WorkbenchRaiders(Critter&player,Scenery&trigger,bool entered,uint8 dir)
{
	if(!entered)
	{
		
		RemoveWorkbench(player,(157));
		RemoveWorkbench(player,(1864));
		player.DropTimers();
	}
} 

bool s_Terminal(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(player.IsPlayer()&&skill==-1&&!(@item!=null))
	RunDialog(player,(1200),terminal.HexX,terminal.HexY,false);
	
	return true;
} 

bool s_Terminal_SAD(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(player.IsPlayer()&&skill==-1&&!(@item!=null))
	RunDialog(player,(800),terminal.HexX,terminal.HexY,false);
	
	return true;
} 

bool s_Mfc_Machine(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(player.IsPlayer()&&skill==-1&&!(@item!=null))
	{
		
		player.DropTimers();    
		
		GiveWorkbench(player,(9914));
		
		GiveWorkbench(player,(4608));
		player.ShowScreen((9),0,"");
		return true;
	}
	return false;
} 

bool s_Power_SAD(Critter&player,Scenery&terminal,int skill,Item@item)
{
	GameVar@power=GetGlobalVar((1160));
	if(!(@power!=null))
	{
		Log("ERROR: not valid GameVar "+(1160)+" "+GetLastError());
		return true;
	} 
	
	if(player.IsPlayer()&&skill==-1&&!(@item!=null))
	{
		if(power==0)
		player.SayMsg((11),(1),(1000000000+((800))*100000+((3))));
		if(power>0)
		player.SayMsg((11),(1),(1000000000+((800))*100000+((2))));
	}
	
	if(player.IsPlayer()&&skill==(213)&&!(@item!=null))
	{
		int check=Random(80,120);
		
		if(power==0)
		{
			if(((player.Param[(213)])>check))
			{
				power=1;
				
				player.ParamBase[(76)]+=50*(GetGvar((62001)));
				LogExperience(player,50*(GetGvar((62001))),"sad terminal");
				player.SayMsg((11),(1),(1000000000+((800))*100000+((1))));
			}
			else
			player.SayMsg((11),(1),(1000000000+((800))*100000+((0))));
		}
		if(power>1)
		player.SayMsg((11),(1),(1000000000+((800))*100000+((2))));
	}
	return true;
}

void place_campfire(Critter&cr,int,int,int)
{
	Item@it=cr.GetMap().AddItem(cr.HexX,cr.HexY,(9913),1);
	it.SetScript("_Campfire");
}                                                                                                                                                                                              

shared interface IPolygon
{
	IPolygon@AddVertex(uint16 x,uint16 y);
	IPolygon@AddVertices(array<uint16>&hexes);   
	
	bool IsWithin(Critter&cr);
	bool IsWithin(Item&item);  
	
	bool IsWithin(uint16 x,uint16 y);
};  

import IPolygon@NewPolygon()from"polygon"; 

import IPolygon@LoadShapeFromEntires(Map&map,uint first,uint last)from"polygon";         

import void InitializeDynamicMob(Map&map)from"mob_dynamic";
import int GetDistance(Critter&mob)from"mob_dynamic";
import void ExplodeEx(Map&map,uint16 hexX,uint16 hexY,uint16 effectPid,uint effectRadius,uint damage,uint damageType,uint damageRadius,uint ownerId,uint16 explodePid)from"explode";                              

bool ElevatorsAdded=false,HowitzerLoaded,DoorAreBroken,    

PowerON,
PowerGen1Working,PowerGen2Working,PowerGen3Working,
PowerGen4Working,PowerGen5Working,PowerGen6Working, 

AccessToElevator123,AccessToElevator34,
RobotsOnline,RobotsHacked,RobotsAreOnline=true;     

array<uint>SierraRobots; 

CElevator Elevator_123((4));

class Elevator_123Callback:IElevatorOnMove
{
	Elevator_123Callback(){}
	bool OnMove(Critter@cr,uint&floor)
	{
		if(!PowerON)
		{
			cr.Say((11),"The elevator seems to be without power.");
			return false;
		}
		return true;
	}
};

CElevator Elevator_34((5));

class Elevator_34Callback:IElevatorOnMove
{
	Elevator_34Callback(){}
	bool OnMove(Critter@cr,uint&floor)
	{
		if(!PowerON)
		{
			cr.Say((11),"The elevator seems to be without power.");
			return false;
		}
		return true;
	}
};

Elevator_123Callback@check_123;
Elevator_34Callback@check_34;

void map_init(Map&map,bool firstTime)
{
	if(map.GetProtoId()==(25)&&firstTime)
	{
		SpawnSierraDoor(map);
		
		Item@rewarddoor=map.GetItem(130,83,3358);
		if((((rewarddoor.LockerCondition)&((0x01)))!=0))
		SwitchState(rewarddoor);
	}
	
	if(map.GetProtoId()==(25))
	{
		if(GetGlobalVar((1150))==1)PowerON=true;else PowerON=false;
		if(GetGlobalVar((1151))==1)PowerGen1Working=true;else PowerGen1Working=false;
		if(GetGlobalVar((1152))==1)PowerGen2Working=true;else PowerGen2Working=false;
		if(GetGlobalVar((1153))==1)PowerGen3Working=true;else PowerGen3Working=false;
		if(GetGlobalVar((1154))==1)PowerGen4Working=true;else PowerGen4Working=false;
		if(GetGlobalVar((1155))==1)PowerGen5Working=true;else PowerGen5Working=false;
		if(GetGlobalVar((1156))==1)PowerGen6Working=true;else PowerGen6Working=false;
		if(GetGlobalVar((1157))==1)AccessToElevator123=true;else AccessToElevator123=false;
		if(GetGlobalVar((1158))==1)AccessToElevator34=true;else AccessToElevator34=false;
		if(GetGlobalVar((1159))==1)HowitzerLoaded=true;else HowitzerLoaded=false;
		if(GetGlobalVar((1161))==1)RobotsOnline=true;else RobotsOnline=false;
		if(GetGlobalVar((1162))==2)RobotsHacked=true;else RobotsHacked=false;
		
		Item@sierraGate=map.GetItem(100,41,(3347));
		if((@sierraGate!=null))DoorAreBroken=false;else DoorAreBroken=true;
		
		InitExternalMagazine(map);
		InitTheMainGate(map);
	}
	
	Item@powerswitch=null;
	
	switch(map.GetProtoId())
	{
		case(26):
		@powerswitch=map.GetItem(80,67,3236);
		if(PowerON)
		{
			powerswitch.Animate(0,1);
			powerswitch.AnimStayBegin=1;
			powerswitch.AnimStayEnd=1;
			powerswitch.Update();
		}
		else
		{
			powerswitch.Animate(1,0);
			powerswitch.AnimStayBegin=0;
			powerswitch.AnimStayEnd=0;
			powerswitch.Update();
		}
		case(27):
		case(28):
		case(29):
		case(30):
		PowerON?map.SetTime(720):map.SetTime(180);
		
		break;
	} 
	
	if(!ElevatorsAdded)
	{
		
		AddElevator(Elevator_123);
		AddElevator(Elevator_34);
		@check_123=@Elevator_123Callback();
		Elevator_123.SetOnMove(check_123);
		@check_34=@Elevator_34Callback();
		Elevator_34.SetOnMove(check_34);
		ElevatorsAdded=true;
	}
	
	uint16 x=0,y=0;
	
	switch(map.GetProtoId())
	{
		case(27):
		if(map.GetEntireCoords(1,0,x,y))
		Elevator_123.AddFloor(map.Id,1);
		break;
		case(28):
		if(map.GetEntireCoords(1,0,x,y))
		Elevator_123.AddFloor(map.Id,1);
		break;
		case(29):
		if(map.GetEntireCoords(1,0,x,y))
		Elevator_123.AddFloor(map.Id,1);
		if(map.GetEntireCoords(2,0,x,y))
		Elevator_34.AddFloor(map.Id,2);
		break;
		case(30):
		if(map.GetEntireCoords(2,0,x,y))
		Elevator_34.AddFloor(map.Id,2);
		break;
		default:
	}  
	
}    

void t_Elevator(Critter&critter,Scenery&trigger,bool entered,uint8 dir)
{
	HandleElevator(Elevator_123,critter,entered);
}

void t_ElevatorPower(Critter&critter,Scenery&trigger,bool entered,uint8 dir)
{
	HandleElevator(Elevator_34,critter,entered);
}    

void SierraTurret(Critter&mob,bool firstTime)
{
	mob.SetEvent((0),"mob_dynamic@_DontMove");
	mob.SetEvent((16),"mob_dynamic@_Alert");
	mob.SetEvent((2),"mob_dynamic@_ClearEnemyStack");
	
	mob.ParamBase[(511)]=1;
	mob.ParamBase[(523)]=1;
	mob.ParamBase[(532)]=1;
	mob.ParamBase[(522)]=1;
	mob.ParamBase[(541)]=1;
	mob.ParamBase[(512)]=1;
	
	(mob.ParamBase[(534)]=mob.Param[(534)]|((0x00000004)));
}    

void SpawnSierraDoor(Map&map)
{
	if(!(@map!=null))return; 
	
	Item@SierraDoor=map.GetItem(100,41,(3347));
	if((@SierraDoor!=null))
	return; 
	
	array<Critter@>critters;
	
	map.GetCrittersHex(98,41,0,(0x03),critters);
	map.GetCrittersHex(99,42,0,(0x03),critters);
	map.GetCrittersHex(101,42,0,(0x03),critters);
	map.GetCrittersHex(100,41,0,(0x03),critters); 
	
	if(critters.length()>0)
	for(uint i=0,j=critters.length();i<j;i++)
	{
		if((@critters[i]!=null))
		{
			if(critters[i].IsPlayer())critters[i].Say((11),"You were squeezed by door.");
			critters[i].ToDead((117),null);
		}
	}
	
	critters.resize(0);
	
	map.GetCritters(0,(0x03),critters);
	
	if(critters.length()>0)
	for(uint i=0,j=critters.length();i<j;i++)
	{
		if((@critters[i]!=null))
		{
			if(IsInTheMainGate(critters[i],map))
			{
				if(critters[i].IsPlayer())
				critters[i].Say((11),"You were squeezed by door.");
				critters[i].ToDead((117),null);
			}
		}
	} 
	
	@SierraDoor=map.AddItem(98,41,(826),1);
	if((@SierraDoor!=null))
	((SierraDoor.Flags)=(SierraDoor.Flags)|(0|(0x00000200)));
	@SierraDoor=map.AddItem(99,42,(826),1);
	if((@SierraDoor!=null))
	((SierraDoor.Flags)=(SierraDoor.Flags)|(0|(0x00000200)));
	@SierraDoor=map.AddItem(101,42,(826),1);
	if((@SierraDoor!=null))
	((SierraDoor.Flags)=(SierraDoor.Flags)|(0|(0x00000200)));
	
	map.AddItem(100,41,(3347),1);
	
	DoorAreBroken=false;
}    

bool s_Howitzer(Critter&player,Scenery&howitzer,int skill,Item@item)
{
	if(!player.IsPlayer())
	return false;
	
	if((@item!=null)&&item.GetProtoId()==(430))
	{
		
		if(HowitzerLoaded)
		{
			player.Say((11),"Howitzer can fire only one shell at once.");
		}
		else
		{
			player.Say((11),"Howitzer is ready to fire.");
			
			if(item.GetCount()>1)
			item.SetCount(item.GetCount()-1);
			else
			DeleteItem(item);
			HowitzerLoaded=true;
			SetGvar((1159),1);
		}
		return true;
	}
	
	if((@item!=null)&&item.GetProtoId()!=(430))
	{
		player.Say((11),"Now seriously... You want to put it there?");
		return true;
	}
	
	if(skill==(-1)&&!(@item!=null))
	{
		if(DoorAreBroken)
		{
			player.Say((11),"Howitzer is too hot now for another shot.");
			return true;
		}
		
		if(HowitzerLoaded)
		{
			Map@map=player.GetMap();
			if(!(@map!=null))
			return true; 
			
			DestroySierraDoor(map,player);
			HowitzerLoaded=false;
			SetGvar((1159),0);
			DoorAreBroken=true;
			array<Item@>lockers;
			map.GetItemsByType((8),lockers);
			for(uint16 i=0;i<lockers.length();i++)
			{
				if((@lockers[i]!=null))
				{
					lockers[i].AddItem((271),1,1);
					lockers[i].LockerId=0;
					lockers[i].LockerComplexity=0;
					ClearContainer(lockers[i]);
				}
			}
			
		}
		else
		{
			player.Say((11),"Howitzer is not loaded.");
		}
		
		return true;
	}
	
	if(skill==(213)&&!(@item!=null)&&DoorAreBroken)
	{
		player.Say((11),"It's too hot, not broken.");
		return true;
	}
	
	return false;
}

void PowerSwitch(Item&powerswitch,bool firstTime)
{
	if(firstTime)
	{
		powerswitch.AnimStayBegin=0;
		powerswitch.AnimStayEnd=0;
		powerswitch.Update();
	}
	powerswitch.SetEvent((4),"_UsePowerSwitch");
}

bool _UsePowerSwitch(Item&powerswitch,Critter&player,int skill)
{
	player.Animate((1),(28),powerswitch,true,true);
	
	if(skill==(-1))
	{
		if(!PowerON&&AllGeneratorsWorking())
		{
			player.Say((11),"Whole base is supplied now.");
			PowerON=true;
			PowerOn(player.GetMap());   
			
			return true;
		}
		else if(!PowerON&&!AllGeneratorsWorking())
		{
			player.Say((11),"Some generator is damaged.");
			return true;
		}
		else if(PowerON)
		{
			player.Say((11),"Turning off the whole base.");
			PowerON=false;
			PowerOff(player.GetMap());   
			
			return true;
		}
	}
	
	return false;
}

bool s_PowerGenerator1(Critter&player,Scenery&generator,int skill,Item@item)
{
	if(!(@item!=null)&&skill==(-1))
	{
		if(PowerGen1Working)
		{
			player.Say((11),"This generator is working well.");
		}
		else
		{
			player.Say((11),"Someone should repair it.");
		}
		return true;
	}
	if(!(@item!=null)&&skill==(213))
	{
		if(PowerGen1Working)
		{
			player.Say((11),"This generator is working well.");
		}
		else
		{
			if(player.Timeout[(232)]>0)
			{
				player.SayMsg((11),(3),(3401));
				return true;
			}
			
			if(player.Param[(213)]>=Random(100,200))
			{
				PowerGen1Working=true;
				SetGvar((1151),1);
			}
			
			player.TimeoutBase[(232)]=((__FullSecond)+(((30)*__TimeMultiplier)));
			
			if(PowerGen1Working)
			player.Say((11),"You've repaired this generator.");
			else
			player.Say((11),"You didn't repair this generator.");
		}
		return true;
	}
	return false;
}

bool s_PowerGenerator2(Critter&player,Scenery&generator,int skill,Item@item)
{
	if(!(@item!=null)&&skill==(-1))
	{
		if(PowerGen2Working)
		{
			player.Say((11),"This generator is working well.");
		}
		else
		{
			player.Say((11),"Someone should repair it.");
		}
		return true;
	}
	if(!(@item!=null)&&skill==(213))
	{
		if(PowerGen2Working)
		{
			player.Say((11),"This generator is working well.");
		}
		else
		{
			if(player.Timeout[(232)]>0)
			{
				player.SayMsg((11),(3),(3401));
				return true;
			}
			
			if(player.Param[(213)]>=Random(100,200))
			{
				PowerGen2Working=true;
				SetGvar((1152),1);
			}
			
			player.TimeoutBase[(232)]=((__FullSecond)+(((30)*__TimeMultiplier)));
			
			if(PowerGen2Working)
			player.Say((11),"You've repaired this generator.");
			else
			player.Say((11),"You didn't repair this generator.");
		}
		return true;
	}
	return false;
}

bool s_PowerGenerator3(Critter&player,Scenery&generator,int skill,Item@item)
{
	if(!(@item!=null)&&skill==(-1))
	{
		if(PowerGen3Working)
		{
			player.Say((11),"This generator is working well.");
		}
		else
		{
			player.Say((11),"Someone should repair it.");
		}
		return true;
	}
	if(!(@item!=null)&&skill==(213))
	{
		if(PowerGen3Working)
		{
			player.Say((11),"This generator is working well.");
		}
		else
		{
			if(player.Timeout[(232)]>0)
			{
				player.SayMsg((11),(3),(3401));
				return true;
			}
			
			if(player.Param[(213)]>=Random(100,200))
			{
				PowerGen3Working=true;
				SetGvar((1153),1);
			}
			
			player.TimeoutBase[(232)]=((__FullSecond)+(((30)*__TimeMultiplier)));
			
			if(PowerGen3Working)
			player.Say((11),"You've repaired this generator.");
			else
			player.Say((11),"You didn't repair this generator.");
		}
		return true;
	}
	return false;
}

bool s_PowerGenerator4(Critter&player,Scenery&generator,int skill,Item@item)
{
	if(!(@item!=null)&&skill==(-1))
	{
		if(PowerGen4Working)
		{
			player.Say((11),"This generator is working well.");
		}
		else
		{
			player.Say((11),"Someone should repair it.");
		}
		return true;
	}
	if(!(@item!=null)&&skill==(213))
	{
		if(PowerGen4Working)
		{
			player.Say((11),"This generator is working well.");
		}
		else
		{
			if(player.Timeout[(232)]>0)
			{
				player.SayMsg((11),(3),(3401));
				return true;
			}
			
			if(player.Param[(213)]>=Random(100,200))
			{
				PowerGen4Working=true;
				SetGvar((1154),1);
			}
			
			player.TimeoutBase[(232)]=((__FullSecond)+(((30)*__TimeMultiplier)));
			
			if(PowerGen4Working)
			player.Say((11),"You've repaired this generator.");
			else
			player.Say((11),"You didn't repair this generator.");
		}
		return true;
	}
	return false;
}

bool s_PowerGenerator5(Critter&player,Scenery&generator,int skill,Item@item)
{
	if(!(@item!=null)&&skill==(-1))
	{
		if(PowerGen5Working)
		{
			player.Say((11),"This generator is working well.");
		}
		else
		{
			player.Say((11),"Someone should repair it.");
		}
		return true;
	}
	if(!(@item!=null)&&skill==(213))
	{
		if(PowerGen5Working)
		{
			player.Say((11),"This generator is working well.");
		}
		else
		{
			if(player.Timeout[(232)]>0)
			{
				player.SayMsg((11),(3),(3401));
				return true;
			}
			
			if(player.Param[(213)]>=Random(100,200))
			{
				PowerGen5Working=true;
				SetGvar((1155),1);
			}
			
			player.TimeoutBase[(232)]=((__FullSecond)+(((30)*__TimeMultiplier)));
			
			if(PowerGen5Working)
			player.Say((11),"You've repaired this generator.");
			else
			player.Say((11),"You didn't repair this generator.");
		}
		return true;
	}
	
	return false;
}

bool s_PowerGenerator6(Critter&player,Scenery&generator,int skill,Item@item)
{
	if(!(@item!=null)&&skill==(-1))
	{
		if(PowerGen6Working)
		{
			player.Say((11),"This generator is working well.");
		}
		else
		{
			player.Say((11),"Someone should repair it.");
		}
		return true;
	}
	if(!(@item!=null)&&skill==(213))
	{
		if(PowerGen6Working)
		{
			player.Say((11),"This generator is working well.");
		}
		else
		{
			if(player.Timeout[(232)]>0)
			{
				player.SayMsg((11),(3),(3401));
				return true;
			}
			
			if(player.Param[(213)]>=Random(100,200))
			{
				PowerGen6Working=true;
				SetGvar((1156),1);
			}
			
			player.TimeoutBase[(232)]=((__FullSecond)+(((30)*__TimeMultiplier)));
			
			if(PowerGen6Working)
			player.Say((11),"You've repaired this generator.");
			else
			player.Say((11),"You didn't repair this generator.");
		}
		return true;
	}
	return false;
}

bool s_SierraTerminal(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(!player.IsPlayer()||skill!=-1||(@item!=null))
	return false;
	RunDialog(player,(802),terminal.HexX,terminal.HexY,false);
	return true;
} 

bool s_SierraTerminalDoor(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(!player.IsPlayer()||skill!=-1||(@item!=null))
	return false;
	if(!PowerON)
	RunDialog(player,804,terminal.HexX,terminal.HexY,false);
	return true;
}

bool s_RewardTerminal(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(!player.IsPlayer()||skill!=-1||(@item!=null))
	return false;
	
	if(!PowerON)
	{
		player.Say((11),"Terminal is still restarting...");
		return true;
	}
	RunDialog(player,(803),terminal.HexX,terminal.HexY,false);
	return true;
}

void ElevatorDoor123(Item&item,bool firstTime)
{
	item.SetEvent((4),"_UseDoor123");
}

void ElevatorDoor34(Item&item,bool firstTime)
{
	item.SetEvent((4),"_UseDoor34");
}

void RewardDoor(Item&item,bool firstTime)
{
	item.SetEvent((4),"_UseRewardDoor");
}

bool s_Scanner1(Critter&player,Scenery&scanner,int skill,Item@item)
{
	if(!player.IsPlayer())
	return false;
	
	if((@item!=null)&&item.GetProtoId()==(281))
	{
		Map@map=player.GetMap();
		if(!(@map!=null))return false;
		
		Item@ElevatorDoor=null;
		
		switch(map.GetProtoId())
		{
			case(27):
			@ElevatorDoor=map.GetItem(76,73,2421);
			break;
			case(28):
			@ElevatorDoor=map.GetItem(86,77,2421);
			break;
			case(29):
			@ElevatorDoor=map.GetItem(98,79,2421);
			break;
			default:return false;
		}
		
		if(!(((ElevatorDoor.LockerCondition)&((0x01)))!=0))
		{
			SwitchState(ElevatorDoor);
		}
		
		return true;
	}
	
	else if((@item!=null)&&item.GetProtoId()!=(281))
	{
		if(item.GetProtoId()==(282))
		player.Say((11),"You can't get access by this eye.");
		else
		player.Say((11),"You can't use it here to get access");
		
		return true;
	}
	else if(!(@item!=null))
	{
		if(skill==(-1))
		player.Say((11),"You can't get access by your eyes.");
		if(skill==(209))
		player.Say((11),"Only right person can open the elevator.");
		if(skill==(213))
		player.Say((11),"It's working realy fine.");
		
		return true;
	}
	
	return false;
}

bool s_Scanner2(Critter&player,Scenery&scanner,int skill,Item@item)
{
	if(!player.IsPlayer())
	return false;
	
	if((@item!=null)&&item.GetProtoId()==(282))
	{
		Map@map=player.GetMap();
		if(!(@map!=null))return false;
		
		Item@ElevatorDoor=null;
		
		switch(map.GetProtoId())
		{
			case(29):
			@ElevatorDoor=map.GetItem(90,79,2421);
			break;
			case(30):
			@ElevatorDoor=map.GetItem(84,75,2421);
			break;
			default:return false;
		}
		
		if(!(((ElevatorDoor.LockerCondition)&((0x01)))!=0))
		{
			SwitchState(ElevatorDoor);
		}
		
		return true;
	}
	
	else if((@item!=null)&&item.GetProtoId()!=(282))
	{
		if(item.GetProtoId()==(281))
		player.Say((11),"You can't get access by this eye.");
		else
		player.Say((11),"You can't use it here to get access");
		
		return true;
	}
	else if(!(@item!=null))
	{
		if(skill==(-1))
		player.Say((11),"You can't get access by your eyes.");
		if(skill==(209))
		player.Say((11),"Only right person can open the elevator.");
		if(skill==(213))
		player.Say((11),"It's working realy fine.");
		
		return true;
	}
	
	return false;
}

bool _UseDoor123(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		if(!AccessToElevator123)
		{
			player.Say((11),"You don't have access to this elevator.");
			return true;
		} 
		
		if((not((item.LockerCondition&(0x01))!=0)))
		{
			return false;
		}
	}
	if(skill==(209)&&!AccessToElevator123)
	{
		player.Say((11),"You can't find the way to open elevator door.");
		return true;
	}
	return false;
}

bool _UseDoor34(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		if(!AccessToElevator34)
		{
			player.Say((11),"You don't have access to this elevator.");
			return true;
		} 
		
		if((not((item.LockerCondition&(0x01))!=0)))
		{
			return false;
		}
	}
	if(skill==(209)&&!AccessToElevator34)
	{
		player.Say((11),"You can't find the way to open elevator door.");
		return true;
	}
	return false;
}

bool _UseRewardDoor(Item&item,Critter&player,int skill)
{
	
	if(skill==(-1))
	{
		player.Say((11),"You don't have access to this building.");
		return true;     
		
	}
	if(skill==(209))
	{
		player.Say((11),"You can't find the way to open building.");
		return true;
	}
	return false;
}

void DeleteEventItems()
{
	array<Item@>eyes;
	GetAllItems((281),eyes);
	GetAllItems((282),eyes);
	
	if(eyes.length()>0)
	for(uint16 i=0;i<eyes.length();i++)
	if((@eyes[i]!=null))
	DeleteItem(eyes[i]);
}

void DestroySierraDoor(Map&map,Critter&player)
{
	DeleteEventItems();
	
	Item@deleteDoor=null; 
	
	@deleteDoor=map.GetItem(98,41,(826));
	if((@deleteDoor!=null))
	DeleteItem(deleteDoor);
	@deleteDoor=map.GetItem(99,42,(826));
	if((@deleteDoor!=null))
	DeleteItem(deleteDoor);
	@deleteDoor=map.GetItem(101,42,(826));
	if((@deleteDoor!=null))
	DeleteItem(deleteDoor);
	
	@deleteDoor=map.GetItem(100,41,(3347));
	if((@deleteDoor!=null))
	DeleteItem(deleteDoor);
	
	uint8 radius=Random(4,6);  
	
	ExplodeEx(map,100,41,(4011),radius,Random(1000,2000),(7),3,player.Id,0); 
	
	array<Critter@>blowcrits;
	map.GetCrittersHex(100,41,radius,(0x03),blowcrits);
	for(uint8 i=0;i<blowcrits.length();i++)
	if((@blowcrits[i]!=null))
	{
		blowcrits[i].Say((11),"You were exploded with door.");
		blowcrits[i].ToDead((117),null);
	}
	
	blowcrits.resize(0);
	array<Map@>maps;
	
	map.GetLocation().GetMaps(maps);
	
	for(uint8 i=0;i<maps.length();i++)
	maps[i].GetCritters(0,(0x0F)|(0x10),blowcrits);
	
	for(uint8 i=0;i<blowcrits.length();i++)
	if((@blowcrits[i]!=null))
	blowcrits[i].PlaySound("sad_siren.wav",true);
	
	array<Item@>lockers;
	
	for(uint8 i=0;i<maps.length();i++)
	{
		if(!(@maps[i]!=null))
		continue;
		if(maps[i].GetProtoId()!=(25))
		maps[i].GetItemsByType((8),lockers);
	}
	
	for(uint16 i=0;i<lockers.length();i++)
	{
		if((@lockers[i]!=null))
		{
			lockers[i].LockerId=0;
			lockers[i].LockerComplexity=0;
			if(Random(1,20)==20)
			lockers[i].AddItem((9935),1,1);
			
		}
	}
	
	map.AddItem(100,41,(3348),1);
	map.AddItem(100,41,(3349),1);
	
	uint16 seconds;
	
	if(player.GetAccess()==(3))
	seconds=60*5;
	else
	seconds=60*(20);
	
	ServerEventCNTSet("Someone broke into Sierra Army Depot: %COUNTDOWN% left.",(8),((11)),((seconds)*__TimeMultiplier));
	CreateTimeEvent(((__FullSecond)+(((seconds)*__TimeMultiplier))),"e_EndSierraEvent",map.Id,true);
	
	for(uint8 i=0;i<maps.length();i++)
	if(maps[i].GetProtoId()!=(26))
	{
		uint8 soldiercount=maps[i].GetNpcCount((203),(0x03)|(0x20));
		
		array<uint>soldierdata={maps[i].Id,soldiercount};
		
		e_SpawnSoldier(soldierdata);
	}
	
	map.SetEvent((7),null);
	
	PowerOff(map);
	SpoilGenerator(map);
	FillLockersByEyes(map);
	CloseAllElevators(map);
	seconds=seconds/60;
	array<uint>warndata={map.Id,seconds};
	CreateTimeEvent(((__FullSecond)+(0)),"e_Warning",warndata,true);
	
	array<Critter@>robots;
	if(RobotsHacked)
	{
		for(uint8 i=0;i<maps.length();i++)
		{
			if(!(@maps[i]!=null))
			continue;
			
			maps[i].GetCritters(0,(0x0F)|(0x20),robots);
		}
		
		for(uint8 i=0;i<robots.length();i++)
		{
			if(!(@robots[i]!=null))
			continue;
			SetGvar((1162),1);
			RobotsHacked=false;
			robots[i].SetEvent((0),"mob_dynamic@_DontMove");
			robots[i].SetEvent((16),"mob_dynamic@_Alert");
			robots[i].ParamBase[(89)]=(203);
			robots[i].ParamBase[(106)]=5001;
			(robots[i].ParamBase[(534)]=robots[i].Param[(534)]|((0x00000004)));
			
			ClearEnemyStack(robots[i]);
			array<NpcPlane@>planes;
			robots[i].GetPlanes(planes);
			
			if(planes.length()>0)
			robots[i].DropPlanes();
		}
		
		SetGvar((1162),1);
		RobotsHacked=false;
		SetGvar((1157),0);
		AccessToElevator123=false;
		SetGvar((1158),0);
		AccessToElevator34=false;
	}
	
	DoorAreBroken=true;
	CreateTimeEvent(((__FullSecond)+(((5)*__TimeMultiplier))),"e_TurnOffRobots",map.Id,false);
}

uint e_TurnOffRobots(array<uint>@offdata)
{
	Map@map=GetMap(offdata[0]);
	if(!(@map!=null))return 0;
	
	SetRobotsOffline(map.GetLocation());
	return 0;
}

uint e_Warning(array<uint>@warndata)
{
	Map@map=GetMap(warndata[0]);
	if(!(@map!=null))
	return 0;
	
	array<Map@>maps;
	map.GetLocation().GetMaps(maps);
	
	array<Critter@>critters;
	for(uint8 i=0;i<maps.length();i++)
	{
		maps[i].GetCritters(0,(0x0F),critters);
	}
	
	if(warndata[1]==0)
	{
		for(uint8 i=0;i<critters.length();i++)
		{
			if(critters[i].GetMap().GetProtoId()!=(25)&&
			critters[i].GetMap().GetProtoId()!=(26))
			{
				if(critters[i].IsPlayer())critters[i].Say((11),"You were killed by unknown virus sprayed via vents.");
				if(critters[i].Param[(67)]!=(10))critters[i].ToDead((116),null);
			}
		}
	}
	else
	{
		for(uint8 i=0;i<critters.length();i++)
		{
			if(critters[i].IsPlayer())critters[i].Say((11),"Message from megaphones: Alert! Intruders inside the base! Extermination in "+warndata[1]+(warndata[1]==1?" minute!":" minutes!"));
		}
		warndata[1]--;
		CreateTimeEvent(((__FullSecond)+(((1)*__TimeMultiplier*60))),"e_Warning",warndata,true);
	}
	
	return 0;
}

void FillLockersByEyes(Map&map)
{
	Location@location=map.GetLocation();
	
	array<Map@>maps; 
	
	array<Item@>lockers_1;
	
	array<Item@>lockers_2;
	
	location.GetMaps(maps);
	for(uint8 i=0;i<maps.length();i++)
	{
		switch(maps[i].GetProtoId())
		{
			case(27):
			maps[i].GetItemsByType((8),lockers_1);
			maps[i].GetItemsByType((8),lockers_2);
			
			break;
			case(28):
			maps[i].GetItemsByType((8),lockers_2);
			break;
			case(29):
			maps[i].GetItemsByType((8),lockers_2);
			break;
		}
	}     
	
	array<Item@>lockers_3;
	
	array<Item@>lockers_4;
	uint8 tablelen=0;
	
	for(uint8 i=0;i<lockers_1.length();i++)
	{
		if(!(@lockers_1[i]!=null))
		continue; 
		
		if(GetScriptName(lockers_1[i].GetScriptId())!="spawner_pve@init_high"&&
		GetScriptName(lockers_1[i].GetScriptId())!="spawner_pve@init_low")
		{
			tablelen++;
			lockers_3.resize(tablelen);
			@lockers_3[tablelen-1]=@lockers_1[i];
		}
	}
	
	tablelen=0;
	
	for(uint8 i=0;i<lockers_2.length();i++)
	{
		if(!(@lockers_2[i]!=null))
		continue; 
		
		if(GetScriptName(lockers_2[i].GetScriptId())!="spawner_pve@init_high"&&
		GetScriptName(lockers_2[i].GetScriptId())!="spawner_pve@init_low")
		{
			tablelen++;
			lockers_4.resize(tablelen);
			@lockers_4[tablelen-1]=@lockers_2[i];
		}
	} 
	
	lockers_3[Random(0,lockers_3.length()-1)].AddItem((281),1,0);
	lockers_4[Random(0,lockers_4.length()-1)].AddItem((282),1,0);
}

void CloseAllElevators(Map&map)
{
	Location@location=map.GetLocation();
	
	array<Map@>maps;
	array<Item@>elevatordoors;
	
	location.GetMaps(maps);
	for(uint8 i=0;i<maps.length();i++)
	{
		switch(maps[i].GetProtoId())
		{
			case(27):
			maps[i].GetItemsByType((9),elevatordoors);
			break;
			case(28):
			maps[i].GetItemsByType((9),elevatordoors);
			break;
			case(29):
			maps[i].GetItemsByType((9),elevatordoors);
			break;
		}
	}
	
	for(uint16 i=0;i<elevatordoors.length();i++)
	if((@elevatordoors[i]!=null))
	if(elevatordoors[i].GetProtoId()==2421&&(((elevatordoors[i].LockerCondition)&((0x01)))!=0))
	SwitchState(elevatordoors[i]);
}

void PowerOff(Map&map)
{
	PowerON=false;
	SetGvar((1150),0);
	
	Location@location=map.GetLocation();
	if(!(@location!=null))
	return;
	
	array<Map@>maps;
	location.GetMaps(maps);
	
	for(uint8 i=0;i<maps.length();i++)
	{
		if(!(@maps[i]!=null))
		continue;
		
		switch(maps[i].GetProtoId())
		{
			case(26):
			case(27):
			case(28):
			case(29):
			case(30):
			maps[i].SetTime(180);
			break;
		}
		
		if(maps[i].GetProtoId()==(26))
		{
			Item@powerswitch=maps[i].GetItem(80,67,3236);
			powerswitch.Animate(1,0);
			powerswitch.AnimStayBegin=0;
			powerswitch.AnimStayEnd=0;
			powerswitch.Update();
		}
	}
	SetRobotsOffline(location);
}

void PowerOn(Map&map)
{
	PowerON=true;
	SetGvar((1150),1);
	
	Location@location=map.GetLocation();
	if(!(@location!=null))
	return;
	
	array<Map@>maps;
	location.GetMaps(maps);
	
	for(uint8 i=0;i<maps.length();i++)
	{
		if(!(@maps[i]!=null))
		continue;
		
		switch(maps[i].GetProtoId())
		{
			case(25):
			map.SetEvent((6),null);
			break;
			case(26):
			case(27):
			case(28):
			case(29):
			case(30):
			maps[i].SetTime(720);
			map.SetEvent((6),null);
			break;
		}
		
		if(maps[i].GetProtoId()==(26))
		{
			Item@powerswitch=map.GetItem(80,67,3236);
			powerswitch.Animate(0,1);
			powerswitch.AnimStayBegin=1;
			powerswitch.AnimStayEnd=1;
			powerswitch.Update();
		}
	}
	
	SetRobotsOnline();
}

void SpoilGenerator(Map&map)
{
	uint8 brokengen;
	uint16 hexX=0,hexY=0;
	do
	{
		brokengen=1;
		switch(Random(1,6))
		{
			case 1:
			hexX=59;hexY=48;
			PowerGen1Working=false;
			SetGvar((1151),0);
			brokengen=1;
			break;
			case 4:
			hexX=59;hexY=42;
			PowerGen2Working=false;
			SetGvar((1152),0);
			brokengen=2;
			break;
			case 5:
			hexX=59;hexY=37;
			PowerGen3Working=false;
			SetGvar((1153),0);
			brokengen=3;
			break;
			case 6:
			hexX=71;hexY=47;
			PowerGen4Working=false;
			SetGvar((1154),0);
			brokengen=4;
			break;
			case 2:
			hexX=71;hexY=42;
			PowerGen5Working=false;
			SetGvar((1155),0);
			brokengen=5;
			break;
			case 3:
			hexX=71;hexY=37;
			PowerGen6Working=false;
			SetGvar((1156),0);
			brokengen=6;
			break;
		}
		
		array<uint>generatordata={map.Id,hexX,hexY,brokengen};
		CreateTimeEvent(((__FullSecond)+(0)),"e_RunGeneratorEffect",generatordata,true);
		brokengen=Random(1,10);
	}while(brokengen==1);
}

uint e_RunGeneratorEffect(array<uint>@values)
{
	Map@map=GetMap(values[0]);
	if(!(@map!=null))
	return 0;
	
	if(values[3]==1&&PowerGen1Working)return 0;
	if(values[3]==2&&PowerGen2Working)return 0;
	if(values[3]==3&&PowerGen3Working)return 0;
	if(values[3]==4&&PowerGen4Working)return 0;
	if(values[3]==5&&PowerGen5Working)return 0;
	if(values[3]==6&&PowerGen6Working)return 0;
	
	map.RunEffect((4008),values[1],values[2],3);
	
	return((Random(700,2500))*__TimeMultiplier/1000);
}

bool AllGeneratorsWorking()
{
	return PowerGen1Working&&PowerGen2Working&&PowerGen3Working&&PowerGen4Working&&PowerGen5Working&&PowerGen6Working;
}

uint e_SpawnSoldier(array<uint>@soldierdata)
{
	
	Map@map=GetMap(soldierdata[0]);
	if(!(@map!=null))
	return 0;
	array<uint>mobdata={map.Id,(3)};
	CreateTimeEvent(((__FullSecond)+(((Random(500,1000))*__TimeMultiplier/1000))),"mob_dynamic@e_TrySpawnMob",mobdata,false);
	
	switch(map.GetProtoId())
	{
		case(25):
		if(soldierdata[1]>=(15))
		return 0;
		break;
		case(27):
		if(soldierdata[1]>=(13))
		return 0;
		break;
		case(28):
		if(soldierdata[1]>=(12))
		return 0;
		break;
		case(29):
		if(soldierdata[1]>=(11))
		return 0;
		break;
		case(30):
		if(soldierdata[1]>=(10))
		return 0;
		break;
	}
	
	soldierdata[1]++;
	
	CreateTimeEvent(((__FullSecond)+(((Random(500,1000))*__TimeMultiplier/1000))),"e_SpawnSoldier",soldierdata,false);
	return 0;
}

uint e_EndSierraEvent(array<uint>@values)
{
	Map@map=GetMap(values[0]);
	if(!(@map!=null))
	return 0;
	
	Item@deleteDoor=null;
	
	@deleteDoor=map.GetItem(100,41,(3348));
	if((@deleteDoor!=null))
	DeleteItem(deleteDoor);
	else
	return 0;
	@deleteDoor=map.GetItem(100,41,(3349));
	if((@deleteDoor!=null))
	DeleteItem(deleteDoor);
	else
	return 0;
	
	SpawnSierraDoor(map);
	
	map.SetEvent((7),"_DeleteEyes");
	
	Location@location=map.GetLocation();
	if(!(@location!=null))
	return 0;
	
	array<Map@>maps;
	array<Critter@>players;
	
	location.GetMaps(maps);
	
	for(uint8 i=0;i<maps.length();i++)
	{
		if((@maps[i]!=null))
		switch(maps[i].GetProtoId())
		{
			case(27):
			
			maps[i].GetCritters(0,(0x0F)|(0x10),players);
			break;
			case(28):
			maps[i].GetCritters(0,(0x0F)|(0x10),players);
			break;
			case(29):
			maps[i].GetCritters(0,(0x0F)|(0x10),players);
			break;
			case(30):
			maps[i].GetCritters(0,(0x0F)|(0x10),players);
			break;
		}
	}    
	
	return 0;
}

void _DeleteEyes(Map&map,Critter&cr)
{
	array<Item@>items;
	cr.GetItems(-1,items);
	
	for(uint i=0;i<items.length();i++)
	{
		if(!(@items[i]!=null))
		continue;
		
		if(items[i].GetProtoId()==(281)||items[i].GetProtoId()==(282))
		DeleteItem(items[i]);
	}
}

void SetRobotsOffline(Location&location)
{
	array<Map@>maps;
	location.GetMaps(maps);
	
	SierraRobots.resize(0);
	uint16 robotindexes=0;
	
	array<Critter@>crits;
	
	for(uint8 i=0;i<maps.length();i++)
	{
		if(!(@maps[i]!=null))
		continue;
		
		maps[i].GetCritters(0,(0x0F)|(0x20),crits);
		maps[i].SetEvent((6),"_SetNewRobotToOff");
	}
	
	for(uint8 i=0;i<crits.length();i++)
	{
		if(!(@crits[i]!=null))
		continue;
		
		if(crits[i].Param[(67)]==(10))
		{
			uint mapid=0;
			uint16 hexX=0,hexY=0;
			uint8 dir=0;
			
			robotindexes=robotindexes+4;
			SierraRobots.resize(robotindexes);
			
			SierraRobots[robotindexes-4]=crits[i].Id;
			crits[i].GetHomePos(mapid,hexX,hexY,dir);
			SierraRobots[robotindexes-3]=hexX;
			SierraRobots[robotindexes-2]=hexY;
			SierraRobots[robotindexes-1]=dir;
			
			crits[i].SetHomePos(crits[i].HexX,crits[i].HexY,crits[i].Dir);
			crits[i].Say((2),"Connection lost...");
			crits[i].SetEvent((0),null);
			crits[i].SetEvent((16),"_DontAttack");
			
			ClearEnemyStack(crits[i]);
			array<NpcPlane@>planes;
			crits[i].GetPlanes(planes);
			
			if(planes.length()>0)
			crits[i].DropPlanes();
		}
	}
	RobotsOnline=false;
	SetGvar((1161),0);
}

void _SetNewRobotToOff(Map&map,Critter&SierraRobot)
{
	if(SierraRobot.Param[(67)]==(10))
	{
		SierraRobot.SetEvent((0),null);
		SierraRobot.SetEvent((16),"_DontAttack");
		
		uint16 CurRobotsLen=SierraRobots.length();
		SierraRobots.resize(CurRobotsLen+4);
		
		SierraRobots[CurRobotsLen]=SierraRobot.Id;
		SierraRobots[CurRobotsLen+1]=SierraRobot.HexX;
		SierraRobots[CurRobotsLen+2]=SierraRobot.HexY;
		SierraRobots[CurRobotsLen+3]=SierraRobot.Dir;
	}
}

bool _DontAttack(Critter&cr,Critter&attacker)
{
	return true;
}

void _HackedRobots(Critter&mob)
{
	if(!(@mob!=null))
	return;
	
	if(!mob.IsLife())
	{
		mob.Wait((1000));
		return;
	} 
	
	array<Critter@>crits;
	
	uint num=mob.GetCritters(false,(0x03),crits);    
	
	uint dist=GetDistance(mob);
	for(uint i=0;i<num;i++)
	{    
		
		if(crits[i].Param[(106)]!=GetGvar((1163)))
		{  
			
			NpcPlane@plane=mob.GetCurPlane();
			if(((@plane!=null))&&(plane.Identifier!=(1)))
			mob.DropPlanes();
			
			mob.AddEnemyInStack(crits[i].Id);
			AddAttackPlane(mob,0,crits[i]);
			return;
		}
		
	}
	
	if(crits.length()>0)
	{
		
		mob.Wait((200));
		
	}
	else  
	
	{ 
		
		mob.Wait((200));
	}
	
}

void SetRobotsOnline()
{
	
	for(uint16 i=0;i<SierraRobots.length();i=i+4)
	{
		Critter@SierraRobot=GetCritter(SierraRobots[i]);
		
		if(!(@SierraRobot!=null))
		continue;
		
		SierraRobot.Say((2),"Connection established..."); 
		
		uint16 hexX=SierraRobots[i+1],hexY=SierraRobots[i+2];
		uint8 dir=SierraRobots[i+3];
		
		SierraRobot.SetHomePos(hexX,hexY,dir);
		if(RobotsHacked)
		{
			SierraRobot.SetEvent((0),"_HackedRobots");
			SierraRobot.SetEvent((16),null);
		}
		else
		{
			SierraRobot.SetEvent((0),"mob_dynamic@_DontMove");
			SierraRobot.SetEvent((16),"mob_dynamic@_Alert");
		}
	}
	RobotsOnline=true;
	SetGvar((1161),1);
}      

bool d_PowerOn(Critter&player,Critter@npc)
{
	return PowerON;
}

bool d_PowerOff(Critter&player,Critter@npc)
{
	return!PowerON;
}

bool d_BrokenGenerator(Critter&player,Critter@npc)
{
	return!AllGeneratorsWorking();
}

void dlg_BrokenGenerator(Critter&player,Critter@npc,string@text)
{
	if(!((@text!=null)&&text.length()==0))
	return;
	
	text+="$failgen"+(PowerGen1Working?"":"Generator 1\n")+(PowerGen2Working?"":"Generator 2\n")+(PowerGen3Working?"":"Generator 3\n")+(PowerGen4Working?"":"Generator 4\n")+(PowerGen5Working?"":"Generator 5\n")+(PowerGen6Working?"":"Generator 6\n");
	string money;
	string prefix;
	switch(npc.Param[(139)])
	{
		case 1:money="Dollars";
		case 2:money="Chips";
		case 3:money="Scrips";
		case 4:money="Pounds";
		case 5:money="Rings";
		default:money="Caps";
	}
	switch(npc.Param[(139)])
	{
		case 1:prefix="Enclave ";
		case 2:prefix="Memory ";
		case 3:prefix="NCR ";
		case 4:prefix="Vault City ";
		case 5:prefix="Pull ";
		default:prefix="Bottle ";
	}
	text+=("$prefix"+prefix);
	text+=("$money"+money);
}

void dlg_RandomErrorMsg(Critter&player,Critter@npc,string@text)
{
	if(!((@text!=null)&&text.length()==0))
	return;
	
	switch(Random(1,14))
	{
		case 1:text+="$error"+"?BAD DATA";break;
		case 2:text+="$error"+"?BAD SUBSCRIPT";break;
		case 3:text+="$error"+"?CAN'T CONTINUE";break;
		case 4:text+="$error"+"?DEVICE NOT PRESENT";break;
		case 5:text+="$error"+"?DIVISION BY ZERO";break;
		case 6:text+="$error"+"?EXTRA IGNORED";break;
		case 7:text+="$error"+"?FILE NOT FOUND";break;
		case 8:text+="$error"+"?FILE NOT OPEN";break;
		case 9:text+="$error"+"?FORMULA TOO COMPLEX";break;
		case 10:text+="$error"+"?ILLEGAL DIRECT";break;
		case 11:text+="$error"+"?ILLEGAL QUANTITY";break;
		case 12:text+="$error"+"?LOAD NEXT WITHOUT FOR";break;
		case 13:text+="$error"+"?SYNTAX ERROR";break;
		case 14:text+="$error"+"?UNDEF'D STATEMENT ERROR IN "+Random(1,30)*10;break;
	}
	string money;
	string prefix;
	switch(npc.Param[(139)])
	{
		case 1:money="Dollars";
		case 2:money="Chips";
		case 3:money="Scrips";
		case 4:money="Pounds";
		case 5:money="Rings";
		default:money="Caps";
	}
	switch(npc.Param[(139)])
	{
		case 1:prefix="Enclave ";
		case 2:prefix="Memory ";
		case 3:prefix="NCR ";
		case 4:prefix="Vault City ";
		case 5:prefix="Pull ";
		default:prefix="Bottle ";
	}
	text+=("$prefix"+prefix);
	text+=("$money"+money);
}

uint r_HackTheElevators(Critter&player,Critter@npc)
{
	uint16 scienceSkill=player.Param[(212)];
	scienceSkill=(((scienceSkill)>(200))?(200):(((scienceSkill)<(1))?(1):(scienceSkill)));
	
	if(Random(scienceSkill,500)>=470)
	{
		array<Map@>maps;
		player.GetMap().GetLocation().GetMaps(maps);
		
		array<Item@>elevatorDoors;
		
		for(uint8 i=0;i<maps.length();i++)
		{
			if(!(@maps[i]!=null))
			continue;
			if(maps[i].GetProtoId()==(27))
			{
				elevatorDoors.resize(1);
				@elevatorDoors[0]=maps[i].GetItem(76,73,2421);
			}
			if(maps[i].GetProtoId()==(28))
			{
				elevatorDoors.resize(2);
				@elevatorDoors[1]=maps[i].GetItem(86,77,2421);
			}
			if(maps[i].GetProtoId()==(29))
			{
				elevatorDoors.resize(3);
				@elevatorDoors[2]=maps[i].GetItem(98,79,2421);
			}
		}
		
		for(uint8 i=0;i<elevatorDoors.length();i++)
		{
			if(!(@elevatorDoors[i]!=null))
			continue;
			
			if(!(((elevatorDoors[i].LockerCondition)&((0x01)))!=0))
			SwitchState(elevatorDoors[i]);
		}
		AccessToElevator123=true;
		SetGvar((1157),1);
	}
	
	if(Random(scienceSkill,500)>=495)
	{
		array<Map@>maps;
		player.GetMap().GetLocation().GetMaps(maps);
		
		array<Item@>elevatorDoors;
		
		for(uint8 i=0;i<maps.length();i++)
		{
			if(!(@maps[i]!=null))
			continue;
			if(maps[i].GetProtoId()==(29))
			{
				elevatorDoors.resize(1);
				@elevatorDoors[0]=maps[i].GetItem(90,79,2421);
			}
			if(maps[i].GetProtoId()==(30))
			{
				elevatorDoors.resize(2);
				@elevatorDoors[1]=maps[i].GetItem(84,75,2421);
			}
		}
		
		for(uint8 i=0;i<elevatorDoors.length();i++)
		{
			if(!(@elevatorDoors[i]!=null))
			continue;
			
			if(!(((elevatorDoors[i].LockerCondition)&((0x01)))!=0))
			SwitchState(elevatorDoors[i]);
		}
		AccessToElevator34=true;
		SetGvar((1158),1);
	}
	
	if(AccessToElevator123||AccessToElevator34)
	return(13);
	else
	return(14);
}

void dlg_ElevatorsHacked(Critter&player,Critter@npc,string@text)
{
	if(!((@text!=null)&&text.length()==0))
	return;
	
	if(AccessToElevator123&&AccessToElevator34)
	{
		text+="$shafts"+"elevator 1-2-3 and elevator 3-4.";
	}
	else if(AccessToElevator123)
	{
		text+="$shafts"+"elevator 1-2-3.";
	}
	else if(AccessToElevator34)
	{
		text+="$shafts"+"elevator 3-4.";
	}
	
	if(AccessToElevator123)
	{
		text+="$access123"+"UNSECURED!!!";
	}
	else
	{
		text+="$access123"+"SECURED";
	}
	
	if(AccessToElevator34)
	{
		text+="$access34"+"UNSECURED!!!";
	}
	else
	{
		text+="$access34"+"SECURED";
	}
}

bool d_ElevatorsNotHacked(Critter&player,Critter@npc)
{
	return!AccessToElevator123&&!AccessToElevator34;
}

void dlg_RobotsSettings(Critter&player,Critter@npc,string@text)
{
	if(!((@text!=null)&&text.length()==0))
	return;
	
	text+="$active"+(RobotsOnline?"Control computer: ONLINE":"Control computer: OFFLINE");
	
	uint8 settings=GetGvar((1162));
	string factionname;
	switch(settings)
	{
		case 1:text+="$process"+"PROTECT SIERRA ARMY DEPOT";break;
		case 2:
		if(GetGvar((1163))<=1)
		{
			text+="$process"+"PROTECT FACTION: !FATAL ERROR";break;
		}
		else
		{
			GetFactionNameStr(GetGvar((1163)),factionname);
			text+="$process"+"PROTECT FACTION: "+factionname;
			break;
		}
		default:text+="$process"+"UNKNOWN CODE";break;
	}
	
	if(RobotsAreOnline)
	text+="$process"+"?SYSTEM FAILURE";
}

bool d_RobotsCanBeHacked(Critter&player,Critter@npc)
{
	return!RobotsHacked&&GetGvar((1163))!=player.Param[(106)];
}

uint r_TryHackRobots(Critter&player,Critter@npc)
{
	uint16 scienceSkill=player.Param[(212)];
	scienceSkill=(((scienceSkill)>(300))?(300):(((scienceSkill)<(1))?(1):(scienceSkill)));
	
	if(Random(scienceSkill,300)>=290)
	{
		array<Map@>maps;
		player.GetMap().GetLocation().GetMaps(maps);
		
		array<Critter@>crits;
		
		for(uint8 i=0;i<maps.length();i++)
		{
			if(!(@maps[i]!=null))
			continue;
			
			maps[i].GetCritters(0,(0x0F)|(0x20),crits);
		}
		
		for(uint8 i=0;i<crits.length();i++)
		{
			if(!(@crits[i]!=null))
			continue;
			
			if(crits[i].Param[(67)]==(10))
			{
				crits[i].SetEvent((0),"_HackedRobots");
				crits[i].SetEvent((16),null);
				crits[i].ParamBase[(89)]=0;
				crits[i].ParamBase[(106)]=player.Param[(106)];
				(crits[i].ParamBase[(534)]=(crits[i].Param[(534)]|((0x00000004)))^((0x00000004)));
				
				ClearEnemyStack(crits[i]);
				array<NpcPlane@>planes;
				crits[i].GetPlanes(planes);
				
				if(planes.length()>0)
				crits[i].DropPlanes();
			}
		}
		RobotsHacked=true;
		SetGvar((1162),2);
		SetGvar((1163),player.Param[(106)]);
		return(19);
	}
	return(18);
}

uint r_TryDisableRobots(Critter&player,Critter@npc)
{
	uint16 scienceSkill=player.Param[(212)];
	scienceSkill=(((scienceSkill)>(300))?(300):(((scienceSkill)<(1))?(1):(scienceSkill)));
	
	if(Random(scienceSkill,300)>=200)
	{
		array<Map@>maps;
		player.GetMap().GetLocation().GetMaps(maps);
		
		array<Critter@>crits;
		
		for(uint8 i=0;i<maps.length();i++)
		{
			if(!(@maps[i]!=null))
			continue;
			
			maps[i].GetCritters(0,(0x0F)|(0x20),crits);
		}
		
		for(uint8 i=0;i<crits.length();i++)
		{
			if(!(@crits[i]!=null))
			continue;
			
			if(crits[i].Param[(67)]==(10))
			{
				crits[i].SetEvent((0),null);
				crits[i].SetEvent((16),"_DontAttack");
				
				ClearEnemyStack(crits[i]);
				array<NpcPlane@>planes;
				crits[i].GetPlanes(planes);
				
				if(planes.length()>0)
				crits[i].DropPlanes();
			}
		}
		RobotsAreOnline=false;
		return(17);
	}
	return(18);
}

uint r_SetRobotsOffline(Critter&player,Critter@npc)
{
	uint16 scienceSkill=player.Param[(212)];
	scienceSkill=(((scienceSkill)>(300))?(300):(((scienceSkill)<(1))?(1):(scienceSkill)));
	
	if(Random(scienceSkill,300)>=225)
	{
		Location@location=player.GetMap().GetLocation();
		SetRobotsOffline(location);
		return(26);
	}
	return(18);
}

uint r_SetRobotsOnline(Critter&player,Critter@npc)
{
	uint16 scienceSkill=player.Param[(212)];
	scienceSkill=(((scienceSkill)>(300))?(300):(((scienceSkill)<(1))?(1):(scienceSkill)));
	
	if(Random(scienceSkill,300)>=100)
	{
		SetRobotsOnline();
		return(27);
	}
	return(18);
}

uint r_TryDestroyRobots(Critter&player,Critter@npc)
{
	uint16 scienceSkill=player.Param[(212)];
	scienceSkill=(((scienceSkill)>(300))?(300):(((scienceSkill)<(1))?(1):(scienceSkill)));
	
	if(Random(scienceSkill,300)>=265)
	{
		array<Map@>maps;
		player.GetMap().GetLocation().GetMaps(maps);
		
		array<Critter@>crits;
		
		for(uint8 i=0;i<maps.length();i++)
		{
			if(!(@maps[i]!=null))
			continue;
			
			maps[i].GetCritters(0,(0x0F)|(0x20),crits);
		}
		
		for(uint8 i=0;i<crits.length();i++)
		{
			if(!(@crits[i]!=null))
			continue;
			
			if(crits[i].Param[(67)]==(10))
			{
				crits[i].ToDead((117),null);
			}
		}
		return(16);
	}
	return(18);
}

bool d_FoundRobot(Critter&player,Critter@npc)
{
	bool foundRobot=false; 
	
	array<Map@>maps;
	player.GetMap().GetLocation().GetMaps(maps);
	
	array<Critter@>crits;
	
	for(uint8 i=0;i<maps.length();i++)
	{
		if(!(@maps[i]!=null))
		continue;
		
		maps[i].GetCritters(0,(0x0F)|(0x20),crits);
	}
	
	for(uint8 i=0;i<crits.length();i++)
	{
		if(!(@crits[i]!=null))
		continue;
		
		if(crits[i].Param[(67)]==(10))
		{
			foundRobot=true;
		}
		
		if(foundRobot)
		break;
	}
	
	return foundRobot;
}

bool d_RobotsAreNotDisabled(Critter&player,Critter@npc)
{
	return RobotsAreOnline;
} 

bool d_RobotsAreOn(Critter&player,Critter@npc)
{
	return RobotsOnline;
} 

bool d_RobotsAreOff(Critter&player,Critter@npc)
{
	return!RobotsOnline;
}

bool d_PowerOffOnly(Critter&player,Critter@npc)
{
	return!PowerON&&AllGeneratorsWorking();
}

bool d_EventIsRunning(Critter&player,Critter@npc)
{
	return DoorAreBroken;
}

void r_OpenRewardDoor(Critter&player,Critter@npc)
{
	Location@location=player.GetMap().GetLocation();
	
	array<Map@>maps;
	
	location.GetMaps(maps);
	
	for(uint8 i=0;i<maps.length();i++)
	if((@maps[i]!=null))
	if(maps[i].GetProtoId()==(25))
	{
		Item@rewarddoor=maps[i].GetItem(130,83,3358);
		if(!(((rewarddoor.LockerCondition)&((0x01)))!=0))
		SwitchState(rewarddoor);
		
		CreateTimeEvent(((__FullSecond)+(((30)*__TimeMultiplier))),"e_CloseRewardDoor",rewarddoor.Id,true);
	}
}

uint e_CloseRewardDoor(array<uint>@values)
{
	Item@rewarddoor=GetItem(values[0]);
	if(!(@rewarddoor!=null))
	return 0; 
	
	array<Critter@>critters;
	
	Map@map=GetMap(rewarddoor.MapId);
	if(!(@map!=null))return 0;
	
	map.GetCrittersHex(130,83,0,(0x03),critters);
	
	for(uint i=0,j=critters.length();i<j;i++)
	{
		if((@critters[i]!=null))
		{
			critters[i].Say((11),"You were squeezed by door.");
			critters[i].ToDead((117),null);
		}
	}
	
	if((((rewarddoor.LockerCondition)&((0x01)))!=0))
	SwitchState(rewarddoor);
	
	CreateTimeEvent(((__FullSecond)+(((10)*__TimeMultiplier))),"e_ElectricShock",map.Id,true);
	
	return 0;
}

uint e_ElectricShock(array<uint>@values)
{
	Map@map=GetMap(values[0]);
	if(!(@map!=null))return 0; 
	
	array<Critter@>critters;
	
	map.GetCritters(0,(0x03),critters);
	
	for(uint i=0,j=critters.length();i<j;i++)
	{
		if((@critters[i]!=null))
		{
			if(IsInExternalMagazine(critters[i],map))
			{
				if(critters[i].IsPlayer())
				critters[i].Say((11),"You were electrocuted by security system.");
				map.RunEffect((4008),critters[i].HexX,critters[i].HexY,3);
				critters[i].ToDead(Random(0,1)==0?(113):(114),null);
			}
		}
	}
	
	return 0;
}        

void CraftingMachine(Item&item,bool firstTime)
{
	item.SetEvent((4),"_UseMachine");
}

bool _UseMachine(Item&item,Critter&player,int skill)
{
	player.Animate((1),(28),item,true,true);
	
	if(skill==(-1))
	{
		if(PowerON)
		{
			
			player.DropTimers();
			
			GiveWorkbench(player,(22098));
			player.ShowScreen((9),0,"");
		}
		else
		{
			player.Say((11),"You see flashing LOADING... text on the screen.");
		}
		return true;
		
	}
	if(skill==(213))
	{
		if(PowerON)
		player.Say((11),"Machinery is working really good. Just use it.");
		else
		player.Say((11),"It looks like running on low power.");
		return true;
	}
	if(skill==(212))
	{
		if(PowerON)
		player.Say((11),"Nothing is complicated here. Follow the instructions on the screen.");
		else
		player.Say((11),"Machinery is still rebooting itself.");
		return true;
	}
	return false;
}       

IPolygon@ExternalMagazine=null;
IPolygon@TheMainGate=null;

void InitExternalMagazine(Map&map)
{
	if(!(@ExternalMagazine!=null))
	@ExternalMagazine=::LoadShapeFromEntires(map,(41),(44));
}

bool IsInExternalMagazine(Critter&cr,Map&map)
{
	if(!(@ExternalMagazine!=null))
	@ExternalMagazine=::LoadShapeFromEntires(map,(41),(44));
	return ExternalMagazine.IsWithin(cr);
}

void InitTheMainGate(Map&map)
{
	if(!(@TheMainGate!=null))
	@TheMainGate=::LoadShapeFromEntires(map,(45),(48));
}

bool IsInTheMainGate(Critter&cr,Map&map)
{
	if(!(@TheMainGate!=null))
	@TheMainGate=::LoadShapeFromEntires(map,(45),(48));
	return TheMainGate.IsWithin(cr);
}                                            

