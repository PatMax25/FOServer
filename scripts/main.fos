//
// FOnline: 2238
// Rotators
//
// main.fos
//

#include "_animation.fos"
#include "_basetypes.fos"
#include "_colors.fos"
#include "_macros.fos"
#include "_town.fos"
#include "_vars.fos"
#include "_npc_pids.fos"
#include "_vals.fos"

#include "backend_h.fos"
#include "broadcast_h.fos"
#include "caravans_h.fos"
#include "config_h.fos"
#include "config_file_h.fos"
#include "critter_age_h.fos"
#include "debug_h.fos"
#include "economy_h.fos"
#include "factions_h.fos"
#include "follower_capturing.fos"
#include "follower_common_h.fos"
#include "follower_h.fos"
#include "groups_h.fos"
#include "item_dogtags_h.fos"
#include "item_perks_h.fos"
#include "logging_h.fos"
#include "lexems_h.fos"
#include "map_tent_h.fos"
#include "mapdata_h.fos"
#include "messages_h.fos"
#include "minigames_h.fos"
#include "mob_wave_h.fos"
#include "MsgStr.h"
#include "npc_common_h.fos"
#include "npc_planes_h.fos"
#include "npc_schedule_h.fos"
#include "online_stats_h.fos"
#include "recycler_h.fos"
#include "reinforcements_h.fos"
#include "reputations_h.fos"
#include "town_h.fos"
#include "utils_h.fos"
#include "weather_h.fos"
#include "world_common_h.fos"
#include "worldmap_h.fos"
#include "xfire_h.fos"
#include "npc_roles_h.fos"
//#include "base_control.fos"
#include "_entires.fos"
// Imports
import void speedboost(Critter& cr) from "critter_item_movement"; 			//Imported function to recalculate speed boost in calls.
//import void speedboost2(Critter& cr) from "critter_item_movement"; 			//Imported function to recalculate speed boost in calls.
import void DropDrugEffects(Critter& cr) from "drugs";
import bool FindBaseEncounter(array<Critter@>& group, Item@ car, uint x, uint y, uint& encounterDescriptor, bool& waitForAnswer) from "factions_player";
import bool IsArenaCombatant(Critter& cr) from "arena";
import bool IsInsideArena(Critter& cr) from "arena";
import bool IsCarTrunk(Item@ item) from "car";
import bool OnUseExplode(Critter& cr, Item& explode, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen, uint timer) from "explode";
import bool PerkCheck(Critter& cr, uint perk, bool always) from "perks";
import bool ReversableItem(Item& item) from "fix_boy";
import bool ReverseItem(Critter& cr, Item& item) from "fix_boy";
import uint GetItemRecipe(uint16 itemPid, array<uint16>& pids, array<uint>& cnt) from "fix_boy";
import bool TryRepairItem(Critter& cr, Item& item) from "repair";
import bool TryRechargeItem(Critter& cr, Item& item) from "teslaRecharge";
import bool UseItemOnCar(Critter& cr, Item& car, Item& item) from "car";
import bool UseProspectMap(Critter& cr, Item& map) from "prospects";
import bool UseSkillOnCar(Critter& cr, Item& car, int skill) from "car";
import bool UseSkillOnLocker(Critter& cr, Item& locker, int skill) from "lockers";
import bool WantedSignSet(Item& wantedSign, string& name, uint cost) from "wanted";
import void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId ) from "combat";
import void CreateCompanion() from "companion";
import uint GetSkillTime(int sk, CritterMutual@ crit) from "wait_time";
import int    GetCarTrunkComplexity(Item@ item) from "car";
import uint   GetRandomDeathAnimation() from "cheats";
import void   AddCrittersKilled() from "cavelog";
import void   AddPlayerDeaths() from "cavelog";
import void   ApplyTimeout(array<Item@>& items, array<uint>& itemsCount, array<Item@>& resources, Critter& crafter) from "fix_boy";
import void   CheckBountyHunters(Critter& cr, Critter@ killer) from "bounties";
import void   CombatAttack(Critter& cr, Critter& target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo) from "combat";
import void   CritterGenerate(Critter& cr) from "parameters";
import void   CritterDescription_Set(Critter& player, int& description1, int& description2) from "critter_description";
import void   EditRadioSettings(Critter& player, Item& radio) from "radio";
import void   FlushInfluenceBuffer(Critter& cr, ITown@ town) from "town";
import uint   GMTrack(uint targetId, string@ message) from "cheats";
import void   GreetPlayer(Critter@ player, Map@ map) from "map_greet";
import void   InitCheats(bool fromGame) from "cheats";
import void   InitBrahminPens() from "brahmin_pens";
import void   InitBrahminTraders() from "brahmin_traders";
import void   InitCars() from "car_seller";
import void   InitCaveLog() from "cavelog";
import void   InitCaveRandomization() from "cave";
import void   InitCompanions() from "companion";
import void   InitMercs() from "mercs";
import void   InitReverseItem() from "fix_boy";
import void   InitRoutes() from "patrolroutes";
import void   InitSlaveruns() from "slaverun";
import void   InitTowns() from "towns";
import void   InitTrains() from "trains";
import void   InitBlueprints() from "blueprints";
import void   InitPerks() from "perks";
import void   InitProduction() from "production";
import void   InitShufflingSpawns() from "shuffling_spawner";
import bool   IsArenaItem(Item@ item) from "arena";
import void   LogAction(Critter& cr, string& s) from "logging_critter";
import void   NpcProcessLevel(Critter& cr) from "parameters";
import void   PlaySound(Critter& cr, string& soundName) from "media";
import string PrepareSound_Pick(Item& item) from "media";
import void   ProcessCrippling() from "crippling";
import void   RemoveAuthed(uint id) from "cheats";
import void   RemoveWorkbenches(Critter& player) from "workbench";
import void   ReplicateCritter(Critter& cr) from "replication";
import void   RemoveArenaItems(Critter& cr) from "arena";
import void   RemoveOnlinePlayer(Critter& cr) from "utils";
import void   SaveBrahminPenData() from "brahmin_pens";
import void   SaveEventSpawns() from "cheats";
import void   SaveCarPriceData() from "car_seller";
import void   SaveCompanionData() from "companion";
import void   SetReplicationTime(Critter& cr) from "replication";
import void   SetSpectator(Critter& cr, bool on) from "utils";
import void   SetStartLocation(Critter& cr) from "replication";
import void   SetTimeoutForAll(Map& map, int timeout, int time) from "cheats";
import void   UseDrug(Critter& cr, Item& drug) from "drugs";
import void   UseDrugOn(Critter& cr, Critter& onCr, Item& drug) from "drugs";
import void   WearItem(Critter& cr, Item& item, int wearCount) from "repair";
import void   WorldmapInit() from "worldmap";
import void   WorldmapUpdatePlayer(Critter@ player) from "worldmap_players";
import void   WorldmapRemovePlayer(Critter@ player) from "worldmap_players";
import void   TrackLocation(Critter& player) from "globalmap_group";
import bool   UseFirstAidOnCritter(Critter& cr, Critter& targetCr, Item@ item) from "skills";
import bool   UseDoctorOnCritter(Critter& cr, Critter& targetCr, Item@ item) from "skills";
import bool   UseRepairOnCritter(Critter& cr, Critter& targetCr, Item@ item) from "skills";
import bool   UseScienceOnCritter(Critter& cr, Critter& targetCr, Item@ item) from "skills";
import array<Critter@> WorldmapGetPlayers(uint zx, uint zy) from "worldmap_players";
import uint CheckPlayerName( const string& name ) from "parameters";
import string getdialogtext(Critter& cr) from "dialog";
import void FixDrugs(Critter& cr) from "utils";

import bool GuardNotLegit(Critter@ cr, Item@ item, bool deleteItem) from "cheats";
import void RemoveNotLegit(Critter@ cr) from "cheats";
import bool IsReadableBook(uint16 pid) from "books";
import void TryReadBook(Critter& cr, Item& book) from "books";
import void AddBonuses(Item@ item, string@ crafter) from "item_bonus";
import uint BonusNumber(Item@ item) from "item_bonus";

import void UpdateDrugs(Critter& cr) from "drugs";

import string IntToIp(int d) from "utils";
import string GetTimeString(uint fullsecond) from "time";
import void InitBaseControl() from "base_control";
import void init_events() from "event_encounter";
import void init_boss_events() from "event_encounter";
import void init_treasures() from "event_utils";
import bool LoadBaseData() from "base_control";
import bool SaveBaseData() from "base_control";
import void CallMobsToTakeBase(uint playerid, uint location, uint baseLocId, uint NPCFaction) from "base_control";
import void SpawnBCReward(uint16 locPid) from "base_control";
import bool IsNukaColaWorker(Critter& mob) from "mob_dynamic";
import void Reno_event()  from "cheats";
dictionary    ItemPids;
dictionary    VarIds;
dictionary    BaseTypes;
dictionary    MapData;
array<string> ItemNames;
array<string> VarNames;
array<uint> BannedIDs;
array<uint> BanEvents;
array<string> BannedReason;

//// Get the id of the item using identifiers
// stored in ITEMPID.H file
bool GetItemPid(const string& in identifier, int& out pid)
{
    return ItemPids.get(identifier, pid);
}
bool GetVarId(const string& in identifier, int& out id)
{
    return VarIds.get(identifier, id);
}
// void GetVarNames(const string& filter
bool GetBaseType(const string& in identifier, int& out id)
{
    return BaseTypes.get(identifier, id);
}

bool GetMapData(const string& in identifier, int& out id)
{
    return MapData.get(identifier, id);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Called before world generation.
void init()
{
    InitLogs();     // Should be first
    InitDebug();
    InitializeGame();
    InitPerks();
    //InitBlueprints();
    FLog(LOG_WMLOCATIONS, "START");
}
void rolltcwindows(Critter& cr, int, int, int) {rolltcwindows();}

void rolltcwindows()
{
	uint tc_zones = 0;
	SetGvar(GVAR_TC_WINDOW_MODOC,0);
	SetGvar(GVAR_TC_WINDOW_KLAMATH,0);
	SetGvar(GVAR_TC_WINDOW_GECKO,0);
	SetGvar(GVAR_TC_WINDOW_BH,0);
	SetGvar(GVAR_TC_WINDOW_REDDING,0);
	SetGvar(GVAR_TC_WINDOW_DEN,0);
	SetGvar(GVAR_TC_WINDOW_NECRO,0);
	for(uint i = 1; i < 8; i++)
	{
		while(tc_zones!=i)
			{
			switch(Random(1,7))
				{
				case 1: if(GetGvar(GVAR_TC_WINDOW_MODOC)==0) 	{SetGvar(GVAR_TC_WINDOW_MODOC,i); SetBestScore(SCORE_TC_MODOC_TIME, null, getwindowtime(i)); tc_zones++; } break;
				case 2: if(GetGvar(GVAR_TC_WINDOW_KLAMATH)==0) 	{SetGvar(GVAR_TC_WINDOW_KLAMATH,i); SetBestScore(SCORE_TC_KLAMATH_TIME, null, getwindowtime(i)); tc_zones++;} break;
				case 3: if(GetGvar(GVAR_TC_WINDOW_GECKO)==0)  	{SetGvar(GVAR_TC_WINDOW_GECKO,i); SetBestScore(SCORE_TC_GECKO_TIME, null, getwindowtime(i)); tc_zones++;} break;
				case 4: if(GetGvar(GVAR_TC_WINDOW_BH)==0) 		{SetGvar(GVAR_TC_WINDOW_BH,i); SetBestScore(SCORE_TC_BH_TIME, null, getwindowtime(i)); tc_zones++;} break;
				case 5: if(GetGvar(GVAR_TC_WINDOW_REDDING)==0)  	{SetGvar(GVAR_TC_WINDOW_REDDING,i); SetBestScore(SCORE_TC_REDDING_TIME, null, getwindowtime(i)); tc_zones++;} break;
				case 6: if(GetGvar(GVAR_TC_WINDOW_DEN)==0)  		{SetGvar(GVAR_TC_WINDOW_DEN,i); SetBestScore(SCORE_TC_DEN_TIME, null, getwindowtime(i)); tc_zones++;} break;
				case 7: if(GetGvar(GVAR_TC_WINDOW_NECRO)==0)  	{SetGvar(GVAR_TC_WINDOW_NECRO,i); SetBestScore(SCORE_TC_NECRO_TIME, null, getwindowtime(i)); tc_zones++;} break;
			//	case 8: if(when_tc_reno==0) 	{when_tc_reno = i; SetBestScore(SCORE_TC_RENO_TIME, null, getwindowtime(i)); tc_zones++;} break;
				
				}	
			}
	}
}



string getwindowtime(uint i)
{
	switch(i)
	{
	case 1: return "16:00-19:00 CET";
	case 2: return "18:00-21:00 CET";
	case 3: return "20:00-23:00 CET";
	case 4: return "22:00-01:00 CET";
	case 5: return "24:00-03:00 CET";
	}
	
	return "anytime";

}
////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on start server.
bool start()
{
    // Send info about others critters
    // Remember:
    // - all this info can be hacked in client;
    // - more parameters - more traffic.
	for(uint i = 0; i < 1200; i++)
		SetSendParameter(i, true);
    
    // Look fields in fonline.h 'struct Item::ItemData'
    //               SortValue  Info Indicator    PicMapHash       PicInvHash   AnimWaitBase AStay[2] AShow[2] AHide[2]      Flags      Rate LightDist Inten Flags  LightColor    ScriptId TrapValue       Count             Cost                ScriptValues[10]                                                                                                   Other 36 bytes
    // ITEM_DATA_MASK_CHOSEN                                                                                           ITEM_DATA_MASK_CHOSEN                                                                                                ITEM_DATA_MASK_CHOSEN
    int8[] mask0 = {  -1, -1,     -1,   -1,     -1, -1, -1, -1,  -1, -1, -1, -1,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    // ITEM_DATA_MASK_CRITTER                                                                                          ITEM_DATA_MASK_CRITTER                                                                                               ITEM_DATA_MASK_CRITTER
    int8[] mask1 = {   0,  0,     -1,    0,      0,  0,  0,  0,   0,  0,  0,  0,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,     0,  0,  0,  0,   0,  0,  0,  0,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0 };
    // ITEM_DATA_MASK_CRITTER_EXT                                                                                      ITEM_DATA_MASK_CRITTER_EXT                                                                                           ITEM_DATA_MASK_CRITTER_EXT
    int8[] mask2 = {   0,  0,     -1,   -1,      0,  0,  0,  0,   0,  0,  0,  0,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,    -1, -1, -1, -1,   0,  0,  0,  0,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    // ITEM_DATA_MASK_CONTAINER                                                                                        ITEM_DATA_MASK_CONTAINER                                                                                             ITEM_DATA_MASK_CONTAINER
    int8[] mask3 = {  -1, -1,     -1,   -1,      0,  0,  0,  0,  -1, -1, -1, -1,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    // ITEM_DATA_MASK_MAP                                                                                              ITEM_DATA_MASK_MAP                                                                                                   ITEM_DATA_MASK_MAP
    int8[] mask4 = {  -1, -1,     -1,   -1,     -1, -1, -1, -1,   0,  0,  0,  0,   -1, -1,  -1, -1,  -1, -1,  -1, -1,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,     0,  0,  0,  0,   0,  0,  0,  0,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    SetItemDataMask(ITEM_DATA_MASK_CHOSEN, mask0);
    SetItemDataMask(ITEM_DATA_MASK_CRITTER, mask1);
    SetItemDataMask(ITEM_DATA_MASK_CRITTER_EXT, mask2);
    SetItemDataMask(ITEM_DATA_MASK_CONTAINER, mask3);
    SetItemDataMask(ITEM_DATA_MASK_MAP, mask4);

    InitDBLogs();

    WorldmapInit();
    ReadDefines("scripts/ITEMPID.H", ItemPids, ItemNames);
    ReadDefines("scripts/_vars.fos", VarIds, VarNames);
    ReadDefines("scripts/_basetypes.fos", BaseTypes, null);
    ReadDefines("scripts/mapdata_h.fos", MapData, null);
    // cheats init
    InitCheats(true);

    // factions!
    InitFactions();
    // register big factions
    RegisterFaction(FACTION_BOS, "Brotherhood Of Steel", false);
    RegisterFaction(FACTION_ENCLAVE, "Enclave", false);
    RegisterFaction(FACTION_UNITY , "The Unity", false);
    RegisterFaction(FACTION_NCR       , "New California Republic", false);
    RegisterFaction(FACTION_VAULT_CITY   , "Vault City", false);
    RegisterFaction(FACTION_RAIDERS             , "Raiders", false);
    RegisterFaction(FACTION_MORDINOS              , "The Mordinos", false);
    RegisterFaction(FACTION_SLAVERS_GUILD          , "Slavers", false);
    RegisterFaction(FACTION_SLAGS               , "Slag Bandits", false);
    RegisterFaction(FACTION_KOKOWEEF               , "Kokoweef Miners", false);
    RegisterFaction(FACTION_MORNINGSTAR            , "Morning Star Miners", false);
    RegisterFaction(FACTION_BH_HUMANS               , "Broken Hills Humans", false);
    RegisterFaction(FACTION_BH_MUTANTS             , "Broken Hills Mutants", false);
    RegisterFaction(FACTION_WRIGHTS                , "The Wrights", false);
    RegisterFaction(FACTION_BISHOPS                , "The Bishops", false);
    RegisterFaction(FACTION_SALVATORES             , "Salvatores's Family", false);
    RegisterFaction(FACTION_NCR_RANGERS            , "NCR Rangers", false);
    RegisterFaction(FACTION_VORTIS_SLAVERS      , "Vortis", false);
    RegisterFaction(FACTION_COMMUNISTS            , "Communists", false);
    RegisterFaction(FACTION_VAGRANTS             , "Vargrants", false);
    RegisterFaction(FACTION_FOOLS                , "The Fools", false);
    RegisterFaction(FACTION_CRYPTS            , "Vault-Tec", false);
    RegisterFaction(FACTION_HUB_CRIMINALS          , "Hub Criminals", false);
    RegisterFaction(FACTION_CRIMSON_CARAVANS       , "Crimson Caravan", false);
    RegisterFaction(FACTION_FARGO_TRADERS         , "The Far-Go Traders", false);
    RegisterFaction(FACTION_WATER_MERCHANTS     , "The Water Merchants", false);
    RegisterFaction(FACTION_HEIGHTS            , "The Heights", false);
    RegisterFaction(FACTION_REGULATORS          , "The Regulators", false);
    RegisterFaction(FACTION_SCAVENGERS           , "Scavengers", false);
    RegisterFaction(FACTION_GUNRUNNERS            , "Gun Runners", false);
    RegisterFaction(FACTION_FOLLOWERS            , "Followers", false);
    RegisterFaction(FACTION_BOUNTY_HUNTERS        , "Bounty Hunters", false);
    RegisterFaction(FACTION_FREE_TRADERS         , "Free Traders", false);
    RegisterFaction(FACTION_REDDING_GUTTERSNIPES , "Redding Gang", false);
    RegisterFaction(FACTION_GUTTERSNIPES         , "Gang", false);
    RegisterFaction(FACTION_FLC                  , "FLC", false);
    RegisterFaction(FACTION_SLAVES                 , "Slaves", false);
    RegisterFaction(FACTION_LARAS_GANG          , "Lara's Gang", false);
    RegisterFaction(FACTION_CHILDREN         , "Children", false);
    RegisterFaction(FACTION_NR_PIMPS             , "New Reno Pimps", false);
    RegisterFaction(FACTION_ELRONOLOGISTS        , "Elecronologists", false);
    RegisterFaction(FACTION_CATHEDRAL            , "Cathedral", false);
    RegisterFaction(FACTION_CORSICAN_BROTHERS , "Corsican Brothers", false);
    RegisterFaction(FACTION_KLAMATH             , "Klamath", false);
    RegisterFaction(FACTION_DEN                  , "Den", false);
    RegisterFaction(FACTION_MODOC            , "Modoc", false);
    RegisterFaction(FACTION_COURTYARD, "Courtyard", false);
    RegisterFaction(FACTION_GECKO            , "Gecko", false);
    RegisterFaction(FACTION_REDDING           , "Redding", false);
    RegisterFaction(FACTION_BH_GHOULS         , "Broken Hills Ghouls", false);
    RegisterFaction(FACTION_NEW_RENO          , "New Reno", false);
    RegisterFaction(FACTION_NECROPOLIS           , "Necropolis", false);
    RegisterFaction(FACTION_JUNKTOWN            , "Junktown Scouts", false);
    RegisterFaction(FACTION_HUB                 , "Hub", false);
    RegisterFaction(FACTION_LA                 , "Los Angeles", false);
    RegisterFaction(FACTION_VEGAS              , "Vegas", false);
    RegisterFaction(FACTION_SALTLAKE, "Salt Lake", false);
    RegisterFaction(FACTION_CARPENTER           , "Carpenter", false);
    RegisterFaction(FACTION_REPEX            , "Repex", false);
    RegisterFaction(FACTION_BRAHMIN_FARMS      , "Brahmin Farms", false);
    RegisterFaction(FACTION_MARIPOSA_MUTANTS   , "Mariposa Mutants", false);
    RegisterFaction(FACTION_AREA51_SYSTEM      , "Area51", false);
    RegisterFaction(FACTION_ARMY_OF_HAWTHORNE  , "Army of Hawthorne", false);
    // RegisterFaction(FACTION_GUNRUNNERS, "Gun Runners", false); <- screw it

    // and some fixed playerdriven factions
    RegisterFaction(FACTION_VAGRANTS, "The Tanker Vagrants", true);
    RegisterFaction(FACTION_REDDING_GUTTERSNIPES, "The Redding Guttersnipes", true);

    __TimeoutBattle = REAL_SECOND(10);   // do not move this to InitializeGame() - __TimeMultiplier is still 0 there!

    InitTents();
    InitCars();

    // Initialize the script for improved economy
    InitEconomy();
    // radiation tables
//    InitRadiationEffects();

    // Mercenaries
    InitMercs();
    //
    InitNpcSchedules();
    // Patrol routes
   InitRoutes();
    // Brahmin pens
   InitBrahminPens();
    // Bramin traders
   InitBrahminTraders();
    // Towns
   InitTowns();
   rolltcwindows();
	if(when_tc_modoc>5)
		can_tc_modoc = true;
	if(when_tc_gecko>5)
		can_tc_gecko= true;
	if(when_tc_den>5)
		can_tc_den = true;
	if(when_tc_klamath>5)
		can_tc_klamath = true;
	if(when_tc_redding>5)
		can_tc_redding = true;
	if(when_tc_bh>5)
		can_tc_bh = true;
	if(when_tc_necro>5)
		can_tc_necro = true;
    InitCaveRandomization();
   InitSlaveruns();
 //  InitAmmoLog();
    InitCaveLog();
    InitCompanions();
    // Caravans wohoo
  InitCaravans();     // Uncomment if you want to have one caravan running Hub-Adytum-Lost Hills
    // reputations, alliances
    InitGroups();
    // scenariooos
 //    InitScenarios();
    InitTrains();
    InitAlertMaps();
    InitWeather();
    InitReverseItem();
    InitProduction();
    InitShufflingSpawns();
    ProcessCrippling();
	//CreateTimeEvent(AFTER(0), "base_control@e_Load", false);
	LoadBaseData();
	InitBaseControl();
	LoadBannedCharacters();
	init_events();
	init_boss_events();
	init_treasures();

    array<Map@> allMaps;
    uint        allMapsCount = GetAllMaps(0, allMaps);
    uint        noGridsMaps = 0;
    for(uint m = 0; m < allMapsCount; m++)
    {
        if(!valid(allMaps[m]) || allMaps[m].IsNotValid)           // JIC
            continue;

        if(_MapHasMode(allMaps[m], MAP_MODE_NO_GRIDS))
        {
            // in case of changes, remember about editing cheats@ExecMapGrids
            allMaps[m].SetEvent(MAP_EVENT_LOOP_3, "cheats@_LockMap");
            allMaps[m].SetLoopTime(3, 500);
            SetTimeoutForAll(allMaps[m], TO_TRANSFER, REAL_SECOND(2238));
            noGridsMaps++;
        }
        // if()
    }

 //   if(noGridsMaps > 0)
      //  Log("Exit grids disabled on " + noGridsMaps + " map" + (noGridsMaps > 1 ? "s" : ""));


		
	if(IS_FIRST_TIME)
	{
		array<Location@> 	locations;
		uint				locationsNum = GetAllLocations(0, locations); 
		for(uint l = 0; l<locationsNum; l++)					//find all locations in game and for each location we go
		{
			if(locations[l].IsDungeon() && locations[l].IsPublic())
				locations[l].Color = COLOR_RGBA(138, 0, 0, 120);
				
			if(locations[l].IsTown() && !locations[l].IsGuarded() && (locations[l].Radius > 6) && locations[l].IsPublic())
				locations[l].Color = COLOR_RGBA(206, 154, 50, 90);
		}
	}
		
    StartPersonalDataCleanup();

    SetGvar(GVAR_is_first_time, 0);
	SetGvar(GVAR_experience_multipler, 1);
	SetGvar(GVAR_experience_multipler_kill, 1);
	SetGvar(GVAR_experience_multipler_caravans, 1);
	CreateTimeEvent(AFTER(REAL_SECOND(30)), "e_KickMultilogs", false);
    return true;
}
array<uint> Tents;
void GotoTent(Critter& cr, int p0, int p1, int p2)
{
    cr.TransitToMap(Tents[p0], 0);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on world initialization.
// Parameter         Min    Max
// multiplier        1      99
// year              1700   30000
// month             1      12
// day               1      31
// hour              0      23
// minute            0      59
void get_start_time(uint16& multiplier, uint16& year, uint16& month, uint16& day, uint16& hour, uint16& minute)
{
    multiplier = 20;
    year = 2278;
    month = 6;
    day = 19;
    hour = 3;
    minute = 3;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on finish server.
void finish()
{
    FLog(LOG_WMLOCATIONS, "FINISH");
    CloseLogs();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call every returned value, in milliseconds.
// Return next call in milliseconds or zero to disable loop.
uint lastsecond = 0;
uint last_os_save = 0;
uint last_os_mod = 0;
bool BCRewardSpawned = false;
uint renos = 0;
bool reno = true;
bool renotry = false;
bool exp_event = false;
uint companionSpawned = 0;
uint companioncheck = 0;
void forceloop(Critter& cr, int, int, int)
{
	loop();

}
uint loop()
{
    // updates worldmap
    // WorldmapUpdate(10000);
    uint16 second = 0;
    uint16 minute = 0;
    uint16 hour = 0;
	uint16 d = 0;
    uint16 a, b, c, g;
    GetTime(a, b, c, d, hour, minute, second, g);

	UpdateBroadcast();
	if(hour>12 && hour<20) //change it
	{
	if(minute == 0 && second < 20 && !reno && !renotry)
		{
		if(Random(1 + renos,6) == 6)
			{
			//Reno_event();
			reno = true;
			renotry = true;
			}
		else
			{
			renos++;
			renotry = true;
			}
		}
	else if(minute == 0 && second < 20 && renotry)
	{
		//Do nothing
	}	
	else if(renotry)
		renotry = false;
	}
	if(hour == 12 && minute == 0 && second < 20 && reno)  //change it
		{
		reno = false;
		renos = 0;	
		renotry = false;
		}
    if((minute == 0 || minute == 30) && second < 20)    // a time buffer to make sure that long cycles won't prevent updating
    {
        for(uint i = 1; i < TOWN_COUNT + 1; i++)
        {
            ITown@ town = GetTown(i);
            town.Update(hour, minute);
        }
			
    }
	if(companionSpawned<75)
	{
	if((minute == 59 || minute == 19 || minute == 39  ) && second < 20 && companionSpawned != companioncheck)
		{
		companioncheck = companionSpawned;
		}
	if((minute == 0 || minute == 20 || minute == 40  ) && second < 20 && companionSpawned == companioncheck)
		{
		CreateCompanion();
		companionSpawned++;
		}
	}
	// Base control
	if(minute == 0 && second < 20 && BCRewardSpawned == false)
	{
		if(hour % 1 == 0)
		{
		//if(hour == 1 || hour == 12)
			SpawnBCReward(LOCATION_Waterworks); //in base_control.fos
		//if(hour == 15)
			SpawnBCReward(LOCATION_Area51);
		//if(hour == 8 || hour == 20)
			SpawnBCReward(LOCATION_MariposaMilitaryBase);
		//if(hour == 4 || hour == 19)
			SpawnBCReward(LOCATION_Hawthorne);
		}
		if(hour == 23 || hour == 11 )	
			SpawnBCReward(LOCATION_SaltLake);
		
		BCRewardSpawned = true;
	}
	else if(minute == 0 && second < 20 && BCRewardSpawned == true)
	{
		//Do nothing
	}
	else if(BCRewardSpawned == true)
	{
		BCRewardSpawned = false;
	}
	
    

    if(last_os_save == 0)
        last_os_save = ELAPSED_TIME;
    else if(ELAPSED_TIME > last_os_save + OS_CYCLE_TIME)
    {
        array<Critter@> players;
        uint            n = GetAllOnlinePlayers(players);
        for(uint i = 0; i < n; i++)
            if(players[i].Id % OS_MAX_MOD == last_os_mod)
                OnlineStats_TrySave(players[i]);
        last_os_save += OS_CYCLE_TIME;
        last_os_mod++;
        if(last_os_mod == OS_MAX_MOD)
            last_os_mod = 0;
    }
	if(d==6 && hour == 23 && minute == 0 && second < 20 && !exp_event && week_patch>1)
		rollexpevent();
    lastsecond = second;
    return 500;
}

void rollexpevent()
{
	if(exp_event)
		return;
	uint8 multipler = 0;
	uint eventtype = Random(1,2);
	uint eventtime = Random(23,30);
	string eventname = "";
	switch(Random(1,20))
	{
	case 1: if(Random(1,100)==1) multipler = 3; else multipler = 2; break;
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
	multipler = 2; break;
	default: multipler = 2; break;
	}
	
	
	
	if(eventtype == 1)
		{
			eventtype = GM_EVENT_MULTIEXP_GLOBAL;
			eventname = "Multi experience (x" + multipler + ") event for %COUNTDOWN_HUMAN%.";
			if(GetGvar(GVAR_experience_multipler) == 1)
			{
				SetGvar(GVAR_experience_multipler, multipler);
			}
			else
			{
				Log("ERROR: EXP EVENT");
				return;
			}
		}
	
	if(eventtype == 2)
		{
			eventtype = GM_EVENT_MULTIEXP_KILL;
			eventname = "Multi experience (x" + multipler + ") for killing event for %COUNTDOWN_HUMAN%.";
			if(GetGvar(GVAR_experience_multipler_kill) == 1)
			{
				SetGvar(GVAR_experience_multipler_kill, multipler);
			}
			else
			{
				Log("ERROR: EXP EVENT");
				return;
			}
		}
	exp_event = true;
	CreateTimeEvent(AFTER(REAL_HOUR(eventtime)), "_erasegmevent", eventtype, false);
	ServerEventCNTSet(eventname, 0, eventtype, REAL_HOUR(eventtime));
}

uint _erasegmevent(array<uint>@ eventtype)
{
	switch(eventtype[0])
	{
		case GM_EVENT_MULTIEXP_GLOBAL: SetGvar(GVAR_experience_multipler, 1); break;
		case GM_EVENT_MULTIEXP_KILL: SetGvar(GVAR_experience_multipler_kill, 1); break;
		case GM_EVENT_MULTIEXP_CARAVANS: SetGvar(GVAR_experience_multipler_caravans, 1); break;
	}
	exp_event = false;
	return 0;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Call when critter attack another.
void critter_attack(Critter& cr, Critter& target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo)
{

	speedboost(cr);
	if(cr.Param[ST_SHOTTED]==0 && cr.IsPlayer())
		CombatAttack(cr, target, weapon, weaponMode, ammo);
	if(!cr.IsPlayer())
		CombatAttack(cr, target, weapon, weaponMode, ammo);
}
uint _SHOT(array<uint>@ cr)
{
	GetCritter(cr[0]).ParamBase[TO_GOD_MODE] = 0;
	return 0;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Called when a critter is attacked by another.
#define _CanHelp     # (npc, who)(_GroupMode(npc) == FACTION_MODE_NPC_ONLY ? _IsTrueNpc(who) : (_GroupMode(npc) == FACTION_MODE_PLAYER_ONLY ? !_IsTrueNpc(who) : true))
#define _AnyGuard    # (npc)         (_GroupMode(npc) != 0 && _GroupMode(npc) != 4)
// These macros are a nice example of code that can't be inlined function nor can be put in do{}while(false) (because of continue) :)
#define _GenGuardTryHelpCr                         \
    # (npc)        if(crHelpers == 0 && !override) \
        continue; if(!_CanHelp(npc, cr))           \
        continue; crHelpers--; AddAttackPlane(npc, 0, attacker); continue
#define _GenGuardTryHelpAttacker                   \
    # (npc)  if(attackerHelpers == 0 && !override) \
        continue; if(!_CanHelp(npc, attacker))     \
        continue; attackerHelpers--; AddAttackPlane(npc, 0, cr); continue
#define _TryHelpCr                                                      \
    # (npc)                if(!_CanHelp(npc, cr))                       \
        continue; if(!_IsTrueNpc(cr)) { if(crHelpers == 0 && !override) \
                                            continue; crHelpers--; } AddAttackPlane(npc, 0, attacker); continue
#define _TryHelpAttacker                                                            \
    # (npc)          if(!_CanHelp(npc, attacker))                                   \
        continue; if(!_IsTrueNpc(attacker)) { if(attackerHelpers == 0 && !override) \
                                                  continue; attackerHelpers--; } AddAttackPlane(npc, 0, cr); continue

void critter_attacked(Critter& cr, Critter& attacker)
{
	speedboost(cr);
    if(attacker.Id == cr.Id)
        return;

    Map@ map = cr.GetMap();
    if(IsDueling(attacker) || IsArenaCombatant(attacker))
        return;
    uint crGroup = _GroupIndex(cr);
    uint attackerGroup = _GroupIndex(attacker);

    DPlayerLog(attacker, "" + attackerGroup + "vs" + crGroup);

    if(crGroup == attackerGroup && _IsTrueNpc(cr) && _IsTrueNpc(attacker))
        return;

    if(attacker.IsPlayer() && !_GroupHasNoAffiliation(crGroup) && !IsFlaggedAsIllegal(cr))
    {
        if(IsTown(map))
            SubReputation(attacker, crGroup, REP_ATK_PENALTY * MAX(1, _GroupRank(cr)));
        else
            TryReportOffense(cr, attacker, REP_ATK_PENALTY * MAX(1, _GroupRank(cr)));
    }
    if(!cr.IsPlayer() && (!_IsTrueNpc(attacker) || (crGroup != attackerGroup)))
        AddAttackPlane(cr, 0, attacker);
		
	//Base Control - retake on attack!
	if(IsBaseControl(map) &&
	(map.GetLocation().GetProtoId() == LOCATION_Waterworks && GetGvar(GVAR_waterworks_score) == attacker.Param[ST_TEAM_ID]) ||
	(map.GetLocation().GetProtoId() == LOCATION_Area51 && GetGvar(GVAR_area51_score) == attacker.Param[ST_TEAM_ID]) ||
	(map.GetLocation().GetProtoId() == LOCATION_SaltLake && GetGvar(GVAR_nukacola_score) == attacker.Param[ST_TEAM_ID] && IsNukaColaWorker(cr)) ||
	(map.GetLocation().GetProtoId() == LOCATION_MariposaMilitaryBase && GetGvar(GVAR_mariposa_score) == attacker.Param[ST_TEAM_ID]) ||
	(map.GetLocation().GetProtoId() == LOCATION_Hawthorne && GetGvar(GVAR_hawthorne_score) == attacker.Param[ST_TEAM_ID]))
	{
		Location@ baseLoc = map.GetLocation();
		uint16 location = baseLoc.GetProtoId(), NPCFaction = 0;
		
		switch(location)
		{
			case LOCATION_Waterworks :
				NPCFaction = FACTION_SLAGS;
				break;
			case LOCATION_Area51 :
				NPCFaction = FACTION_AREA51_SYSTEM;
				break;
			case LOCATION_SaltLake :
				NPCFaction = FACTION_SALTLAKE;
				break;
			case LOCATION_MariposaMilitaryBase :
				NPCFaction = FACTION_MARIPOSA_MUTANTS;
				break;
			case LOCATION_Hawthorne :
				NPCFaction = FACTION_ARMY_OF_HAWTHORNE;
				break;
		}

		array<uint> controllingdata = { 0, location, baseLoc.Id, NPCFaction };
		//CreateTimeEvent(AFTER(0), "base_control@e_TakeControlByNPC", controllingdata, false);
		CallMobsToTakeBase( 0, location, baseLoc.Id, NPCFaction );
	}

    // In similar fashion to vanilla, but only for general purpose guards (normal guards will react no matter what, unless the helped is player/follower)
    uint crHelpers = 10 - attacker.Param[ST_CHARISMA];
    crHelpers = CLAMP(crHelpers, 2, 8);
    if(_AnyGuard(cr))
        crHelpers += 4;
    uint attackerHelpers = 10 - cr.Param[ST_CHARISMA];
    attackerHelpers = CLAMP(attackerHelpers, 2, 4);
    if(_AnyGuard(attacker))
        attackerHelpers += 4;

    // Reinforcements
    bool override = GetAlertLevel(map) >= __AlertLevelReact;   // map is on high alert, don't use helpers number, everyone fights

    // We say again: *Helpers are potential general purpose guards or faction-guards helping player/follower :)
    // Put all critters that can see either the target or the attacker in critters
    array<Critter@> critters;
    uint            k = 0;

    if(override)
        k = map.GetCritters(0, FIND_LIFE_AND_KO | FIND_ONLY_NPC, critters);
    else
    {
        uint n = cr.GetCritters(true, FIND_LIFE_AND_KO | FIND_ONLY_NPC, critters);
        uint m = attacker.GetCritters(true, FIND_LIFE_AND_KO | FIND_ONLY_NPC, critters);
        m += n;
        if(m == 0)
            return;

        k = m;
        if(n != 0 && m != n)       // union-find if necessary (usually it is)
        {
            k = n;
            // Remove the doubled ones
            m -= 1;
            while(k != m)
            {
                if(critters[k].IsSee(cr))
                {
                    // Swap this guy with the last on the "probably ok" list
                    Critter@ temp = critters[k];
                    @critters[k] = critters[m];
                    @critters[m] = temp;
                    m--;
                }
                else
                    k++;
            }
            if(!critters[k].IsSee(cr))
                k++;
        }
    }

    // Exclude those that are already busy helping, check if a general purpose guard is there and if the attacker should be flagged
    // Flagging unflagged attacker when the target is unflagged and there's no extreme reputations combination

    for(uint i = 0; i < k; i++)
    {
        if(!_IsTrueNpc(critters[i]) || critters[i].Id == cr.Id || critters[i].Id == attacker.Id)
        {
            @critters[i] = null;
            continue;
        }
        if(_CritHasExtMode(critters[i], MODE_EXT_GUARD))
        {
            uint crRepIndex = _GroupIndex(critters[i]);
            if(!_IsTrueNpc(attacker) &&
               !IsFlaggedAsIllegal(attacker) &&
               !IsFlaggedAsIllegal(cr) &&
               (crRepIndex >= REPUTATION_COUNT || (attacker.Reputation[crRepIndex] < __ReputationLoved) ||
                (cr.Reputation[crRepIndex] >= __ReputationHated)) && !_IsMobNpc(cr)
               )
                SetCritterIllegalFlag(attacker, ILLEGAL_FLAG_ATTACKING);
        }


        NpcPlane@ plane = critters[i].GetCurPlane();
        if(valid(plane) && plane.Type == AI_PLANE_ATTACK && plane.Attack_TargId == attacker.Id)
        {
            if(crHelpers > 0)
                crHelpers--;
            @critters[i] = null;           // Exclude this critter
        }
        if(valid(plane) && plane.Type == AI_PLANE_ATTACK && plane.Attack_TargId == cr.Id)
        {
            if(attackerHelpers > 0)
                attackerHelpers--;
            @critters[i] = null;           // Exclude this critter
        }
    }

    int  crRep = 0;
    int  attackerRep = 0;
    uint npcGroup = 0;
    int  crStatus = FACTION_NEUTRAL;
    int  attackerStatus = FACTION_NEUTRAL;

    // Global rule: always help a friend against a non-friend; always attack the enemy if against non-enemy
    for(uint i = 0; i < k; i++)
    {
        if(!valid(critters[i]))
            continue;                                        // Skip excluded
        npcGroup = _GroupIndex(critters[i]);

        if(_CritHasExtMode(critters[i], MODE_EXT_GUARD))     // General purpose guard
        {
            if(attackerHelpers == 0 && crHelpers == 0 && !override)
                continue;
			//worldremaker
			
			if(cr.Param[ST_NPC_ROLE] == ROLE_MOB_DYNAMIC && (attacker.IsPlayer() || (attacker.IsNpc() && _IsFollower(attacker) && attacker.FollowerVar[FV_MASTER] > 0)))
				continue;
				
			if(attacker.Param[ST_NPC_ROLE] == ROLE_MOB_DYNAMIC && (cr.IsPlayer() || (cr.IsNpc() && _IsFollower(cr) && cr.FollowerVar[FV_MASTER] > 0)))
				continue;
            // Logic behind an all-purpose guard:
            // Always ignore the attack if critter is flagged as illegal
            // Help all npc members if they are attacking
            // Help all npc members if they are attacked
            // If neither of the above, check if the attacked is liked very much, and the target is not. help the attacker if this is the case.
            // Otherwise, check if reputation difference is big enough, ignore the attack then
            // If not, then proceed with the default action (help the target)

            // Faction members npcs are ok, help them
            if((npcGroup == attackerGroup) && _IsTrueNpc(attacker))
            {
                _GenGuardTryHelpAttacker(critters[i]);
            }

            // Always help a friend against a non-friend; always attack the enemy if against non-enemy
            crStatus = GetGroupsStatus(cr, critters[i]);
            attackerStatus = GetGroupsStatus(attacker, critters[i]);

            if(crStatus == FACTION_ALLY)
            {
                if(attackerStatus != FACTION_ALLY)
                {
                    _GenGuardTryHelpCr(critters[i]);
                }
                else
                    continue;
            }
            else if(crStatus == FACTION_NEUTRAL)
            {
                if(attackerStatus == FACTION_ALLY)
                {
                    _GenGuardTryHelpAttacker(critters[i]);
                }
            }
            else if(crStatus == FACTION_ENEMY)
            {
                if(attackerStatus != FACTION_ENEMY)
                {
                    _GenGuardTryHelpAttacker(critters[i]);
                }
            }

            // Is the critter illegal? then the attacker is ok
            if(IsFlaggedAsIllegal(cr))
                continue;

            // Help the friendly npc
            if((crGroup == npcGroup) && _IsTrueNpc(cr))
            {
                _GenGuardTryHelpCr(critters[i]);
            }

            // If the attacker is liked, and the target is not, actually help the attacker
            crRep = npcGroup < REPUTATION_COUNT ? cr.Reputation[npcGroup] : 0;
            attackerRep = npcGroup < REPUTATION_COUNT ? attacker.Reputation[npcGroup] : 0;
            if((attackerRep >= __ReputationLoved) && (crRep < __ReputationHated))
            {
                _GenGuardTryHelpAttacker(critters[i]);
            }

            // Be neutral on medium difference
            if(attackerRep - crRep > REP_DIFF)
                continue;

            // Default behaviour
			_GenGuardTryHelpCr(critters[i]);
        }                                                                                                           // General purpose guard
        else if(_GroupIndex(critters[i]) > 1 && _GroupMode(critters[i]) > 0 && _GroupMode(critters[i]) < 4)         // non-general guard
        {
            // General rules: target is in our team, npc attacker is in our team:     do nothing
            //                target is in our team, player attacker is in our team:  kill the player
            //                target is in our team, attacker not is in our team:     kill the attacker
            //                target is not in our team, attacker is in our team:     kill the critter
            //                target is not in our team, attacker is not in our team: help the side that has v. high reputation,
            //                                                                        providing that the other side has v. low reputation


            // Always help a friend against a non-friend; always attack the enemy if against non-enemy
            crStatus = GetGroupsStatus(cr, critters[i]);
            attackerStatus = GetGroupsStatus(attacker, critters[i]);

            if(crStatus == FACTION_ALLY)
            {
                if(attackerStatus != FACTION_ALLY)
                {
                    _GenGuardTryHelpCr(critters[i]);                     // Act like a generic guard in this case
                }
            }
            else if(crStatus == FACTION_NEUTRAL)
            {
                if(attackerStatus == FACTION_ALLY)
                {
                    _GenGuardTryHelpAttacker(critters[i]);                     // Act like a generic guard in this case
                }
            }
            else if(crStatus == FACTION_ENEMY)
            {
                if(attackerStatus != FACTION_ENEMY)
                {
                    _GenGuardTryHelpAttacker(critters[i]);                     // Act like a generic guard in this case
                }
            }

            if(npcGroup == crGroup)
            {
                if(npcGroup == attackerGroup)
                {
                    if(_IsTrueNpc(attacker))
                        continue;
                    else
                    {
                        _TryHelpCr(critters[i]);
                    }
                }
                else
                {
                    if(_IsTrueNpc(attacker))
                        continue;
                    else
                        _TryHelpCr(critters[i]);
                }
            }
            else
            {
                if(npcGroup == attackerGroup)
                {
                    _TryHelpAttacker(critters[i]);
                }
                else
                {
                    crRep = npcGroup < REPUTATION_COUNT ? cr.Reputation[npcGroup] : 0;
                    attackerRep = npcGroup < REPUTATION_COUNT ? attacker.Reputation[npcGroup] : 0;
                    if((attackerRep >= __ReputationLoved) && (crRep < __ReputationHated))
                    {
                        _TryHelpAttacker(critters[i]);
                    }
                    else if((crRep >= __ReputationLoved) && (attackerRep < __ReputationHated))
                    {
                        _TryHelpCr(critters[i]);
                    }
                }
            }
        }                                             // Non-general purpose guard
        else if(_GroupHasNoAffiliation(npcGroup))     // In encounters
        {
            if(npcGroup == crGroup)
                AddAttackPlane(critters[i], 0, attacker);
            else if(npcGroup == attackerGroup)
                AddAttackPlane(critters[i], 0, cr);
        }
    }     // Main loop
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Called after the critter gets any damage.
void PostDamage(Critter& cr)
{
    if(valid(cr.GetMap()) && cr.GetMap().IsTurnBased())
        return;
    if(cr.IsPlayer() || !IsHumanoid(cr) || cr.Cond == COND_DEAD)
        return;
    if(cr.IsInjured())
    {
        if(cr.Param[TO_SK_DOCTOR] <= 0)
        {
            if(cr.Param[ST_INTELLECT] >= Random(1, 10))
            {
                array<NpcPlane@> planes;
                cr.GetPlanes(PLANE_DOCTOR_CRITTER, planes);
                if(planes.length() > 0)
                    planes[0].IdentifierExt = cr.Id;
                else
                    AddDoctorCritterPlane(cr, valid(cr.GetCurPlane()) ? cr.GetCurPlane().Priority + 5 : 0, cr, false);     // self
            }
        }
    }
    if(cr.Param[ST_CURRENT_HP] != cr.Param[ST_MAX_LIFE])
    {
        if(cr.Param[TO_SK_FIRST_AID] <= 0)
        {
            if(cr.Param[ST_INTELLECT] >= Random(1, 10))
            {
                if(cr.Param[ST_CURRENT_HP] <= cr.Param[ST_MAX_LIFE] / 2 || (cr.Param[ST_MAX_LIFE] - cr.Param[ST_CURRENT_HP] > cr.Param[SK_FIRST_AID]))
                {
                    array<NpcPlane@> planes;
                    cr.GetPlanes(PLANE_HEAL_CRITTER, planes);
                    if(planes.length() > 0)
                        planes[0].IdentifierExt = cr.Id;
                    else
                        AddHealCritterPlane(cr, valid(cr.GetCurPlane()) ? cr.GetCurPlane().Priority + 5 : 0, cr, false);     // self
                }
            }
        }
		else _TryUseSS(cr);
    }

}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call when a critter steals from another.
bool critter_stealing(Critter& cr, Critter& thief, Item& item, uint count)
{
    if(cr.IsDead() || cr.Param[TO_BATTLE] > 0 || thief.Param[TO_BATTLE] > 0)
    {
        thief.ParamBase[ST_LAST_STEAL_CR_ID] = 0;
        thief.ParamBase[ST_STEAL_COUNT] = 0;
        return false;
    }

    switch(item.GetProtoId())
    {
        case PID_WORKBENCH:
        case PID_WORKBENCH_PRIMITIVE:
        case PID_WORKBENCH_RAIDERS:
        case PID_MFC_MACHINE:
        case PID_MED_MACHINE:
        case PID_AMMO_FACILITY:
        case PID_CAMPFIRE:
        case PID_ADVANCED_BENCH:
        case PID_TOBACCO_BENCH:
        case PID_MACHINERY_POWER_ARMOR:
        case PID_MACHINERY_SMALL_GUNS:
        case PID_MACHINERY_BIG_GUNS:
        case PID_MACHINERY_ENERGY_WEAPONS:
        case PID_MACHINERY_ENERGY_CELLS:
        case PID_MACHINERY_LATHE:
		case PID_WORKBENCH_FAT_FOUNDRY:
        case PID_WORKBENCH_FAT_HI_AMMO:
        case PID_WORKBENCH_FAT_EXTENDED:
        case PID_WORKBENCH_FAT_CLOSE_COMBAT:
        case PID_WORKBENCH_FAT_POWDER_AMMO:
        case PID_WORKBENCH_FAT_PRIMITIVE:
        case PID_WORKBENCH_FAT_NUKACOLA:
        case PID_WORKBENCH_FAT_BEER:
        case PID_WORKBENCH_FAT_TOBACCO:
        case PID_WORKBENCH_FAT_ROTGUT:
            //DeleteItem(item);
            return false;
    }

    int dir1 = cr.Dir;
    int dir2 = thief.Dir;
    int kDir = MAX(dir1, dir2) - MIN(dir1, dir2);
    if(kDir > 3)
        kDir = 6 - kDir;

    int steal = thief.Param[SK_LOCKPICK];
    if(steal <= 0)
        steal = 1;
    int size = item.Proto.Volume;
    if(size <= 0)
        size = 1;

    // Perk pickpocket, ignore size and facing --> now only halve
    bool pickpocket = thief.Param[PE_PICKPOCKET] != 0;

    // Count modifier
    int kCount = count / steal;
    if(kCount <= 0)
        kCount = 1;

    // Check time of stealing
    uint lastStealCrId = thief.Param[ST_LAST_STEAL_CR_ID];
    uint stealCount = thief.Param[ST_STEAL_COUNT];
    if(lastStealCrId == cr.Id && thief.Param[TO_SK_LOCKPICK] > 0)
        steal -= steal * stealCount * 10 / 100;

    // Calc
    int k = (steal - kDir * (pickpocket ? 5 : 10)) / MAX(1, (size * kCount) / (pickpocket ? 2 : 1));
    k = CLAMP(k, 5, 95);

    GameVar@ var = GetUnicumVar(UVAR_proximity_check, cr.Id, thief.Id);
    if(var.GetValue() == 1)
        k /= 2;

    bool success = !(Random(1, 100) > k);
	
	
	Map@ map = cr.GetMap();
	if(_MapHasMode(map, MAP_MODE_NO_PVP))
	{
	thief.Say(SAY_NETMSG, "|4291317840 " + "You cannot steal here.");
	success = false;
	}

    // flag critter if guards spot it
    /*if (IsTown(thief.GetMap()) && !IsFlaggedAsIllegal(thief))
            thief.SendMessage(MSG_IM_STEALING, cr.Id, MESSAGE_TO_VISIBLE_ME);*/

    if(success || cr.Param[PE_THIEF] != 0 || Random(1, 50) <= cr.Param[ST_LUCK])
        _SetTimeout(thief, TO_SK_LOCKPICK, STEAL_TIMEOUT(thief));

    if(success)
    {
        // Add experience
        // const int stealExp[12]={10,30,60,100,150,210,280,360,450,550,660,780};
        // const int stealExp[12]={10,20,30,40,50,60,70,80,90,100,110,120};
        const int[] stealExp = { 50, 100, 150, 250, 300, 400, 500, 600, 700, 1000 };

        if(lastStealCrId == cr.Id && thief.Param[TO_SK_LOCKPICK] > 0)
        {
            stealCount++;
            if(stealCount > 9)
                stealCount = 9;
            thief.ParamBase[ST_STEAL_COUNT] = stealCount;
        }
        else
        {
            thief.ParamBase[ST_LAST_STEAL_CR_ID] = cr.Id;
            thief.ParamBase[ST_STEAL_COUNT] = 0;
        }

        if(_IsFollower(cr) || IsBase(cr.GetMap()) || IsTent(cr.GetMap()))
            return success;

        if(cr.IsNpc())
        {
            thief.ParamBase[ST_EXPERIENCE] += stealExp[stealCount];
            LogExperience(thief, stealExp[stealCount], SK_LOCKPICK, cr.GetProtoId());
            AddScore(thief, SCORE_THIEF, 1);
        }
    }
    else
    {
        if(IsTown(thief.GetMap()))
            SetCritterIllegalFlag(thief, ILLEGAL_FLAG_STEALING);

        thief.ParamBase[ST_LAST_STEAL_CR_ID] = 0;
        thief.ParamBase[ST_STEAL_COUNT] = 0;

        if(cr.IsNpc())
        {
            int thiefHp = thief.Param[ST_CURRENT_HP];
            if(!(_IsFollower(cr) && IsTown(thief.GetMap())))
                AddAttackPlane(cr, 0, thief, thiefHp < 10 || Random(1, 10) > cr.Param[ST_LUCK] ? __DeadHitPoints : Random(thiefHp / 4, thiefHp / 2));

            uint crGroup = _GroupIndex(cr);
            if(_ValidReputationIndex(crGroup))
                SubReputation(thief, crGroup, REP_STEAL_PENALTY * MAX(1, _GroupRank(cr)));
        }
        else
        {
            cr.Say(SAY_NETMSG, "|4291317840 " + thief.Name + " failed to steal from you.");
            cr.RunClientScript("_ActionStealing", thief.Id, 0, 0, null, null);       // send action
        }
    }

    return success;
}

uint e_as(array<uint>@ mobdata)
{
	
	Critter@ cr = GetCritter(mobdata[0]);
	cr.ParamBase[ST_SHOTTED] = 0;
	if(cr.Param[PE_MUTANT]==0)
		cr.ParamBase[MODE_NO_RUN] = 0;
	cr.ParamBase[MODE_NO_WALK] = 0;
	//cr.RunClientScript("client_main@_as", mobdata[0], 0, 0, "", null);
	return 0;
}

uint get_as(Critter& cr)
{
	int val = 1700;
	//val -= cr.Param[ST_SEQUENCE] * 8; // 1% per sequence
	//val -= cr.Param[ST_AGILITY] * 8; // 1% per ag
	//val -= cr.Param[TRAIT_FAST_SHOT] * 40; // 5%
	//val -= cr.Param[PE_CLAW] * 40; // 5%
	//val -= cr.Param[PE_CLAW2] * 40; // 5%
	//if( valid(cr.GetItem(SLOT_HAND1, 0)))
	//if(FLAG(cr.GetItem(SLOT_HAND1, 0).Flags,ITEM_TWO_HANDS))
	//	val -= cr.Param[PE_COWBOY] * 240; //30% 
	//if(cr.Param[PE_COWBOY] > 0 && cr.Param[PE_EARLIER_SEQUENCE] > 0  && cr.Param[PE_WEAPON_HANDLING] > 0 && cr.Param[PE_QUICK_POCKETS] > 0)
	//	val -= 120; //15%	
		
	return val;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter use item.
bool critter_use_item(Critter& cr, Item& item, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen, uint param)
{
	//speedboost(cr);
    // scenario
    bool   isPlayer = cr.IsPlayer();
    uint16 pid = item.GetProtoId();
    bool   useOnSelf = (!valid(targetCr) && !valid(targetItem) && !valid(targetScen));
	
    DLog("Using item with pid: " + item.GetProtoId());

    // Book reading
    // disabled
    /*
       if(useOnSelf && IsReadableBook(pid))
       {
            TryReadBook(cr,item);
            return true;
       }
     */

    // Explosion
    if(OnUseExplode(cr, item, targetCr, targetItem, targetScen, param))
        return true;

    // Use item on another item
    //
    if(valid(targetItem))
    {
        if(targetItem.GetType() == ITEM_TYPE_CAR && UseItemOnCar(cr, targetItem, item))
        {
            return true;
        }
    }

    // Drugs
    if(item.GetType() == ITEM_TYPE_DRUG)
    {
/*        if(item.GetProtoId() == PID_CIGARETTES && !HasItem(cr, PID_LIGHTER))
        {
            cr.Say(SAY_NETMSG, "You need a lighter to smoke.");
            return true;
        }
*/
        if(useOnSelf)
            UseDrug(cr, item);
        else if(valid(targetCr))
            UseDrugOn(cr, targetCr, item);
        else
            cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING);
        return true;
    }

    // Tools (FA and doctor now)
    if(!valid(targetScen) && !valid(targetItem) && item.GetType() == ITEM_TYPE_MISC)
    {
        if(item.Proto.Misc_ToolSkillNum == SK_FIRST_AID)
        {
            if(!valid(targetCr))
                @targetCr = cr;
            if(UseFirstAidOnCritter(cr, targetCr, item))
                return true;
        }
        else if(item.Proto.Misc_ToolSkillNum == SK_DOCTOR)
        {
            if(!valid(targetCr))
                @targetCr = cr;
            if(UseDoctorOnCritter(cr, targetCr, item))
                return true;
        }
		else if(item.Proto.Misc_ToolSkillNum == SK_REPAIR)
        {
            if(!valid(targetCr))
                @targetCr = cr;
            if(UseRepairOnCritter(cr, targetCr, item))
                return true;
        }
		else if(item.Proto.Misc_ToolSkillNum == SK_SCIENCE)
        {
            if(!valid(targetCr))
                @targetCr = cr;
            if(UseScienceOnCritter(cr, targetCr, item))
                return true;
        }
    }

    // Radio
    if(FLAG(item.Flags, ITEM_RADIO) && useOnSelf)
    {
        if(isPlayer)
            EditRadioSettings(cr, item);
        return true;
    }

    // capturing
    if(pid == PID_ROPE && valid(targetCr))
    {
        bool sub = false;
        if(CaptureBrahmin(cr, targetCr, sub))
        {
            if(sub)
                cr.DeleteItem(PID_ROPE, 1);
            return true;
        }
        if(CaptureSlave(cr, targetCr, sub))
        {
            if(sub)
                cr.DeleteItem(PID_ROPE, 1);
            return true;
        }
    }

    // Play dice
    if(pid == PID_DICE)
    {
        cr.SayMsg(SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_DICE_THROW, "$result" + Random(1, 6));
        return true;
    }
    if(pid == PID_LOADED_DICE)
    {
        cr.SayMsg(SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_DICE_THROW, "$result" + uint((item.Id % 6) + 1));
        return true;
    }

    // Magic ball
    if(pid == PID_MAGIC_8_BALL)
    {
        cr.SayMsg(SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, Random(1, 2) == 1 ? STR_MAGIC_BALL_YES : STR_MAGIC_BALL_NO);
        return true;
    }

    // Cosmetic
    if(pid == PID_COSMETIC_CASE && cr.Param[ST_GENDER] == GENDER_FEMALE)
    {
        cr.SayMsg(SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_COSMETIC_USE);
        return true;
    }

    // prospect map
    if(item.GetProtoId() == PID_PROSPECT_MAP)
    {
        return UseProspectMap(cr, item);
    }
	
	// Book reading
	if(useOnSelf && IsReadableBook(pid))
	{
		TryReadBook(cr,item);
		return true;
	}
	if(item.GetProtoId() == PID_UPGRATE_PARTS)
    {
	if(item.GetCount() > 1)
        item.SetCount(item.GetCount() - 1);
    else
        DeleteItem(item);
		if(targetItem.GetType() == ITEM_TYPE_WEAPON)
			{
	
			//	player.Say(SAY_NETMSG, "6");
			targetItem.Val0 += Random(7500,15000);
			targetItem.Update();
			_weapon_perk(targetItem, false);
			return true;
			}
		if(targetItem.GetType() == ITEM_TYPE_ARMOR)
			{
			//	player.Say(SAY_NETMSG, "7");
			targetItem.Val0 += Random(7500,15000);
			targetItem.Update();
			_armor_perk(targetItem, false);
			return true;
			}
	}
	if(item.GetProtoId() == PID_UPGRATE_PARTS_MK2)
    {
	if(item.GetCount() > 1)
        item.SetCount(item.GetCount() - 1);
    else
        DeleteItem(item);
		if(targetItem.GetType() == ITEM_TYPE_WEAPON)
			{
			for(uint i = 0; i < 10; i++)
				targetItem.Val0 += Random(7500,15000);
			targetItem.Update();
			_weapon_perk(targetItem, false);
			return true;
			}
		if(targetItem.GetType() == ITEM_TYPE_ARMOR)
			{
			//	player.Say(SAY_NETMSG, "7");
			for(uint i = 0; i < 10; i++)
				targetItem.Val0 += Random(7500,15000);
			targetItem.Update();
			_armor_perk(targetItem, false);
			return true;
			}
	}
	if(item.GetProtoId() == PID_UPGRATE_PARTS_MK3)
    {
	if(item.GetCount() > 1)
        item.SetCount(item.GetCount() - 1);
    else
        DeleteItem(item);
		if(targetItem.GetType() == ITEM_TYPE_WEAPON)
			{
			for(uint i = 0; i < 100; i++)
				targetItem.Val0 += Random(7500,15000);
			targetItem.Update();
			_weapon_perk(targetItem, false);
			return true;
			}
		if(targetItem.GetType() == ITEM_TYPE_ARMOR)
			{
			//	player.Say(SAY_NETMSG, "7");
			for(uint i = 0; i < 100; i++)
				targetItem.Val0 += Random(7500,15000);
			targetItem.Update();
			_armor_perk(targetItem, false);
			return true;
			}
	}
    // Take process to engine
    return false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
bool critter_use_skill(Critter& cr, int skill, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen)
{
	//speedboost(cr);
    bool isPlayer = cr.IsPlayer();
	cr.Wait(GetSkillTime(skill,cr));
    if(valid(targetItem))
    {
        if(GuardNotLegit(cr, targetItem, false))
        {
            cr.Say(SAY_NETMSG, "You can't do this with not legit item.");
            return true;
        }
	if(targetItem.GetType() == ITEM_TYPE_CAR)
	if(cr.IsPlayer())
			if(cr.GetMap().GetLocation().IsTent() || cr.GetMap().GetLocation().IsBase())
			{
			uint16 year=0, month=0, day=0, dayofweek=0, hour=0, minute=0, second=0;
			GetGameTime( __FullSecond, year, month, day, dayofweek, hour, minute, second );
			file f;
			f.open("logs/carsuse.txt", "w");
			f.writeString(day + "." + month + " " + cr.Name + " using car number: " + targetItem.Id + " in map: " + cr.GetMap().Id);
			f.close();
			}
        // Cars
        if(targetItem.GetType() == ITEM_TYPE_CAR && UseSkillOnCar(cr, targetItem, skill))
            return true;
		
        // Doors or containers
        if((targetItem.GetType() == ITEM_TYPE_DOOR || targetItem.GetType() == ITEM_TYPE_CONTAINER) && UseSkillOnLocker(cr, targetItem, skill))
            return true;
    }
	if( isPlayer )
    {
        if( skill == SKILL_TAKE_ALL_CONT )
        {
            cr.ParamBase[ ST_CURRENT_AP ] -= 500;
        }
    }
	Map@ baseMap = cr.GetMap();
	Location@ baseLoc = null;
	if(valid(baseMap)) @baseLoc = baseMap.GetLocation();
	uint16 location, NPCFaction = 0;
	if(valid(baseLoc)) location = baseLoc.GetProtoId();
	IPolygon@ HawthorneMilitaryBase = null;
	bool IsBCRewardContainer = false;
	
	if(valid(baseLoc)) switch(location)
	{
		case LOCATION_Waterworks :
			NPCFaction = FACTION_SLAGS;
			break;
		case LOCATION_Area51 :
			NPCFaction = FACTION_AREA51_SYSTEM;
			break;
		case LOCATION_SaltLake :
			NPCFaction = FACTION_SALTLAKE;
			break;
		case LOCATION_MariposaMilitaryBase :
			NPCFaction = FACTION_MARIPOSA_MUTANTS;
			break;
		case LOCATION_Hawthorne :
			NPCFaction = FACTION_ARMY_OF_HAWTHORNE;
			break;
	}

    switch(skill)
    {
    case SKILL_PICK_ON_GROUND:     // Pick item or scenery on ground
    {
        // Stairs
        // Scenery
        if(valid(targetScen))
        {
            cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING);
            return true;
        }

        // Explosives
        if(valid(targetItem) && targetItem.GetProtoId() == PID_ACTIVE_MINE && OnUseExplode(cr, targetItem, null, null, null, 0))
            return true;

        // Pick some item
        if(valid(targetItem))
        {
            if(targetItem.GetType() == ITEM_TYPE_CONTAINER) cr.ParamBase[ST_LAST_LOOT] = int(targetItem.Id);
			
			if(valid(baseLoc))
			if(IsBaseControl(baseMap) && targetItem.GetType() == ITEM_TYPE_CONTAINER && targetItem.GetScriptId() > 0)
				if(GetScriptName(targetItem.GetScriptId()) == "base_control@RewardSpawner")
					IsBCRewardContainer = true;
			
			
			Item@ item = targetItem;
            if(!FLAG(item.Flags, ITEM_CAN_PICKUP))
            {
                cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING);
                break;
            }

            bool picked = true;
            int  freeWeight = cr.Param[ST_CARRY_WEIGHT]*2 - cr.ItemsWeight();
            if(freeWeight >= int(item.Proto.Weight * item.GetCount()))
            {
                // Pick full
                MoveItem(item, 0, cr);
                if(cr.Param[MODE_HIDE] != 0 && cr.GetAccess() < ACCESS_TESTER)
                {
                    int sk = cr.Param[SK_LOCKPICK] - 10 * GRAMM_TO_LBS(item.Proto.Weight * item.GetCount());
                    sk = CLAMP(sk, 5, 95);
                    if(sk < Random(1, 100))
                        cr.ParamBase[MODE_HIDE] = 0;
                }
            }
            else
            {
                // Pick half
                if(item.IsStackable() && freeWeight >= int(item.Proto.Weight))
                {
                    MoveItem(item, freeWeight / item.Proto.Weight, cr);
                    if(cr.Param[MODE_HIDE] != 0 && cr.GetAccess() < ACCESS_TESTER)
                    {
                        int sk = cr.Param[SK_LOCKPICK] - 10 * GRAMM_TO_LBS(item.Proto.Weight * MAX(int(freeWeight / item.Proto.Weight), int(item.GetCount())));
                        sk = CLAMP(sk, 5, 95);
                        if(sk < Random(1, 100))
                            cr.ParamBase[MODE_HIDE] = 0;
                    }
                }
                // Overweight
                else
                {
                    cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_OVERWEIGHT);
                    picked = false;
                }
            }
            if(picked)
            {
                string sound = PrepareSound_Pick(item);
                if(sound.length() > 4)                           // .ext
                    cr.PlaySound(sound, true);
            }
        }
    }
    break;
    case SKILL_PUT_CONT:     // Put item in container, only targetItem is valid
    case SKILL_TAKE_CONT:    // Take item from container, only targetItem is valid
    {
      /* if(targetItem.LockerCondition == 0)
		{
		cr.ToDead(GetRandomDeathAnimation(), null);
		cr.Say(SAY_NETMSG, "Locker is closed.");
		return false;
		}*/

	  // if(cr.Param[ST_LAST_LOOT] != int(targetItem.Id)) // && cr.Param[ST_LAST_LOOT] != int(targetCr.Id))
       // {
        //    cr.Say(SAY_NETMSG, "Don't try it anymore!");
		//	cr.ShowScreen( SCREEN_CLOSE, 0, "" );
        //    return true;
       // }
		
		switch(targetItem.GetProtoId())
        {
            case PID_WORKBENCH:
            case PID_WORKBENCH_PRIMITIVE:
            case PID_WORKBENCH_RAIDERS:
            case PID_MFC_MACHINE:
            case PID_MED_MACHINE:
            case PID_AMMO_FACILITY:
            case PID_CAMPFIRE:
            case PID_ADVANCED_BENCH:
            case PID_TOBACCO_BENCH:
			case PID_MACHINERY_POWER_ARMOR:
			case PID_MACHINERY_SMALL_GUNS:
			case PID_MACHINERY_BIG_GUNS:
			case PID_MACHINERY_ENERGY_WEAPONS:
			case PID_MACHINERY_ENERGY_CELLS:
			case PID_MACHINERY_LATHE:
			case PID_WORKBENCH_FAT_FOUNDRY:
			case PID_WORKBENCH_FAT_HI_AMMO:
			case PID_WORKBENCH_FAT_EXTENDED:
			case PID_WORKBENCH_FAT_CLOSE_COMBAT:
			case PID_WORKBENCH_FAT_POWDER_AMMO:
			case PID_WORKBENCH_FAT_PRIMITIVE:
			case PID_WORKBENCH_FAT_NUKACOLA:
			case PID_WORKBENCH_FAT_BEER:
			case PID_WORKBENCH_FAT_TOBACCO:
			case PID_WORKBENCH_FAT_ROTGUT:
                DeleteItem(targetItem);
                return true;
        }

        if(cr.Param[MODE_HIDE] != 0 && cr.GetAccess() < ACCESS_TESTER)
        {
            int sk = cr.Param[SK_LOCKPICK] - 10 * GRAMM_TO_LBS(targetItem.Proto.Weight * targetItem.GetCount());
            sk = CLAMP(sk, 5, 95);
            if(sk < Random(1, 100))
                cr.ParamBase[MODE_HIDE] = 0;
        }
        return false;
    }
    case SKILL_TAKE_ALL_CONT:     // Take all items from critter or item container
    {
		
		if(cr.Param[MODE_HIDE] != 0 && cr.GetAccess() < ACCESS_TESTER)
            cr.ParamBase[MODE_HIDE] = 0;
        return false;     
		// Don't allow - hardcoded take all is replaced by unsafe_TakeAll called from button injected at position of original one
        //return false;                  // Allow transactions
    }
    case SKILL_LOOT_CRITTER:           // Loot critter, only targetCr is valid
    {
        //cr.ParamBase[ST_LAST_LOOT] = targetCr.Id;
		CritterTrophy(targetCr, cr);   // Critters like brahmins should drop meat, skin etc		cr.ShowContainer(targetCr,null,TRANSFER_CRIT_LOOT);
        cr.Action(ACTION_PICK_CRITTER, 0, null);
        cr.ShowContainer(targetCr, null, TRANSFER_CRIT_LOOT);
        if(cr.Param[MODE_HIDE] != 0 && Random(0, 1) == 1 && cr.GetAccess() < ACCESS_TESTER)
            cr.ParamBase[MODE_HIDE] = 0;
        return true;
    }
    case SKILL_PUSH_CRITTER:     // Push critter, only targetCr is valid
        cr.Action(ACTION_PICK_CRITTER, 2, null);
        if((cr.Param[TO_BATTLE] == 0 && targetCr.Param[TO_BATTLE] == 0) && (targetCr.IsPlayer() || (targetCr.IsNoPlanes() && targetCr.GetTalkedPlayers(null) == 0)))
        {
            targetCr.MoveRandom();
            if(targetCr.IsPlayer()) targetCr.Wait(450);
            CreateTimeEvent(AFTER(REAL_MS(500)), "e_CritterMove", cr.Id, false);
        }
        return true;
    case SK_SCIENCE:     //////////////////////////////////////////////////
    {
        if(valid(targetItem) && (!FLAG(targetItem.Flags, ITEM_CAN_PICKUP) || IsArenaItem(targetItem)))
        {
            cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING);
            return true;
        }

        if(valid(targetItem) && ReversableItem(targetItem))
        {
            /*if(_IsNotLegit(targetItem.Val2))
            {
                cr.Say(SAY_NETMSG, "You can't disassemble not legit items.");
                return true;
            }*/

            Map@ map = cr.GetMap();
            if(valid(map) && _MapHasMode(map, MAP_MODE_NO_DISMANTLING))
            {
                cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING);
                return(true);
            }

            // disassembling
            if(cr.Param[TO_BATTLE] > 0)
            {
                cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_TIMEOUT_BATTLE_WAIT);
                return true;
            }
            if(ReverseItem(cr, targetItem))
            {
                if(_IsSneaking(cr) && _IsRealPlayer(cr))
                {
                    _DisableSneak(cr);
                }
                return true;
            }
        }
		
		if(UseScienceOnCritter(cr, targetCr, null))
            return true;
        cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING);   // todo "You fail to learn anything."
    }
    break;
    case SK_REPAIR:                                             ///////////////////////////////////////////////////
    {
        // Generic repair
        if(valid(targetItem) && targetItem.Accessory == ACCESSORY_CRITTER && targetItem.IsDeteriorable())
        {
            TryRepairItem(cr, targetItem);
            return true;
        }
		if(UseRepairOnCritter(cr, targetCr, null))
            return true;
        cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING);
    }
    break;
    case SK_SNEAK:     ////////////////////////////////////////////////////
    {
        if(cr.Param[MODE_HIDE] != 0)
            cr.ParamBase[MODE_HIDE] = 0;
        else if(!isPlayer)
            cr.ParamBase[MODE_HIDE] = 1;
        else
        {
            if(cr.Param[TO_SNEAK] > 0)
                cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_TIMEOUT_SNEAK_WAIT);
            else if(IS_TURN_BASED_TIMEOUT(cr))
                cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_TIMEOUT_BATTLE_WAIT);
            else if(_IsRealPlayer(cr))
            {
                // PA/APA = no sneak
                Item@ armor = _CritGetItemArmor(cr);
                if(valid(armor))
                {
                    switch(armor.GetProtoId())
                    {
                    case PID_POWERED_ARMOR:
                    case PID_HARDENED_POWER_ARMOR:
                    case PID_ADVANCED_POWER_ARMOR:
                    case PID_ADVANCED_POWER_ARMOR_MK2:
                    {
                        cr.Say(SAY_NETMSG, "You can't sneak while wearing powered armor.");
                        return true;
                    }
                    }
                }

                array<Critter@> critters;
                uint            num = cr.GetCritters(true, FIND_LIFE | FIND_ONLY_PLAYERS, critters);

                for(uint i = 0; i < num; i++)
                {
                    // You can sneak in front of...

                    if(critters[i].Param[MODE_HIDE] != 0)   // ...other sneaking players
                        continue;

                    if(_IsOffline(critters[i]))            // ...disconnected players
                        continue;

                    if(!_IsRealPlayer(critters[i]))        // ...server staff
                        continue;

                    if(_hasMinigame(cr))                   // ...if you have a minigame team, players with the same minigame team
                    {
                        if(_getMinigameTeamAndId(_minigame(cr)) == _getMinigameTeamAndId(_minigame(critters[i])))
                            continue;
                    }
                    else     // If you don't have a minigame team, you can sneak in front of...
                    {
                        if(_GroupIndex(critters[i]) > 1 && IsGang(_GroupIndex(critters[i])))
                        {
                            if(_GroupIndex(critters[i]) == _GroupIndex(cr))                       // ...players from the same player faction
                                continue;
                            if(GetStatus(_GroupIndex(critters[i]), cr.Id) == STATUS_FRIEND)       // ...players from a faction where you are a friend
                                continue;
                        }

                        if(critters[i].Param[ST_FOLLOW_CRIT] > 0)
                        {
                            if(uint(critters[i].Param[ST_FOLLOW_CRIT]) == cr.Id)      // ...players who tagged you
                                continue;

                            Critter@ taggedCr = GetCritter(critters[i].Param[ST_FOLLOW_CRIT]);
                            if(valid(taggedCr) && uint(taggedCr.Param[ST_FOLLOW_CRIT]) == cr.Id)       // ...players who tagged another player in the game who tagged you
                                continue;
                        }
                    }
                    cr.Say(SAY_NETMSG, "You can't enter sneak while being seen by players who aren't in your team, unless they are sneaking.");
                    return true;
                }
                cr.ParamBase[MODE_HIDE] = 1;
            }
            else
            {
                cr.ParamBase[MODE_HIDE] = 1;
            }
        }
    }
    break;
	case SK_ENGINE: {
	cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING);
	break;
	}
    case SK_LOCKPICK:     /////////////////////////////////////////////////
    {
        if(valid(targetItem))
        {
            cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING);
        }
        else if(valid(targetCr) && valid(cr.GetMap()))
        {
            // Loot
            if(targetCr.IsPlayer() && targetCr.Param[MODE_KILLER_ADMIN] > 0)
            {
                if(cr.GetAccess() >= ACCESS_TESTER)
                {
                    // we need to block auth->auth stealing, accidental unsetting NO_LOOT/NO_STEAL is evil
                    cr.Say(SAY_NETMSG, "You sense a bad aura around " + targetCr.Name + " and decided to not steal anything.");
                }
                else
                {
                    SetLvar(cr, LVAR_killer_admin, cr.ParamBase[ST_CURRENT_HP]);
                    _CritSetMode(cr, MODE_NO_LOOT);
                    _CritSetMode(cr, MODE_NO_STEAL);
                    int deathAnim = ANIM2_DEAD_PULSE;
                    if(targetCr.Param[MODE_KILLER_ADMIN] == 2)
                    {
                        deathAnim = GetRandomDeathAnimation();
                    }
                    else if(targetCr.Param[MODE_KILLER_ADMIN] >= ANIM2_DEAD_BEGIN &&
                            targetCr.Param[MODE_KILLER_ADMIN] < ANIM2_DEAD_END)
                    {
                        deathAnim = targetCr.Param[MODE_KILLER_ADMIN];
                    }
                    cr.ToDead(deathAnim, null);
                }
            }
            else if(targetCr.Cond == COND_DEAD)
            {
                CritterTrophy(targetCr, cr);
                cr.Action(ACTION_PICK_CRITTER, 0, null);
                if(cr.Param[MODE_HIDE] != 0 && Random(0, 1) == 1 && cr.GetAccess() < ACCESS_TESTER)
                    cr.ParamBase[MODE_HIDE] = 0;
                cr.ShowContainer(targetCr, null, TRANSFER_CRIT_LOOT);
            }
            else if(targetCr.Param[ST_CURRENT_HP] <= 0 || targetCr.Cond == COND_KNOCKOUT)
            {
                cr.Action(ACTION_PICK_CRITTER, 0, null);
                if(cr.Param[MODE_HIDE] != 0 && Random(0, 1) == 1 && cr.GetAccess() < ACCESS_TESTER)
                    cr.ParamBase[MODE_HIDE] = 0;
                cr.ShowContainer(targetCr, null, TRANSFER_CRIT_LOOT);
            }
            // Steal
            else
            {
                if(isPlayer && cr.Param[TO_SK_LOCKPICK] > 0)
                    cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_WEARINESS);
				else if(valid(baseMap) // pointer taken in earlier part
					&& baseMap.GetProtoId() == MAP_HubDowntown &&
					(targetCr.IsPlayer() || (_IsFollower(targetCr) && targetCr.ParamBase[FV_MASTER] != 0)))
						cr.Say(SAY_NETMSG, "This town is protected from stealing.");
                else
                {
                    cr.Action(ACTION_PICK_CRITTER, 1, null);
                    cr.ShowContainer(targetCr, null, TRANSFER_CRIT_STEAL);
                    _SetTimeout(cr, TO_SK_LOCKPICK, STEAL_TIMEOUT(cr));
                    cr.ParamBase[ST_LAST_STEAL_CR_ID] = 0;
                    cr.ParamBase[ST_STEAL_COUNT] = 0;
                }
            }
        }
        else
        {
            cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING);
        }
    }
    break;
    case SK_FIRST_AID:     ////////////////////////////////////////////////
    {
        if(valid(targetItem) || valid(targetScen))
        {
            cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING);
            break;
        }

        if(!valid(targetCr))
            @targetCr = cr;
        if(UseFirstAidOnCritter(cr, targetCr, null))
            return true;
    }
    break;
    case SK_DOCTOR:     ///////////////////////////////////////////////////
    {
        if(valid(targetItem) || valid(targetScen))
        {
            cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING);
            break;
        }

        if(!valid(targetCr))
            @targetCr = cr;
        if(UseDoctorOnCritter(cr, targetCr, null))
            return true;
    }
    break;
    case SK_TRAPS:     /////////////////////////////////////////////////
    {
        // Explosion
        if(valid(targetItem))
        {
            uint16 pid = targetItem.GetProtoId();
            if((pid == PID_ACTIVE_DYNAMITE || pid == PID_ACTIVE_PLASTIC_EXPLOSIVE || pid == PID_ACTIVE_MINE) &&
               OnUseExplode(cr, targetItem, null, null, null, 0))
                return true;

            if(targetItem.GetType() == ITEM_TYPE_ARMOR)
            {
                TryRechargeItem(cr, targetItem);
                return true;
            }
        }

        cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING);
    }
    break;
    default:     //////////////////////////////////////////////////////////
    {
        cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING);
    }
    break;
    }

    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reload weapon.
// If ammo is not valid than only unload.
void critter_reload_weapon(Critter& cr, Item& weapon, Item@ ammo)
{
	speedboost(cr);
    // Special weapons
    if(weapon.Proto.Weapon_Caliber == 0)
    {
        if(weapon.GetProtoId() == PID_SOLAR_SCORCHER)
        {
            if(IS_NIGHT(__Hour))
                cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_SOLAR_SCORCHER_NO_LIGHT);
            else
            {
                weapon.AmmoCount = weapon.Proto.Weapon_MaxAmmoCount;
                if(cr.Param[MODE_LAST_WPN_MODE] != 0)
                {
                    weapon.SetMode(cr.Param[MODE_LAST_WPN_MODE]);
                    cr.ParamBase[MODE_LAST_WPN_MODE] = 0;
                }
                weapon.Update();
            }
        }

        return;
    }

    // Other weapons
    // Unload
    if(!valid(ammo) || (weapon.AmmoCount > 0 && weapon.AmmoPid != ammo.GetProtoId()))
    {
        if(weapon.AmmoPid != 0)
        {
            Item@ existAmmo = cr.GetItem(weapon.AmmoPid, -1);
            if(!valid(existAmmo))
                cr.AddItem(weapon.AmmoPid, weapon.AmmoCount);
            else
                _IncItem(existAmmo, weapon.AmmoCount);
        }
        weapon.AmmoCount = 0;
    }

    // Load
    if(valid(ammo))
    {
        uint count = MIN(ammo.GetCount(), weapon.Proto.Weapon_MaxAmmoCount - weapon.AmmoCount);
        weapon.AmmoCount += count;
        weapon.AmmoPid = ammo.GetProtoId();
        _SubItem(ammo, count);
        if(cr.Param[MODE_LAST_WPN_MODE] != 0)
        {
            weapon.SetMode(cr.Param[MODE_LAST_WPN_MODE]);
            cr.ParamBase[MODE_LAST_WPN_MODE] = 0;
        }
    }

    weapon.Update();
}

uint e_CritterInitRun(array<uint>@ values)
{
    Critter@ cr = GetCritter(values[0]);
    if(!valid(cr))
        return 0;
    cr.RunClientScript("_PingServer", 0, 0, 0, null, null);   // check for FOCD

    if(GetLvar(cr, LVAR_authed_char) == 1)
    {
        cr.RunClientScript("client_messages@_Listen", 0, 0, 0, null, null);
        SetCritterEvents(cr);
    }

    return 0;
}

uint e_CritterMove(array<uint>@ values)
{
    Critter@ cr = GetCritter(values[0]);
    if(valid(cr)) cr.MoveToDir(cr.Dir);
    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on player register or login in game.
// Default start position for players is center of global map.
import void AddOnlinePlayer(Critter& cr) from "utils";
import void SetCritterEvents(Critter& cr) from "logging_critter";

#pragma bindfunc "bool InitWalkProcessing(Critter@+)  -> parameters.dll  InitWalkProcessing "
#pragma bindfunc "bool InitWalkProcessing2(Critter@+) -> check_look.dll  InitWalkProcessing2"
#pragma bindfunc "bool Critter::IsMoving()            -> parameters.dll  Critter_IsMoving   " // test
bool MustInitWalkProcessing = true;                                                           // todo: get rid of it when GameTick is in scripts (use wrappers in dlls)

void critter_init(Critter& cr, bool firstTime)
{
	speedboost(cr);
	if(cr.IsPlayer())
		{
		cr.ParamBase[ST_NPC_ROLE] = 0;
		cr.ParamBase[MODE_NO_DROP] = 0;
		cr.ParamBase[MODE_NO_LOOT] = 0;
		cr.ParamBase[ST_TURN_TIME] = 30000 + cr.ParamBase[PE_PVE_ACTOR]*1000;
		}
	if(!cr.IsPlayer())
	{
		cr.ParamBase[ST_TURN_TIME] = 5000;
	
	}
    cr.ClearExtEvents();
    if(MustInitWalkProcessing)
    {
        MustInitWalkProcessing = false;
        cr.Wait(0);
        InitWalkProcessing(cr);
        cr.Wait(0);
        InitWalkProcessing2(cr);
    }
		SetCritterEvents(cr);
    FixDrugs(cr);

    if(firstTime)
    {
        GameVar@ var = GetLocalVar(LVAR_kamikaze_fix, cr.Id);
        var = 1;
    }
    if(cr.Trait[TRAIT_KAMIKAZE] != 0)
    {
        GameVar@ var = GetLocalVar(LVAR_kamikaze_fix, cr.Id);
        if(var.GetValue() == 0)
        {
            for(uint i = ST_NORMAL_RESIST; i <= ST_EXPLODE_RESIST; i++)
                cr.ParamBase[i] -= 10;
            for(uint i = ST_NORMAL_ABSORB; i <= ST_EXPLODE_ABSORB; i++)
                cr.ParamBase[i] += 10;
            var = 1;
        }
    }

   // RemoveArenaItems(cr);     // keep it here, for future hinkley+followers bugs
	if(IsCompanion(cr) && !cr.IsPlayer())
    {
	cr.ParamBase[ST_DESCRIPTION2] = 7;
	}
    if(cr.IsNpc())
    {
        cr.SetEvent(CRITTER_EVENT_BARTER, "trader@_OnBarter");
        if(_IsFollower(cr))
        {
            cr.SetBagRefreshTime((uint(-1)));
        }
    }

    if(cr.IsPlayer())
    {
		/*for(uint i = 0; i < BannedIDs.length(); i += 2)
		{
			if(BannedIDs[i] == cr.Id)
			{
				cr.Say(SAY_NETMSG, "You are banned by " + BannedReason[i] + " with reason: " + BannedReason[i + 1]);
				//textMsg = TEXTMSG_GAME;
				//strNum = 1034;
				cr.Disconnect();
				return;
			}
		}
	
		// Check ban list... Look for player's IP address...
		for(uint i = 1; (i + 1) < BannedIDs.length(); i += 2)
		{
			if(BannedIDs[i] == cr.GetIp())
			{
				cr.Say(SAY_NETMSG, "Your IP is banned by " + BannedReason[i - 1] + " with reason: " + BannedReason[i]);
				//textMsg = TEXTMSG_GAME;
				//strNum = 1043;
				cr.Disconnect();
				return;
			}
		}*/
		
		
		//if((GetGroupIndex(cr)<200) && IsLexem(cr,"$faction")) UnsetLexem(cr, "$faction");
		if(cr.Param[ST_TEAM_ID] > 0)
		{
		uint faction = GetGroupIndex(cr);
		string factionname;

		GetFactionNameStr(faction, factionname);
		SetLexem(cr, "$faction", factionname);
		}
        AddOnlinePlayer(cr);
        CreateTimeEvent(AFTER(REAL_SECOND(5)), "e_CritterInitRun", cr.Id, false);
        if(GetLvar(cr, LVAR_authed_char) == 0)
            SetSpectator(cr, false);

        // such paranoic i am!
        CreateTimeEvent(AFTER(REAL_SECOND(5)), "e_CritterInit_Broadcast", cr.Id, false);
        CreateTimeEvent(AFTER(REAL_SECOND(6)), "e_CritterInit_OnlineStats", cr.Id, false);
        CreateTimeEvent(AFTER(REAL_SECOND(7)), "e_CritterInit_XFire", cr.Id, false);

        int   modeRun = 0;
       /* Item@ weap = cr.GetItem(0, SLOT_HAND1);
        if(valid(weap) && weap.GetType() == ITEM_TYPE_WEAPON && weap.Proto.Weapon_NoRunning)
            modeRun++;
        @weap = cr.GetItem(0, SLOT_HAND2);
        if(valid(weap) && weap.GetType() == ITEM_TYPE_WEAPON && weap.Proto.Weapon_NoRunning)
            modeRun++;

        cr.ParamBase[MODE_NO_RUN] = modeRun;*/

        UpdateFactionsInfo(cr);
		
		cr.ParamBase[ST_COMMAND]=0;
		cr.ParamBase[ST_COMMAND_X]=0;
		cr.ParamBase[ST_COMMAND_Y]=0;
		
		if(cr.IsPlayer())
		{
			cr.ParamBase[ST_NPC_BOSS]=ACCESS_CLIENT;
		}
 
		// FACTION ICONS
		cr.ParamBase[FACTION_TAG1] = 66;
	cr.ParamBase[FACTION_TAG2] = 66;
	cr.ParamBase[FACTION_TAG3] = 66;
	cr.ParamBase[FACTION_TAG4] = 66;
	cr.ParamBase[FACTION_TAG5] = 66;
	cr.ParamBase[FACTION_R1] = 1;
	cr.ParamBase[FACTION_R2] = 1;
	cr.ParamBase[FACTION_R3] = 1;
	cr.ParamBase[FACTION_R4] = 1;
	cr.ParamBase[FACTION_R5] = 1;
	cr.ParamBase[FACTION_G1] = 1;
	cr.ParamBase[FACTION_G2] = 1;
	cr.ParamBase[FACTION_G3] = 1;
	cr.ParamBase[FACTION_G4] = 1;
	cr.ParamBase[FACTION_G5] = 1;
	cr.ParamBase[FACTION_B1] = 1;
	cr.ParamBase[FACTION_B2] = 1;
	cr.ParamBase[FACTION_B3] = 1;
	cr.ParamBase[FACTION_B4] = 1;
	cr.ParamBase[FACTION_B5] = 1;
	
	}
    if(firstTime)
    {
        // INITIALIZE PARAMS
        if(cr.IsPlayer())
        {
            if(int(cr.Id) > GetGvar(GVAR_last_registered))
                SetGvar(GVAR_last_registered, cr.Id);

            GameVar@ var = GetLocalVar(LVAR_factions_player_faction, cr.Id);
            var = _GroupIndex(cr);
            GameVar@ var2 = GetLocalVar(LVAR_factions_player_rank, cr.Id);
            var2 = _GroupRank(cr);

            // Input: 7 special, 3 tag skills, 2 traits, age, gender,
            // body type, some 3d layers
            uint traits = 0;
            for(uint i = TRAIT_BEGIN; i <= TRAIT_END; i++)
            {
                if(cr.ParamBase[i] != 0 && traits < 2)
                {
                    cr.ParamBase[i] = 1;
                    traits++;
                }
                else
                    cr.ParamBase[i] = 0;
            }

            if(cr.ParamBase[ST_GENDER] < 0 || cr.ParamBase[ST_GENDER] > 1)
                cr.ParamBase[ST_GENDER] = 0;
            if(cr.ParamBase[ST_AGE] < 14 || cr.ParamBase[ST_AGE] > 80)
                cr.ParamBase[ST_AGE] = 25;
            for(uint i = ST_STRENGTH; i <= ST_LUCK; i++)
                cr.ParamBase[i] = CLAMP(cr.ParamBase[i], 1, 10);

            if((cr.ParamBase[ST_STRENGTH] + cr.ParamBase[ST_PERCEPTION] + cr.ParamBase[ST_ENDURANCE] +
                cr.ParamBase[ST_CHARISMA] + cr.ParamBase[ST_INTELLECT] + cr.ParamBase[ST_AGILITY] + cr.ParamBase[ST_LUCK]) != __StartSpecialPoints)
            {
                for(uint i = ST_STRENGTH; i <= ST_LUCK; i++)
                    cr.ParamBase[i] = 5;
            }

            cr.ParamBase[ST_EMP_RESIST] = 500;
            cr.ParamBase[PE_AWARENESS] = 1;

            #ifdef PLAYERS_3D
            if(cr.ParamBase[ST_GENDER] == GENDER_MALE)
            {
                cr.ParamBase[ST_BASE_CRTYPE] = CLAMP(cr.ParamBase[ST_BASE_CRTYPE], CRTYPE_3D_MALE_NORMAL, CRTYPE_3D_MALE_FAT);
                cr.ParamBase[ST_ANIM3D_LAYERS + ANIM3D_LAYER_HAIR] = CLAMP(cr.ParamBase[ST_ANIM3D_LAYERS + ANIM3D_LAYER_HAIR], ATTRIBUTE_Hair_Male_Afro, ATTRIBUTE_Hair_Male_Shoulder + ATTRIBUTE_COLOR_RedGrey);
                if(cr.ParamBase[ST_ANIM3D_LAYERS + ANIM3D_LAYER_MUSTACHE] != ATTRIBUTE_Mustache_MadMax)
                    cr.ParamBase[ST_ANIM3D_LAYERS + ANIM3D_LAYER_MUSTACHE] = CLAMP(cr.ParamBase[ST_ANIM3D_LAYERS + ANIM3D_LAYER_MUSTACHE], 0, ATTRIBUTE_Mustache_Male_Stubble + ATTRIBUTE_COLOR_RedGrey);
                cr.ParamBase[ST_ANIM3D_LAYERS + ANIM3D_LAYER_BEARD] = CLAMP(cr.ParamBase[ST_ANIM3D_LAYERS + ANIM3D_LAYER_BEARD], 0, ATTRIBUTE_Beard_Male_Stubble + ATTRIBUTE_COLOR_RedGrey);
            }
            else
            {
                cr.ParamBase[ST_BASE_CRTYPE] = CLAMP(cr.ParamBase[ST_BASE_CRTYPE], CRTYPE_3D_FEMALE_NORMAL, CRTYPE_3D_FEMALE_FAT);
                cr.ParamBase[ST_ANIM3D_LAYERS + ANIM3D_LAYER_HAIR] = CLAMP(cr.ParamBase[ST_ANIM3D_LAYERS + ANIM3D_LAYER_HAIR], ATTRIBUTE_Hair_Female_Afro, ATTRIBUTE_Hair_Female_Short + ATTRIBUTE_COLOR_RedGrey);
                if(cr.ParamBase[ST_ANIM3D_LAYERS + ANIM3D_LAYER_MUSTACHE] != ATTRIBUTE_Mustache_MadMax)
                    cr.ParamBase[ST_ANIM3D_LAYERS + ANIM3D_LAYER_MUSTACHE] = 0;
                cr.ParamBase[ST_ANIM3D_LAYERS + ANIM3D_LAYER_BEARD] = 0;
            }

            cr.ParamBase[ST_ANIM3D_LAYERS + ANIM3D_LAYER_SKIN] = CLAMP(cr.ParamBase[ST_ANIM3D_LAYERS + ANIM3D_LAYER_SKIN], ATTRIBUTE_Skin_Human_White01, ATTRIBUTE_Skin_Human_Yellow03);
            cr.ParamBase[ST_ANIM3D_LAYERS + ANIM3D_LAYER_PONYTAIL] = CLAMP(cr.ParamBase[ST_ANIM3D_LAYERS + ANIM3D_LAYER_PONYTAIL], 0, ATTRIBUTE_Ponytail_Ponytail2 + ATTRIBUTE_COLOR_RedGrey);
            cr.ParamBase[ST_ANIM3D_LAYERS + ANIM3D_LAYER_ARMLET] = ATTRIBUTE_Armlet_PipBoyClosed;
            cr.ChangeCrType(cr.ParamBase[ST_BASE_CRTYPE]);
            #endif
            #ifndef PLAYERS_3D
            cr.ParamBase[ST_BASE_CRTYPE] = (cr.Param[ST_GENDER] == GENDER_MALE ? CRTYPE_MALE_DEFAULT : CRTYPE_FEMALE_DEFAULT);
            cr.ChangeCrType(cr.ParamBase[ST_BASE_CRTYPE]);
            #endif

            cr.ParamBase[ST_FIXBOY_COUNTER] = 1;
            cr.ParamBase[ST_FIXBOY_FILTER] = 0;
            cr.ParamBase[ST_FIXBOY_FIXALL] = 0;
        }
/*
        if(cr.Param[TAG_SKILL1] < int(SKILL_BEGIN) || cr.Param[TAG_SKILL1] > int(SKILL_END))
            cr.TagParamBase[TAG_SKILL1] = 0;
        if(cr.Param[TAG_SKILL2] < int(SKILL_BEGIN) || cr.Param[TAG_SKILL2] > int(SKILL_END))
            cr.TagParamBase[TAG_SKILL2] = 0;
        if(cr.Param[TAG_SKILL3] < int(SKILL_BEGIN) || cr.Param[TAG_SKILL3] > int(SKILL_END))
            cr.TagParamBase[TAG_SKILL3] = 0;
        if(cr.Param[TAG_SKILL1] == cr.Param[TAG_SKILL2])
            cr.TagParamBase[TAG_SKILL1] = 0;
        if(cr.Param[TAG_SKILL2] == cr.Param[TAG_SKILL3])
            cr.TagParamBase[TAG_SKILL2] = 0;
        if(cr.Param[TAG_SKILL3] == cr.Param[TAG_SKILL1])
            cr.TagParamBase[TAG_SKILL3] = 0;
*/
        CritterGenerate(cr);
        cr.ParamBase[ST_CURRENT_HP] = cr.Param[ST_MAX_LIFE];
        cr.ParamBase[ST_CURRENT_AP] = cr.Param[ST_ACTION_POINTS] * 100;

        for(uint i = REPUTATION_BEGIN; i <= REPUTATION_END; i++)
            cr.ParamBase[i] = int(0x80000000);
        ReputationsInit(cr);

        if(cr.IsPlayer())
        {
            string charSpecialStr = cr.ParamBase[ST_STRENGTH] +" "+ cr.ParamBase[ST_PERCEPTION] +" "+ cr.ParamBase[ST_ENDURANCE] +" "+ cr.ParamBase[ST_CHARISMA] +" "+ cr.ParamBase[ST_INTELLECT] +" "+ cr.ParamBase[ST_AGILITY] +" "+ cr.ParamBase[ST_LUCK];
           // string charTagsStr =  cr.Param[TAG_SKILL1]+" "+cr.Param[TAG_SKILL2]+" "+cr.Param[TAG_SKILL3];
            string charTraitsStr;
            for(uint i = TRAIT_BEGIN; i <= TRAIT_END; i++)
                if(cr.ParamBase[i] != 0)
                    charTraitsStr += " "+i;
                    
            FLog(LOG_CHARS_CREATED, cr.Name+"("+cr.Id+") special: "+charSpecialStr+" traits:"+charTraitsStr);
        }

        // FURTHER INITIALIZATION
        if(cr.IsPlayer())
        {
            for(uint i = ST_STRENGTH; i <= ST_LUCK; i++)
                cr.ParamBase[i] = CLAMP(cr.ParamBase[i], 1, 10);
            cr.ParamBase[ST_DAMAGE_TYPE] = DAMAGE_NORMAL;

            SetStartLocation(cr);
            // if(_CritCountItem(cr,PID_RADIO)==0) _CritAddItem(cr,PID_RADIO,1);

            array<uint16> pids;
            array<uint>   minCounts;
            array<uint>   maxCounts;
            array<int>    slots;

            uint          bagId = 2;
            uint          num = 0;
            uint[] bags = { 131, 132, 133, 134, 135, 136, 137, 138, 139, 144, 145 };
            bagId = random_from_array(bags);
            num = GetBagItems(bagId, pids, minCounts, maxCounts, slots);

            // cr.Say(SAY_NETMSG, "Free stuff!");
            for(uint i = 0; i < num; i++)
            {
                Item@ it = cr.AddItem(pids[i], Random(minCounts[i], maxCounts[i]));
                it.Cost = 1;
            }
            SetGroupIndex(cr, FACTION_NONE);
        }
        else
        {
            cr.ChangeCrType(cr.ParamBase[ST_BASE_CRTYPE]);

            if(cr.Param[ST_DEFAULT_ARMOR_PID] != 0)
            {
                Item@ armor = cr.AddItem(cr.Param[ST_DEFAULT_ARMOR_PID], 1);
                if(valid(armor))
                {
                    cr.MoveItem(armor.Id, 1, SLOT_ARMOR);
                    if(cr.Param[ST_OVERRIDE_CRTYPE] != 0)
                        cr.ChangeCrType(cr.ParamBase[ST_OVERRIDE_CRTYPE]);
                }
                cr.SetFavoriteItem(SLOT_ARMOR, cr.Param[ST_DEFAULT_ARMOR_PID]);
            }

            if(cr.Param[ST_DEFAULT_HELMET_PID] != 0)
            {
                Item@ helmet = cr.AddItem(cr.Param[ST_DEFAULT_HELMET_PID], 1);
                if(valid(helmet))
                    cr.MoveItem(helmet.Id, 1, SLOT_HEAD);
                // cr.SetFavoriteItem(SLOT_HEAD,cr.Param[ST_DEFAULT_HELMET_PID]);
            }

            #define _AddTrophy                                                                                               \
                # (__critter, __pid, __count, __buffer) { Item@__item = __critter.AddItem(__pid, __count); if(valid(__item)) \
                                                              __buffer.insertLast(__item);                                   \
                }

            if(valid(cr.GetMap()) && !cr.GetMap().GetLocation().IsInstancedQuest())
            {
                array<Item@> trophies;
                switch(cr.Param[ST_BASE_CRTYPE])
                {
                case CRTYPE_BRAHMIN:
                {
                    _AddTrophy(cr, PID_BRAHMIN_HIDE_TROPHY, 1, trophies);
                    break;
                }
                case CRTYPE_SCORPION:
                case CRTYPE_SCORPION_SMALL:
                    _AddTrophy(cr, PID_SCORPION_TAIL, 1, trophies);
                    break;
                case CRTYPE_GECKO_SMALL:
                    _AddTrophy(cr, PID_GECKO_PELT, 1, trophies);
                    break;
                case CRTYPE_GECKO:
                    _AddTrophy(cr, PID_GOLDEN_GECKO_PELT, 1, trophies);
                    break;
                case CRTYPE_GECKO_FIRE:
                    _AddTrophy(cr, PID_FIREGECKO_PELT, 1, trophies);
                    break;
                }
                for(uint t = 0, tlen = trophies.length(); t < tlen; t++)
                {
                    cr.MoveItem(trophies[t].Id, trophies[t].GetCount(), SLOT_TROPHY);
                }
            }

            if(cr.Param[ST_LEVEL] != 0)
                NpcProcessLevel(cr);
            // TODO: npcprocessbag ?
        }
        SetBloodType(cr);        // arrr
        SetBirthDate(cr);

        #ifdef __DEBUG__         // WIPENIGHT: starter item, dogtag
        // need to be after setting birth date/blood type
        if(cr.IsPlayer())
        {
            Item@ dogtag = DogTag(cr);
            if(valid(dogtag))
            {
                dogtag.Cost = 50;
                for(uint s = SLOT_HEAD; s >= SLOT_HAND1; s--)
                {
                    if(s == SLOT_ARMOR)
                        continue;
					if(s == SLOT_HAND1)
                        continue;
					if(s == SLOT_HAND2)
                        continue;

                    if(!valid(cr.GetItem(0, s)))
                    {
                        if(cr.MoveItem(dogtag.Id, dogtag.GetCount(), s))
                            break;
                    }
                }
            }
        }
        #endif

        #ifdef __DEBUG__         // WIPENIGHT: SPECIAL-based description
        int description1 = 0, description2 = 0;
        CritterDescription_Set(cr, description1, description2);
        if(description1 > 0 && description2 > 0)
        {
            WLog("special_description", "SPECIAL description : " + description1 + "," + description2);
            cr.ParamBase[ST_DESCRIPTION1] = description1;
            cr.ParamBase[ST_DESCRIPTION2] = description2;
        }
        #endif

        // selected NPCs can call it inside own init function
        if(cr.IsPlayer())
            CritterAgeInit(cr);
    }
    else     // not first time
    {
        CheckBirthDate(cr);

        // selected NPCs can call it inside own init function
        if(cr.IsPlayer())
            CritterAgeInit(cr);

        if(cr.Trait[TRAIT_FAST_SHOT] != 0)
            cr.ParamBase[MODE_NO_AIM] = 1;

        // Erase zero time events
        cr.EraseTimeEvents(0);

        // Current skin validation
        Item@ armor = cr.GetItem(0, SLOT_ARMOR);
        if(!valid(armor))           // Restore
        {
            uint crType = cr.Param[ST_BASE_CRTYPE];
            if(crType == 0)
                crType = (cr.Param[ST_GENDER] == GENDER_MALE ? CRTYPE_MALE_DEFAULT : CRTYPE_FEMALE_DEFAULT);
            if(cr.CrType != crType)
                cr.ChangeCrType(crType);
        }

        int[] slots = { SLOT_ARMOR, ITEM_PERK_ARMOR, SLOT_HEAD, ITEM_PERK_HELMET };
        for(uint s = 0, slen = slots.length(); s < slen; s += 2)
        {
            Item@ item = cr.GetItem(0, slots[s]);
            if(!valid(item) && cr.Param[slots[s + 1]] != 0)
                DisableItemPerk(cr, slots[s + 1]);
        }

        // group index/rank sync if player
        if(cr.IsPlayer())
        {
            UpdateGroupVars(cr);
        }
        // locations visibility
        if(cr.IsPlayer())
        {
            if(GetLvar(cr, LVAR_tent_id) != 0)
            {
                Location@ loc = GetLocation(GetLvar(cr, LVAR_tent_id));
                if(valid(loc))
                    cr.SetKnownLoc(true, loc.Id);
                Map@ map;
                if(valid(loc))
                    @map = loc.GetMapByIndex(0);
                if(valid(map))
                    map.SetData(MAP_DATA_LAST_ENTERED, ELAPSED_TIME);
            }
        }
        // Clear timeouts if too long (happens when saves got removed)
        for(uint i = TIMEOUT_BEGIN; i <= TIMEOUT_END; i++)
            if(i != TO_BATTLE && cr.Param[i] > MAXIMUM_TIMEOUT)
                cr.ParamBase[i] = ELAPSED_TIME;
		
		//druto
		//cr.ParamBase[ TO_GOD_MODE ] = __FullSecond;
				
        if(_IsTrueNpc(cr) && _GroupIndex(cr) > 0 && _GroupIndex(cr) < 1 && FACTION_MODE_PASSIVE < _GroupMode(cr) && _GroupMode(cr) < FACTION_MODE_NEVER && cr.GetScriptId() == 0)
        {
            // Scriptless guard; fill with default events
            if(IsTown(cr.GetMap()))
                cr.SetScript("generic_guard@_FactionGuard");
            else
                cr.SetScript("encounter_guard@critter_init");
        }

        // Rejoin group
        if(cr.IsPlayer() && cr.GetMapId() == 0)
        {
            array<Critter@> followers;
            uint            n = GetFollowers(cr, true, followers);
            for(uint i = 0; i < n; i++)
                if(followers[i].GetMapId() == 0)
                {
                    followers[i].LeaveGlobalGroup();
                    TransferToNPCMap(followers[i]);             // Can't transfer directly to group when on global
                    followers[i].TransitToGlobalGroup(cr.Id);
                    followers[i].ParamBase[FV_WM_IDLE] = 0;
                }
        }
    }
	
	if(IsCompanion(cr) && cr.Param[ST_DESCRIPTION2] == 7)
		cr.SetEvent(CRITTER_EVENT_BARTER, "_barter_logs");

}

bool _barter_logs(Critter & trader, Critter & player, bool attach, uint barterCount)
{
	uint16 second = 0;
    uint16 minute = 0;
    uint16 hour = 0;
    uint16 year = 0, month = 0, c = 0, day = 0, ms = 0;
    GetTime(year, month, c, day, hour, minute, second, ms);
	
			file f;
			f.open("logs/player_shop.txt", "a");
			f.writeString(day + "." + month + "." + year + " " + hour + ":" + minute + ":" + second + player.Name + " trading with player Shop ID: " + trader.Id + " with value of items: "  + barterCount);
			f.close();
	return true;

}

uint e_CritterInit_SendFactionData(array<int>@ data)
{
	Critter@ cr = GetCritter(data[0]);
	//if(valid(cr) && cr.IsPlayer())
	//{	
	//	cr.RunClientScript("client_faction_icons@ReceiveFactionData", GetFactionsCount(), 0, 0, null, null);
	//}
	return(0);
}
uint e_CritterInit_Broadcast(array<int>@ data)
{
    Critter@ cr = GetCritter(data[0]);
    if(valid(cr) && cr.IsPlayer())
        DumpBroadcastBuffer(cr);

    return(0);
}

uint e_CritterInit_OnlineStats(array<int>@ data)
{
    Critter@ cr = GetCritter(data[0]);
    if(valid(cr) && cr.IsPlayer())
        OnlineStats_SendSetup(cr);

    return(0);
}

uint e_CritterInit_XFire(array<int>@ data)
{
    Critter@ cr = GetCritter(data[0]);
    if(valid(cr) && cr.IsPlayer())
        XFireClient_Update(cr);

    return(0);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on critter exit from game.

void critter_finish(Critter& cr, bool toDelete)
{
	speedboost(cr);
    if(!(FLAG(_getMinigameFlags(cr.Param[ST_MINIGAME_DATA]), MINIGAME_PERSISTENT)))
        UnsetMinigame(cr, false);     // Minigames end along with gaming session IF the minigame team isn't persistent

    if(cr.IsPlayer())
    {
        if(_IsRealPlayer(cr))
            RemoveNotLegit(cr);
        RemoveOnlinePlayer(cr);
        WorldmapRemovePlayer(cr);
        RemoveWorkbenches(cr);
        RemoveAuthed(cr.Id);
        GMTrack(cr.Id, "TARGET logged out.");
		if(IsBaseControl(cr.GetMap()))
		{
			array<uint> logoutdata = { cr.Id , cr.GetMap().GetLocation().Id };
			CreateTimeEvent(AFTER(REAL_MINUTE(2)), "base_control@e_AntiLogOut", logoutdata, true);
		}
    }
    if(toDelete && cr.Param[ST_DEAD_BLOCKER_ID] != 0)
    {
        Item@ block = ::GetItem(cr.Param[ST_DEAD_BLOCKER_ID]);
        if(valid(block))
            DeleteItem(block);
        cr.ParamBase[ST_DEAD_BLOCKER_ID] = 0;
    }
    if(toDelete && !cr.IsPlayer())
    {
        {
        //  DeleteVars(cr.Id);
        RemoveNpcSchedule(cr);
        GMTrack(cr.Id, "TARGET deleted.");
		
		}
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////
// Call every __CritterIdleTick time.
#define REPUTATION_DECAY         (10.0f)        // 100 points per day
#define REPUTATION_DECAY_TIME    (REAL_DAY(1) / REPUTATION_DECAY)
void critter_idle(Critter& cr)
{
	//speedboost(cr);
	Map@ map = cr.GetMap();
	if(cr.IsDead() && cr.Param[TO_REPLICATION] == 0)
        ReplicateCritter(cr);
	if(!valid(cr))
		return;
	if(valid(map) && map.IsTurnBased())
		return;
	//speedboost2(cr);
    // Healing && !cr.GetMap().IsTurnBased()
        //druto
		if(cr.Param[ST_REGISTER_CHAR]==0)
		{
		cr.ParamBase[ST_START_ST] = cr.ParamBase[ST_STRENGTH] + cr.ParamBase[TRAIT_SKILLED];
		cr.ParamBase[ST_START_PE] = cr.ParamBase[ST_PERCEPTION] + cr.ParamBase[TRAIT_SKILLED];
		cr.ParamBase[ST_START_EN] = cr.ParamBase[ST_ENDURANCE] + cr.ParamBase[TRAIT_SKILLED];
		cr.ParamBase[ST_START_CH] = cr.ParamBase[ST_CHARISMA] + cr.ParamBase[TRAIT_SKILLED];
		cr.ParamBase[ST_START_IN] = cr.ParamBase[ST_INTELLECT] + cr.ParamBase[TRAIT_SKILLED];
		cr.ParamBase[ST_START_AG] = cr.ParamBase[ST_AGILITY] + cr.ParamBase[TRAIT_SKILLED];
		cr.ParamBase[ST_START_LK] = cr.ParamBase[ST_LUCK] + cr.ParamBase[TRAIT_SKILLED];
		
		cr.ParamBase[ST_REGISTER_CHAR] = 1;
		}
	float healingrate = cr.Param[ST_ENDURANCE]/16.7f;
	if(cr.ParamBase[PE_PRIEST]>0) healingrate += 0.01f * cr.Param[ST_ENDURANCE];
		if(cr.Param[TO_HEALING] <= 0)
		{
			if(!cr.IsDead() && cr.Param[MODE_NO_HEAL] == 0  && cr.Param[PE_CHOSEN] == 0 )
			{
		int heal = 0;
		heal += cr.Param[ST_HEALING_RATE] * (cr.Param[PE_PRIEST] > 0 ? 2 : 1);
		if(cr.Param[ST_POISONING_LEVEL] > 0)
			heal = heal * HEAL_REDUCE;
		heal = heal * healingrate;
		cr.ParamBase[ST_CURRENT_HP] += heal;
			}
                //cr.ParamBase[ST_CURRENT_HP] += MAX(cr.Param[ST_HEALING_RATE] * cr.Param[ST_MAX_LIFE] / 100, 3); 	//	old system
            if(cr.ParamBase[ST_CURRENT_HP] > cr.Param[ST_MAX_LIFE])
                cr.ParamBase[ST_CURRENT_HP] = cr.Param[ST_MAX_LIFE];
				
			int toheal = 25;
			if(cr.Param[TRAIT_FAST_METABOLISM] > 0)
				toheal -= 10;
			if(cr.Param[PE_FASTER_HEALING] > 0)
				toheal -= 5;
			if(cr.Param[PE_NEMEAN_ARMOR] > 2)
				toheal -= 5;
	
	Item@ realWeapon = _CritGetItemHand(cr);
	Item@ armorek = cr.GetItem(0, SLOT_ARMOR);
	//Log("28");
	if(valid(armorek) && armorek.Val3 == AP_LEG_REGEN  && valid(cr) && cr.IsPlayer()) toheal -= 4;
	if(valid(armorek) && armorek.Val4 == AP_LEG_REGEN && valid(cr)&& cr.IsPlayer()) toheal -= 4;
	if(valid(armorek) && armorek.Val5 == AP_LEG_REGEN && valid(cr)&& cr.IsPlayer()) toheal -= 4;
	if(valid(armorek) && armorek.Val6 == AP_LEG_REGEN && valid(cr)&& cr.IsPlayer()) toheal -= 4;
	if(valid(armorek) && armorek.Val7 == AP_LEG_REGEN && valid(cr)&& cr.IsPlayer()) toheal -= 4;
	if(valid(armorek) && armorek.Val8 == AP_LEG_REGEN && valid(cr)&& cr.IsPlayer()) toheal -= 4;
	if(valid(armorek) && armorek.Val2 == AP_LEG_REGEN && valid(cr)&& cr.IsPlayer()) toheal -= 4;
			
			_SetTimeout(cr, TO_HEALING, REAL_SECOND(toheal));		 
		}
	if(cr.IsPlayer())	
	{
	if(cr.Param[ST_CURRENT_AP] > cr.Param[ST_ACTION_POINTS] * 100)
		cr.ParamBase[ST_CURRENT_AP] = cr.Param[ST_ACTION_POINTS] * 100;
	cr.AddScoreVal(SCORE_RITCH, cr.Param[ST_EXPERIENCE]);
	}
	if(cr.GetProtoId()	== 1485 && cr.Param[ST_CURRENT_HP] > 10)
		cr.ParamBase[ST_CURRENT_HP] -= 5;
	if(cr.GetProtoId()	== 1485 && cr.Param[ST_CURRENT_HP] < 10)
		DeleteNpc(cr);

    // try to heal injuries
   if(cr.IsInjured() && cr.IsNpc() && IsHumanoid(cr) && cr.Param[TO_SK_DOCTOR] <= 0 && cr.Param[TO_BATTLE] == 0)
    {
        if(cr.Param[ST_INTELLECT] >= Random(1, 10))
        {
            array<NpcPlane@> planes;
            cr.GetPlanes(PLANE_DOCTOR_CRITTER, planes);
            if(planes.length() > 0)
                planes[0].IdentifierExt = cr.Id;
            else
                AddDoctorCritterPlane(cr, valid(cr.GetCurPlane()) ? cr.GetCurPlane().Priority + 5 : 0, cr, false);     // self
        }
    }
	if(IsCompanion(cr))
	cr.ParamBase[FV_LOYALITY] = 100;


    if(_IsOffline(cr) && cr.Param[ST_NPC_ROLE] > 1 && cr.IsPlayer() && cr.Param[MODE_NO_DROP] != 0 && cr.Param[EVENT_AFK] == 0)
		{
		cr.ParamBase[EVENT_AFK] += 1;
		CreateTimeEvent( __FullSecond + REAL_SECOND( 120 ), "e_checkafk", cr.Id, false );
		}

    if(!valid(cr))     // might have been deleted during replication
        return;

    if(cr.IsPlayer())
    {

        UpdateDrugs(cr);
    }
	array<Item@> items;
    uint         num = cr.GetItems(-1, items);
	 for(uint i = 0; i < num; i++)
	 {
	 if(items[i].GetType() == ITEM_TYPE_WEAPON && items[i].IsStackable())
		{
		items[i].Val0 = 0;
		items[i].Val1 = 0;
		items[i].Val2 = 0;
		items[i].Val3 = 0;
		items[i].Val4 = 0;
		items[i].Val5 = 0;
		items[i].Val6 = 0;
		items[i].Val7 = 0;
		items[i].Val8 = 0;
		items[i].Update();
		}
	 
	 }
	
}
uint e_checkafk(array<int>@ data)
{
    Critter@ cr = GetCritter(data[0]);
	if(_IsOffline(cr) && cr.Param[ST_NPC_ROLE] > 1 && cr.IsPlayer() && cr.Param[MODE_NO_DROP] != 0)
		{
		cr.ParamBase[EVENT_WARMING] += 1;
		return REAL_SECOND( 120 );
		}
	if(cr.Param[EVENT_WARMING] > 10 && cr.IsPlayer())
		AddBan(cr, cr.Id, 0, 24, "Autoban: War Event AFK");
		
	cr.ParamBase[EVENT_AFK] == 0;
	return 0;
	
}
void CritterTrophy(Critter& critter, Critter& looter)
{
    uint count = _CritCountItem(critter, PID_BRAHMIN_HIDE_TROPHY);
    if(count > 0)
    {
        _CritDeleteItem(critter, PID_BRAHMIN_HIDE_TROPHY, count);
        _CritAddItem(critter, PID_BRAHMIN_HIDE, count);
    }

    if(looter.Param[PE_GECKO_SKINNING] <= 0 &&
       (critter.CrType == CRTYPE_GECKO ||
        critter.CrType == CRTYPE_GECKO_SMALL ||
        critter.CrType == CRTYPE_GECKO_FIRE))
        return;

    bool geckoSkinning = false;
    array<Item@> trophies;
    count = critter.GetItems(SLOT_TROPHY, trophies);
    for(uint t = 0; t < count; t++)
    {
        if(!geckoSkinning &&
           (trophies[t].GetProtoId() == PID_GECKO_PELT ||
            trophies[t].GetProtoId() == PID_GOLDEN_GECKO_PELT ||
            trophies[t].GetProtoId() == PID_FIREGECKO_PELT))
        {
            geckoSkinning = true;
            looter.Say(SAY_NETMSG, "You have skinned the gecko.");
        }

        critter.MoveItem(trophies[t].Id, trophies[t].GetCount(), SLOT_INV);
    }
}

void TownCitizenKilled(Critter& critter, Critter@ killer)
{
    if(!valid(killer))
        return;
    uint mapid = critter.GetMapId();

    for(uint i = 1; i < GetTownCount() + 1; i++)
    {
        // DLog("mapid = " + mapid);
        // DLog("town mapid = " + GetTown(i).GetMapID());

        ITown@ town = GetTown(i);
        if(mapid == town.GetMapID())
        {
            uint factionId = town.GetControllingFaction();
            if(GetGroupIndex(killer) == factionId)
                town.ModifyInfluence(factionId, -0.05);
        }
    }

}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter dies.
// Killer can be null.
void death(Critter& cr, int p0, int p1, int p2)
{
    cr.ToDead(p0, null);
}

void critter_dead(Critter& cr, Critter@ killer)
{
    //if(!valid(cr) || !valid(killer))
		//return;
	//Log("1");
	//uint crGroup = _GroupIndex(cr);
    Map@ map = cr.GetMap();
	if(!valid(map) || !valid(cr))
		{
	//	Log("2");
		return;
		}
   // cr.ParamBase[TO_IMMUNITY_TIME] = MAX(uint(cr.Param[TO_IMMUNITY_TIME]), ELAPSED_TIME + SLEEPY_DEATH_IMMUNITY(cr));
	//Log("3");
	if(valid(cr) && cr.IsPlayer())
		{
	//	Log("4");
		RemoveWorkbenches(cr);   
		}

    if(cr.IsNpc() && valid(cr))
    {
		//Log("5");
        cr.ClearEnemyStack();
    }

    Item@ armor = cr.GetItem(0, SLOT_ARMOR);
    Item@ helmet = cr.GetItem(0, SLOT_HEAD);
    array<Item@> trophies;
    array<Item@> items;
	
    cr.GetItems(SLOT_TROPHY, trophies);
    cr.GetItems(SLOT_HAND1, items);
    cr.GetItems(SLOT_HAND2, items);
    cr.GetItems(SLOT_INV, items);
	cr.ParamBase[ST_SLOW] = 0;
	cr.ParamBase[ARMOR_WEAKER] = 0;
    bool isArmor = (valid(armor));
    bool isHelmet = (valid(helmet));
    bool isTrophy = (trophies.length() > 0);
	//Log("6");
    if((isArmor || isHelmet) &&
       (cr.Anim2Dead == ANIM2_DEAD_BURST ||  cr.Anim2Dead == ANIM2_DEAD_BLOODY_SINGLE || cr.Anim2Dead == ANIM2_DEAD_BLOODY_BURST ||
        cr.Anim2Dead == ANIM2_DEAD_PULSE || cr.Anim2Dead == ANIM2_DEAD_PULSE_DUST || cr.Anim2Dead == ANIM2_DEAD_LASER ||
        cr.Anim2Dead == ANIM2_DEAD_EXPLODE || cr.Anim2Dead == ANIM2_DEAD_FUSED || cr.Anim2Dead == ANIM2_DEAD_BURN || cr.Anim2Dead == ANIM2_DEAD_BURN_RUN)
       )
    {
		//Log("7");
        if(isArmor)
            WearItem(cr, armor,  ((MAX_DETERIORATION - armor.Deterioration) / 5) * ((IsT4Item(armor) && cr.IsPlayer()) ? GetGvar(GVAR_deterioration_T4) : 1)); // 23-07-2013 Cubik: złagodzone psucie sie pancerzy i helmow podczas smierci z 50% na 20% na każda smierc
        if(isHelmet)
            WearItem(cr, helmet, ((MAX_DETERIORATION - helmet.Deterioration) / 5) * ((IsT4Item(helmet) && cr.IsPlayer()) ? GetGvar(GVAR_deterioration_T4) : 1));
		//Log("8");
    }

    if(isArmor)
		{
        items.insertLast(armor);
		//Log("9");
		}
    if(isHelmet)
		{
        items.insertLast(helmet);
		//Log("10");
		}
	//Log("10A");
    // move all armor items to inventory of npc. delete it if no drop.
    if(cr.Param[ST_REPLICATION_TIME] < 0 && cr.IsNpc() && valid(killer))
    {
        for(uint i = 0, j = items.length(); i < j; i++)
            if(items[i].GetType() == ITEM_TYPE_ARMOR && items[i].CritSlot != SLOT_INV)
            {
				//Log("11");
                if(FLAG(items[i].Flags, ITEM_NO_STEAL) || FLAG(items[i].Flags, ITEM_NO_LOOT))
                    DeleteItem(items[i]);
                else
                    cr.MoveItem(items[i].Id, 1, SLOT_INV);
			//	Log("12");
            }
    }

//	Log("13");
    // 'loot-me'
    if(!_CritHasMode(cr, MODE_NO_LOOT) && valid(killer) && killer.Param[ST_NPC_ROLE] != ROLE_MOB_DYNAMIC)
    {
	//	Log("14");
        uint mappid = 0;
        if(valid(cr.GetMap()))
            mappid = cr.GetMap().GetProtoId();

        // encounters and certain towns
        if(IsEncounterMap(cr.GetMap()) || mappid == MAP_NCR || mappid == MAP_Junktown || mappid  == MAP_HubDowntown || mappid == MAP_SanFranChina)
        {
            DPlayerLog(cr, "Having loot here!");
            array<Critter@> crits;
            uint num = cr.GetCritters(true, FIND_LIFE | FIND_ONLY_NPC, crits);

            for(uint i = 0; i < num; i++)
            {
                // loot only players and other humanoids, and only when you're humanoid and you don't have loot plane already
                if((cr.IsPlayer() || IsHumanoid(cr)) && IsHumanoid(crits[i]) && crits[i].GetPlanes(PLANE_LOOT, null) == 0 && _IsTrueNpc(crits[i]))
                {
                    string scriptName = "";
                    if(crits[i].GetScriptId() > 0)
                        scriptName = GetScriptName(crits[i].GetScriptId());

                    //caravan guards will not loot
                    if(crits[i].GetScriptId() == 0 || !(scriptName == "caravans@_CaravanGuard" || scriptName == "caravans@_CaravanDriver"))
                    {
                        DPlayerLog(cr, "Critter " + crits[i].Id + " will loot me.");
                        AddWalkPlane(crits[i], 0, PLANE_LOOT, cr.Id, cr.HexX, cr.HexY, 6, true, 1);
                        break;
                    }
                }
            }
        }
		//Log("15");
    }
	//Log("16");
    if(valid(killer) && killer.IsPlayer())
    {
      //  CheckBountyHunters(cr, killer);
////	Log("17");
        if(cr.Param[ST_BODY_TYPE] == BT_CHILDREN)
        {
            uint8 current = killer.Param[KARMA_CHILDKILLER];
            if(current < 200)             // Check overflow
            {
                killer.ParamBase[KARMA_CHILDKILLER] = current + 1;
            }
        }
//	Log("18");
    }
	//w dol jest gdzies bug
	SetReplicationTime(cr);
//	Log("19");
	//cebula
    if(cr.IsNpc() && valid(killer) && valid(cr))
		{
        cr.DropPlanes();                // Delete all planes
	//	Log("20");
		}
//	Log("21");
    // additional stuff
    if(cr.IsNpc())
    {
		//Log("22");
        TownCitizenKilled(cr, killer);    // Check if its a town citizen, if so, add npc death penalty

        if(valid(map) && (cr.CrType == CRTYPE_BRAHMIN) && IsBase(map))
            cr.ParamBase[ST_REPLICATION_TIME] = REPLICATION_DELETE;

        if(valid(map) && IsCave(map))
            AddCrittersKilled();

        if(valid(map))
            ProcessDeath(map, cr, killer);    // reinforcements
		//Log("23");
    }
    else if(cr.IsPlayer())                                      // IsPlayer
    {
		//Log("24");
        if(valid(map))
        {
			//Log("24a");
            array<Critter@> followers;
            uint num = GetFollowers(cr, map, followers);
            for(uint i = 0; i < num; i++)
            {
				//Log("24b" + i);
                if(map.GetLocation().IsEncounter())
                {
                    if(!Flee(followers[i]))
                    {
                        followers[i].ParamBase[FV_MODE] = FOLLOWMODE_GUARD;
                        _CritUnsetMode(followers[i], MODE_GECK);
					//	Log("24c" + i);
                    }
                }
                else
                {
                    if(followers[i].GetMapId() != 0 && (IsTent(map) || IsBase(map) || !Flee(followers[i])))
                        followers[i].ParamBase[FV_MODE] = FOLLOWMODE_GUARD;
				//	Log("24d" + i);
                }
            }
		//	Log("24e");
            cr.SendMessage(MSG_PLAYER_KILLED, cr.Id, MESSAGE_TO_ALL_ON_MAP);

            if(IsCave(map))
                AddPlayerDeaths();
			//Log("24f");
            // detect spawnkill
            if(valid(killer))
            {
                int locPid = map.GetLocation().GetProtoId();
			//	Log("24g");
                if((locPid == LOCATION_Replication1  ||
                    locPid == LOCATION_Replication2  ||
                    locPid == LOCATION_Replication3  ||
                    locPid == LOCATION_Replication4  ||
                    locPid == LOCATION_Replication5  ||
                    locPid == LOCATION_Replication6  ||
                    locPid == LOCATION_Replication7  ||
                    locPid == LOCATION_Replication8)
                   &&
                   (cr.IsPlayer() && cr.GetAccess() == ACCESS_CLIENT  &&
                    killer.IsPlayer() && killer.GetAccess() == ACCESS_CLIENT)
                   )
                {
				//	Log("24h");
                    Broadcast_Message(
                        "Player " + killer.Name + "(" + killer.Id + ") killed " +
                        cr.Name + "(" + cr.Id + ") at respawn point (map " + map.Id + ")",
                        0, BROADCAST_FILTER_AUTHENTICATED, true
                        );
                }
            }
        }
	//Log("25");
	}
	//Log("26");	
      /* #ifdef __DEBUG__
        if(Random(0, 0) == 0 && cr.IsPlayer() && valid(killer))
        #endif
        #ifndef __DEBUG__
        if(Random(0, 1) == 1 && cr.IsPlayer() && valid(killer))
        #endif
        {
            CreateTimeEvent(AFTER(REAL_SECOND(Random(4, 8))), "e_DeathSpeech", cr.Id, false);
        }*/
  //  Log("27");
	//kiling spree
	
	
		if(cr.Param[BUFF_DEATHCLAW] > 0  && cr.IsPlayer() && valid(killer))
			cr.ParamBase[BUFF_DEATHCLAW] = 0;
		if(cr.Param[BUFF_ALIEN] > 0 && cr.IsPlayer() && valid(killer))
			cr.ParamBase[BUFF_ALIEN] = 0;
		if(cr.Param[BUFF_ROBOT] > 0 && cr.IsPlayer() && valid(killer))
			cr.ParamBase[BUFF_ROBOT] = 0;
		if(cr.Param[BUFF_SPIDER] > 0 && cr.IsPlayer() && valid(killer))
			cr.ParamBase[BUFF_SPIDER] = 0;
		if(cr.Param[BUFF_MELCHIOR] > 0 && cr.IsPlayer() && valid(killer))
			cr.ParamBase[BUFF_MELCHIOR] = 0;
		if(cr.Param[BUFF_RAIDER] > 0 && cr.IsPlayer() && valid(killer))
			cr.ParamBase[BUFF_RAIDER] = 0;
//	Log("34");
		int bt = cr.Param[ST_BODY_TYPE];
	//	Log("34CB");
	if(valid(killer))
	{
//	Log("34CB1");
	if(killer.Param[TRAIT_CHEM_RESISTANT] > 0 && (bt == BT_MEN || bt == BT_WOMEN || bt == BT_CHILDREN || bt == BT_GHOUL || bt == BT_SUPER_MUTANT))
		{
	//	Log("34CB2");
		addhumanparts(cr);
	//	Log("34CB3");
		}
	//Log("34CB4");
	}
//	Log("35");


}


void addhumanparts(Critter& item)
{
	//Log("34CD");
	if(!valid(item))
		return;
	//Log("34CF");
		switch(Random(1,6)) //tier IV
		{
		case 1: {item.AddItem(PID_BLOODPACK, 1); break;}
		case 2: {item.AddItem(PID_HEART, 1); break;}
		case 3: {item.AddItem(PID_LIVER, 1); break;}
		case 4: {item.AddItem(PID_BRAIN, 1); break;}
		case 5: {item.AddItem(PID_EAR, 1); break;}
		case 6: {item.AddItem(PID_EYE, 1); break;}
		}
	//Log("34CE");
}
uint e_DeathSpeech(array<uint>@ values)
{
    if(!valid(values) || values.length() < 1)
        return(0);

    Critter@ cr = GetCritter(values[0]);
    if(!valid(cr))
        return(0);

    string[] death =
    {
        "4",         // The darkness of the afterlife is all that awaits you now. May you find more peace in that world then you found in this one...
        "5",         // Not even the carrion eaters are interested in your radiated corpse.
        "6",         // Your life ends in the wasteland.
        "dth2",      // You have perished.
        "jdd1",      // You're dead. Again.
        "jdd3",      // Time to reload.
        "jdd4",      // Hoped you saved your game, cause you're dead.
        "jdd6"       // Boy, are you stupid. And dead.
        "7",         // The radiation has taken its toll. Your death was lingering and extremely painful. Your adventure is done.
    };

    PlaySound(cr, "sound\\speech\\narrator\\nar_" + death[Random(0, death.length() - 1)] + ".acm");

    return(0);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reswapned.
void critter_respawn(Critter& cr)
{
	speedboost(cr);

}
import bool IsCompanion(Critter& follower) from "follower";
uint e_check(array<uint>@ mobdata)
{
	Critter@ cr = GetCritter(mobdata[0]);
	if(cr.ParamBase[MODE_INVULNERABLE] == 0)
		return 0;
	if(cr.GetMap().GetProtoId() == MAP_VaultCityDowntown || cr.GetMap().GetProtoId() == MAP_NCR)
	{
	array<uint> filldata = { cr.Id };
	return CreateTimeEvent(AFTER(REAL_SECOND(100)), "e_check", filldata, false);
	}
	else
	{
	cr.ParamBase[ST_NPC_ROLE] = 0;
	cr.ParamBase[MODE_NO_LOOT] = 0;
	cr.ParamBase[MODE_NO_STEAL] = 0;
	cr.ParamBase[MODE_INVULNERABLE] = 0;
	cr.ParamBase[ST_DESCRIPTION2] = 0;
	return 0;
	}
}
uint e_preseason(array<uint>@ mobdata)
{
	GetCritter(mobdata[0]).TransitToMap(254, 0, false); 
	return 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
// Called when a critter enters a map.
void map_critter_in(Map& map, Critter& cr)
{
	speedboost(cr);
	SetWalkRunTimeForNpcs(map, 0);
    //RemoveArenaItems(cr);
	
    Location@ loc = map.GetLocation();
	array<uint> filldata = { cr.Id };
	array<Critter@> critters;
	if(map.GetLocation().IsTent() || map.GetLocation().IsBase())
		cr.ParamBase[ST_CLEAR_BONUS] = cr.Param[PE_PVE_CLEAR];
	else cr.ParamBase[ST_CLEAR_BONUS] = 0;
	uint n = map.GetCritters(0, FIND_ONLY_NPC | FIND_LIFE_AND_KO, critters);
	for(uint i = 0; i < n; i++)
	{
	
	if(valid(critters[i]) && !IsCompanion(critters[i]) && critters[i].Param[ST_DESCRIPTION2] < 6 && critters[i].Param[ST_DIALOG_ID] != 760 && critters[i].Param[ST_DIALOG_ID] != 741)
		{
		cr.ParamBase[ST_DESCRIPTION2] = critters[i].Param[ST_DESCRIPTION2];
		break;
		}
	}
	if(IsCompanion(cr) && cr.ParamBase[MODE_INVULNERABLE] > 0 && !cr.IsPlayer())
		CreateTimeEvent(AFTER(REAL_SECOND(10)), "e_check", filldata, false);
		
	if(cr.IsPlayer()) 
	{
		//cr.ParamBase[TO_GOD_MODE] = __FullSecond + REAL_SECOND( 3 );		// Old spawnkill protection by remek. TODO: change timeout name
		cr.ParamBase[ST_COMMAND]=0;
		cr.ParamBase[ST_COMMAND_X]=0;
		cr.ParamBase[ST_COMMAND_Y]=0;
	}
	if(cr.IsPlayer())
	if(map.GetLocation().IsTent() || map.GetLocation().IsBase())
		{
		uint16 year=0, month=0, day=0, dayofweek=0, hour=0, minute=0, second=0;
		GetGameTime( __FullSecond, year, month, day, dayofweek, hour, minute, second );
		file f;
		f.open("logs/baseenter.txt", "w");
		f.writeString(day + "." + month + " " + cr.Name + " Enter tent/base ID: " + map.Id);
		f.close();
		}
	
	
    if(cr.IsPlayer() || _IsFollower(cr))
    {

        if(loc.IsEncounter())
        {
            if(_IsRealPlayer(cr))
                TryStartEncounterMobWave(map);

            if(map.IsTurnBasedAvailability() && map.IsTurnBased() && cr.IsPlayer())
                cr.ParamBase[ST_CURRENT_AP] = 0;
        }
        else if(IsTent(map) || IsBase(map))
        {
            cr.ParamBase[TO_IMMUNITY_TIME] = MAX(uint(cr.Param[TO_IMMUNITY_TIME]), ELAPSED_TIME + SLEEPY_BASE_IMMUNITY(cr));
        }
    }

    if(cr.EventExtMapIn(map))
        return;
    if(cr.IsPlayer() && cr.GetAccess() < ACCESS_TESTER)
        map.SetData(MAP_DATA_LAST_ENTERED, ELAPSED_TIME);

    if(cr.IsPlayer() && IsFlaggedAsIllegal(cr))
        cr.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_FLAGGED_ENTERING_MAP);

    if(_IsFollower(cr))
    {
        if(IsTown(map))
            PutAwayItems(cr);
        cr.ParamBase[FV_WM_IDLE] = 0;
    }

    if(GetLvar(cr, LVAR_authed_char) == 0)
        SetSpectator(cr, false);

    if(_MapHasMode(map, MAP_MODE_SPECTATE_ENTER) && (GetLvar(cr, LVAR_authed_char) == 0))
        SetSpectator(cr, true);

    if(_IsTrueNpc(cr) && (_CritHasExtMode(cr, MODE_EXT_GUARD)))
    {
        cr.SetBagRefreshTime(1);
        int bagbug = cr.GetBagRefreshTime(); // this is need right now
    }
    else if(_IsTrueNpc(cr))
    {
        if(map.GetLocation().GetProtoId() == LOCATION_Sierra || map.GetLocation().GetProtoId() == LOCATION_TheGlow)
            cr.SetBagRefreshTime(60);
        else
            cr.SetBagRefreshTime(360);
        int bagbug = cr.GetBagRefreshTime(); // this is need right now
    }
    if(_IsTrueNpc(cr) && IsTown(cr.GetMap()))

    {
        uint bt = cr.Param[ST_BODY_TYPE];

        if(bt == BT_MEN || bt == BT_WOMEN || bt == BT_CHILDREN || bt == BT_GHOUL || bt == BT_SUPER_MUTANT)
        {
            cr.ParamBase[ST_REPLICATION_TIME] = REPLICATION_MINUTE(10);
        }
    }


    // update zone players info
    if(cr.IsPlayer())
    {
        WorldmapUpdatePlayer(cr);
        // tracking stuff - it updates track coords, but it should also
        // set location as known if tracked player still is idling in global
        // at that location
        // TrackLocation(cr);

        // Info about not legit location when entering map by tester+
        if(cr.GetAccess() > ACCESS_CLIENT && _IsNotLegit(map.GetData(MAP_DATA_SPAWNER)))
        {
            cr.Say(SAY_NETMSG, "Warning: This map is not legit (players can use not-legit items here).");
        }
    }

    // If critter is being tracked (by command, not tracking feature) and tracker is online
    GMTrack(cr.Id, "TARGET has entered map" + cr.GetMapId());

    if(GetLvar(cr, LVAR_authed_char) == 1 && cr.IsPlayer())
        LogAction(cr, GetCritterInfo(cr) + " has entered map " + cr.GetMapId());

    if(cr.IsPlayer())
    {
        GreetPlayer(cr, map);
        XFireClient_Update(cr);

        uint16 locPid = loc.GetProtoId();

        //	if(not LOCATION_IS_CITY(locPid)) return;
        //	GameVar@ lastCityVar = GetLocalVar(LVAR_last_city, cr.Id);
        //	if (lastCityVar is null) return;
        //	lastCityVar = locPid;

        if((locPid == LOCATION_Replication1  ||
            locPid == LOCATION_Replication2  ||
            locPid == LOCATION_Replication3  ||
            locPid == LOCATION_Replication4  ||
            locPid == LOCATION_Replication5  ||
            locPid == LOCATION_Replication6  ||
            locPid == LOCATION_Replication7  ||
            locPid == LOCATION_Replication8) &&
           cr.GetAccess() == ACCESS_CLIENT
           )
        {
           
        }
    }
	/*	
	if(cr.IsPlayer())
	{
		if(IsTent(map) || IsBase(map) || loc.IsMine())
			return;
		file fr;
		fr.open("logs/fr/" + loc.Id + "_" + cr.Id + ".txt", "w");
		fr.writeString(cr.GetUID(0) + " " + cr.GetUID(1) + " " + cr.GetUID(2) + " "  + cr.GetUID(3) + " " + cr.GetUID(4));
		fr.close();
	
	file frc; //files for saving uid to check fast relogs
	file r; //cheat file for bot
	array<Critter@> players;
	uint            pp = GetAllOnlinePlayers(players);
	string check_uid = "";
			
	for(uint i = 0; i < pp; i++)
		{
		if(cr.Id == players[i].Id)
			continue;
		
			
		frc.open("logs/fr/" + loc.Id + "_" + players[i].Id + ".txt", "r");
		frc.readString(frc.getSize(), check_uid);
		if(check_uid == "0 0 0 0 0")
			continue;
		if(check_uid == cr.GetUID(0) + " " + cr.GetUID(1) + " " + cr.GetUID(2) + " "  + cr.GetUID(3) + " " + cr.GetUID(4))
			{
			r.open("logs/cheats.txt", "w");
			r.writeString(cr.Name + " and " + players[i].Name + " used fast relog in location ID: " + loc.Id + " map Id: " + map.Id);
			r.close();
			}
		frc.close();
		}
	}*/
}

//druto
uint e_refresh_fov( uint[] @ values )
{
    Critter@ cr = GetCritter( values[ 0 ] );
    GameVar@ spawn_blocker = GetLocalVar( LVAR_spawn_blocker, values[ 0 ] );
    if( valid( spawn_blocker ) )
    {
        Item@ block = ::GetItem( spawn_blocker.GetValue() );
        if( valid( block ) )
            DeleteItem( block );

        spawn_blocker = 0;
    }
    if( valid( cr ) && cr.IsPlayer() )
    {
        //if( cr.Param[ TO_GOD_MODE ] == 0 )
       // {
        //    cr.RefreshVisible();
         //   return 0;
        //}
     //   Log( "Desync" );
        return 5;
    }
    return 0;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter out from map.
void map_critter_out(Map& map, Critter& cr)
{
	speedboost(cr);
    //RemoveArenaItems(cr);

    if(_IsNotLegit(map.GetData(MAP_DATA_SPAWNER)) && (cr.IsNpc() || _IsRealPlayer(cr)))
    {

        Map@ newMap = cr.GetMap();
        if(!valid(newMap) || _IsLegit(newMap.GetData(MAP_DATA_SPAWNER)))
        {
            RemoveNotLegit(cr);
        }
    }
	
	if(cr.IsPlayer())
	{
		cr.ParamBase[ST_COMMAND]=0;
		cr.ParamBase[ST_COMMAND_X]=0;
		cr.ParamBase[ST_COMMAND_Y]=0;
	}

    if(cr.EventExtMapOut(map))
        return;
    if(GetLvar(cr, LVAR_authed_char) == 0)
        SetSpectator(cr, false);

    RemoveWorkbenches(cr);   // there
    // If critter is being tracked (by command, not tracking feature) and tracker is online
    GMTrack(cr.Id, "TARGET has entered the worldmap");

    if(GetLvar(cr, LVAR_authed_char) == 1)
        LogAction(cr, GetCritterInfo(cr) + " has entered worldmap");

    // Move the followers
    if(!cr.IsDead())
    {
        array<Critter@> crits;
        int n = GetFollowers(cr, map, crits);
        for(int i = 0; i < n; i++)
        {
            if(!crits[i].IsLife())
            {
                string cond = crits[i].Cond == COND_KNOCKOUT ? "unconscious" : "dead";
                cr.Say(SAY_NETMSG, "You've left your " + cond + " follower " + GetLexem(crits[i], "$name") + " behind.");
                continue;
            }

            if(crits[i].Param[TO_BATTLE] > 0)
            {
                cr.Say(SAY_NETMSG, "You've left behind your follower " + GetLexem(crits[i], "$name") + ", who is still fighting.");
                continue;
            }

            if(!(crits[i].FollowerVar[FV_MODE] == FOLLOWMODE_FOLLOW || crits[i].FollowerVar[FV_MODE] == FOLLOWMODE_FOLLOW_CONTROL))
            {
                cr.Say(SAY_NETMSG, "You've left your follower " + GetLexem(crits[i], "$name") + " behind.");
                continue;
            }

            crits[i].ErasePlane(AI_PLANE_WALK, true);
            crits[i].ErasePlane(AI_PLANE_ATTACK, true);
            crits[i].ErasePlane(AI_PLANE_MISC, true);
            if(cr.GetMapId() != 0)
                crits[i].TransitToMap(cr.GetMapId(), cr.HexX, cr.HexY, crits[i].Dir);
            else
				{
				array<Critter@> critsOnGlobal = cr.GetGlobalGroup();
				if(critsOnGlobal.length<10) crits[i].TransitToGlobalGroup(cr.Id);
				}
        }
    }

    if(cr.IsPlayer())
    {
        XFireClient_Update(cr);
        if(cr.GetMapId() == 0)
        {
            ITown@ town = RetrieveTown(cr);
            if(valid(town))
                FlushInfluenceBuffer(cr, town);

            // 33% chance for lost encounter to be recycled (100% in debug)
            //
            Location@ loc = map.GetLocation();
            if(!loc.IsNotValid)
            {
                #ifdef __DEBUG__
                if(IsDisposableEncounter(loc))
                {
                    RecycleEncounter(loc);
                }
                #endif
                #ifndef __DEBUG__
                if(IsDisposableEncounter(loc) && Random(0, 2) == 0)
                {
                    RecycleEncounter(loc);
                }
                #endif
            }
	
		array<Critter@>@ players = WorldmapGetPlayers(ZONE_X(cr.WorldX), ZONE_Y(cr.WorldY));
		string characters;
		if(players.length()-1>0)
		{
		characters +="Other characters on worldmap in zone: ";
        for(uint i = 0, j = players.length(); i < j; i++)  if(cr.Id!=players[i].Id) characters+=""+(IsLexem(players[i], "$@")?GetLexem(players[i], "$@"):players[i].Name)+",";
		cr.Say(SAY_NETMSG, characters);
		}

        }
    }
	if(cr.IsPlayer())
		check_fast_relog(cr.Id,map.Id);
}

void check_fast_relog(uint cr_id, uint map_id)
{
	
	if(IsTent(GetMap(map_id)) || IsBase(GetMap(map_id)))
		return;
	array<uint> filldata = { cr_id, map_id };
		
	CreateTimeEvent(AFTER(REAL_SECOND(180)), "e_check_fr", filldata, false);
	
}

uint e_check_fr(array<uint>@ values)
{
	//Critter@ cr = GetCritter(values[0]);
	Map@ map = GetMap(values[1]);
	if(!valid(map))
		return 0;
	Location@ loc = map.GetLocation();
	array<Map@> maps;
	array<Critter@> players;
	if(!valid(loc))
		return 0;
	loc.GetMaps(maps);
	for(uint i = 0; i < maps.length(); i++)
		if(valid(maps[i]))
			maps[i].GetCritters(0, FIND_ALL | FIND_ONLY_PLAYERS , players);
			
	for(uint i = 0; i < players.length(); i++) //checking if character reenter
		if(valid(players[i]))
			if(values[0] == players[i].Id)
				return 0;
	
		file fr;
		fr.open("logs/fr/" + loc.Id + "_" + values[0] + ".txt", "w");
		fr.writeString(" ");
		fr.close();
		//only for testing

	return 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something player votes for another.
// Already checked valid positions and timeout.
void karma_voting(Critter& crFrom, Critter& crTo, bool valUp)
{
    // Players karma system (not used)
//	crTo.ParamBase[ST_PLAYER_KARMA]+=(valUp?int(5):-10);
//	crFrom.ParamBase[TO_KARMA_VOTING]=__FullMinute+__TimeMultiplier*4*60; // 4 hours

    // Good / Evil system
   // _SetTimeout(crFrom, TO_KARMA_VOTING, REAL_SECOND(3));     // Some small time to prevent bruteforce
    int crId = int(crTo.Id);
    // Find alredy added
   /* for(uint i = GOOD_EVIL_LIST_BEGIN; i <= GOOD_EVIL_LIST_END; i++)
    {
        int id = crFrom.GoodEvilList[i];
        if(id != 0)
        {
            bool isEvil = FLAG(id, 0x80000000);
            if(isEvil)
                id ^= 0x80000000;

            if(id == crId)
            {
                if((valUp && !isEvil) || (!valUp && isEvil))
                    return;                                   // Already added
                crFrom.GoodEvilListBase[i] = 0;               // Erase from list
                return;
            }
        }
    }
    // Add new record
    if(!valUp)
        crId |= 0x80000000;
    for(uint i = GOOD_EVIL_LIST_BEGIN; i <= GOOD_EVIL_LIST_END; i++)
    {
        int id = crFrom.GoodEvilList[i];
        if(id == 0)
        {
            crFrom.GoodEvilListBase[i] = crId;
            return;
        }
    }
    // All places busy, erase first 10
    for(uint i = GOOD_EVIL_LIST_BEGIN; i <= GOOD_EVIL_LIST_END - 10; i++)
        crFrom.GoodEvilListBase[i] = crFrom.GoodEvilListBase[i + 10];
    for(uint i = GOOD_EVIL_LIST_END - 9; i <= GOOD_EVIL_LIST_END; i++)
        crFrom.GoodEvilListBase[i] = 0;
    crFrom.GoodEvilListBase[GOOD_EVIL_LIST_END - 10] = crId;*/
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine cost of single item.
// To allow function set __CustomItemCost to true.
// Don't forgot specify this function in client script.
uint item_cost(Item& item, Critter& cr, Critter& npc, bool buy)
{
    return GetItemCost(item, cr, npc, buy);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on barter transaction.
// Return false to cancel transaction.
bool items_barter(array<Item@>& saleItems, array<uint>& saleItemsCount, array<Item@>& buyItems, array<uint>& buyItemsCount, Critter& player, Critter& npc)
{

    if(player.GetMapProtoId() == MAP_Arena)
    {
        player.Say(SAY_NETMSG, "You can't trade here.");
        return false;
    }
	//if(_IsFollower(npc))
    if(_IsTrader(npc))
    {
        // reputations
        int profit = 0;
        for(uint i = 0, j = saleItems.length(); i < j; i++)
        {
            profit += GetItemCostPlain(saleItems[i], player, npc) * saleItemsCount[i];
        }
        for(uint i = 0, j = buyItems.length(); i < j; i++)
        {
            profit -= GetItemCostPlain(buyItems[i], player, npc) * buyItemsCount[i];
        }
        ProcessProfitReputation(player, _GroupIndex(npc), profit);
        DPlayerLog(player, "Increased reputation " + _GroupIndex(npc) + " from profit of " + profit);

        // log
        string npcname = GetScriptName(npc.GetScriptId());
        for(uint i = 0, j = saleItems.length(); i < j; i++)
        {
            uint value = GetItemCost(saleItems[i], player, npc, true);
            // might aswell hide it under some layer
            dbLog("log_items_barter", "" + player.Id + "|" + npcname + "|" + saleItems[i].GetProtoId() + "|" + saleItemsCount[i] + "|" + value + "|1");
        }
        for(uint i = 0, j = buyItems.length(); i < j; i++)
        {
            uint value = GetItemCost(buyItems[i], player, npc, false);
            dbLog("log_items_barter", "" + player.Id + "|" + npcname + "|" + buyItems[i].GetProtoId() + "|" + buyItemsCount[i] + "|" + value + "|0");
        }
    }
    return true;
}
import void _weapon_perk(Item& item, bool firstTime) from "item_level";
import void _armor_perk(Item& item, bool firstTime) from "item_level";
// Call on something player craft some items.
void items_crafted(array<Item@>& items, array<uint>& itemsCount, array<Item@>& resources, Critter& crafter)
{
    uint8 multiplier = CLAMP(crafter.ParamBase[ST_FIXBOY_COUNTER], 1, 99);
    if(crafter.ParamBase[ST_FIXBOY_FIXALL] > 0)
        multiplier = CLAMP(crafter.ParamBase[ST_FIXBOY_FIXALL], 1, 100);

    array<uint16> recipePids;
    array<uint> recipeCnt;

    if(multiplier > 1)
    {
        GetItemRecipe(items[0].GetProtoId(), recipePids, recipeCnt);
    }

    for(uint8 m = 0; m < multiplier; ++m)
    {
        if(m > 0)
        {
            for(uint i = 0, j = items.length(); i < j; i++)
            {
                @items[i] = crafter.AddItem(items[i].GetProtoId(), itemsCount[i]);
            }
            for(uint ri = 0, rj = resources.length(); ri < rj; ri++) 
            {
			
                if((resources[ri].GetType()==ITEM_TYPE_WEAPON && !resources[ri].IsStackable()) || resources[ri].GetType()==ITEM_TYPE_ARMOR)
                {
                    uint16 oldPid = resources[ri].GetProtoId();
                    if(m > 1)
                    {
                        MoveItem(resources[ri], 1, crafter.GetMap(), 1, 1);
                        DeleteItem(resources[ri]);
                    }
                    Item@ res = crafter.GetItem(oldPid, -1);
                    if(valid(res))
                    {
                        @resources[ri] = res;
                    }
                }
            }
        }

        for(uint ii = 0, jj = items.length(); ii < jj; ii++)
        {
            // Unload weapons
            Item@ item = items[ii];
            if(item.GetType() == ITEM_TYPE_WEAPON && item.Proto.Weapon_MaxAmmoCount > 0)
            {
                item.AmmoCount = 0;
                item.Update();
            }
			string@ crafterName=""+crafter.Name;
			int craftexp = Random(1,2500) * multiplier;
			int craftmulti = crafter.Param[ST_LUCK] * 10 + crafter.Param[ST_INTELLECT] * 3 + crafter.Param[SK_CRAFTING];
			if(crafter.Param[PE_ALIEN]>0) craftmulti += crafter.Param[ST_INTELLECT] * 5;
			craftmulti /= 100;
			item.Val0 = craftexp * craftmulti;
                if(!item.IsStackable()) 
                    SetLexem(item, "$crafter", crafterName);
			ApplyTimeout(items, itemsCount, resources, crafter);
		if(item.GetType()==ITEM_TYPE_ARMOR && !item.IsStackable()) 
				{
                AddScore(crafter, SCORE_ARMORER, 1);
				_armor_perk(item, false);
				
				}
            else 
                if(item.GetType()==ITEM_TYPE_WEAPON && !item.IsStackable()) 
					{
                    AddScore(crafter, SCORE_GUNSMITH, 1);
					_weapon_perk(item,false);
					}
			if(IsT4Item(item))
				{
				AddScore(crafter, SCORE_T4_CRAFTER, 1);
			if(crafter.IsPlayer())
			{
			uint16 year=0, month=0, day=0, dayofweek=0, hour=0, minute=0, second=0;
			GetGameTime( __FullSecond, year, month, day, dayofweek, hour, minute, second );
			file f;
			f.open("logs/t4craft.txt", "w");
			f.writeString(day + "." + month + " " + crafter.Name + " crafted T4 " + item.Id);
			f.close();
			}
            
            
        }

        for(uint i = 0, j = resources.length(); i < j; i++)
        {
            // Unload weapons
            Item@ item = resources[i];
            if(item.GetType() == ITEM_TYPE_WEAPON && item.Proto.Weapon_MaxAmmoCount > 0)
            {
                if(item.AmmoCount > 0)
                {
                    crafter.AddItem(item.AmmoPid, item.AmmoCount);
                    item.AmmoCount = 0;
                    item.Update();
                }
            }
        }
        
        if(m > 0 && m == multiplier-1)
        {
            for(uint ri = 0, rj = resources.length(); ri < rj; ri++) 
            {
                if((resources[ri].GetType()==ITEM_TYPE_WEAPON && !resources[ri].IsStackable()) || resources[ri].GetType()==ITEM_TYPE_ARMOR)
                {
                    DeleteItem(resources[ri]);
                }
            }
        }

        if(m > 0)
        {    
            for(uint i = 0, j = recipePids.length(); i < j; i++)
            {
                Item@ res = crafter.GetItem(recipePids[i], -1);
                if(valid(res))
                {
                    if( !( (res.GetType()==ITEM_TYPE_WEAPON && !res.IsStackable()) || res.GetType()==ITEM_TYPE_ARMOR ) )
                    {
                        if(res.IsStackable())
                        {
                            if(res.GetCount() > recipeCnt[i])
                            {
                                res.SetCount(res.GetCount() - recipeCnt[i]);
                            }
                            else
                                DeleteItem(res);
                        }
                        else
                            DeleteItem(res);
                    }
                }
            }
        }
    }
}
}
/**
 * Checks if critter B is out of fov. (used in 'entering sneak mode' check)
 */
bool FovCheck(Critter& cr, Critter& opponent)
{
    uint16 cx = cr.HexX;
    uint16 cy = cr.HexY;
    uint16 ox = opponent.HexX;
    uint16 oy = opponent.HexY;

    uint16 dist = GetDistantion(cx, cy, ox, oy);
    uint16 range = 20 + 3 * cr.Param[ST_PERCEPTION] + 6 * cr.Param[PE_SHARPSHOOTER] + 11 * cr.Param[PE_TACTICAL] + 11 * cr.Param[PE_TACTICAL2] + cr.Param[PE_HUNTER]>0 ? cr.Param[ST_CRITICAL_CHANCE] : 0;
    if(dist > range)
        return false;

    // transform direction from critter A to critter B into "character coord-space"
    uint8 dir = GetDirection(cx, cy, ox, oy);
    dir = (dir > cr.Dir) ? dir - cr.Dir : cr.Dir - dir;

    uint16 nrange = range;
    // adjust distance based on fov
    if(dir == 0)                    // front
        nrange -= nrange * __LookDir0 / 100;
    else if(dir == 5 || dir == 1)   // frontsides
        nrange -= nrange * __LookDir1 / 100;
    else if(dir == 4 || dir == 2)   // backsides
        nrange -= nrange * __LookDir2 / 100;
    else                            // back
        nrange -= nrange * __LookDir3 / 100;

    if(dist > nrange)
        return false;
    else
        return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Levelup callback.

void player_levelup(Critter& player, uint skillIndex, uint skillUp, uint perkIndex)
{
    if(skillIndex >= SKILL_BEGIN && skillIndex <= SKILL_END)
    {
        for( ; skillUp != 0; skillUp--)
        {
			
            int skillVal = player.ParamBase[skillIndex];
			//Log("skillindex " + skillIndex + " skill val " + skillVal);
			//Log("cap " + player.ParamBase[SK_LEARNING_CAP] + " int " + player.Param[ST_INTELLECT]);
            if(skillVal >= MAX_SKILL_VAL)
                break;
			
			bool skillcap = false;
		switch(skillIndex)
		{
		case SK_SMALL_GUNS: if(player.ParamBase[SK_SMALL_GUNS] >= 300 + player.ParamBase[SK_SMALL_GUNS_CAP] + player.ParamBase[ST_INTELLECT]) skillcap = true; break;
		case SK_BIG_GUNS: if(player.ParamBase[SK_BIG_GUNS] >= 300 + player.ParamBase[SK_BIG_GUNS_CAP] + player.ParamBase[ST_INTELLECT]) skillcap = true; break;
		case SK_ENERGY_WEAPONS: if(player.ParamBase[SK_ENERGY_WEAPONS] >= 300 + player.ParamBase[SK_ENERGY_WEAPONS_CAP] + player.ParamBase[ST_INTELLECT]) skillcap = true; break;
		case SK_UNARMED: if(player.ParamBase[SK_UNARMED] >= 300 + player.ParamBase[SK_UNARMED_CAP] + player.ParamBase[ST_INTELLECT]) skillcap = true; break;
		case SK_THROWING: if(player.ParamBase[SK_THROWING] >= 300 + player.ParamBase[SK_THROWING_CAP] + player.ParamBase[ST_INTELLECT]) skillcap = true; break;
		case SK_SNEAK: if(player.ParamBase[SK_SNEAK] >= 300 + player.ParamBase[SK_SNEAK_CAP] + player.ParamBase[ST_INTELLECT]) skillcap = true; break;
		case SK_SPEECH: if(player.ParamBase[SK_SPEECH] >= 300 + player.ParamBase[SK_SPEECH_CAP] + player.ParamBase[ST_INTELLECT]) skillcap = true; break;
		case SK_LEARNING: if(player.ParamBase[SK_LEARNING] >= 200 + player.ParamBase[SK_LEARNING_CAP]) skillcap = true; break;
		case SK_FIRST_AID: if(player.ParamBase[SK_FIRST_AID] >= 200 + player.ParamBase[SK_FIRST_AID_CAP] + player.ParamBase[ST_INTELLECT]) skillcap = true; break;
		case SK_DOCTOR: if(player.ParamBase[SK_DOCTOR] >= 200 + player.ParamBase[SK_DOCTOR_CAP] + player.ParamBase[ST_INTELLECT]) skillcap = true; break;
		case SK_LOCKPICK: if(player.ParamBase[SK_LOCKPICK] >= 200 + player.ParamBase[SK_LOCKPICK_CAP] + player.ParamBase[ST_INTELLECT]) skillcap = true; break;
		case SK_ENGINE: if(player.ParamBase[SK_ENGINE] >= 200 + player.ParamBase[SK_ENGINE_CAP] + player.ParamBase[ST_INTELLECT]) skillcap = true; break;
		case SK_OUTDOORSMAN: if(player.ParamBase[SK_OUTDOORSMAN] >= 200 + player.ParamBase[SK_OUTDOORSMAN_CAP] + player.ParamBase[ST_INTELLECT]) skillcap = true; break;
		case SK_REPAIR: if(player.ParamBase[SK_REPAIR] >= 200 + player.ParamBase[SK_REPAIR_CAP] + player.ParamBase[ST_INTELLECT]) skillcap = true; break;
		case SK_SCIENCE: if(player.ParamBase[SK_SCIENCE] >= 200 + player.ParamBase[SK_SCIENCE_CAP] + player.ParamBase[ST_INTELLECT]) skillcap = true; break;
		case SK_TRAPS: if(player.ParamBase[SK_TRAPS] >= 150 + player.ParamBase[SK_TRAPS_CAP] + player.ParamBase[ST_INTELLECT]) skillcap = true; break;
		case SK_BARTER: if(player.ParamBase[SK_BARTER] >= 150 + player.ParamBase[SK_BARTER_CAP] + player.ParamBase[ST_INTELLECT]) skillcap = true; break;
		case SK_CRAFTING: if(player.ParamBase[SK_CRAFTING] >= 150 + player.ParamBase[SK_CRAFTING_CAP] + player.ParamBase[ST_INTELLECT] + player.Param[PE_ALIEN]*50) skillcap = true; break;
		}			
			if(skillcap) break;

            int needPoints = 1;
			
			if(skillVal > 650)
                needPoints = 3200;
			else if(skillVal > 625)
                needPoints = 1600;
			else if(skillVal > 600)
                needPoints = 800;
			else if(skillVal > 575)
                needPoints = 400;
			else if(skillVal > 550)
                needPoints = 200;
			else if(skillVal > 525)
                needPoints = 100;
			else if(skillVal > 500)
                needPoints = 50;
			else if(skillVal > 475)
                needPoints = 40;
			else if(skillVal > 450)
                needPoints = 30;
			else if(skillVal > 425)
                needPoints = 25;
			else if(skillVal > 400)
                needPoints = 20;
			else if(skillVal > 375)
                needPoints = 15;
			else if(skillVal > 350)
                needPoints = 10;
			else if(skillVal > 325)
                needPoints = 9;
			else if(skillVal > 300)
                needPoints = 8;
			else if(skillVal > 275)
                needPoints = 7;
            else if(skillVal > 250)
                needPoints = 6;
            else if(skillVal > 225)
                needPoints = 5;
            else if(skillVal > 200)
                needPoints = 4;
            else if(skillVal > 175)
                needPoints = 3;
            else if(skillVal > 150)
                needPoints = 2;

            if(player.ParamBase[ST_UNSPENT_SKILL_POINTS] < needPoints)
                break;

            skillVal++;
			
						  
//            if(_CritIsTagSkill(player, skillIndex) && skillVal < MAX_SKILL_VAL && !skillCap)
         //       skillVal++;
            player.ParamBase[skillIndex] = skillVal;
            player.ParamBase[ST_UNSPENT_SKILL_POINTS] -= needPoints;
        }
    }
    else if(perkIndex >= PERK_BEGIN && perkIndex <= PERK_END)
    {
        if(PerkCheck(player, perkIndex, false))
        {
            if(player.IsPlayer())
                FLog(LOG_PERKS_PICKED, player.Name+"("+player.Id+") perk: "+perkIndex+" at level "+player.Param[ST_LEVEL]);
            player.ParamBase[perkIndex]++;
            player.ParamBase[ST_UNSPENT_PERKS]--;
        }
    }
	//speedboost(player);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Turn based callbacks.
// Called on every round begin, return false to disable turn-based

#define BURN_DAMAGE			   ( Random(10,20) )
#define FIRE_STEP_ON		   ( Random(10,20) )
/*
array<uint> flags =
        {
		//0                 1             bos,         enc               unity           New California Republic, Vault City      raiders             9
		PID_FLAG_NEUTRAL, PID_FLAG_NEUTRAL, PID_FLAG_BOS, PID_FLAG_ENCLAVE, PID_FLAG_PINK,  PID_FLAG_ORANGE,   PID_FLAG_VC, PID_FLAG_PIRATE, PID_FLAG_NEUTRAL
		//10-43
		PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,
		PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,
		PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,
		PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_HEAL, //dev team
		//players flags
		//45-49
		PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN,
		//50-59
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//60-79
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//npcs
		PID_FLAG_NEUTRAL, PID_FLAG_NEUTRAL, PID_FLAG_NEUTRAL, PID_FLAG_NEUTRAL, PID_FLAG_NEUTRAL, PID_FLAG_NEUTRAL, PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL, PID_FLAG_NEUTRAL,
		PID_FLAG_NEUTRAL, PID_FLAG_NEUTRAL, PID_FLAG_NEUTRAL, PID_FLAG_NEUTRAL, PID_FLAG_NEUTRAL, PID_FLAG_NEUTRAL, PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL,PID_FLAG_NEUTRAL, PID_FLAG_NEUTRAL,
		//100+
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//110
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//120
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//130
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//140
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//150
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//160
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//170
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//180
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//190
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//200
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//210
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//220
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//230
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//240
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//250
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//260
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//270
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK,
		//280
		PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_YELLOW, PID_FLAG_GREY, PID_FLAG_RED, PID_FLAG_PINK, PID_FLAG_GREEN, PID_FLAG_VC, PID_FLAG_ORANGE, PID_FLAG_DARK
		};*/
		

void turn_based_begin(Map& map)
{
	SetWalkRunTimeForNpcs(map, 30);
    array<Critter@> critters;
    array<Critter@> players;
    uint count = map.GetCritters(0, FIND_LIFE_AND_KO, critters);
    uint playersCount = map.GetCritters(0, FIND_LIFE_AND_KO, players);
	for(uint a = 0; a < players.length(); a++)
	{
		speedboost(players[a]);
		if(!critters[a].IsPlayer() && critters[a].Param[ST_CURRENT_HP] < 1)
			critters[a].ToDead(100, null);
	}
	

    // Try end battle
    if(map.TurnBasedRound > 0)
    {
        array<uint> crittersIds;
        map.GetTurnBasedSequence(crittersIds);

        bool continueBattle = false;
        if(crittersIds.length() >= 2)
        {
            for(uint i = 0, j = crittersIds.length(); i < j; i++)
            {
                Critter@ cr = ::GetCritter(crittersIds[i]);
				if(valid(cr) && cr.Param[ST_BURN_STACK] >= 1)
				{
					for (uint b = 0; b < 2; b++) //2 - is count of damage after every round turn
					{
					InjureCritter(cr,FIRE_STEP_ON,DAMAGE_FIRE,0,cr.Param[ST_BURN_LAST_ENEMY_ID]);
					cr.ParamBase[ST_BURN_STACK]--;
					}
				}
                if(!(!valid(cr) || cr.IsDead() ||
                     (cr.IsNpc() && cr.GetPlanes(AI_PLANE_ATTACK, null) == 0) ||
                     (cr.IsPlayer() && (cr.Param[MODE_END_COMBAT] != 0))))
                {
                    continueBattle = true;
                    break;
                }
            }
        }

        if(!continueBattle)
            map.EndTurnBased();
    }
}

// Call on end turn-based battle
void turn_based_end(Map& map)
{
	SetWalkRunTimeForNpcs(map, 0);
    array<Critter@> critters;
    uint count = map.GetCritters(0, FIND_LIFE_AND_KO, critters);
}

void SetWalkRunTimeForNpcs(Map& map, uint time)
{
	Critter@[] critters;
	map.GetCritters(0, FIND_ONLY_NPC | FIND_LIFE_AND_KO, critters);


	for (uint i = 0; i < critters.length(); i++)
	{
		if(valid(critters[i]))
		{
			critters[i].ParamBase[ST_WALK_TIME] = time;
			//critters[i].ParamBase[ST_RUN_TIME] = time;
		}
	}
}


// Call on every begin and end turn
void turn_based_process(Map& map, Critter& cr, bool beginTurn)
{
    if(beginTurn)
    {
        if(cr.Param[TO_BATTLE] == 0)
            cr.ParamBase[TO_BATTLE] = 100000000; // setting to initial value (TB_BATTLE_TIMEOUT in fonline.h)

        if(!_IsTrueNpc(cr))
            SetLvar(cr, LVAR_tb_turn_time, ELAPSED_TIME);
		if(cr.Param[PE_CHOSEN] == 0)
		{
		int heal = 0;
		heal += cr.Param[ST_HEALING_RATE] * (cr.Param[PE_PRIEST] > 0 ? 2 : 1);
		if(cr.Param[ST_POISONING_LEVEL] > 0)
			heal = heal * HEAL_REDUCE;
		cr.ParamBase[ST_CURRENT_HP] += heal;
		}
        if(cr.ParamBase[ST_CURRENT_HP] > cr.Param[ST_MAX_LIFE])
           cr.ParamBase[ST_CURRENT_HP] = cr.Param[ST_MAX_LIFE];
        cr.ParamBase[ST_MOVE_AP] = cr.Param[ST_MAX_MOVE_AP];
        cr.ParamBase[ST_TURN_BASED_AC] = 0;
        cr.ParamBase[ST_TURN_BASED_HEX] = MAKELONG(cr.HexX, cr.HexY);
        if(map.TurnBasedRound > 0)
            PlaySound(cr, "icombat1.acm");
		
        // Offline and non-real players (staff) skip turns in TB
        if(cr.IsPlayer())
        {
            if(_IsOffline(cr) || !_IsRealPlayer(cr))
            {
                _EndTurn(cr);
            }
        }
    }
    else
    {
        uint dist = GetDistantion(cr.HexX, cr.HexY, LOWORD(cr.Param[ST_TURN_BASED_HEX]), HIWORD(cr.Param[ST_TURN_BASED_HEX]));
        cr.ParamBase[ST_TURN_BASED_AC] = 2 * (dist + cr.Param[ST_CURRENT_AP]) >= cr.Param[ST_ACTION_POINTS] ? 1 : 0;
        if(cr.Param[ST_TURN_BASED_AC] < 0)
            cr.ParamBase[ST_TURN_BASED_AC] = 0;
        cr.ParamBase[ST_MOVE_AP] = 0;
        PlaySound(cr, "icombat2.acm");
    }
}

// Call when need generate turns sequence
void turn_based_sequence(Map& map, array<Critter@>& critters, Critter@ firstTurnCrit)
{
    // Check first turn critter
    if(valid(firstTurnCrit) && (firstTurnCrit.IsDead() || firstTurnCrit.Param[ST_CURRENT_AP] <= 0))
        @firstTurnCrit = null;

    // Collect critters
    array<SequenceCritter> sequenceCritters;
    for(uint i = 0, j = critters.length(); i < j; i++)
    {
        Critter@ cr = critters[i];
        if(valid(firstTurnCrit) && firstTurnCrit.Id == cr.Id)
            continue;
        if(cr.IsDead())
            continue;
        sequenceCritters.resize(sequenceCritters.length() + 1);
        @sequenceCritters.last().critter = cr;
    }

    // Sort sequence, see SequenceCritter::opCmp below
    SequenceCritterRandom = Random(0, 1);
    sequenceCritters.sortDesc();

    // Fill result
    critters.resize(0);
    if(valid(firstTurnCrit))
        critters.insertLast(firstTurnCrit);
    for(uint i = 0, j = sequenceCritters.length(); i < j; i++)
        critters.insertLast(sequenceCritters[i].critter);
}

// Sequence sorter for turn_based_sequence
int   SequenceCritterRandom = 0;
class SequenceCritter
{
    Critter@ critter;
    int opCmp(SequenceCritter& in other)
    {
        bool     result;
        Critter@ cr1 = critter;
        Critter@ cr2 = other.critter;
        int      seq1 = cr1.Param[ST_SEQUENCE];
        int      seq2 = cr2.Param[ST_SEQUENCE];
        if(seq1 == seq2)
        {
            int ag1 = cr1.Param[ST_AGILITY];
            int ag2 = cr2.Param[ST_AGILITY];
            if(ag1 == ag2)
            {
                int lk1 = cr1.Param[ST_LUCK];
                int lk2 = cr2.Param[ST_LUCK];
                if(lk1 == lk2)
                {
                    if(SequenceCritterRandom == 0)
                        result = cr1.Id > cr2.Id;
                    else
                        result = cr1.Id < cr2.Id;
                }
                else
                    result = lk1 > lk2;
            }
            else
                result = ag1 > ag2;
        }
        else
            result = seq1 > seq2;
        return result ? int(1) : int(-1);
    }
};

// Call on world saving
// Range of currentIndex: 1..9999
void world_save(uint currentIndex, array<uint>& deleteIndexes)
{
    SaveAlertMaps();

   // Log("Saving faction data...");
    for(uint i = 0; i < FACTION_COUNT; i++)
    {
        if(FactionExists(i))
        {
            /*Faction@ f = GetFaction(i);
               if(!valid(f))
               Log("ERROR: FactionType.dll failure, id: " + i);
               else
               f.Save(); // Save params*/
            SaveFactionData(i);
        }
    }
   // Log("Faction data saved.");
   // Log("Saving TC data...");
    for(uint i = 0; i < TOWN_COUNT; i++)
    {
        for(uint i = 1; i <= TOWN_COUNT; i++)
        {
            ITown@ town = GetTown(i);
            town.SaveData();
        }
    }
   // Log("TC data saved.");
   // Log("Saving bank data...");
    SaveBankData();
   // Log("Bank data saved.");
   // Log("Saving brahmin pen data...");
    SaveBrahminPenData();
   // Log("Saved brahmin pen data.");
    SaveEventSpawns();
   // Log("Saving car price data...");
    SaveCarPriceData();
   // Log("Saved car price data.");

  //  Log("Saving npc schedules");
    SaveNpcSchedules();
  //  Log("Saved npc schedules");

   // Log("Saving companion data...");
    SaveCompanionData();
   // Log("Saved companion data");

    // Keep only current and four last saves
    if(currentIndex == 1)
    {
        deleteIndexes.resize(5);
        for(uint i = 0; i < 5; i++)
            deleteIndexes[i] = 999999 - i;
    }
    else if(currentIndex > 4 && ((currentIndex % 24) != 0))
    {
        deleteIndexes.resize(1);
        deleteIndexes[0] = currentIndex - 5;
    }
  //  Log("Saving weather data...");
    SaveWeather();
  //  Log("Saved weather data.");
	//CreateTimeEvent(AFTER(0), "base_control@e_Save", false);
	SaveBaseData();
  //  Log("Saved Base Control data.");
	SaveBannedCharcters();
	//Log("Saved list of bans data.");

    FLog(LOG_WMLOCATIONS, "SAVE");
    // SaveCheats();
}

// Call on player try register
// Return true to allow, false to disallow
bool player_registration(uint ip, string& name, uint& textMsg, uint& strNum)
{
    // check for staff members
    LoadConfig("config/GetAccess.cfg");

    string@ reserved = GetConfigValue("config/GetAccess.cfg", name, "Reserved", false);

    if(!valid(reserved))         // dedicated to RJ
    {
        IConfigFile@ config = GetConfigFile("config/GetAccess.cfg");
        if(valid(config))
        {
            array<string> sections;
            config.GetSections(sections);
            if(sections.length() > 0)
            {
                for(uint s = 0; s < sections.length(); s++)
                {
                    string@ alias = GetConfigValue("config/GetAccess.cfg", sections[s], "Nickname", false);
                    if(valid(alias) && strlwr(name) == strlwr(alias))
                    {
                        @reserved = GetConfigValue("config/GetAccess.cfg", sections[s], "Reserved", false);
                        break;
                    }
                }
            }
        }
    }

    if(valid(reserved))
    {
        if(reserved == "true")
        {
            // kick client
            textMsg = TEXTMSG_GAME;
            strNum  = 1049;
            return(false);
        }
        else
        {
            // allow client, reserve again
            IConfigSection@ section = GetConfigSection("config/GetAccess.cfg", name, false);
            SetConfigValue("config/GetAccess.cfg", section.GetName(), "Reserved", "true");
            SaveConfig("config/GetAccess.cfg");
            return(true);
        }
    }
    else
    {
        // check player-reserved names
        LoadConfig("config/ReservedNicknames.cfg");

        @reserved = GetConfigValue("config/ReservedNicknames.cfg", "Reserved", name, false);

        if(valid(reserved) && reserved == "1")
        {
            // kick client
            textMsg = TEXTMSG_GAME;
            strNum  = 1050;
            return(false);
        }
    }
	
	uint nameError = CheckPlayerName( name );
    if( nameError != 0 )
    {
        textMsg = TEXTMSG_GAME;
        strNum = nameError;
        return false;
    }
    return(true);
}

// Call on player try login
// Return true to allow, false to disallow
bool player_login(uint ip, string& name, uint id, uint& textMsg, uint& strNum)
{
	CreateTimeEvent(AFTER(REAL_SECOND(Random(1,2))), "e_checkUID", id, false);
    // Check ban list... Look for player's character...
	for(uint i = 0; i < BannedIDs.length(); i += 2)
	{
		if(BannedIDs[i] == id)
		{
			//player.Say(SAY_NETMSG, "You are banned by " + BannedReason[i] + " with reason: " + BannedReason[i + 1]);
			textMsg = TEXTMSG_GAME;
			strNum = 1034;
			return false;
		}
	}
	
	// Check ban list... Look for player's IP address...
	for(uint i = 1; (i + 1) < BannedIDs.length(); i += 2)
	{
		if(BannedIDs[i] == ip)
		{
			//player.Say(SAY_NETMSG, "Your IP is banned by " + BannedReason[i - 1] + " with reason: " + BannedReason[i]);
			textMsg = TEXTMSG_GAME;
			strNum = 1043;
			return false;
		}
	}
	
	Critter@ player = GetCritter(id);
    if(valid(player))
    {
    //PERMABANS
	array<uint> permabanned = { 3523, 1760, 3375};	
	
		// Player is online and the IP is the same, try disconnect the player to solve "character already in game"
        if(_IsOnline(player) && player.GetIp() == ip)
        {
            player.Say(SAY_NETMSG, "Another connection from the same IP incoming, logging off.");
            player.Disconnect();
            textMsg = TEXTMSG_TEXT;
            strNum = 400;
            return false;
        }
        else
        {
            UpdateFactionsInfo(player);
        }

        if(_IsOffline(player))
            CreateTimeEvent(AFTER(REAL_SECOND(5)), "e_CritterInit_Broadcast", player.Id, false);
		CreateTimeEvent( __FullSecond + REAL_SECOND( 3 ), "e_CritterInit_SendFactionData", player.Id, false );
    }
    uint16 year=0, month=0, day=0, dayofweek=0, hour=0, minute=0, second=0;
    GetGameTime( __FullSecond, year, month, day, dayofweek, hour, minute, second );
    FLog(LOG_LOGIN, GetTimeString(__FullSecond) + " " + name + " " +  IntToIp(ip));
	
    
	// 
    return true;
}

uint e_checkUID(array<uint>@ values)
{
	Critter@ player = GetCritter(values[0]);
	if(!valid(player))
		return 0;

	FLog(LOG_LOGIN, player.Name + " uids: " + player.GetUID(0) + " " + player.GetUID(1) + " " + player.GetUID(2) + " "  + player.GetUID(3) + " " + player.GetUID(4));
	//umbra permban	
	if(player.GetUID(0) == -1695384756 && player.GetUID(1) == 1963811384 && player.GetUID(2) == 538997566  && player.GetUID(3) == -2147350824 && player.GetUID(4) == 36866101)
		AddBan(player, player.Id, 1, 999999, "Umbra permban");
	return 0;
}
uint8 access_level(string& access)
{
    if(strlwr(access) == "admin")
        return(ACCESS_ADMIN);
    else if(strlwr(access) == "moder")
        return(ACCESS_MODER);
    else if(strlwr(access) == "tester")
        return(ACCESS_TESTER);
    else
        return(ACCESS_CLIENT);
}

string access_level(uint8& access)
{
    switch(access)
    {
    case ACCESS_ADMIN:
        return("admin");
    case ACCESS_MODER:
        return("moder");
    case ACCESS_TESTER:
        return("tester");
    default:
        return("client");
    }
    return("client");
}

// Call on player try change access
// Return true to allow, false to disallow
bool player_getaccess(Critter& player, int access, string& password)
{
    FLog(LOG_GETACCESS, "Access changed for player " + GetCritterInfo(player) + ", from " + GetAuthString(player.GetAccess()) + " to " + GetAuthString(access) + ".");
	player.ParamBase[ST_NPC_BOSS] = access;
    SetLvar(player, LVAR_authed_char, 1);
    player.RunClientScript("client_messages@_Listen", 0, 0, 0, null, null);
    SetCritterEvents(player);
    Broadcast_CheckRequestHelpBuffer(player);
    return true;
}

// Call on player trying to use a command
// Return true to allow, false to disallow
bool player_allowcommand(Critter@ cr, string@ adminPanel, uint8 command)
{
    if(valid(adminPanel))
        return true;

    switch(command)
    {
    /* disabled commands
            when adding another command, don't forget to
            add it to client-side check (client_messages@out_message)
     */
    case COMMAND_ADDITEM:
    case COMMAND_ADDITEM_SELF:
    case COMMAND_ADDLOCATION:
    case COMMAND_ADDNPC:
    case COMMAND_CRASH:
    case COMMAND_PARAM:
     //   Log("WARN: " + cr.Name + "(" + cr.Id + ") tried to use disabled command (" + command + ")");
        break;

    /* overwritten commands
            hardcoded commands moved to scripts, client should never send them
     */
    case COMMAND_MYINFO:
    //    Log("WARN: " + cr.Name + "(" + cr.Id + ") tried to use overwritten command (" + command + ")");
        break;

    // ACCESS_CLIENT
    case COMMAND_CHANGE_PASSWORD:
    case COMMAND_DELETE_ACCOUNT:
        if(cr.GetAccess() == ACCESS_CLIENT && cr.Param[PE_AWARENESS] == 42)
        {
            cr.Say(SAY_NETMSG, "You are not allowed to " + (command == COMMAND_CHANGE_PASSWORD ? "change password of" : "delete") + " this character.");
            return(false);
        }
        
        return(true);

    case COMMAND_EXIT:
    case COMMAND_GETACCESS:
        return(true);

    // ACCESS_TESTER
    case COMMAND_DROP_UID:
    case COMMAND_GAMEINFO:
    case COMMAND_TOGLOBAL:
        if(cr.GetAccess() >= ACCESS_TESTER)
            return(true);
        break;

    // ACCESS_MODER
    case COMMAND_BAN:
    case COMMAND_CHECKVAR:
    case COMMAND_CRITID:
    case COMMAND_DISCONCRIT:
    case COMMAND_KILLCRIT:
    case COMMAND_LOG:
    case COMMAND_MOVECRIT:
    case COMMAND_RESPAWN:
    case COMMAND_SETVAR:
	case COMMAND_REGENMAP:
	case COMMAND_RUNSCRIPT:
        if(cr.GetAccess() >= ACCESS_MODER)
            return(true);
        break;

    // ACCESS_ADMIN
    case COMMAND_LOADDIALOG:
    case COMMAND_LOADLOCATION:
    case COMMAND_LOADMAP:
    case COMMAND_LOADSCRIPT:
    case COMMAND_RELOAD_CLIENT_SCRIPTS:
    case COMMAND_RELOADAI:
    case COMMAND_RELOADDIALOGS:
    case COMMAND_RELOADLOCATIONS:
    case COMMAND_RELOADMAPS:
    case COMMAND_RELOADSCRIPTS:
    case COMMAND_RELOADTEXTS:
    case COMMAND_SETTIME:
        if(cr.GetAccess() >= ACCESS_ADMIN)
            return(true);
        break;

    default:
     //   Log("WARN: " + cr.Name + "(" + cr.Id + ") tried to use unknown command (" + command + ")");
        break;
    }

    cr.Say(SAY_NETMSG, "Unknown command.");
    return(false);
}

void server_log(string& message)
{
    // placeholder
};

void CheckScripts(Critter& cr, int p0, int p1, int p2)
{
    array<Item@> items;
    uint num = cr.GetMap().GetItems(0, items);
    for(uint i = 0; i < num; i++)
    {
        uint16 hx, hy;
        hx = hy = 0;
        Map@ map = items[i].GetMapPosition(hx, hy);
        uint id = items[i].GetScriptId();
        map.SetText(hx, hy, 0, "" + id + " : " + GetScriptName(id));
    }
    array<Critter@> crs;
    num = cr.GetMap().GetCritters(0, FIND_ALL | FIND_ONLY_NPC, crs);

    for(uint i = 0; i < num; i++)
    {
        uint id = cr.GetScriptId();
        crs[i].Say(SAY_NORM, "" + id + " : " + GetScriptName(id));
    }
}

void CheckPids(Critter& cr, int p0, int p1, int p2)
{
    array<Critter@> critters;
    uint num = cr.GetMap().GetCritters(0, FIND_ALL | FIND_ONLY_NPC, critters);
    for(uint i = 0; i < num; i++)
        critters[i].Say(SAY_NORM, "PID: " + critters[i].GetProtoId());
}

void CheckItems(Critter& cr, int p0, int p1, int p2)
{
    Item@ it = cr.AddItem(1, 1);
    cr.Say(SAY_NETMSG, "" + it.Id);
}

void reprohang(Critter& cr, int p0, int p1, int p2)
{
    cr.ParamBase[305] = 1 << 32;
    cr.Say(SAY_NETMSG, "Done");
    cr.Say(SAY_NETMSG, "Param's value: " + cr.ParamBase[305]);
}

void spawnjunk(Critter& cr, int, int, int)
{
    Item@ junk = cr.GetMap().AddItem(cr.HexX, cr.HexY, PID_PUMP_PARTS, 1);
    junk.SetScript("prod_barrel_junk@_Junk");
}

void _TryUseSS(Critter& follower) // try use Super Stimpack or stimpack when attacked
{
	if(!follower.IsLife()) return;
		
	if(follower.CountItem(PID_SUPER_STIMPAK)>0)
	{
		Item @ item = follower.GetItem(PID_SUPER_STIMPAK, -1);
		UseDrug(follower, item);
		_CritAnimateUse(follower);
	}
	if(follower.CountItem(PID_STIMPAK)>0)
	{
		Item @ item = follower.GetItem(PID_STIMPAK, -1);
		UseDrug(follower, item);
		_CritAnimateUse(follower);
	}
	return;
}
//druto
 void r_RaiseEnduranceHP(Critter& cr, Critter@ unused)
{
	if(!valid(cr))
		return;
	
	int hpBonus = 0;
	
	if(cr.Param[ST_ENDURANCE] < 10)
	{
		if(ODD(cr.Param[ST_ENDURANCE]))		// total HP gain by Endurance
			hpBonus += 16;
		else
			hpBonus += 16;
		
		hpBonus -= 2;			// because EN implant adds +2
		cr.ParamBase[ST_MAX_LIFE] += hpBonus;
	}
}

uint e_KickMultilogs(array<uint>@ EmptyArray)
{
	array<Critter@> OnlinePlayers;
	array<Critter@> PlayersToKick;
	GetAllOnlinePlayers(OnlinePlayers);
	
	
	for(uint16 i = 0; i < OnlinePlayers.length(); i++)
	{
		PlayersToKick.resize(0);
		if(_IsOnline(OnlinePlayers[i]))
		{
			uint16 connections = 0;
			
			for(uint16 j = 0; j < OnlinePlayers.length(); j++)
			{
				if(OnlinePlayers[i].Id != OnlinePlayers[j].Id && match_UID(OnlinePlayers[i], OnlinePlayers[j]) && _IsOnline(OnlinePlayers[j]))
				{
					connections++;
					PlayersToKick.resize(connections);
					@PlayersToKick[connections-1] = @OnlinePlayers[j];
				}
			}
			connections++;
			PlayersToKick.resize(connections);
			@PlayersToKick[connections-1] = @OnlinePlayers[i];
			
			if(connections > 4)
			{
				for(uint16 j = 0; j < PlayersToKick.length(); j++)
				{
					PlayersToKick[j].Say(SAY_NETMSG, "Too many connections. Disconnecting...");
					
					PlayersToKick[j].Disconnect();
				}
			}
		}
	}
	return REAL_SECOND(30);
}
bool match_UID(Critter& cr, Critter& dual)
{
	if(cr.GetUID(0) == dual.GetUID(0) && cr.GetUID(1) == dual.GetUID(1) && cr.GetUID(2) == dual.GetUID(2)  && cr.GetUID(3) == dual.GetUID(3) && cr.GetUID(4) == dual.GetUID(4))
	return true;
	
	return false;

}
bool LoadBannedCharacters()
{
	Serializator@ BannedCharacters = @Serializator();
	BannedCharacters.Clear();
	
	if(!IsAnyData("BansData"))
		return false;

	if(!BannedCharacters.Load("BansData"))
	{
		return false;
	}
	
	BannedCharacters.Get(BannedIDs);
	
	Serializator@ BanReasons = @Serializator();
	BanReasons.Clear();
	
	if(!IsAnyData("BansReason"))
		return false;

	if(!BanReasons.Load("BansReason"))
	{
		return false;
	}
	
	BanReasons.Get(BannedReason);
	
	// event ids
	
	Serializator@ BanEvent = @Serializator();
	BanReasons.Clear();
	
	if(!IsAnyData("BansEvents"))
	{
		BanEvents.resize(BannedIDs.length() / 2);
	}
	

	if(IsAnyData("BansEvents"))
	{
		if(!BanEvent.Load("BansEvents"))
			return false;
		
		BanEvent.Get(BanEvents);
	}
	
	uint16 banned = BannedIDs.length() / 2, bannedIP = 0, permban = 0;
	
	
	for(uint16 i = 1; (i + 1) < BannedIDs.length(); i += 2)
	{
		if(BannedIDs[i] != 0) bannedIP++;
		if(BanEvents[i / 2] == 0) permban++;
	}
	
	//Log("Loaded ban list (" + banned + " characters, " + permban + " permanent and " + bannedIP + " IP addresses)...");
		
	return true;
}

bool SaveBannedCharcters()
{
	uint16 banned = BannedIDs.length() / 2, bannedIP = 0, permban = 0;
		
	for(uint16 i = 1; (i + 1) < BannedIDs.length(); i += 2)
	{
		if(BannedIDs[i] != 0) bannedIP++;
		if(BanEvents[i / 2] == 0) permban++;
	}	
	
	//Log("Saving ban list (" + banned + " characters, " + permban + " permanent and " + bannedIP + " IP addresses)...");
	Serializator@ BannedCharacters = @Serializator();
	BannedCharacters.Clear();
	
	Serializator@ BanReasons = @Serializator();
	BanReasons.Clear();
	
	Serializator@ BanEvent = @Serializator();
	BanEvent.Clear();
	
	if(BanReasons.Set(BannedReason).Save("BansReason") && BanEvent.Set(BanEvents).Save("BansEvents"))
		return BannedCharacters.Set(BannedIDs).Save("BansData");
	
//	Log("Nothing to save...");
	return false;
}
void AddBan(Critter& banner, int bannedid, int withip, int hours)
{
	AddBan(banner, bannedid, withip, hours, "Ask me...");
}

void AddBan(Critter& banner, int bannedid, int withip, int hours, string reasonwhy)
{
	string@ bannedName = GetSafePlayerName(bannedid);
	if(bannedName == "[player not found]")
	{
		banner.Say(SAY_NETMSG, "Couldn't find player with ID <" + bannedid + ">...");
		return;
	}
	
	
	Critter@ bannedPlayer = GetCritter(bannedid);
	
	if(valid(bannedPlayer))
		if(withip == 1 && bannedPlayer.GetIp() == banner.GetIp())
		{
			banner.Say(SAY_NETMSG, "It's your IP!");
			return;
		}
	
	// Check ban list for that ID already exists...
	for(uint i = 0; i < BannedIDs.length(); i += 2)
	{
		
		if(BannedIDs[i] == uint(bannedid))
		{
			string alsoip = (BannedIDs[i + 1] != 0 ? (", also with IP " + BannedIDs[i + 1]) : ", but without IP");
			banner.Say(SAY_NETMSG, "This player is already banned by " + BannedReason[i] + " with reason: " + BannedReason[i + 1]);
			if(withip == 1)
			{
				if(!valid(bannedPlayer))
				{
					banner.Say(SAY_NETMSG, "Couldn't set ban for IP...");
					//return;
				}
				else if(_IsOnline(bannedPlayer))
				{
					BannedIDs[i + 1] = bannedPlayer.GetIp();
					banner.Say(SAY_NETMSG, "Whole IP addresses <" + bannedPlayer.GetIp() + "> are banned.");
					KickFromGame(bannedPlayer, true);
					KickFromGame(bannedPlayer.GetIp());
				}
				else if(bannedPlayer.Param[MODE_LAST_IP] != 0)
				{
					BannedIDs[i + 1] = bannedPlayer.Param[MODE_LAST_IP];
					banner.Say(SAY_NETMSG, "Whole IP addresses <" + bannedPlayer.Param[MODE_LAST_IP] + "> are banned.");
					KickFromGame(bannedPlayer.Param[MODE_LAST_IP]);
				}
				else
				{
					banner.Say(SAY_NETMSG, "Unknown exceptions, couldn't ban this IP");
				}
			}
			
			return;
		}
		
	}
	
	uint16 newPosition = BannedIDs.length();
	BannedIDs.resize(newPosition + 2);
	BannedReason.resize(newPosition + 2);
	
	BannedIDs[newPosition] = bannedid;
	banner.Say(SAY_NETMSG, "Player " + bannedName + " ID: <" + bannedid + "> is banned...");
	if(valid(bannedPlayer) && withip == 1)
	{
		if(_IsOnline(bannedPlayer))
		{
			BannedIDs[newPosition + 1] = bannedPlayer.GetIp();
			banner.Say(SAY_NETMSG, "...with IP :" + bannedPlayer.GetIp());
			KickFromGame(bannedPlayer, true);
			KickFromGame(bannedPlayer.GetIp());
		}
		else
		{
			BannedIDs[newPosition + 1] = bannedPlayer.Param[MODE_LAST_IP];
			banner.Say(SAY_NETMSG, "...with IP :" + bannedPlayer.Param[MODE_LAST_IP]);
		}
	}
	else if(valid(bannedPlayer) && withip == 0)
	{
		if(_IsOnline(bannedPlayer))
		{
			BannedIDs[newPosition + 1] = 0;
			KickFromGame(bannedPlayer, false);
		}
		else
		{
			BannedIDs[newPosition + 1] = 0;
		}
	}
	
	if(withip == 0) BannedIDs[newPosition + 1] = 0;
	if(!valid(bannedPlayer) && withip == 1)
	{
		banner.Say(SAY_NETMSG, "Couldn't receive current or last used IP address!");
		BannedIDs[newPosition + 1] = 0;
	}
	BannedReason[newPosition] = banner.Name;
	BannedReason[newPosition + 1] = reasonwhy; // DONE
	BanEvents.resize((newPosition / 2) + 1);
	BanEvents[(newPosition / 2)] = 0;
	if(hours != 0)
	{
		array<uint> bandata = { BannedIDs[newPosition], BannedIDs[newPosition + 1] };
		BanEvents[(newPosition / 2)] = CreateTimeEvent(AFTER(REAL_HOUR(hours)), "e_RemoveBan", bandata, true);
	}
}

void KickFromGame(Critter& kickedPlayer, bool withBan)
{
	if(withBan)
	{
		kickedPlayer.Say(SAY_NETMSG, "You're banned!");
	}
	else
	{
		kickedPlayer.Say(SAY_NETMSG, "You're kicked from the game!");
	}
	kickedPlayer.Disconnect();
}

void KickFromGame(uint bannedIP)
{
	array<Critter@> OnlinePlayers;
	GetAllOnlinePlayers(OnlinePlayers);
	
	uint16 connections = 0;
	
	
	for(uint16 i = 0; i < OnlinePlayers.length(); i++)
	{
		if(_IsOnline(OnlinePlayers[i]) && OnlinePlayers[i].GetIp() == bannedIP)
		{
			OnlinePlayers[i].Say(SAY_NETMSG, "Your IP address is banned!");
			OnlinePlayers[i].Disconnect();
		}
	}
}

uint e_RemoveBan(array<uint>@ removeBanData)
{
	uint critId = removeBanData[0], critIp = removeBanData[1];
	int indx = -1;
	
//	Log("Removing ban from player " + GetSafePlayerName(critId) + " <" + critId + ">...");
	if((indx = BannedIDs.find(critId)) >= 0)
	{
		BannedIDs.removeAt(indx);
		BannedIDs.removeAt(indx);
		BannedReason.removeAt(indx);
		BannedReason.removeAt(indx);
		BanEvents.removeAt(indx / 2);
	}
	else
	{
		//Log("ERR: Can't find player " + GetSafePlayerName(critId) + " <" + critId + ">!");
	}
            
	return 0;
}

// This is the function which must be run at first time after injection of new ban system.
void SetNewBanArray(Critter& cr, int, int, int)
{
	if((BannedIDs.length() / 2) == BanEvents.length())
	{
		cr.Say(SAY_NETMSG, "It seems that everything is OK!");
	}
	else
	{
		cr.Say(SAY_NETMSG, "Setting up the new array...");
		BanEvents.resize(BannedIDs.length() / 2);
		if((BannedIDs.length() / 2) != BanEvents.length())
		{
			cr.Say(SAY_NETMSG, "Setting up the new array...");
			if((BannedIDs.length() / 2) == BanEvents.length())
				cr.Say(SAY_NETMSG, "Done - filled with " + BanEvents.length() + " IDs of event (0)");
			else
				cr.Say(SAY_NETMSG, "Couldn't fill with " + BanEvents.length() + " IDs of event (0)");
		}
	}	
}

void ShowBanList(Critter& cr, int, int, int)
{
	ShowBanList(cr);
}

void ShowBanList(Critter& cr)
{
	if(BannedIDs.length() == 0)
	{
		cr.Say(SAY_NETMSG, "List of bans is empty...");
		return;
	}
	
	for(uint16 i = 0; i < BannedIDs.length(); i += 2)
	{
		cr.Say(SAY_NETMSG, ((i / 2) + 1) + ". " + GetSafePlayerName(BannedIDs[i]) + " (" + BannedIDs[i] + "), " + (BannedIDs[i + 1] == 0 ? "for character" : "for IP address") + ", " + (BanEvents[i / 2] == 0 ? "permanent" : "for some time") + ", by " + BannedReason[i] + " for " + BannedReason[i + 1]);
	}
}

void RemoveBan(Critter& cr, int critId, int, int)
{
	RemoveBan(cr, critId);
}

void RemoveBan(Critter& cr, int critId)
{
	int indx = -1;
	
	if(BannedIDs.length() == 0)
	{
		cr.Say(SAY_NETMSG, "List of bans is empty...");
		return;
	}
	
	//Log(cr.Name + " is trying to remove ban from player " + GetSafePlayerName(critId) + " <" + critId + ">...");
	if((indx = BannedIDs.find(critId)) >= 0)
	{
		BannedIDs.removeAt(indx);
		BannedIDs.removeAt(indx);
		BannedReason.removeAt(indx);
		BannedReason.removeAt(indx);
		if(BanEvents[indx / 2] != 0)
			EraseTimeEvent(BanEvents[indx / 2]);
		BanEvents.removeAt(indx / 2);
		
	//	Log(cr.Name + " removed ban from player " + GetSafePlayerName(critId) + " <" + critId + ">...");
		cr.Say(SAY_NETMSG, "Removed ban from player " + GetSafePlayerName(critId) + " <" + critId + ">!");
	}
	else
	{
		cr.Say(SAY_NETMSG, "Can't find player " + GetSafePlayerName(critId) + " <" + critId + ">!");
	//	Log("ERR: Can't find player " + GetSafePlayerName(critId) + " <" + critId + ">!");
	}
}

string propermoney(Critter& cr)
{
	if(!valid(cr))
		return "";
	switch(cr.Param[ST_DESCRIPTION2])
	{
	case 1: return "Dollars";
	case 2: return "Chips";
	case 3: return "Scrips";
	case 4: return "Pounds";
	case 5: return "Rings";
	default: return "Caps";
	}
	return "caps";
}
string properprefix(Critter& cr)
{
	if(!valid(cr))
		return "";
	switch(cr.Param[ST_DESCRIPTION2])
	{
	case 1: return "Enclave ";
	case 2: return "Memory ";
	case 3: return "NCR ";
	case 4: return "Vault City ";
	case 5: return "Pull ";
	default: return "Bottle ";
	}
	return "Bottle";
}
void dlg_Caps(Critter& player, Critter@ npc, string@ text)
{
	if(!valid(npc))
		return;
	if(!valid(player))
		return;
//	if(findFirst(getdialogtext(npc), "@lex money@") == -1)
	//	return;
	SetLexem(npc, "$money", propermoney(npc));	
	text += ("$money" + propermoney(npc));
	//if(findFirst(getdialogtext(npc), "@lex prefix@") == -1)
		//return;
	SetLexem(npc, "$prefix", properprefix(npc));
	//player.Say(SAY_NETMSG, "1: " + findFirst(text, "@lex prefix@"));
	text += ("$prefix" + properprefix(npc));
	//player.Say(SAY_NETMSG, "2: " + findFirst(text, "@lex prefix@"));	
		
	
		

}