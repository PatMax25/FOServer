//
// FOnline: 2238
// Rotators
//
// cheats.fos
//

// various commands

#include "_animation.fos"
#include "_ai.fos"
#include "_basetypes.fos"
#include "_macros.fos"
#include "_scripts.fos"
#include "_vals.fos"

#include "achievements_h.fos"
#include "backend_h.fos"
#include "broadcast_h.fos"
#include "buffer_h.fos"
#include "cheats_core_h.fos"
#include "combat_h.fos"
#include "combat_msg.fos"
#include "config_file_h.fos"
#include "critter_age_h.fos"
#include "debug_h.fos"
#include "economy_h.fos"
#include "entire.fos"
#include "follower_common_h.fos"
#include "follower_h.fos"
#include "factions_h.fos"
#include "factions_bases_h.fos"
#include "gm.fos"
#include "lexems_h.fos"
#include "mapdata_h.fos"
#include "minigames.fos"
#include "npc_ai.fos"
#include "npc_common_h.fos"
#include "npc_names_h.fos"
#include "npc_planes_h.fos"
#include "serializator.fos"
#include "town_h.fos"
#include "traps_h.fos"
#include "triggers_h.fos"
#include "utils_h.fos"
#include "weather_h.fos"
#include "world_common_h.fos"
#include "worldmap_h.fos"
#include "_colors.fos"
#include "item_pools_h.fos"
//#include "map_events.fos"
// #include "cheats_help.fos"

// #include "event_teleporter_h.fos"

/**
 * \~english @defgroup CheatsGroup Cheats
 * Cheat module with various commands.
 * \~ @ingroup FOnline2238
 */
/*@{*/

#define GETACCESS_CFG    "config/GetAccess.cfg"
#define CHEATS_CFG       "config/Cheats.cfg"
#define CFG_TRACKING     "Tracking"
#define MODE_EXT_GOD     (0x00020000)

// imports
// import void start() from "game";

// import void ExecUsedAmmo(Critter@ player) from "ammolog";

import void            AffectRadiation(Critter& cr, int value) from "radiation";
import void            DropDrugEffects(Critter& cr, bool dropAddictions) from "drugs";
import void            DropPoison(Critter& cr) from "poison";
import void            DropRadiation(Critter& cr) from "radiation";
import void            Explode(Map@ map, uint16 hexX, uint16 hexY, Critter@ cr, uint16 explodePid, uint ownerId, int bonusDamage, int bonusRadius) from "explode";
import void            ExplodeEx(Map& map, uint16 hexX, uint16 hexY, uint16 effectPid, uint effectRadius, uint damage, uint damageType, uint damageRadius, uint ownerId, uint16 explodePid) from "explode";
import bool            GetBaseType(const string& in, int& out) from "main";
import bool            GetItemPid(const string& in, int& out) from "main";
import bool            GetMapData(const string& in, int& out) from "main";
import bool            GetVarId(const string& in, int& out) from "main";
import void            InitPrices() from "economy";
import void            InjureCritter(Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId) from "combat";
import bool            IsGrenade(Item& item) from "throwing";
import uint            numDigits(int number) from "critter_description";
import void            SetCritterEvents(Critter& cr) from "logging_critter";
import void            SetWear(Item& item, int wearProcent) from "repair";
import int             stringReplaceText(string& s, string@ f, string@ t) from "config_file";
import array<Critter@> WorldmapGetPlayers(uint zx, uint zy) from "worldmap_players";
import int             WorldmapGetTotalValue() from "worldmap";
import void 		   AddBonuses(Item@ it, int magic) from "item_bonus";
import void 		   SetMinWear(Item& item, int wearProcent) from "repair";
import void SpawnBuffItem(Item& container, uint16 pid) from "spawner_pve";
import void eventAtak(Critter& cr, int howmany, int team, int team2) from "mob_dynamic";
import void eventDef(Critter& cr, int howmany, int team, int team2) from "mob_dynamic";
import void event3(Critter& cr, int howmany, int team, int team2) from "mob_dynamic";
import void event4(Critter& cr, int howmany, int team, int team2) from "mob_dynamic";
import void SpawnTeam(Critter& cr, int howmany, int whatkind, int team, bool withboss) from "mob_dynamic";
import void AddBan(Critter& banner, int bannedid, int withip, int hours, string reasonwhy) from "main";
import void ShowBanList(Critter& cr) from "main";
import void RemoveBan(Critter& cr, int critId) from "main";
import void r_RemoveMoney(Critter& player, Critter@ npc, int val) from "dialog";
import void _weapon_perk(Item& item, bool firstTime) from "item_level";
import void _armor_perk(Item& item, bool firstTime) from "item_level";
import uint CountTimeEvents(string& scriptName) from "utils";
import uint CountTimeEvents(string& scriptName, bool ignoreValues) from "utils";
import uint CountTimeEvents(string& scriptName, uint withValue) from "utils";
import uint CountTimeEvents(string& scriptName, int withValue) from "utils";
import uint CountTimeEvents(string& scriptName, array<uint>@ withValues) from "utils";
import uint CountTimeEvents(string& scriptName, array<int>@ withValues) from "utils";
import uint EraseTimeEvents(string& scriptName) from "utils";
import uint EraseTimeEvents(string& scriptName, bool ignoreValues) from "utils";
import uint EraseTimeEvents(string& scriptName, uint withValue) from "utils";
import uint EraseTimeEvents(string& scriptName, int withValue) from "utils";
import uint EraseTimeEvents(string& scriptName, array<uint>@ withValues) from "utils";
import uint EraseTimeEvents(string& scriptName, array<int>@ withValues) from "utils";
import array<uint>@ GetTimeEventsByNameExt(string& scriptName) from "utils";
import array<uint>@ GetTimeEventsByNameExt(string& scriptName, bool ignoreValues) from "utils";
import array<uint>@ GetTimeEventsByNameExt(string& scriptName, uint withValue) from "utils";
import array<uint>@ GetTimeEventsByNameExt(string& scriptName, int withValue) from "utils";
import array<uint>@ GetTimeEventsByNameExt(string& scriptName, array<uint>@ withValues) from "utils";
import array<uint>@ GetTimeEventsByNameExt(string& scriptName, array<int>@ withValues) from "utils";
import array<uint>@ GetTimeEventsByPartValues(string& scriptName, array<uint>@ partValues) from "utils";
import array<uint>@ GetTimeEventsByPartValues(string& scriptName, array<int>@ partValues) from "utils";

#define _SetSpawner                      \
    # (__item, __cr) { if(valid(__item)) \
                           __item.Val2 = _AsNotLegit(__cr.Id); }
#define _SetSpawnerLegit                 \
    # (__item, __cr) { if(valid(__item)) \
                           __item.Val2 = __cr.Id; }
#define _GetSpawner      # (__item) _AsLegit(__item.Val2)

// globals

bool CheatsInitialized = false;

// list of maps identifiers
dictionary Maps;

// items and critters spawned during event
array<int> eventItems;
array<int> eventCritters;

// Remember to wear protective goggles :)
string[] commandlist =
{
    "accesslist", "addban", "addbankmoney", "addfollower", "addmob", "addnpc", "airstrike", "alts", "autobalance",
    "animate", "antiblock", "append", "aura", "auracleanup",
    "banlist", "bc", "blockers", "broadcast", "callmobs", "createofficer",
    "ces", "changefaction", "changerank", "checkbank", "checkbankaccount",
    "checkbankaccounts", "checktown", "cleanup", "clearallillegalflags",
    "clearenemystack", "clearenemystacks", "clearinventory", "clearillegalflags",
    "cleartimeouts", "clone", "condition", "controlmobs", "controlnpc", "corecheats",
    "countitems", "createlocation", "crinfo", "criticalchance", "critterinfo",
    "cto",
    "damage", "deathincarnate", "deathmatch", "deletelocation", "devenable", "dl",
    "dialog", "disguise","massdisguise", "disabledismantling", "disablegrids", "disablepvp", "disablepve",
    "disabletb", "disguiseinfo", "dismiss", "dismissteam", "dropalltimeouts",
    "dropdrugs", "dropitems", "eraseallevent",
    "emote", "emoteh", "enabledismantling", "enablegrids", "enablepvp", "enabletb", "enablepve"
    "erasetimeevent", "explode",
	"ev-ponyattack", "ev-trader", "event", "eventtimer", "et",
    "factioninfo", "factionnews", "factiononline", "findchars", "finditems",
    "findnpc", "flash", "foart",
    "gaintowncontrol", "gameinfo", "getclaim", "getclaimtime", "getcolor",
    "getitems", "getleader", "getleadertime", "getuvar", "getvar", "give","massgive",
    "givelevelbook", "givekey", "goto", "gototeam",
    "heal", "healall", "help", "hideloc", "hidemap",
    "id2name", "iddqd", "idkfa", "inspect", "irradiate", "itemflags", "itemlight",
    "itemproto",
    "karma", "karmateam", "kill", "killeradmin", "killmobs",
    "la", "lastregistered", "lastspawned", "listauthenticated",     "listcommands",
    "listfollowers", "listfactions", "listmaps", "listplayers",     "listtents",
    "listtracked", "lock", "lockcar", "log", "lp", "lt",
    "makeencounter", "mapinfo", "masssetanim", "massslap", "modchar", "move", "massparam",
    "name2id", "netmsg", "normaldeadly", "numplayers",
    "param", "perkadjust", "pickitems", "phase", "phaseteam", "playerkarma",
    "playmusic", "playsound", "playspeech", "profadjust",
    "registerfaction", "removeban", "removebankmoney", "removefaction", "removeitems",
    "reservednickname", "resetalldisguises", "resetprices", "resetreputations",
    "resettown", "resettowns", "resetworldmap", "respawn", "revive", "respawnall",
    "reviveall", "respawnallplayers", "reviveallplayers", "rotate", "rundialog",
    "saferegen", "say", "sayh",
	"setcolor", "setdeterioration",
	"seteventwithcar", "seteventwithitem", "seteventwithmobs",
	"setfaction", "setmapdata", "setanim",
	"setgmevent", "sethp",
    "setlexem", "setperk",
	"setremoveitemsonmap", "setreputation", "setrep", "settimeout", "sto",
    "setuvar", "setvar", "setlocvisibility", "setrain", "shift", "shiftteam", "shout",
    "shouth", "showhands", "showloc", "showvars", "slap", "spawncar", "spawngmspawner", "spawnitem",
    "spawnpoint", "stoptrackplayer", "suicide", "summon", "summonteam","tee",
    "team", "tentinfo", "tp", "teleport", "teleporter", "teleportteam", "toglobal", "trackplayer",
    "usedammo", "unlockcar",
	"unsetevent", "unsetmapoutevent",
    "whisper", "whisperh",
    "virtualmoney",
    "xp", "xpteam",
    "zeroext", "zone", "zoneplayers","gm", "spawnteam", "st"
};

string[] gmcommandlist =
{
    "accesslist", "addban", "addbankmoney", "addfollower", "addmob", "addnpc", "airstrike", "alts", "autobalance",
    "animate", "antiblock", "append", "aura", "auracleanup",
    "banlist", "bc", "blockers", "broadcast", "callmobs", "createofficer",
    "ces", "changefaction", "changerank", "checkbank", "checkbankaccount",
    "checkbankaccounts", "checktown", "cleanup", "clearallillegalflags",
    "clearenemystack", "clearenemystacks", "clearinventory", "clearillegalflags",
    "cleartimeouts", "clone", "condition", "controlmobs", "controlnpc", "corecheats",
    "countitems", "createlocation", "crinfo", "criticalchance", "critterinfo",
    "cto",
    "damage", "deathincarnate", "deathmatch", "deletelocation", "devenable", "dl",
    "dialog", "disguise","massdisguise", "disabledismantling", "disablegrids", "disablepvp", "disablepve",
    "disabletb", "disguiseinfo", "dismiss", "dismissteam", "dropalltimeouts",
    "dropdrugs", "dropitems", "eraseallevent",
    "emote", "emoteh", "enabledismantling", "enablegrids", "enablepvp", "enabletb", "enablepve"
    "erasetimeevent", "explode",
	"ev-ponyattack", "ev-trader", "event", "eventtimer",
    "factioninfo", "factionnews", "factiononline", "findchars", "finditems",
    "findnpc", "flash", "foart",
    "gaintowncontrol", "gameinfo", "getclaim", "getclaimtime", "getcolor",
    "getitems", "getleader", "getleadertime", "getuvar", "getvar", "give","massgive",
    "givelevelbook", "givekey", "goto", "gototeam",
    "heal", "healall", "help", "hideloc", "hidemap",
    "id2name", "iddqd", "idkfa", "inspect", "irradiate", "itemflags", "itemlight",
    "itemproto",
    "karma", "karmateam", "kill", "killeradmin", "killmobs",
    "la", "lastregistered", "lastspawned", "listauthenticated",     "listcommands",
    "listfollowers", "listfactions", "listmaps", "listplayers",     "listtents",
    "listtracked", "lock", "lockcar", "log", "lp", "lt",
    "makeencounter", "mapinfo", "masssetanim", "massslap", "modchar", "move", "massparam",
    "name2id", "netmsg", "normaldeadly", "numplayers",
    "param", "perkadjust", "pickitems", "phase", "phaseteam", "playerkarma",
    "playmusic", "playsound", "playspeech", "profadjust",
    "registerfaction", "removeban", "removebankmoney", "removefaction", "removeitems",
    "reservednickname", "resetalldisguises", "resetprices", "resetreputations",
    "resettown", "resettowns", "resetworldmap", "respawn", "revive", "respawnall",
    "reviveall", "respawnallplayers", "reviveallplayers", "rotate", "rundialog",
    "saferegen", "say", "sayh",
	"setcolor", "setdeterioration",
	"seteventwithcar", "seteventwithitem", "seteventwithmobs",
	"setfaction", "setmapdata", "setanim",
	"setgmevent", "sethp",
    "setlexem", "setperk",
	"setremoveitemsonmap", "setreputation", "setrep", "settimeout", "sto",
    "setuvar", "setvar", "setlocvisibility", "setrain", "shift", "shiftteam", "shout",
    "shouth", "showhands", "showloc", "showvars", "slap", "spawncar", "spawngmspawner", "spawnitem",
    "spawnpoint", "stoptrackplayer", "suicide", "summon", "summonteam","tee",
    "team", "tentinfo", "tp", "teleport", "teleporter", "teleportteam", "toglobal", "trackplayer",
    "usedammo", "unlockcar",
	"unsetevent", "unsetmapoutevent",
    "whisper", "whisperh",
    "virtualmoney",
    "xp", "xpteam",
    "zeroext", "zone", "zoneplayers","gm", "spawnteam", "st"
};

string[] testercommandlist =
{
    "alts", "animate",
    "ces", "changefaction", "changerank", "clearillegalflags", "clearenemystack",
    "clearenemystacks", "cleartimeouts", "countitems", "crinfo", "critterinfo",
    "cto",
    "devenable", "dismiss", "dismissteam", "dropitems",
    "finditems",
    "gameinfo", "getcolor", "getvar", "goto",
    "heal", "healall", "help",
    "id2name", "killmobs",
    "lastregistered", "listcommands", "listfactions", "listfollowers", "listmaps",
    "listplayers", "listtents", "listtracked", "lp", "lt", "log",
    "mapinfo",
    "name2id", "netmsg", "numplayers",
    "pickitems", "playerkarma", "playmusic", "playsound", "playspeech",
    "revive", "rotate",
    "say", "sayh", "setanim", "showhands", "shout", "shouth", "showvars", "slap",
    "suicide",
    "tentinfo", "tp", "teleport", "toglobal", "trackplayer",
    "whisper", "whisperh"
};

int[] testerparamlist =
{
    // various statistics
    ST_ACTION_POINTS,
    ST_AGE,
    ST_ARMOR_CLASS,
    ST_CARRY_WEIGHT,
    ST_GENDER,
    ST_HEALING_RATE,
    ST_LEVEL,
    ST_MAX_LIFE,
    ST_SEQUENCE,
    ST_RADIATION_RESISTANCE, ST_POISON_RESISTANCE,

    ST_NORMAL_ABSORB, ST_LASER_ABSORB, ST_FIRE_ABSORB, ST_PLASMA_ABSORB, ST_ELECTRO_ABSORB, ST_EMP_ABSORB, ST_EXPLODE_ABSORB,
    ST_NORMAL_RESIST, ST_LASER_RESIST, ST_FIRE_RESIST, ST_PLASMA_RESIST, ST_ELECTRO_RESIST, ST_EMP_RESIST, ST_EXPLODE_RESIST,

    ST_DESCRIPTION1, ST_DESCRIPTION2,

    // 3d
    #ifdef PLAYERS_3D
    (ST_ANIM3D_LAYERS + 0),     // 150
    (ST_ANIM3D_LAYERS + 1),
    (ST_ANIM3D_LAYERS + 2),
    (ST_ANIM3D_LAYERS + 3),
    (ST_ANIM3D_LAYERS + 4),
    (ST_ANIM3D_LAYERS + 5),
    (ST_ANIM3D_LAYERS + 6),
    (ST_ANIM3D_LAYERS + 7),
    (ST_ANIM3D_LAYERS + 8),
    (ST_ANIM3D_LAYERS + 9),
    (ST_ANIM3D_LAYERS + 10),    // 160
    (ST_ANIM3D_LAYERS + 11),
    (ST_ANIM3D_LAYERS + 12),
    (ST_ANIM3D_LAYERS + 13),
    (ST_ANIM3D_LAYERS + 14),
    (ST_ANIM3D_LAYERS + 15),
    (ST_ANIM3D_LAYERS + 16),
    (ST_ANIM3D_LAYERS + 17),
    (ST_ANIM3D_LAYERS + 18),
    (ST_ANIM3D_LAYERS + 19),
    (ST_ANIM3D_LAYERS + 20),    // 170
    (ST_ANIM3D_LAYERS + 21),
    (ST_ANIM3D_LAYERS + 22),
    (ST_ANIM3D_LAYERS + 23),
    (ST_ANIM3D_LAYERS + 24),
    (ST_ANIM3D_LAYERS + 25),
    (ST_ANIM3D_LAYERS + 26),
    (ST_ANIM3D_LAYERS + 27),
    (ST_ANIM3D_LAYERS + 28),
    (ST_ANIM3D_LAYERS + 29), // 179
    #endif                   // PLAYERS_3D

    // SPECIAL
    ST_STRENGTH, ST_PERCEPTION, ST_ENDURANCE, ST_CHARISMA, ST_INTELLECT, ST_AGILITY, ST_LUCK,

    // skills
    SK_SMALL_GUNS, SK_BIG_GUNS, SK_ENERGY_WEAPONS, SK_UNARMED, SK_LEARNING, SK_THROWING, SK_FIRST_AID, SK_DOCTOR, SK_SNEAK, SK_LOCKPICK, SK_ENGINE, SK_TRAPS, SK_SCIENCE, SK_REPAIR, SK_SPEECH, SK_BARTER, SK_CRAFTING, SK_OUTDOORSMAN,

    // tag skills
    //TAG_SKILL1, TAG_SKILL2, TAG_SKILL3, TAG_SKILL4,

    // modes
    MODE_NO_AIM,
    MODE_NO_KNOCK,
    MODE_NO_PUSH,
    MODE_NO_PVP,
    MODE_NO_RUN,
    MODE_NO_UNARMED,
    MODE_NO_WALK,
    MODE_RANGE_HTH,
    MODE_UNLIMITED_AMMO
};

void SetMapId(string location, uint mapprotoid)
{
    Map@ map = GetMapByPid(mapprotoid, 0);
    if(!valid(map))
    {
        DLog("Couldn't find map object for " + location);
        return;
    }

    WLog("cheats", "Setting mapid for " + location + " to " + map.Id);
    Maps.set(location, map.Id);
}

void RefreshAliases(Critter& player, int, int, int)   // ~runscript cheats RefreshAliases 0 0 0
{
    SetAliases();
}

void SetAliases()
{
    // Fallout 1
    SetMapId("junktown",    MAP_Junktown);
    SetMapId("jt",                  MAP_Junktown);
    SetMapId("hub",                 MAP_HubDowntown);
    SetMapId("glow",                MAP_Glow_Entrance);
    //SetMapId("gunrunners",  MAP_Gunrunner);
    //SetMapId("fortress",    MAP_Gunrunner);
    SetMapId("adytum",              MAP_Adytum);
    //SetMapId("scavenger",   MAP_Blade);
    //SetMapId("library",             MAP_Library);
    SetMapId("lh",                  MAP_LostHills_Entrance);
	SetMapId("bos",                  MAP_LostHills_Entrance);
    SetMapId("v13",                 MAP_Vault13Level1);
    SetMapId("necropolis",  MAP_NecropolisHotel);
	SetMapId("necro",  MAP_NecropolisHotel);
	SetMapId("wh", MAP_Ripper);
	SetMapId("warehouse", MAP_Ripper);

    // Fallout 2
    SetMapId("arroyo",              MAP_ArroyoTemple);
    SetMapId("den",                 MAP_DenBusiness);
    SetMapId("klamath",             MAP_KlamathDowntown);
    SetMapId("klamcave",    MAP_KlamathToxicCaves1);
    SetMapId("modoc",               MAP_ModocLarge);
    SetMapId("vc",                  MAP_VaultCityDowntown);
    SetMapId("gecko",               MAP_GeckoSettlement);
    SetMapId("bh",                  MAP_BrokenHills);
    SetMapId("broken",              MAP_BrokenHills);
    SetMapId("nr",                  MAP_NewReno1);
	SetMapId("newreno",                  MAP_NewReno1);
	SetMapId("reno",                  MAP_NewReno1);
    SetMapId("gasstation",  MAP_NewRenoChopShop);
    SetMapId("tray",                MAP_NewRenoChopShop);
    SetMapId("t-ray",               MAP_NewRenoChopShop);
    SetMapId("sad",                 MAP_SierraArmyDepot_TheBattlefield);
    SetMapId("v15",                 MAP_Vault15Surface);
    SetMapId("ncr",                 MAP_NCR);
    SetMapId("shady",               MAP_NCR);
    SetMapId("shadysands",  MAP_NCR);
    SetMapId("cathedral",   MAP_Cathedral_Enter);
	SetMapId("cath",   MAP_Cathedral_Enter);
    SetMapId("mariposa",    MAP_MilitaryBaseEntrance);
	SetMapId("mari",    MAP_MilitaryBaseEntrance);
    SetMapId("redding",             MAP_Redding);
    SetMapId("sf",                  MAP_SanFranChina);
    SetMapId("navarro",             MAP_Navarro);
    SetMapId("golgotha",    MAP_NewReno_Golgotha);
    SetMapId("raiders1",    MAP_KhansCaveEntrance);
    SetMapId("khans",               MAP_KhansCaveEntrance);
    SetMapId("raiders2",    MAP_KhansHQ);

    // 2238-specific
    SetMapId("repl1",               MAP_Replication1);
    SetMapId("repl2",               MAP_Replication2);
    SetMapId("repl3",               MAP_Replication3);
    SetMapId("repl4",               MAP_Replication4);
    SetMapId("repl5",               MAP_Replication5);
    SetMapId("repl6",               MAP_Replication6);
    SetMapId("repl7",               MAP_Replication7);
    SetMapId("repl8",               MAP_SalvagerCamp);

    // Fixed Mining Sides
    SetMapId("bh_mine",             MAP_BrokenHillsMine);
    SetMapId("broken_mine", MAP_BrokenHillsMine);
    SetMapId("klamath_mine", MAP_KlamathMiningSite);
    SetMapId("ncr_mine",    MAP_NCRMiningSite);
    SetMapId("redding_mine", MAP_ReddingMine);
    SetMapId("sf_mine",             MAP_SanFranciscoMiningSite);
    SetMapId("jt_mine",             MAP_JunktownMiningSite);
    SetMapId("vc_mine",             MAP_VaultCityMiningSite);

    // Trainyards
    SetMapId("sf_train",    MAP_SanFransiscoTrainStation);
    SetMapId("la_train",    MAP_BoneyardTrainStation);
    SetMapId("ncr_train",   MAP_NCRTrainStation);
    SetMapId("vc_train",    MAP_VaultCityTrainStation);

    SetMapId("train1",              MAP_SanFransiscoTrainStation);
    SetMapId("train2",              MAP_BoneyardTrainStation);
    SetMapId("train3",              MAP_NCRTrainStation);
    SetMapId("train4",              MAP_VaultCityTrainStation);

    // Slaver Camps
    SetMapId("slaver1",             MAP_SlaverCamp);
    /* Used in future
       SetMapId("slaver2",		569);
       SetMapId("slaver3",		570);
       SetMapId("slaver4",		571);
     */

    SetMapId("ares",                MAP_AresMilitaryBase_Entrance);
    SetMapId("gasstation2", MAP_GordonsGasStation);
	SetMapId("ggg", MAP_GordonsGasStation);
    SetMapId("hinkley",             MAP_Arena);
    SetMapId("hub_arena",   MAP_HubArena);
    SetMapId("junkyard",    MAP_Junkyard);
    SetMapId("tesla",               MAP_TeslaTower);
    SetMapId("themepark",   MAP_Themepark);
    SetMapId("waterworks",  MAP_Waterworks);
	SetMapId("ww",  MAP_Waterworks);
    SetMapId("ncr_army",    MAP_MilitaryCamp);
    SetMapId("ncrcf",               MAP_NCRCF);
    SetMapId("prison",              MAP_NCRCF);
    SetMapId("ncr_rails",   MAP_Rails);

    // Special maps
    SetMapId("npcmap",              MAP_BufferMap);
    SetMapId("jail",                MAP_Jail);
	SetMapId("cubik",                MAP_Cubik);
	SetMapId("bg", MAP_BarterGround);
	SetMapId("barterground", MAP_BarterGround);
	
	// FOnline: Aftertimes
	SetMapId("v14",         MAP_Vault14Entrance);
	SetMapId("slvvlt",      MAP_SlaveryVault1);
	SetMapId("slave",      MAP_SlaveryVault1);
	SetMapId("slavevault",      MAP_SlaveryVault1);
	SetMapId("carson",      MAP_Purgratory);
	SetMapId("ghosttown",   MAP_GhostTown);
	SetMapId("raiderscave", MAP_RaidersCaveEntry);
	
	// Fallout of Nevada
	SetMapId("vegas", MAP_Vegas);
	SetMapId("vegasstables", MAP_VegasStables);
	SetMapId("vs", MAP_VegasStables);
	SetMapId("sl", MAP_SaltLake);
	SetMapId("saltlake", MAP_SaltLake);
	SetMapId("vx", MAP_VaultXEntranceLevel1);
	SetMapId("vaultx", MAP_VaultXEntranceLevel1);
	SetMapId("area51", MAP_Area51Entrance);
	SetMapId("a51", MAP_Area51Entrance);
	SetMapId("hawthorne", MAP_Hawthorne);
	SetMapId("provo", MAP_Provo);
	SetMapId("bport", MAP_BPort);
	SetMapId("renofon", MAP_NewRenoFoN);
	SetMapId("renoraiders", MAP_NewRenoRaiders);
	SetMapId("cheyenne", MAP_Cheyenne);
	SetMapId("windofwar", MAP_WindOfWarMain);
	SetMapId("wow", MAP_WindOfWarMain);
	SetMapId("bikersbase", MAP_BikersBase);
	SetMapId("bb", MAP_BikersBase);
	
	// Mapy KompreSora
	SetMapId("ct", MAP_CloudTowerEnter);
	SetMapId("cloudtower", MAP_CloudTowerEnter);
	SetMapId("fv", MAP_FakeVault1);
	SetMapId("fakevault", MAP_FakeVault1);
	SetMapId("labandits", MAP_LABandits1);
	
	// Tito
	SetMapId("talchem", MAP_Talchem_1);
	SetMapId("tunnel", MAP_Tunnel_1);
	SetMapId("tunel", MAP_Tunnel_1);
	SetMapId("temple", MAP_Temple_1);
	SetMapId("abbey", MAP_Abbey_sur);
	SetMapId("labx7", MAP_Labx7_sur);
	SetMapId("lab7", MAP_Labx7_sur);
	SetMapId("l7", MAP_Labx7_sur);
	SetMapId("farm", MAP_Stfarm1);
	//FO3
	SetMapId("rockside", 988);
	SetMapId("bco", 729);
	SetMapId("oilrig", 700);
	SetMapId("treasure", 453);
	SetMapId("treasureclub", 453);
	SetMapId("NSA", 473);
	SetMapId("nsa", 473);
	SetMapId("zc1", 476);
	SetMapId("zc2", 477);
	SetMapId("zc3", 478);
	SetMapId("infinity", 484);
	SetMapId("pv", 502);
	SetMapId("diego", 507);
	SetMapId("fp", 522);
	SetMapId("sas", 527);

}

class CNPC
{
    uint          protoId;
    uint          dialogId;
    array<string> names;

    CNPC(uint protoId, uint dialogId)
    {
        this.protoId  = protoId;
        this.dialogId = dialogId;
        names.resize(0);
    }

    bool IsImportant(Critter& cr)
    {
        if(cr.GetProtoId() == this.protoId &&
           cr.Param[ST_DIALOG_ID] == int(this.dialogId))
            return(true);
        else
            return(false);
    }

    CNPC@ Name(string& name)
    {
        this.names.insertLast(name);

        return(this);
    }
};
array<CNPC@> INPC;

CNPC@ ImportantNpc(uint protoId, uint dialogId)
{
    INPC.insertLast(CNPC(protoId, dialogId));
    return(INPC.last());
}

void SetImportantNpcs()
{
    // ImportantNpc( critter_pid, dialog_id )

    // Broken Hills
    ImportantNpc(161, 625)
    .Name("marcus")
    .Name("town_leader")
    ;
    ImportantNpc(119, 650)
    .Name("mercs")
    ;
    // Frisco
    ImportantNpc(58, 9300)
    .Name("banker")
    ;
    ImportantNpc(297, 1405)
    .Name("dr_fung")
    .Name("doctor")
    ;
    ImportantNpc(308, 1403)
    .Name("lao_chou")
    .Name("trader")
    ;
    ImportantNpc(300, 1402)
    .Name("mai_da_chiang")
    .Name("trader");
    ImportantNpc(300, 772)
    .Name("mercs")
    ;
    ImportantNpc(472, 46)
    .Name("tatoo")
    ;
    // Gordon's Gas Station
    ImportantNpc(149, 10701)
    .Name("tamira")
    .Name("pe_ranger")
    .Name("support_perk")
    ;
    // Junktown
    ImportantNpc(100, 1713)
    .Name("boyce")
    .Name("pe_dismantrler")
    .Name("support_perk")
    ;
    // Raiders
    ImportantNpc(409, 2722)
    .Name("gomes")
    .Name("raiders")
    ;
    // Shady Sands
    ImportantNpc(150, 1002)
    .Name("buster")
    .Name("trader_ncr")
    .Name("trader")
    ;
    ImportantNpc(139, 1025)
    .Name("hoss")
    .Name("pe_cautious_nature")
    .Name("pe_pathfinder")
    .Name("pe_awareness")
    .Name("support_perk")
    ;
    ImportantNpc(20,  1048)
    .Name("sha_enin")
    .Name("trader_ncr")
    .Name("trader")
    ;
    ImportantNpc(144, 1035)
    .Name("tandi")
    ;
}

//////////////////////////////////
//
// Protection of GM-spawned items
//
//

// Checks if item can be used by critter with optional deletion if not.
// Returns true if item is illegal (not-legit item in legit map or not-legit
// item in not-legit map, if the critter carries a stackable legit item
// with the same pid). Called on item transfers and picking up / skills.
//
bool GuardNotLegit(Critter@ cr, Item@ item, bool deleteItem)   // export
{

	/*
    if(_IsNotLegit(item.Val2))
    {
        if(_IsRealPlayer(cr) || cr.IsNpc())
        {
            Map@ map = cr.GetMap();
            if(valid(map) && _IsNotLegit(map.GetData(MAP_DATA_SPAWNER)))
            {
                Item@ item2 = cr.GetItem(item.GetProtoId(), -1);
                if(!valid(item2))
                {
                    return false;
                }
                if(_IsNotLegit(item2.Val2) || !item2.IsStackable())
                {
                    return false;
                }
            }
            if(deleteItem)
            {
                DeleteItem(item);
                cr.Say(SAY_NETMSG, "Not legit item removed.");
            }
            return true;
        }
    }
    return false;
	*/
	return false;
}

// Removes all not legit items from a critter. Called when a critter moves from
// a not-legit map to WM or to a legit map.
//
void RemoveNotLegit(Critter@ cr)   // export
{
	/*
    bool         foundNotLegit = false;
    array<Item@> items;
    uint         num = cr.GetItems(-1, items);
    for(uint i = 0; i < num; i++)
    {
        if(_IsNotLegit(items[i].Val2))
        {
            DeleteItem(items[i]);
            foundNotLegit = true;
        }
    }
    if(foundNotLegit)
    {
        cr.Say(SAY_NETMSG, "Not legit items removed.");
    }*/
	return;
};



//////////////////////////////////////////////////////////////////////////////////////////////
//
//	GET CHEAT OPTIONS - NEW UTILITY USED BY BLOCKERS COMMAND (AND MAYBE OTHER IN THE FUTURE)
//	Gets option by reference and returns a string with option value, with optional
//	[default] note if the option can't be found in command.
//

string cheatGetOption(array<string@>@ command, int& option, string optionSwitch)
{
    if(StrToInt(GetParameterString(command, optionSwitch), option))
    {
        return option + "";
    }
    else
    {
        return option + " [default]";
    }
}

string cheatGetOption(array<string@>@ command, uint& option, string optionSwitch)
{
    if(StrToInt(GetParameterString(command, optionSwitch), option))
    {
        return option + "";
    }
    else
    {
        return option + " [default]";
    }
}

string cheatGetOption(array<string@>@ command, int16& option, string optionSwitch)
{
    if(StrToInt(GetParameterString(command, optionSwitch), option))
    {
        return option + "";
    }
    else
    {
        return option + " [default]";
    }
}

string cheatGetOption(array<string@>@ command, uint16& option, string optionSwitch)
{
    if(StrToInt(GetParameterString(command, optionSwitch), option))
    {
        return option + "";
    }
    else
    {
        return option + " [default]";
    }
}

string cheatGetOption(array<string@>@ command, bool& option, string optionSwitch)
{
    if(GetIndexOfString(command, optionSwitch) != -1)
    {
        option = true;
        return option + "";
    }
    else
    {
        return option + " [default]";
    }
}

void InitCheats(bool fromGame)
{
    if(!fromGame)
    {
        // Todo: Restart other things ?
        // game init
        // start();
    }

    SetAliases();
    SetImportantNpcs();
    LoadEventSpawns();
    // LoadRiddles();

    CheatsInitialized = true;
}

void SaveCheats()
{
    /*
       Log( "Saving cheats..." );
       SaveRiddles();
       Log( "Saved cheats." );
     */
}

//
// Checks if player's authorization allows for given command
//
bool IsAllowed(uint playerId, const string& command)
{
    Critter@ cr = GetCritter(playerId);
    if(!valid(cr) || cr.IsNpc())
        return false;
    switch(cr.GetAccess())
    {
    case ACCESS_CLIENT:
        return false;
    case ACCESS_TESTER:
        return IsInArray(testercommandlist, command);
    case ACCESS_MODER:
        return IsInArray(gmcommandlist, command);
    case ACCESS_ADMIN:
    default:       // iii
        return GodOfTheRealm(playerId) || IsInArray(commandlist, command);
    }
    return false;
}

bool IsInArray(array<string>& arr, string& str)
{
    for(uint i = 0, j = arr.length(); i < j; i++)
        if(arr[i] == str)
            return true;
    return false;
}

bool GodOfTheRealm(uint id)
{
    // return false;
    
    Critter@ cr = GetCritter(id);
    if(!valid(cr))
        return false;
    string@ name = GetSafePlayerName(id);
    if(!valid(name))
        return false;
    return(name == "KompreSor");
    
}

bool WrathOfTheGod(Critter& di)
{
    if(!GodOfTheRealm(di.Id))
        return(false);

    return(_CritHasExtMode(di, MODE_EXT_GOD));
}

// --- stuff from deleteme starts here

void god(Critter& cr, int, int, int)
{
    if(!GodOfTheRealm(cr.Id))
    {
        Critter@ crit = null;
        crit.Param[0];
    }

    _CritSetExtMode(cr, MODE_EXT_GOD);
}

void mortal(Critter& cr, int, int, int)
{
    _CritUnsetExtMode(cr, MODE_EXT_GOD);
}

void adminlook(Critter& player, int p, int r, int)
{
    //if(r != 878787 && p != 0)
       // return;
   // Critter@ player = (p == 0 ? @cr : GetCritter(p));
    _CritSetExtMode(player, MODE_EXT_LOOK_ADMIN);
    _CritSetExtMode(player, MODE_EXT_LOOK_INVISIBLE);
}

void npcmovebydir(Critter& player, int p, int r, int)
{
    array<Critter@> critters;
    uint            num = player.GetCritters(false, FIND_ALL, critters);

    player.Say(SAY_NETMSG, "STEP");

    for(uint i = 0; i < num; i++)
    {
        if(critters[i].IsPlayer())
            continue;
            critters[i].MoveToDir(p);
    }
}


void npcrun(Critter& player, int p, int x, int y)
{
    array<Critter@> critters;
    uint            num = player.GetCritters(false, FIND_ALL, critters);

    player.Say(SAY_NETMSG, "STEP");

    for(uint i = 0; i < num; i++)
    {
        if(critters[i].IsPlayer())
            continue;
       AddWalkPlane(critters[i], 0, critters[i].HexX + x, critters[i].HexY + y, p, true, 0);
    }
}

void fixserver(Critter& player, int p, int r, int)
{
			CreateTimeEvent(AFTER(REAL_SECOND(1)), "e_fixserver", 40000000, false);
}

void fixserver2(Critter& player, int p, int r, int)
{
			CreateTimeEvent(AFTER(REAL_SECOND(1)), "e_fixserver2", 0, false);
}

uint e_fixserver2(array<uint>@ eventtype)
{
	for(uint i = 0; i < 100; i++)
		EraseTimeEvent(eventtype[0] + i);
	CreateTimeEvent(AFTER(REAL_MS(200)), "e_fixserver2", eventtype[0] + 100, false);
	return 0;
}

uint e_fixserver(array<uint>@ eventtype)
{
	int j = eventtype[0];
	for(int i = j; i < j-500; i--)
			{
			EraseTimeEvent(i);
			}
	j -= 500;
	CreateTimeEvent(AFTER(REAL_SECOND(1)), "e_fixserver", j, false);
	return 0;
}
//Spawn Random Gear
void SRG(Critter& cr, int p, int d, int ammo)
{
	Map@ map = cr.GetMap();
	if(d<=3)	d = 3;
	for( int i =1; i <= p; i++ )
	{				
	int[] ammopid = { 	tier3drugs(), 	tier3ammo() , 	tier3ammo(), 	tier3ammo(), 	tier3ammo(), tierlowammo(),tierlowammo(), tier4ammo() };
	int[] pidy = {		tier3armor(), tier3weapon(), tier3armor(), tier3weapon(), tier3helmet(), tier3armor(), tier3weapon(), tier3armor(), tier3weapon(), tier3helmet(), rareitem()};
		
	Item@ it1 = map.AddItem(cr.HexX + i + Random(1,d), cr.HexY + i + Random(1,d), pidy[Random(0,10)], 1);
	it1.Val0 = Random(0,ammo);
	it1.Val2 = 9999;
	it1.Update(); 
	if(it1.GetType() == ITEM_TYPE_WEAPON)
		_weapon_perk(it1, false);
	if(it1.GetType() == ITEM_TYPE_ARMOR)
		_armor_perk(it1, false);
	Item@ it2 = map.AddItem(cr.HexX + i + Random(1,d), cr.HexY - i - Random(1,d), pidy[Random(0,10)], 1);
	it2.Val0 = Random(0,ammo);
	it2.Val2 = 9999;
	it2.Update(); 
	if(it2.GetType() == ITEM_TYPE_WEAPON)
		_weapon_perk(it2, false);
	if(it2.GetType() == ITEM_TYPE_ARMOR)
		_armor_perk(it2, false);
	Item@ it3 = map.AddItem(cr.HexX - i - Random(1,d), cr.HexY + i + Random(1,d), pidy[Random(0,10)], 1);
	it3.Val0 = Random(0,ammo);
	it3.Val2 = 9999;
	it3.Update(); 
	if(it3.GetType() == ITEM_TYPE_WEAPON)
		_weapon_perk(it3, false);
	if(it3.GetType() == ITEM_TYPE_ARMOR)
		_armor_perk(it3, false);
	Item@ it4 = map.AddItem(cr.HexX - i - Random(1,d), cr.HexY - i - Random(1,d), pidy[Random(0,10)], 1);
	it4.Val0 = Random(0,ammo);
	it4.Val2 = 9999;
	it4.Update();
	if(it4.GetType() == ITEM_TYPE_WEAPON)
		_weapon_perk(it4, false);
	if(it4.GetType() == ITEM_TYPE_ARMOR)
		_armor_perk(it4, false);

	map.AddItem(cr.HexX + i + Random(1,d), cr.HexY + i + Random(1,d), ammopid[Random(0,7)], Random(1,1000));
	map.AddItem(cr.HexX + i + Random(1,d), cr.HexY - i - Random(1,d), ammopid[Random(0,7)], Random(1,1000));
	map.AddItem(cr.HexX - i * Random(1,d), cr.HexY + i + Random(1,d), ammopid[Random(0,7)], Random(1,1000));
	map.AddItem(cr.HexX - i * Random(1,d), cr.HexY - i - Random(1,d), ammopid[Random(0,7)], Random(1,1000));
	}
}

void scorring(Critter& cr, int playerid, int score, int amount)
{
	switch(score)
	{
	case 1: score = SCORE_EVENT_PVP; break;
	case 2: score = SCORE_EVENT_PVE; break;
	case 3: score = SCORE_EVENT_TB; break;
	case 4: score = SCORE_EVENT_GMA; break;
	case 5: score = SCORE_EVENT_FACTION; break;
	}
	Critter@ player = (playerid == 0 ? @cr : GetCritter(playerid));
	if(score != SCORE_EVENT_FACTION)
	AddScore(player, score, amount);
	else
		{
		IFaction@ faction = GetFactionByIdx(amount);
		SetBestScore(SCORE_EVENT_FACTION, null, faction.get_Name());
		}
}

void normallook(Critter& cr, int p, int r, int)
{
    if(r != 878787 && p != 0)
        return;
    Critter@ player = (p == 0 ? @cr : GetCritter(p));
    _CritUnsetExtMode(player, MODE_EXT_LOOK_ADMIN);
    _CritUnsetExtMode(player, MODE_EXT_LOOK_INVISIBLE);
}
void check_param(Critter& cr, int p, int r, int)
{
	Log("param " + cr.Param[p]);
	Log("paramBase " + cr.ParamBase[p]);

}
void imsospeed(Critter& cr, int p0, int p1, int p2)
{
    Critter@ target = cr;
    if(p1 > 0)
        @target = GetCritter(p1);
    if(!valid(target))
        return;

    if(p0 == 0)
        p0 = 500;

    SetLvar(target, LVAR_extra_speed, p0);
}

void DeleteLocsByPid(Critter& cr, int pid, int , int)
{
	array<Location@> locs;
	uint num = GetAllLocations(pid, locs);
	uint deletedlocs = 0;
	
	for(uint i = 0; i < num; i++)
	{
		if(valid(locs[i]))
		{
			DeleteLocation(locs[i].Id);
			cr.Say(SAY_NETMSG, "Deleted location with id: " + locs[i].Id);
			deletedlocs++;
		}
	}
	cr.Say(SAY_NETMSG, "Deleted " + deletedlocs + " locations.");
}

void vals(Critter& cr, int, int, int id)
{
    if(id > 0)
    {
        Item@ it = GetItem(id);
        if(valid(it))
        {
            cr.Say(SAY_NETMSG, "Val0: " + it.Val0);
            cr.Say(SAY_NETMSG, "Val1: " + it.Val1);
            cr.Say(SAY_NETMSG, "Val2: " + it.Val2);
            cr.Say(SAY_NETMSG, "Val3: " + it.Val3);
            cr.Say(SAY_NETMSG, "Val4: " + it.Val4);
            cr.Say(SAY_NETMSG, "Val5: " + it.Val5);
            cr.Say(SAY_NETMSG, "Val6: " + it.Val6);
            cr.Say(SAY_NETMSG, "Val7: " + it.Val7);
            cr.Say(SAY_NETMSG, "Val8: " + it.Val8);
            cr.Say(SAY_NETMSG, "Val2: " + it.Val2);
            return;
        }
    }
    cr.Say(SAY_NETMSG, "Item id not valid (format: ~run cheats vals 0 0 id)");
}

void Fly(Critter& cr, int pid, int p1, int p2)
{
    if(p2 == 0)
    {
        Critter@ to = GetCritter(p1);
        cr.GetMap().RunFlyEffect(pid, cr, to, cr.HexX, cr.HexY, to.HexX, to.HexY);
    }
    else
    {
        cr.GetMap().RunFlyEffect(pid, cr, null, cr.HexX, cr.HexY, p1, p2);
    }
}

void INFERNO(Critter& cr, int pid, int p1, int p2)
{
	uint16 x = 0;
	uint16 y = 0;
	cr.GetMap().MoveHexByDir(x, y, 4, p1);
        for(uint8 stepDir = 0; stepDir < 6; stepDir++)
        {
            for(int step = 0; step < p1; step++)
            {
                cr.GetMap().MoveHexByDir(x, y, stepDir, 1);
				cr.GetMap().RunFlyEffect(pid, cr, null, cr.HexX, cr.HexY, x, y);
            }
        }
}

void grab(Critter& player, int, int, int id)
{
    Item@ grabThis = GetItem(id);
    if(valid(grabThis))
    {
        MoveItem(grabThis, grabThis.GetCount(), player);
    }
}

void checkparam2(Critter& cr, int p, int r, int)
{
    Critter@ target = GetCritter(r);
    if(!valid(target))
        return;
    if(GodOfTheRealm(target.Id))
        @target = null;
    cr.Say(SAY_NETMSG, "param " + p + ": " + target.Param[p]);
}

void mapdata(Critter& cr, int p, int, int)
{
    cr.Say(SAY_NETMSG, "map data " + p + ": " + cr.GetMap().GetData(p));
}

void setmapdata(Critter& cr, int p, int r, int)
{
    cr.GetMap().SetData(p, r);
}

void massteleport(Critter& cr, int p0, int p1, int p2)
{
    array<Critter@> crits;
    uint            n = cr.GetMap().GetCritters(0, FIND_ALL | FIND_ONLY_PLAYERS, crits);
    for(uint i = 0; i < n; i++)
        crits[i].TransitToMap(p0, 0);
}

void givebuffed(Critter& cr, int pid, int count, int magic)
{
	for( int i =1; i <= count; i++ )
	{
	Item@ item = cr.AddItem(pid, 1);
	AddBonuses(item, magic);
	if(item.GetType() == ITEM_TYPE_ARMOR || item.GetType() == ITEM_TYPE_WEAPON)
	SetLexem(item, "$spawnedby", cr.Name);
	}
}

array<string> authName;
array<uint>   authId;

string GetAuthed(uint id)
{
    for(uint a = 0, aLen = authId.length(); a < aLen; a++)
    {
        if(authId[a] == id)
            return(authName[a]);
    }

    return("[error:" + id + "]");
}


string AuthedInfo(uint id)
{
    string gm = GetAuthed(id);
    string player = GetSafePlayerName(id);
    if(gm != player)
        gm += " (" + player + ",";
    else
        gm += " (";

    Critter@ cr = GetCritter(id);
    if(valid(cr) && cr.GetMapId() > 0)
        gm += "map:" + cr.GetMapId() + ",id:";

    gm += id + ")";

    return(gm);
}

void SetAuthed(uint id, string name)
{
    for(uint a = 0, aLen = authId.length(); a < aLen; a++)
    {
        if(authId[a] == id)
        {
            authName[a] = name;
            return;
        }
    }

    authId.insertLast(id);
    authName.insertLast(name);
}

void RemoveAuthed(uint id)
{
    for(uint a = 0, aLen = authId.length(); a < aLen; a++)
    {
        if(authId[a] == id)
        {
            authId.removeAt(a);
            authName.removeAt(a);
            return;
        }
    }
}

/*
   // for older code
   uint LastSpawnedNpc( Critter& player ) // Export
   {
        return( player.LastSpawnedCritter );
   }

   uint LastSpawnedItem( Critter& player ) // Export
   {
        return( player.LastSpawnedItem );
   }
 */

uint GetRandomDeathAnimation()
{
    // because there's hole between first and last ones
    array<uint> anims =
    {
        ANIM2_DEAD_FRONT, ANIM2_DEAD_BACK, ANIM2_DEAD_BLOODY_SINGLE, ANIM2_DEAD_BLOODY_BURST, ANIM2_DEAD_BURST,
        ANIM2_DEAD_PULSE, ANIM2_DEAD_PULSE_DUST, ANIM2_DEAD_LASER, ANIM2_DEAD_FUSED, ANIM2_DEAD_EXPLODE, ANIM2_DEAD_BURN, ANIM2_DEAD_BURN_RUN
    };


    return random_from_array(anims);
}

// helper
string GenderString(Critter& player, string male, string female, string it)
{
    switch(player.Param[ST_GENDER])
    {
    case GENDER_MALE:
        return(male);
    case GENDER_FEMALE:
        return(female);
    case GENDER_IT:
    default:
        return(it);
    }
    ;
    return(it);
}

//
// Execute give command
//
// give item_pid number_of_items
//
void ExecGiveCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    bool legit = false;
    cheatGetOption(command, legit, "-legit");
    if(legit && player.GetAccess() < ACCESS_MODER)
    {
        player.Say(SAY_NETMSG, "You need admin access level to give a legit item.");
        return;
    }
    #ifndef __DEBUG__
    if(_IsRealPlayer(target) && !legit)
    {
        Map@ map = target.GetMap();
        if(!valid(map) || (valid(map) && _IsLegit(map.GetData(MAP_DATA_SPAWNER))))
        {
            player.Say(SAY_NETMSG, "You can't give not legit items to a player in a legit map.");
            return;
        }
    }
    #endif

    player.Say(SAY_NETMSG, "Executing give command");

    int pid = 0, number = 1;
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    // try to parse pid if it was passed as number
    bool parsed = StrToInt(command[2], pid);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetItemPid(command[2], pid))
        {
            player.Say(SAY_NETMSG, "Item does not exist");
            return;
        }
    }
    if(command.length() > 3)
    {
        // we just use 1 in case of failure
        StrToInt(command[3], number);
    }

    if(number == 0)
    {
        player.Say(SAY_NETMSG, "Nothing to spawn.");
        return;
    }
    else if(number < 0)
    {
        player.Say(SAY_NETMSG, "Negative value, nothing to spawn.");
        return;
    }
	//if(number >= 150 && pid!=41 || pid!=25568 || pid!=25570 || pid!= 29 || pid!= 30 || pid!= 31 || pid!= 33 || pid!= 34 || pid!= 35 || pid!= 36 || pid!= 95 || pid!= 111 || pid!= 121 || pid!= 359 || pid!= 357 || pid!= 358 || pid!= 360 || pid!= 363 || pid!= 574 || pid!= 575 || pid!= 576 || pid!= 621 || pid!= 850 || pid!= 361 || pid!= 362  || pid!= 32 || pid!= 382 || pid!= 14 || pid!= 37 || pid!= 38 || pid!= 39 || pid!= 163 || pid!= 40 || pid!= 48 || pid!= 49 || pid!= 109 || pid!= 144 || pid!= 260 || pid!= 273 || pid!= 525 || pid!= 9655  || pid!= 106 || pid!= 124 || pid!= 125 || pid!= 310 || pid!= 311 || pid!= 469  || pid!=  53 || pid!=  87 || pid!= 110 || pid!= 259 || pid!= 71 || pid!= 81 || pid!= 103 || pid!= 378 || pid!= 41 || pid!= 420 || pid!= 494 || pid!= 519 || pid!= 9715)
	//{
	//player.Say(SAY_NETMSG, "Too much items, nothing to spawn.");
	//return;
	//}
    Item@ item = number > 0 ? target.AddItem(pid, 1) : null;
    if(valid(item))
    {
        if(legit)     // record spawner id
        {
            ILog("legitspawn", AuthedInfo(player.Id) + " gave legit item " +  "(Id:" + item.Id + ") to critter " + target.Id);
            _SetSpawnerLegit(item, player);
        }
        else
        {
            _SetSpawner(item, player);
        }
		for( int i =1; i <= number; i++ )
		{
		if(item.GetType() == ITEM_TYPE_ARMOR || item.GetType() == ITEM_TYPE_WEAPON)
			SetLexem(item, "$spawnedby", player.Name);
		}
        player.Say(SAY_NETMSG, "Whoa, I've just found " + number + " item(s) with pid " + pid);

        string script = GetParameterString(command, "-script");
        if(script != "")
        {
            player.Say(SAY_NETMSG, "Script: " + script);
            if(!item.SetScript(script))
                player.Say(SAY_NETMSG, " !! ERROR setting script.");
            item.Update();
        }

        if(GetGvar(GVAR_event_status) == 1)
        {
            eventItems.insertLast(item.Id);
        }
        player.LastSpawnedItem = item.Id;
        // item.SpawnedBy = player.Id;
        if(item.IsStackable())
            item.SetCount(number);
        else
        {
            for(int i = 1; i < number; i++)
            {
                @item = target.AddItem(pid, 1);
                if(legit)     // record spawner id
                {
                    ILog("legitspawn", AuthedInfo(player.Id) +  " gave legit item " +  "(Id:" + item.Id + ") to critter " + target.Id);
                    _SetSpawnerLegit(item, player);
                }
                else
                {
                    _SetSpawner(item, player);
                }
                item.SetScript(script);
				if(!legit)
					item.Val2 = 9999;
                item.Update();
            }
        }
    }
    else
        player.Say(SAY_NETMSG, "Failed to create " + number + " item(s) with pid " + pid);
}

void ExecMassGiveCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
	array<Critter@> crits;
    uint            n = player.GetMap().GetCritters(0, FIND_ALL | FIND_ONLY_PLAYERS, crits);
    for(uint i = 0; i < n; i++)
	{
    bool legit = false;
    cheatGetOption(command, legit, "-legit");
    if(legit && player.GetAccess() < ACCESS_MODER)
    {
        player.Say(SAY_NETMSG, "You need admin access level to give a legit item.");
        return;
    }
    #ifndef __DEBUG__
    if(_IsRealPlayer(crits[i]) && !legit)
    {
        Map@ map = crits[i].GetMap();
        if(!valid(map) || (valid(map) && _IsLegit(map.GetData(MAP_DATA_SPAWNER))))
        {
            player.Say(SAY_NETMSG, "You can't give not legit items to a player in a legit map.");
            return;
        }
    }
    #endif

    player.Say(SAY_NETMSG, "Executing give command");

    int pid = 0, number = 1;
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    // try to parse pid if it was passed as number
    bool parsed = StrToInt(command[2], pid);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetItemPid(command[2], pid))
        {
            player.Say(SAY_NETMSG, "Item does not exist");
            return;
        }
    }
    if(command.length() > 3)
    {
        // we just use 1 in case of failure
        StrToInt(command[3], number);
    }

    if(number == 0)
    {
        player.Say(SAY_NETMSG, "Nothing to spawn.");
        return;
    }
    else if(number < 0)
    {
        player.Say(SAY_NETMSG, "Negative value, nothing to spawn.");
        return;
    }
	//if(number >= 150 && pid!=41 || pid!=25568 || pid!=25570 || pid!= 29 || pid!= 30 || pid!= 31 || pid!= 33 || pid!= 34 || pid!= 35 || pid!= 36 || pid!= 95 || pid!= 111 || pid!= 121 || pid!= 359 || pid!= 357 || pid!= 358 || pid!= 360 || pid!= 363 || pid!= 574 || pid!= 575 || pid!= 576 || pid!= 621 || pid!= 850 || pid!= 361 || pid!= 362  || pid!= 32 || pid!= 382 || pid!= 14 || pid!= 37 || pid!= 38 || pid!= 39 || pid!= 163 || pid!= 40 || pid!= 48 || pid!= 49 || pid!= 109 || pid!= 144 || pid!= 260 || pid!= 273 || pid!= 525 || pid!= 9655  || pid!= 106 || pid!= 124 || pid!= 125 || pid!= 310 || pid!= 311 || pid!= 469  || pid!=  53 || pid!=  87 || pid!= 110 || pid!= 259 || pid!= 71 || pid!= 81 || pid!= 103 || pid!= 378 || pid!= 41 || pid!= 420 || pid!= 494 || pid!= 519 || pid!= 9715)
	//{
	//player.Say(SAY_NETMSG, "Too much items, nothing to spawn.");
	//return;
	//}
    Item@ item = number > 0 ? crits[i].AddItem(pid, 1) : null;
    if(valid(item))
    {
        if(legit)     // record spawner id
        {
            ILog("legitspawn", AuthedInfo(player.Id) + " gave legit item " +  "(Id:" + item.Id + ") to critter " + crits[i].Id);
            _SetSpawnerLegit(item, player);
        }
        else
        {
            _SetSpawner(item, player);
        }
		for( int i =1; i <= number; i++ )
		{
		if(item.GetType() == ITEM_TYPE_ARMOR || item.GetType() == ITEM_TYPE_WEAPON)
			SetLexem(item, "$spawnedby", player.Name);
		}
        player.Say(SAY_NETMSG, "Whoa, I've just found " + number + " item(s) with pid " + pid);

        string script = GetParameterString(command, "-script");
        if(script != "")
        {
            player.Say(SAY_NETMSG, "Script: " + script);
            if(!item.SetScript(script))
                player.Say(SAY_NETMSG, " !! ERROR setting script.");
            item.Update();
        }

        if(GetGvar(GVAR_event_status) == 1)
        {
            eventItems.insertLast(item.Id);
        }
        player.LastSpawnedItem = item.Id;
        // item.SpawnedBy = player.Id;
        if(item.IsStackable())
            item.SetCount(number);
        else
        {
            for(int i = 1; i < number; i++)
            {
                @item = crits[i].AddItem(pid, 1);
                if(legit)     // record spawner id
                {
                    ILog("legitspawn", AuthedInfo(player.Id) +  " gave legit item " +  "(Id:" + item.Id + ") to critter " + crits[i].Id);
                    _SetSpawnerLegit(item, player);
                }
                else
                {
                    _SetSpawner(item, player);
                }
                item.SetScript(script);
                item.Update();
            }
        }
    }
    else
        player.Say(SAY_NETMSG, "Failed to create " + number + " item(s) with pid " + pid);
	}
}


void ExecAutoBalanceCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
	int type = 0;
    cheatGetOption(command, type, "-a");
	int typeB = 0;
    cheatGetOption(command, typeB, "-b");
	int typeC = 0;
    cheatGetOption(command, typeC, "-c");
	int typeD = 0;
    cheatGetOption(command, typeD, "-d");
	
	int teams = 2;
	if(typeC>0)
		teams = 3;
	if(typeD>0)
		teams = 4;

	int teamA = 204;
	int teamB = 206;
	int teamC = 207;
	int teamD = 212;
	switch(type)
	{
	case 1: teamA = 204; break;
	case 2: teamA = 209; break;
	case 3: teamA = 207; break;
	case 4: teamA = 206; break;
	case 5: teamA = 208; break;
	case 6: teamA = 212; break;
	default: break;
	}
	switch(typeB)
	{
	case 1: teamB = 204; break;
	case 2: teamB = 209; break;
	case 3: teamB = 207; break;
	case 4: teamB = 206; break;
	case 5: teamB = 208; break;
	case 6: teamB = 212; break;
	default: break;
	}
	switch(typeC)
	{
	case 1: teamC = 204; break;
	case 2: teamC = 209; break;
	case 3: teamC = 207; break;
	case 4: teamC = 206; break;
	case 5: teamC = 208; break;
	case 6: teamC = 212; break;
	default: break;
	}
	switch(typeD)
	{
	case 1: teamD = 204; break;
	case 2: teamD = 209; break;
	case 3: teamD = 207; break;
	case 4: teamD = 206; break;
	case 5: teamD = 208; break;
	case 6: teamD = 212; break;
	default: break;
	}
	Log("1");
	array<Critter@> crits;
    uint            n = player.GetMap().GetCritters(0, FIND_ALL| FIND_ONLY_PLAYERS , crits);//| FIND_ONLY_PLAYERS
    for(uint i = 0; i < n+1; i += teams)
	{
	//if(crits[i].GetAccess() != ACCESS_CLIENT)
	//	continue;
	if(!valid(crits[i]))
		continue;
	if(!valid(crits[i+1]))
		continue;
		
	
	if(crits[i].Param[ST_LEVEL] > 24)
		{
		crits[i].ParamBase[ST_NPC_ROLE] = teamA;
		team(player, type, 15, crits[i].Id);
		}
	if(crits[i+1].Param[ST_LEVEL] > 24)	
		{
		crits[i+1].ParamBase[ST_NPC_ROLE] = teamB;
		team(player, typeB, 15, crits[i+1].Id);
		}
	if(teams>2)
		{
		if(!valid(crits[i+2]))
		continue;
		if(crits[i+2].Param[ST_LEVEL] > 24)
			{
			crits[i+2].ParamBase[ST_NPC_ROLE] = teamC;
			team(player, typeC, 15, crits[i+2].Id);
			}
		}
	if(teams>3)
		{
		if(!valid(crits[i+3]))
		continue;
		if(crits[i+3].Param[ST_LEVEL] > 24)
			{
			crits[i+3].ParamBase[ST_NPC_ROLE] = teamD;
			team(player, typeD, 15, crits[i+3].Id);
			}
		}
    }
	
}

void AutoBalance(Map& map)
{
	int type = 0;
	int typeB = 0;
	int typeC = 0;
	int typeD = 0;
	

	int teamA = 231;
	int teamB = 232;
	int teamC = 233;
	int teamD = 234;
	
	array<Critter@> crits;
    uint            n = map.GetCritters(0, FIND_ALL| FIND_ONLY_PLAYERS , crits);//| FIND_ONLY_PLAYERS
	Critter@ player = AddNpc(map, 2,2 , 1, 3, 0, "", 0, 0, 0, true, 1);
    for(uint i = 0; i < n; i += 4)
	{
	//if(crits[i].GetAccess() != ACCESS_CLIENT)
	//	continue;
	if(!valid(crits[i]))
		continue;
	crits[i].AddScoreVal(SCORE_WE_KILLS, 0);
	crits[i].AddScoreVal(SCORE_WE_PLAYERS_KILLS, 0);
	crits[i].AddScoreVal(SCORE_WE_FF, 0);
	crits[i].AddScoreVal(SCORE_WE_PLAYERS_FF, 0);
	crits[i].AddScoreVal(SCORE_WE_DEATHS, 0);
	DropDrugEffects(crits[i], true);
	crits[i].ParamBase[ST_NPC_ROLE] = teamA;
	team(player, type, 15, crits[i].Id);
	if(!valid(crits[i+1]))
		continue;
	crits[i+1].ParamBase[ST_NPC_ROLE] = teamB;
	team(player, typeB, 15, crits[i+1].Id);
	
	if(!valid(crits[i+2]))
		continue;
	crits[i+2].ParamBase[ST_NPC_ROLE] = teamC;
	team(player, typeC, 15, crits[i+2].Id);
		

	if(!valid(crits[i+3]))
		continue;
	crits[i+3].ParamBase[ST_NPC_ROLE] = teamD;
	team(player, typeD, 15, crits[i+3].Id);
		
    }
	
}

void rebalance(Critter& player, int type, int typeB, int typeC)
{
	//Log("2");
	array<Critter@> critsa;
	array<Critter@> critsb;
	array<Critter@> critsc;
	array<Critter@> critsd;
	int teamA = 204;
	int teamB = 206;
	int teamC = 207;
	int teamD = 212;
	switch(type)
	{
	case 1: teamA = 204; break;
	case 2: teamA = 209; break;
	case 3: teamA = 207; break;
	case 4: teamA = 206; break;
	case 5: teamA = 208; break;
	case 6: teamA = 212; break;
	default: break;
	}
	switch(typeB)
	{
	case 1: teamB = 204; break;
	case 2: teamB = 209; break;
	case 3: teamB = 207; break;
	case 4: teamB = 206; break;
	case 5: teamB = 208; break;
	case 6: teamB = 212; break;
	default: break;
	}
	switch(typeC)
	{
	case 1: teamC = 204; break;
	case 2: teamC = 209; break;
	case 3: teamC = 207; break;
	case 4: teamC = 206; break;
	case 5: teamC = 208; break;
	case 6: teamC = 212; break;
	default: break;
	}
	array<Critter@> crits2;
    uint            x = player.GetMap().GetCritters(0, FIND_ALL| FIND_ONLY_PLAYERS , crits2);//| FIND_ONLY_PLAYERS
	for(uint i = 0; i < x; i++)
	{
	if(crits2[i].GetAccess() != ACCESS_CLIENT)
		continue;
	//Log("3 " + i);
	if(teamA == 204 || teamB == 204  || teamC == 204  || teamD == 204 ) //enclave
		{
		if(crits2[i].Param[ST_TEAM_ID] != 3)
			continue;
		crits2[i].ParamBase[ST_NPC_ROLE] = 204;
		//Log("4 " + i);
		}
	if(teamA == 209 || teamB == 209  || teamC == 209  || teamD == 209 ) //alliance
		{
		if(crits2[i].Param[ST_TEAM_ID] != 2)
			continue;
		crits2[i].ParamBase[ST_NPC_ROLE] = 209;
		//Log("4b " + i);
		}
	if(teamA == 206 || teamB == 206  || teamC == 206  || teamD == 206 ) //vc
		{
		if(crits2[i].Param[ST_TEAM_ID] != 6)
			continue;
		crits2[i].ParamBase[ST_NPC_ROLE] = 206;
		}
	if(teamA == 212 || teamB == 212  || teamC == 212  || teamD == 212 ) //tma
		{
		if(crits2[i].Param[ST_TEAM_ID] != 4)
			continue;
		crits2[i].ParamBase[ST_NPC_ROLE] = 212;
		}
	}
	//Log("5");
	uint            a = player.GetMap().GetCritters(teamA, FIND_ALL| FIND_ONLY_PLAYERS , critsa);//| FIND_ONLY_PLAYERS
	uint            b = player.GetMap().GetCritters(teamB, FIND_ALL| FIND_ONLY_PLAYERS , critsb);
	uint            c = player.GetMap().GetCritters(teamC, FIND_ALL| FIND_ONLY_PLAYERS , critsc);
	uint            d = player.GetMap().GetCritters(teamD, FIND_ALL| FIND_ONLY_PLAYERS , critsd);
	if(a != b)
	{
	if(a+1 == b)
		{
		//Log("6");
		return;
		}
	if(b+1 == a)
		{
	//	Log("7");
		return;
		}
	player.Say(SAY_NETMSG, "Need Rebalance.");
	//Log("8");
	if(a>b)
		{
		for(uint i = 0; i < a+1; i++)
			{
			critsa[i].ParamBase[ST_NPC_ROLE] = teamB;
			a = player.GetMap().GetCritters(teamA, FIND_ALL| FIND_ONLY_PLAYERS , critsa);//| FIND_ONLY_PLAYERS
			b = player.GetMap().GetCritters(teamB, FIND_ALL| FIND_ONLY_PLAYERS , critsb);
			//Log("9 " + i);
			if(a==b)
				{
			//	Log("10 " + i);
				return;
				}
			if(b>a)
				{
			//	Log("11 " + i);
				return;
				}
			}
		}
	if(b>a)
		{
		for(uint i = 0; i < b+1; i++)
			{
			critsb[i].ParamBase[ST_NPC_ROLE] = teamA;
			a = player.GetMap().GetCritters(teamA, FIND_ALL| FIND_ONLY_PLAYERS , critsa);//
			b = player.GetMap().GetCritters(teamB, FIND_ALL| FIND_ONLY_PLAYERS , critsb);
			//Log("12 " + i);
			if(a==b)
				{
				//Log("13 " + i);
				return;
				}
			if(a>b)
				{
				//Log("14 " + i);
				return;
				}
			}
		}
	//Log("15");
	}
//	Log("16");
}
//
// GiveKey command
//
// givekey keyid number
//
void ExecGiveKeyCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    bool legit = false;
    cheatGetOption(command, legit, "-legit");
    if(legit && player.GetAccess() < ACCESS_ADMIN)
    {
        player.Say(SAY_NETMSG, "You need admin access level to create a legit key.");
        return;
    }
    #ifndef __DEBUG__
    if(_IsRealPlayer(target) && !legit)
    {
        Map@ map = target.GetMap();
        if(!valid(map) || (valid(map) && _IsLegit(map.GetData(MAP_DATA_SPAWNER))))
        {
            player.Say(SAY_NETMSG, "You can't give not legit items to a player in a legit map.");
            return;
        }
    }
    #endif

    player.Say(SAY_NETMSG, "Executing give key command");

    int id = 0, number = 1;
    if(command.length() < 2)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }

    bool parsed = StrToInt(command[2], id);
    if(!parsed)
    {
        player.Say(SAY_NETMSG, "Wrong key id");
        return;
    }
    if(command.length() > 3)
    {
        // we just use 1 in case of failure
        StrToInt(command[3], number);
    }
    // everything should be ok (id still may be bad)
    player.Say(SAY_NETMSG, "" + number + " key(s) with id " + id + " created.");
    Item@ it = target.AddItem(PID_KEY, number);
    // wonder what about stackables
    if(valid(it))
    {
        it.LockerId = id;
        if(legit)     // record spawner id
        {
            ILog("legitspawn", AuthedInfo(player.Id) + " spawned legit key " + id + " (Id:" + it.Id + ")");
            _SetSpawnerLegit(it, player);
        }
        else
        {
            _SetSpawner(it, player);
        }
        it.Update();

        if(GetGvar(GVAR_event_status) == 1)
            eventItems.insertLast(it.Id);

        player.LastSpawnedItem = it.Id;
        // it.SpawnedBy = player.Id;
    }
}

//
// ExecAddNpcCommand
//
// Spawns NPC with default parameters
// AddNpc pid deltaX deltaY
// coords of NPC are calculated basing on players position and delta params
//
// Switches used:
void ExecAddNpcCommand(array<string@>@ command, Critter@ player, Critter@ target, bool isMob, bool isFollower)
{
    if(isMob)
        player.Say(SAY_NETMSG, "Executing AddMob command");
    else if(!isFollower)
        player.Say(SAY_NETMSG, "Executing AddNpc command");
    else
        player.Say(SAY_NETMSG, "Executing AddFollower command");

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    uint16 pid = 0;
    if(!StrToInt(command[2], pid))      // ||
    // not StrToInt(command[3], deltaX) ||
    // not StrToInt(command[4], deltaY))
    {
        player.Say(SAY_NETMSG, "Invalid arguments");
        return;
    }

    // everything should be ok

    Map@ map = player.GetMap();
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "I wasn't able to obtain map object");
        return;
    }

    int dist = 1;
    StrToInt(GetParameterString(command, "-dist"), dist);

    int x = target.HexX;
    int y = target.HexY;
    StrToInt(GetParameterString(command, "-x"), x);
    StrToInt(GetParameterString(command, "-y"), y);

    int dir = Random(0, 6);
    StrToInt(GetParameterString(command, "-dir"), dir);

    int dialogId = 0;
    StrToInt(GetParameterString(command, "-d"), dialogId);

    string script = GetParameterString(command, "-s");

    int    aiPack = 0;
    StrToInt(GetParameterString(command, "-a"), aiPack);

    int bagId = 0;
    StrToInt(GetParameterString(command, "-b"), bagId);

    int teamIdPack = 0;
    StrToInt(GetParameterString(command, "-t"), teamIdPack);

    int level = 1;
    StrToInt(GetParameterString(command, "-l"), level);

    int respawnTime = -1;
    StrToInt(GetParameterString(command, "-r"), respawnTime);

    int npcRole = 0;
    StrToInt(GetParameterString(command, "-role"), npcRole);

    int crType = 0;
    StrToInt(GetParameterString(command, "-skin"), crType);

    int num = 1;
    if(!StrToInt(GetParameterString(command, "-z"), num))
    {
        num = 1;
    }
    ;

    if(isFollower)
    {
        script = "follower@critter_init";
        if(dialogId == 0)
            dialogId = 9310;
    }

    if(isMob)
    {
        script = SCRIPT_mob;
    }
    //	Critter@ npc=AddNpc(CurMap, pid,hexX,hexY,dir,dialogId,scriptId,aiPack,bagId,teamIdPack,isMob,NpcLevel);

    // player.Say( SAY_NETMSG, "Before spawning "+num+" critter(s)");
    for(int i = 0; i < num; i++)
    {
        // player.Say( SAY_NETMSG, "Spawning critter "+(i+1)+"/"+num );
        Critter@ SpawnedNpc = AddNpc(map, pid, x + Random(-dist, dist), y + Random(-dist, dist), dir,
                                     dialogId, script, aiPack, bagId, teamIdPack / 100, (teamIdPack / 10) % 10, teamIdPack % 10, isMob, level);

        if(!valid(SpawnedNpc))
        {
            player.Say(SAY_NETMSG, "Failed to spawn NPC.");
            return;
        }

        SpawnedNpc.ParamBase[ST_REPLICATION_TIME] = respawnTime;
        SpawnedNpc.ParamBase[ST_NPC_ROLE] = npcRole;
        if(crType != 0)
        {
            SpawnedNpc.ChangeCrType(crType);
            SpawnedNpc.ParamBase[ST_BASE_CRTYPE] = crType;
        }
        if(GetGvar(GVAR_event_status) == 1)
        {
            eventCritters.insertLast(SpawnedNpc.Id);
            _CritSetExtMode(SpawnedNpc, MODE_EXT_EVENT);
        }

        if(GetIndexOfString(command, "-e") != -1)
            _CritSetExtMode(SpawnedNpc, MODE_EXT_NO_ATTACK_AUTH);


        player.Say(SAY_NETMSG, "Spawned npc: " + pid);
        player.Say(SAY_NETMSG, "Dialog: " + dialogId);
        player.Say(SAY_NETMSG, "Script: " + script);
        player.Say(SAY_NETMSG, "AiPack: " + aiPack);
        player.Say(SAY_NETMSG, "Bag: " + bagId);
        player.Say(SAY_NETMSG, "TeamPack: " + teamIdPack);
        player.Say(SAY_NETMSG, "Level: " + level);

        if(isFollower)
        {
            MakeFollower(SpawnedNpc, FOLLOWER_TYPE_MERC_HUMAN_UNARMED, "follower@FollowerBaseInit", dialogId, target, true);

            string name = GetParameterString(command, "-name");

            if(name == "")
                name = GetRandomFullName(SpawnedNpc.Param[ST_GENDER]);
            SetLexem(SpawnedNpc, "$name", name);

            int attackpolicy = 0;
            StrToInt(GetParameterString(command, "-c"), attackpolicy);
            SpawnedNpc.FollowerVarBase[FV_ATTACK_POLICY] = attackpolicy;

            int mode = 0;
            StrToInt(GetParameterString(command, "-f"), mode);
            SpawnedNpc.FollowerVarBase[FV_MODE] = mode;
        }
        player.LastSpawnedCritter = SpawnedNpc.Id;
        SpawnedNpc.SpawnedBy = player.Id;
    }
}

/**
 * Spawns item on map.
 */
void ExecSpawnItemCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    bool legit = false;
    cheatGetOption(command, legit, "-legit");
    if(legit && player.GetAccess() < ACCESS_ADMIN)
    {
        player.Say(SAY_NETMSG, "You need admin access level to spawn a legit item.");
        return;
    }

    player.Say(SAY_NETMSG, "Spawning fat loot...");
    Map@ map = target.GetMap();
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "Target on worldmap...");
        return;
    }
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    uint16 pid = 0;
    // try to parse pid if it was passed as number
    bool   parsed = StrToInt(command[2], pid);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetItemPid(command[2], pid))
        {
            player.Say(SAY_NETMSG, "Item pid does not exist in the list.");
            return;
        }
    }
    int count = 1;
    if(command.length() > 3)
        StrToInt(command[3], count);
    if(count == 0)
    {
        player.Say(SAY_NETMSG, "Nothing to spawn.");
        return;
    }
    else if(count < 0)
    {
        player.Say(SAY_NETMSG, "Negative value, nothing to spawn.");
        return;
    }
	if(count >= 150)
	{
	if(pid!=41 || pid!=25568 || pid!=25570 || pid!= 29 || pid!= 30 || pid!= 31 || pid!= 33 || pid!= 34 || pid!= 35 || pid!= 36 || pid!= 95 || pid!= 111 || pid!= 121 || pid!= 359 || pid!= 357 || pid!= 358 || pid!= 360 || pid!= 363 || pid!= 574 || pid!= 575 || pid!= 576 || pid!= 621 || pid!= 850 || pid!= 361 || pid!= 362  || pid!= 32 || pid!= 382 || pid!= 14 || pid!= 37 || pid!= 38 || pid!= 39 || pid!= 163 || pid!= 40 || pid!= 48 || pid!= 49 || pid!= 109 || pid!= 144 || pid!= 260 || pid!= 273 || pid!= 525 || pid!= 9655  || pid!= 106 || pid!= 124 || pid!= 125 || pid!= 310 || pid!= 311 || pid!= 469  || pid!=  53 || pid!=  87 || pid!= 110 || pid!= 259 || pid!= 71 || pid!= 81 || pid!= 103 || pid!= 378 || pid!= 41 || pid!= 420 || pid!= 494 || pid!= 519 || pid!= 9715)
		{
		player.Say(SAY_NETMSG, "Too much items, nothing to spawn.");
		return;
		}
	}
    ProtoItem@ proto = GetProtoItem(pid);
    if(!valid(proto))
    {
        player.Say(SAY_NETMSG, "Wrong proto number.");
        return;
    }
    uint16 x = target.HexX;
    uint16 y = target.HexY;
    StrToInt(GetParameterString(command, "-x"), x);
    StrToInt(GetParameterString(command, "-y"), y);

    // check if we can spawn in container
    array<Item@> items;
    Item@        cont;
    map.GetItems(x, y, items);
    if(items.length() == 1 && items[0].GetType() == ITEM_TYPE_CONTAINER)
    {
        player.Say(SAY_NETMSG, "Container detected...");
        @cont = items[0];
    }

    uint max = count;
    StrToInt(GetParameterString(command, "-max"), max);
    uint min = max;
    StrToInt(GetParameterString(command, "-min"), min);
    min = MIN(min, max);
    int chance = 100;
    StrToInt(GetParameterString(command, "-c"), chance);
    chance = CLAMP(chance, 1, 100);
    int amount = 1;
    StrToInt(GetParameterString(command, "-a"), amount);

    bool optLine = false;
    bool optCirc = false;
    cheatGetOption(command, optLine, "-line");
    cheatGetOption(command, optCirc, "-circ");

    // creme de la creme
    if(chance >= Random(1, 100))
    {
        Item@ it;
        count = Random(min, max);
        uint  spawned = 0;
        int   radius = 0;
        StrToInt(GetParameterString(command, "-r"), radius);

        array<uint16> xList;
        array<uint16> yList;
        if(optLine)
        {
            HexLine(player.HexX, player.HexY, x, y, xList, yList);
            count = xList.length;
        }
        else if(optCirc)
        {
            if(radius < 1)
                radius = 1;
            HexCircle(x, y, radius, xList, yList);
            count = xList.length;
        }

        for(int i = 0; i < count; i++)
        {
            if(optLine || optCirc)
            {
                @it = map.AddItem(xList[i], yList[i], pid, 1);
            }
            else
            {
                if(valid(cont))
                    @it = cont.AddItem(pid, 1, 0);
                else
                    @it = map.AddItem(x + Random(-radius, radius), y + Random(-radius, radius), pid, 1);
            }


            if(valid(it))
            {
                if(legit)     // record spawner id
                {
                    ILog("legitspawn", AuthedInfo(player.Id) + " spawned legit item (Id:" + it.Id + ")");
                    _SetSpawnerLegit(it, player);
                }
                else
                {
                    _SetSpawner(it, player);
                }
				
				if(it.GetType() == ITEM_TYPE_ARMOR || it.GetType() == ITEM_TYPE_WEAPON)
					SetLexem(it, "$spawnedby", player.Name);
					
                spawned++;

                if(it.IsStackable())
                    it.SetCount(amount);

                if((it.GetType() == ITEM_TYPE_DOOR || it.GetType() == ITEM_TYPE_CONTAINER) &&
                   it.Proto.Container_Changeble)
                {
                    it.LockerOpen();
                    it.LockerClose();
                }

                if(pid == PID_ACTIVE_MINE)
                {
                    // difficulties
                    SETFLAG(it.Flags, ITEM_TRAP);
                    it.Update();
                    // _ExplodeSetOwner(it, player.Id);
                    uint skill = 150;
                    StrToInt(GetParameterString(command, "-s"), skill);
                    it.TrapValue = skill / 5 + 10;
                    _ExplodeSetBonusDamage(it, skill);
                    if(GetIndexOfString(command, "-b") != -1)
                        _ExplodeSetBonusRadius(it, 1);
                    else
                        _ExplodeSetBonusRadius(it, 0);
                    it.SetScript("explode@_ExplodeInit");
                }
                if(pid == PID_TRAP)
                {
                    // some aliases
                    uint skill = 150;
                    StrToInt(GetParameterString(command, "-s"), skill);
                    _Complexity(it) = skill;
                    uint dmg = 0;
                    StrToInt(GetParameterString(command, "-dmg"), dmg);
                    _BonusDamage(it) = dmg;
                }

                                // other parameters (careful, it overrides various stuff)
                if(GetIndexOfString(command, "-v0") >= 0)
                    StrToInt(GetParameterString(command, "-v0"), it.Val0);
                if(GetIndexOfString(command, "-v1") >= 0)
                    StrToInt(GetParameterString(command, "-v1"), it.Val1);
                if(GetIndexOfString(command, "-v2") >= 0)
                    StrToInt(GetParameterString(command, "-v2"), it.Val2);
                if(GetIndexOfString(command, "-v3") >= 0)
                    StrToInt(GetParameterString(command, "-v3"), it.Val3);
                if(GetIndexOfString(command, "-v4") >= 0)
                    StrToInt(GetParameterString(command, "-v4"), it.Val4);
                if(GetIndexOfString(command, "-v5") >= 0)
                    StrToInt(GetParameterString(command, "-v5"), it.Val5);
                if(GetIndexOfString(command, "-v6") >= 0)
                    StrToInt(GetParameterString(command, "-v6"), it.Val6);
                if(GetIndexOfString(command, "-v7") >= 0)
                    StrToInt(GetParameterString(command, "-v7"), it.Val7);
                if(GetIndexOfString(command, "-v8") >= 0)
                    StrToInt(GetParameterString(command, "-v8"), it.Val8);
				uint wall = 0;	
				StrToInt(GetParameterString(command, "-wall"), wall);
					
				if(wall>0)
				{
				UNSETFLAG(it.Flags, ITEM_NO_BLOCK);
				UNSETFLAG(it.Flags, ITEM_SHOOT_THRU);
				}
                // Val2 used to store spawner id, don't allow to fake that
                it.Update();

                if(it.Val0 != 0)
                {
                    player.Say(SAY_NETMSG, "Val0: " + it.Val0);
                }
                if(it.Val1 != 0)
                {
                    player.Say(SAY_NETMSG, "Val1: " + it.Val1);
                }
                if(it.Val2 != 0)
                {
                    player.Say(SAY_NETMSG, "Val2: " + it.Val2);
                }
                if(it.Val3 != 0)
                {
                    player.Say(SAY_NETMSG, "Val3: " + it.Val3);
                }
                if(it.Val4 != 0)
                {
                    player.Say(SAY_NETMSG, "Val4: " + it.Val4);
                }
                if(it.Val5 != 0)
                {
                    player.Say(SAY_NETMSG, "Val5: " + it.Val5);
                }
                if(it.Val6 != 0)
                {
                    player.Say(SAY_NETMSG, "Val6: " + it.Val6);
                }
                if(it.Val7 != 0)
                {
                    player.Say(SAY_NETMSG, "Val7: " + it.Val7);
                }
                if(it.Val8 != 0)
                {
                    player.Say(SAY_NETMSG, "Val8: " + it.Val8);
                }

                string script = GetParameterString(command, "-script");
                if(script != "")
                {
                    player.Say(SAY_NETMSG, "Script: " + script);
                    it.SetScript(script);
                }
				if(!legit)
					{
					it.Val2 = 9999;
					it.Update();					
					}
                player.LastSpawnedItem = it.Id;
                // it.SpawnedBy = player.Id;

            }
        }
        player.Say(SAY_NETMSG, "" + spawned + " item(s) spawned.");
    }
    else
        player.Say(SAY_NETMSG, "Item(s) not spawned, chance test not passed.");
}
import void forcelights(Critter& cr, int groupId, int on, int nono) from "dynamic_light_source";
import void changelights(Critter& cr, int groupId, int paramId, int paramVal) from "dynamic_light_source";
void ExecDLCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
	Item@ it = player.GetMap().AddItem(player.HexX, player.HexY, 20015, 1);
   	int type = 0;
    cheatGetOption(command, type, "-delete");
	int typeB = 0;
    cheatGetOption(command, typeB, "-add");
	int typeC = 0;
    cheatGetOption(command, typeC, "-buzzing");
	int typeD = 0;
    cheatGetOption(command, typeD, "-change");
	int val0 = 0;
    cheatGetOption(command, val0, "-color");
	int val1 = 0;
    cheatGetOption(command, val1, "-int");
	int val2 = 0;
    cheatGetOption(command, val2, "-rad");
	int val3 = 0;
    cheatGetOption(command, val3, "-group");
	cheatGetOption(command, val3, "-timeOn");
	int val4 = 0;
    cheatGetOption(command, val4, "-timeOff");
	cheatGetOption(command, val4, "-on");
	int val5 = 0;
	cheatGetOption(command, val5, "-off");
	if(typeB>0)
	it.SetScript("dynamic_light_source@_InitLightItem");
	if(typeC>0)
	it.SetScript("dynamic_light_source@_BuzzingLight");
	if(typeD==0)
	{
	it.Val0 = val0;
	it.Val1 = val1;
	it.Val2 = val2;
	it.Val3 = val3;
	it.Val4 = val4;
	}
	
	if(typeD>0)
	{
	if(val4>0)
	forcelights(player, val3, 1, 0);
	if(val5>0)
	forcelights(player, val3, 0, 0);
	if(val0>0)
	changelights(player, val3, 0, val0);
	if(val1>0)
	changelights(player, val3, 1, val1);
	if(val2>0)
	changelights(player, val3, 2, val2);
	}
	
	it.Update();
	
	if(type>0)
	{
	Map@         blockerMap = player.GetMap();

    array<Item@> blockers;
    uint         blockersNum = blockerMap.GetItems(20015, blockers);

    for(uint i = 0; i < blockersNum; i++)
    {
            player.Say(SAY_NETMSG, "Removing lights [" + blockers[i].Val4 + "]: " + blockers[i].HexX + "," + blockers[i].HexY);
            blockerMap.RunEffect(PID_EXPLODE_EMP, blockers[i].HexX, blockers[i].HexY, 0);
            DeleteItem(blockers[i]);
    }
	}
}

/**
 * Locks doors/ container at given coords.
 */
void ExecLockCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Close, Simsim!");

    Map@ map = target.GetMap();
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "Target on the worldmap.");
    }
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    int x = target.HexX;
    int y = target.HexY;
	int c = 0;
    StrToInt(GetParameterString(command, "-x"), x);
    StrToInt(GetParameterString(command, "-y"), y);
	StrToInt(GetParameterString(command, "-c"), c);
    Item@ locker = map.GetDoor(x, y);
    if(!valid(locker))
    {
        array<Item@> items;
        map.GetItems(x, y, items);
        if(items.length() == 1 && items[0].GetType() == ITEM_TYPE_CONTAINER)
            @locker = items[0];
    }
    if(valid(locker))
    {
        int complexity = c;
        StrToInt(command[2], complexity);
        locker.LockerComplexity = complexity;
        int lockerid = Random(0, 65535);
        StrToInt(GetParameterString(command, "-i"), lockerid);
        locker.LockerId = lockerid;
        Item@  key = player.AddItem(PID_KEY, 1);
        key.LockerId = lockerid;
        string desc = GetParameterString(command, "-d");
        if(desc != "")
        {
            key.Info = 2;
            SetLexem(key, "$desc", desc);
        }
        key.Update();
    }
    else
        player.Say(SAY_NETMSG, "Couldn't obtain the locker.");
}

void ExecteeCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
	string message = GetParameterString(command, "-script");
	EraseTimeEvents(message, true);
}


/**
 * Clone another critter. Warning: there is no easy way to undo this operation (yet).
 */
void ExecCloneCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(player.Id == target.Id)
    {
        player.Say(SAY_NETMSG, "You turn into yourself. Whew, that was easy.");
        return;
    }

    if(target.IsPlayer())
    {
        if((player.GetAccess() < target.GetAccess()) || GodOfTheRealm(target.Id))
        {
            player.Say(SAY_NETMSG, "You can't turn into this being.");
            return;
        }
    }

    bool optFull = false; // Change everything
    cheatGetOption(command, optFull, "-full");

    if(optFull)
    {
        if(player.GetAccess() < ACCESS_ADMIN)
        {
            player.Say(SAY_NETMSG, "This option requires admin access level.");
            return;
        }

        // All params
        //
        for(uint i = 0; i <= 999; i++)
            player.ParamBase[i] = target.ParamBase[i];

        // Skin
        //
        if(player.ChangeCrType(target.CrType))
            player.ParamBase[ST_BASE_CRTYPE] = target.ParamBase[ST_BASE_CRTYPE];

        // Critter lexems
        //
        if(IsLexem(target, "$~"))
            SetLexem(player, "$~", GetLexem(target, "$~"));
        else
            UnsetLexem(player, "$~");
        if(IsLexem(target, "$tatoo"))
            SetLexem(player, "$tatoo", GetLexem(target, "$tatoo"));
        else
            UnsetLexem(player, "$tatoo");
        if(target.IsNpc())
        {
            SetLexem(player, "$name", "@msg dlg " + target.GetProtoId() + "0@");
            UnsetLexem(player, "$@");
            SetLexem(player, "$@", "");
        }
        else
        {
            SetLexem(player, "$name", GetSafePlayerName(target.Id) + "'s clone");
            SetLexem(player, "$@", GetSafePlayerName(target.Id) + "'s clone");
        }


        // Items
        //

        // Remove all existing items hold by abuser
        //
        array<Item@> playerItems = {};
        if(player.GetItems(-1, playerItems) > 0)
        {
            DeleteItems(playerItems);
        }

        // Copy items from target critter ...we need to delay it a bit or things in slot > 0
        // won't fit there for some reason.
        //
        array<uint> values = { player.Id, target.Id };
        CreateTimeEvent(AFTER(REAL_SECOND(1)), "e_ExecCloneItems", values, false);

        player.Say(SAY_NETMSG, "You look exactly like the critter " + target.Id + ".");
    }
    else
    {
        // Stats, Skills, Tags, Timeouts, Kills, Perks, Addictions, Karma, Damages
        //
        for(uint i = 0; i <= __DamageEnd; i++)
        {
            player.ParamBase[i] = target.ParamBase[i];
        }
        // Traits
        //
        for(uint i = __TraitBegin; i <= __TraitEnd; i++)
        {
            player.ParamBase[i] = target.ParamBase[i];
        }
        // Reputations
        //
        for(uint i = __ReputationBegin; i <= __ReputationEnd; i++)
        {
            player.ParamBase[i] = target.ParamBase[i];
        }

        player.Say(SAY_NETMSG, "You look similar to the critter " + target.Id + ".");
    }
}

uint e_ExecCloneItems(array<uint>@ values)
{
    Critter@ player = GetCritter(values[0]);
    Critter@ target = GetCritter(values[1]);

    if(!valid(player) || !valid(target))
        return 0;

    for(int slot = 0; slot < SLOT_GROUND; slot++)
    {
        array<Item@> targetItems = {};
        uint         num = target.GetItems(slot, targetItems);

        for(uint i = 0; i < num; i++)
        {
            Item@ source = targetItems[i];
            Item@ copy = player.AddItem(source.Proto.ProtoId, source.GetCount());
            player.MoveItem(copy.Id, copy.GetCount(), slot);
            copy.SortValue          = source.SortValue;
            copy.Info               = source.Info;
            copy.PicMap             = source.PicMap;
            copy.PicInv             = source.PicInv;
            copy.AnimWaitBase       = source.AnimWaitBase;
            copy.AnimStayBegin      = source.AnimStayBegin;
            copy.AnimStayEnd        = source.AnimStayEnd;
            copy.AnimShowBegin      = source.AnimShowBegin;
            copy.AnimShowEnd        = source.AnimShowEnd;
            copy.AnimHideBegin      = source.AnimHideBegin;
            copy.AnimHideEnd        = source.AnimHideEnd;
            copy.Cost               = source.Cost;
            copy.Val0               = source.Val0;
            copy.Val1               = source.Val1;
            copy.Val2               = source.Val2;
            copy.Val3               = source.Val3;
            copy.Val4               = source.Val4;
            copy.Val5               = source.Val5;
            copy.Val6               = source.Val6;
            copy.Val7               = source.Val7;
            copy.Val8               = source.Val8;
            copy.Val2               = player.Id; // !
            copy.LightIntensity     = source.LightIntensity;
            copy.LightDistance      = source.LightDistance;
            copy.LightFlags         = source.LightFlags;
            copy.LightColor         = source.LightColor;
            copy.Indicator          = source.Indicator;
            copy.BrokenFlags        = source.BrokenFlags;
            copy.BrokenCount        = source.BrokenCount;
            copy.Deterioration      = source.Deterioration;
            copy.AmmoPid            = source.AmmoPid;
            copy.AmmoCount          = source.AmmoCount;
            copy.LockerId           = source.LockerId;
            copy.LockerCondition    = source.LockerCondition;
            copy.LockerComplexity   = source.LockerComplexity;
            copy.Charge             = source.Charge;
            copy.RadioChannel       = source.RadioChannel;
            copy.RadioFlags         = source.RadioFlags;
            copy.RadioBroadcastSend = source.RadioBroadcastSend;
            copy.RadioBroadcastRecv = source.RadioBroadcastRecv;
            copy.HolodiskNumber     = source.HolodiskNumber;
            copy.OffsetX            = source.OffsetX;
            copy.OffsetY            = source.OffsetY;
            copy.Dir                = source.Dir;
            copy.set_Flags(source.get_Flags());
            copy.Update();
        }
    }
    return 0;
}



/**
 * Spawns car.
 */
void ExecSpawnCarCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    bool legit = false;
    cheatGetOption(command, legit, "-legit");
    if(legit && player.GetAccess() < ACCESS_ADMIN)
    {
        player.Say(SAY_NETMSG, "You need admin access level to spawn a legit car.");
        return;
    }

    player.Say(SAY_NETMSG, "Spawning car...");

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    int  pid = 0;
    // try to parse pid if it was passed as number
    bool parsed = StrToInt(command[2], pid);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetItemPid(command[2], pid))
        {
            player.Say(SAY_NETMSG, "Item pid does not exist in the list.");
            return;
        }
    }
    int keyId = Random(10000, 50000);
    StrToInt(GetParameterString(command, "-k"), keyId);

    Map@  map = target.GetMap();

    Item@ car;
    for(uint16 x = target.HexX - 2; x <= target.HexX + 2; x++)
    {
        for(uint16 y = target.HexY - 2; x <= target.HexY + 2; y++)
        {
            @car = map.AddItem(x, y, pid, 1);
            if(valid(car))
                break;
        }
        if(valid(car))
            break;
    }
    if(!valid(car))
    {
        player.Say(SAY_NETMSG, "Couldn't spawn car.");
        return;
    }
    car.LockerId = keyId;
    car.Charge = 0;
	SetLexem(car, "$carowner", player.Name);
    car.Update();

    Item@ bag = car.GetChild(0);
    if(valid(bag))
    {
        bag.LockerId = keyId;
        bag.LockerComplexity = Random(50, 100);
        bag.Update();
    }
    else
        player.Say(SAY_NETMSG, "Couldn't obtain car trunk.");

    Item@ key = target.AddItem(PID_KEY, 1);
    if(valid(key))
    {
        key.LockerId = keyId;
        key.Update();
    }

    if(legit)        // record spawner id
    {
        ILog("legitspawn", AuthedInfo(player.Id) + " spawned legit car (Id:" + car.Id + ")");
        _SetSpawnerLegit(car, player);
        _SetSpawnerLegit(bag, player);
        _SetSpawnerLegit(key, player);
    }
    else
    {
        _SetSpawner(car, player);
        _SetSpawner(bag, player);
        _SetSpawner(key, player);
    }

    player.LastSpawnedItem = car.Id;
    /*
       car.SpawnedBy = player.Id;
       bag.SpawnedBy = player.Id;
       key.SpawnedBy = player.Id;
     */

    if(GetGvar(GVAR_event_status) == 1)
    {
        eventItems.insertLast(car.Id);
        eventItems.insertLast(bag.Id);
        eventItems.insertLast(key.Id);
    }

    player.Say(SAY_NETMSG, "Now go and drive.");
}

//
// Calls CreateLocation function
//
// createlocation pid /* x y */
// x y are chosen randomly based on player's world coords
void ExecCreateLocationCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Executing CreateLocation command");
    int  pid = 0;

    bool legit = false;
    cheatGetOption(command, legit, "-legit");
	bool red = false;
    cheatGetOption(command, red, "-red");
    if(legit && player.GetAccess() < ACCESS_ADMIN)
    {
        player.Say(SAY_NETMSG, "You need admin access level to create a legit location.");
        return;
    }
	
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    if(!StrToInt(command[2], pid))       // ||
    // not StrToInt(command[3], deltaX) ||
    // not StrToInt(command[4], deltaY))
    {
        player.Say(SAY_NETMSG, "Invalid arguments");
        return;
    }

    // everything should be ok

    // int x = Random(-4,4);
    // int y = Random(-4,4);

    Critter@[] crits = { player };
    int id = CreateLocation(pid, player.WorldX, player.WorldY, crits);

    if(id == 0)
    {
        player.Say(SAY_NETMSG, "I wasn't able to create location.");
    }
    else
    {
        player.Say(SAY_NETMSG, "Created location, id: " + id);

        array<Map@> maps;
        Location@   loc = GetLocation(id);
        Map@        map = loc.GetMapByIndex(0);
        WeatherUpdateFast(loc);
        uint        n = loc.GetMaps(maps);
		int type = 0;
		cheatGetOption(command, type, "-t");
        if(type > 0)         // immediately teleport there
			{
			
            player.TransitToMap(loc.GetMapByIndex(type).Id, 0);
			
			}

        if(legit)
        {
            ILog("legitspawn", AuthedInfo(player.Id) + " created legit location " +  "(Id:" + id + ")");
        }
        for(uint i = 0; i < n; i++)
        {
            maps[i].SetData(MAP_DATA_CREATED_ON, ELAPSED_TIME);
            if(legit)
                maps[i].SetData(MAP_DATA_SPAWNER, player.Id);
            else
                maps[i].SetData(MAP_DATA_SPAWNER, _AsNotLegit(player.Id));
        }
        player.LastSpawnedLocation = id;
		if(red)
		loc.Color = COLOR_RGBA(255, 0, 0, 120);
		loc.Update();
		
    }
}
/**
 * Deletes location player is in.
 */
void ExecDeleteLocationCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Executing DeleteLocation command");

    uint id = 0;
	
    if(valid(player.GetMap()))
    {
        id = player.GetMap().GetLocation().Id;
		cheatGetOption(command, id, "-id");
        DeleteLocation(id);
        player.Say(SAY_NETMSG, "Deleted location with id: " + id);
    }
    else
    {
		StrToInt(command[2], id);
		cheatGetOption(command, id, "-id");
		if(id==0)
		player.Say(SAY_NETMSG, "try with -id");
		else
		{
        DeleteLocation(id);
        player.Say(SAY_NETMSG, "Deleted location with id: " + id);
		}
	}
}

//
// Changing rank of the player in the faction db
//
//
void ExecChangeRankCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Executing ChangeRank command");
    uint newRank = 0;

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    if(!StrToInt(command[2], newRank))
    {
        player.Say(SAY_NETMSG, "Invalid arguments");
        return;
    }

    uint faction = GetGroupIndex(target);

    // it means player belong somewhere
    if(faction > FACTION_NONE)
    {
        int res = ChangeRank(faction, target.Id, newRank);
        player.Say(SAY_NETMSG, "ChangeRank returned: " + FD_Result2String(res));
    }
    else
        player.Say(SAY_NETMSG, "Not a member of any faction");
}

//
// Changing faction player belongs
//
//
void ExecChangeFactionCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Executing ModifyFaction command");
    uint newFaction = 0;

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    if(!StrToInt(command[2], newFaction))
    {
        player.Say(SAY_NETMSG, "Invalid arguments");
        return;
    }
    bool applyModifiers = false;
    if(GetIndexOfString(command, "-r") != -1)
        applyModifiers = true;
    uint oldFaction = GetGroupIndex(target);
    int  res = 0;
    if(oldFaction != FACTION_NONE)
    {
        // expel from old
        res = ExpelMember(oldFaction, target.Id, applyModifiers);
        player.Say(SAY_NETMSG, "Expelling from previous faction: " + FD_Result2String(res));
    }
    res = AddMember(newFaction, target.Id, applyModifiers);
    player.Say(SAY_NETMSG, "AddMember returned: " + FD_Result2String(res));
}

//
// Changing faction of the player in the faction db
//
//
void ExecShowVarsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    #ifndef __DEBUG__
    player.Say(SAY_NETMSG, "DEPRECATED, use `critterinfo / `crinfo");
    player.Say(SAY_NETMSG, "  `critterinfo -p [player_name/id]");
    player.Say(SAY_NETMSG, "  `critterinfo -n [npc_id]");
    #endif
    #ifdef __DEBUG__
    player.Say(SAY_NETMSG, "Executing ShowVars command to see the faction related LVARs");

    GameVar@ var = GetLocalVar(LVAR_factions_player_faction, target.Id);

    if(valid(var))
        player.Say(SAY_NETMSG, "LVAR_factions_player_faction: " + var.GetValue());
    else
        player.Say(SAY_NETMSG, "LVAR_factions_player_faction not found.");

    @var = GetLocalVar(LVAR_factions_player_rank, target.Id);

    if(valid(var))
        player.Say(SAY_NETMSG, "LVAR_factions_player_rank: " + var.GetValue());
    else
        player.Say(SAY_NETMSG, "LVAR_factions_player_rank not found.");

    player.Say(SAY_NETMSG, "Faction: " + GetGroupIndex(target) + ", rank: " + GetGroupRank(target));
    #endif
}
/**
 * Removing faction.
 */
void ExecRemoveFactionCommand(array<string@>@ command, Critter@ player)
{
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    uint factionId = 0;
    StrToInt(command[2], factionId);
    if(factionId >= FIRST_FACTION && factionId < FACTION_COUNT)
    {
        if(RemoveFaction(factionId))
            player.Say(SAY_NETMSG, "Removed faction: " + factionId);
        else
            player.Say(SAY_NETMSG, "Unable to remove faction.");
    }
    else
        player.Say(SAY_NETMSG, "Wrong faction id");
}

bool ParseFactionBaseLocationId(const string& fparam, uint& out locId)
{
    int baseIdx = -1;
    int faction = 0;
    array<string@>@ fparams = split(fparam, ".");
    if(fparams.length() >= 1)
    {
        if(!StrToInt(fparams[0], faction))
            return(false);

        if(fparams.length() >= 2)
        {
            stringReplaceText(fparams[1], "_", " ");
            StrToInt(fparams[1], baseIdx);
        }
        else
            baseIdx = 0;
    }
    else
        return(false);

    if(baseIdx >= 0)
    {
        array<IFactionBase@> bases;
        int                  count = GetFactionBases(faction, bases);
        if(baseIdx > count - 1)
            return(false);
        else
        {
            locId = bases[baseIdx].get_LocationId();
            return(true);
        }
    }
    else
    {
        DLog("base < 0, byname " + fparams[1]);
        IFactionBase@ base = GetFactionBase(faction, fparams[1]);
        if(valid(base))
        {
            locId = base.get_LocationId();
            return(true);
        }
        else
            return(false);
    }
}

/**
 * Changes the visilibity of given location.
 */
void ExecLocVisCommand(array<string@>@ command, Critter@ player, Critter@ target, bool show)
{
    int locId = 0;
    StrToInt(GetParameterString(command, "-l"), locId);
    if(locId == 0)       // by faction location
    {
        if(!ParseFactionBaseLocationId(GetParameterString(command, "-f"), locId))
        {
            player.Say(SAY_NETMSG, "Unable to parse faction location param. Must be in form <faction_id>_<basename>.");
            return;
        }
    }
    if(locId == 0)
    {
        player.Say(SAY_NETMSG, "Couldn't obtain location id.");
        return;
    }
    if(show)
    {
        player.Say(SAY_NETMSG, "Showing location " + locId + " to " + target.Name);
        target.SetKnownLoc(true, locId);
    }
    else
    {
        player.Say(SAY_NETMSG, "Hiding location " + locId + " from " + target.Name);
        target.UnsetKnownLoc(true, locId);
    }
}

//
// Sets the TRANSFER timeout for safe travels
//
//
void ExecSetTimeoutCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Executing settimeout command");

    int to = 0;
    if(command.length() == 2)
    {
        _SetTimeout(player, TO_TRANSFER, REAL_DAY(1));
        return;
    }

    if(!StrToInt(command[2], to))
    {
        player.Say(SAY_NETMSG, "Invalid arguments");
        return;
    }
    _SetTimeout(target, TO_TRANSFER, to);
}

//
// Shows the value of the local variable specified in the parameter
//
void ExecGetVarCommand(array<string@>@ command, Critter@ player, uint targetId)
{
    player.Say(SAY_NETMSG, "Executing GetVar command");

    int id = 0;
    if(command.length() < 2)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    // try to parse id if it was passed as number
    bool parsed = StrToInt(command[2], id);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetVarId(command[2], id))
        {
            player.Say(SAY_NETMSG, "LVAR does not exist");
            return;
        }
    }

    // everything should be ok (id still may be bad)
    GameVar@ var = GetLocalVar(id, targetId);
    if(valid(var))
        player.Say(SAY_NETMSG, GetSafePlayerName(targetId) + "'s " + "Var value is: " + var.GetValue());
    else
        player.Say(SAY_NETMSG, "LVAR not found");
}

//
// Sets the value of the local variable specified in the parameter
//
void ExecSetVarCommand(array<string@>@ command, Critter@ player, uint targetId)
{
    player.Say(SAY_NETMSG, "Executing SetVar command");

    int id = 0;
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    // try to parse id if it was passed as number
    bool parsed = StrToInt(command[2], id);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetVarId(command[2], id))
        {
            player.Say(SAY_NETMSG, "LVAR does not exist");
            return;
        }
    }
    int val = 0;
    if(!StrToInt(command[3], val))
    {
        player.Say(SAY_NETMSG, "Wrong value");
        return;
    }

    // everything should be ok (id still may be bad)
    GameVar@ var = GetLocalVar(id, targetId);
    if(valid(var))
    {
        player.Say(SAY_NETMSG, GetSafePlayerName(targetId) + "'s " + "Var value is: " + var.GetValue() + ", changing to: " + val);
        var = val;
    }
    else
        player.Say(SAY_NETMSG, "LVAR not found");
}

//
// Shows the value of the specified unique variable for the critters in sight
// default master-slave: critter-player
// with switch r, player become master, critter slave
//
void ExecGetUVarCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Executing GetUVar command");

    int id = 0;
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    // try to parse id if it was passed as number
    bool parsed = StrToInt(command[2], id);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetVarId(command[2], id))
        {
            player.Say(SAY_NETMSG, "UVAR does not exist");
            return;
        }
    }

    // everything should be ok
    // get critters in sight
    array<Critter@> critters;
    uint            num = target.GetCritters(false, FIND_ALL, critters);
    GameVar@        var;
    for(uint i = 0; i < num; i++)
    {
        if(GetIndexOfString(command, "-r") != -1)
            @var = GetUnicumVar(id, target.Id, critters[i].Id);
        else
            @var = GetUnicumVar(id, critters[i].Id, target.Id);

        if(valid(var))
            critters[i].Say(SAY_NORM, "Var value is: " + var.GetValue());
        else
            critters[i].Say(SAY_NORM, "UVAR null");
    }
}

//
// Sets the value of the unique variable for the critter in front of player
//
void ExecSetUVarCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Executing SetUVar command");

    int id = 0;
    if(command.length() < 4)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    // try to parse id if it was passed as number
    bool parsed = StrToInt(command[2], id);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetVarId(command[2], id))
        {
            player.Say(SAY_NETMSG, "LVAR does not exist");
            return;
        }
    }
    int val = 0;
    if(!StrToInt(command[3], val))
    {
        player.Say(SAY_NETMSG, "Wrong value");
        return;
    }

    // get critters in sight
    array<Critter@> critters;
    uint            num = target.GetCritters(false, FIND_ALL, critters);
    GameVar@        var;
    bool            set = false;
    for(uint i = 0; i < num; i++)
    {
        if(GetDistantion(target.HexX, target.HexY, critters[i].HexX, critters[i].HexY) > 1)
            continue;

        if(GetDirection(target.HexX, target.HexY, critters[i].HexX, critters[i].HexY) != target.Dir)
            continue;

        if(GetIndexOfString(command, "-r") != -1)
            @var = GetUnicumVar(id, target.Id, critters[i].Id);
        else
            @var = GetUnicumVar(id, critters[i].Id, target.Id);
        if(valid(var))
        {
            var = val;
            critters[i].Say(SAY_NORM, "Setting var value to: " + var.GetValue());
            set = true;
        }
        else
            critters[i].Say(SAY_NORM, "UVAR null");
    }
    if(!set)
        player.Say(SAY_NETMSG, "Critter should be in front of target");
}

//
// Kills the critter in front of player, without consequences
// or kills player with specified name
void ExecKillCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Executing... critter?");

    // Try to kill a critter in front of the player
    if(command.length() < 3)
    {
        uint16 frontHexX = player.HexX;
        uint16 frontHexY = player.HexY;
        Map@   map = player.GetMap();
        if(valid(map))
        {
            map.MoveHexByDir(frontHexX, frontHexY, player.Dir, 1);
            Critter@ cr = map.GetCritter(frontHexX, frontHexY);
            if(valid(cr))
            {
                if(cr.IsPlayer())
                    _CritSetMode(cr, MODE_NO_LOOT);
                cr.ToDead(GetRandomDeathAnimation(), null);
            }
            else
                player.Say(SAY_NETMSG, "Nobody to kill.");
        }
        else
            player.Say(SAY_NETMSG, "Nobody to kill.");
    }
    else
    {
        if(command[2] == "players")
        {
            player.Say(SAY_NETMSG, "Killing all Players in sight...");
            array<Critter@> critters;
            uint            num = player.GetCritters(false, FIND_ONLY_PLAYERS | FIND_LIFE, critters);
            for(uint i = 0; i < num; i++)
            {
                _CritSetMode(target, MODE_NO_LOOT);
                critters[i].ToDead(GetRandomDeathAnimation(), null);
            }
        }
        else if(command[2] == "npcs")
        {
            player.Say(SAY_NETMSG, "Killing all NPCs in sight...");
            array<Critter@> critters;
            uint            num = player.GetCritters(false, FIND_ONLY_NPC | FIND_LIFE, critters);
            for(uint i = 0; i < num; i++)
            {
                if(_IsTrueNpc(critters[i]))
                    critters[i].ToDead(GetRandomDeathAnimation(), null);
            }
        }
        else if(command[2] == "all")
        {
            player.Say(SAY_NETMSG, "Killing all critters in sight...");
            array<Critter@> critters;
            uint            num = player.GetCritters(false, FIND_LIFE, critters);
            for(uint i = 0; i < num; i++)
            {
                if(critters[i].IsPlayer())
                    _CritSetMode(target, MODE_NO_LOOT);
                critters[i].ToDead(GetRandomDeathAnimation(), null);
            }
        }
        else
        {
            // otherwise, specified target
            if(player.Id == target.Id)
            {
                player.Say(SAY_NETMSG, "Are you crazy?");
                return;
            }

            if(valid(target))
            {
                target.Say(SAY_NETMSG, "Out of a sudden, you decided to be a little bit dead. Sleep tight.");
                if(target.IsPlayer())
                    _CritSetMode(target, MODE_NO_LOOT);
                target.ToDead(GetRandomDeathAnimation(), null);
                player.Say(SAY_NETMSG, GetSafePlayerName(target.Id) + " died a painful death. You feel quite good about it.");
            }
            else
                player.Say(SAY_NETMSG, "Player not found");
        }
    }
}


//
// Register new faction with specified id and name
//
void ExecRegisterFactionCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Executing RegisterFaction command");

    int id = 0;
    if(command.length() < 4)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    if(!StrToInt(command[2], id))
    {
        player.Say(SAY_NETMSG, "Invalid parameters");
        return;
    }
	int min = 1000000, max = 1004000, l, stringId = 0, num;
	string str;
	
	file f;
    Log("Reading strings from file" + "text/engl/fotext.msg");
    // Open the file in 'read' mode
	if(f.open("text/engl/fotext.msg", "r") >= 0)
    {
        // Read the whole file into the string buffer
        
        f.readString(f.getSize(), str);
        f.close();

        // now we need to process that whole string
        array<string@>@ lines = split(str, "\n");
        Log("Read " + lines.length() + " lines");

        

        // process the lines
        for(uint i = 0; i < lines.length(); i++)
        {
            string msgStr;
            

            // comment
            if(lines[i].length() <= 2)
                continue;

            if(ParseMsgString(lines[i], min, max, num, msgStr))
            {
                if(num % 2 == 0)
                {
                   //WLog("factions", "Faction name(" + (stringId + 1) + "): " + msgStr);
                    //FactionNames.insertLast(msgStr);
                    //UnassignedNames.insertLast(stringId);
                    stringId++;
                }
                else
                {
                    WLog("factions", "with Alias: " + msgStr);
                    //NameAliases.set(msgStr, stringId - 1);
                }
            }
        }
		//stringId = stringId / 10 + 2;
	}
	
	if(f.open("text/engl/fotext.msg", "a") >= 0)
	{
		//stringId = stringId * 2;
		//int newindex = min + stringId;
		int newindex = num + 1;
		f.writeString("{" + newindex + "}{}{" + command[3] +"}");
		newindex++;
		f.writeString("\r\n{" + newindex + "}{}{" + command[3] +"}\r\n");
		f.close();
	}

    int res = RegisterFaction(id, command[3], true);
    if(res == REGRESULT_SUCCESS)
        player.Say(SAY_NETMSG, "Faction registered");
    else
        player.Say(SAY_NETMSG, "Faction couln't be registered");
}

bool ParseMsgString(const string& in line, int min, int max, int& out num, string& out msgStr)
{
    array<string@>@ parts = split(line, "{");
    if(parts.length() != 4)
    {
        // Log("ERR: Incorrect line format: " + line);
        return false;
    }
    // Log("Processing line: " + line);
    // for(uint i = 0; i < parts.length(); i++)
    //	Log(parts[i]);
    string number = substring(parts[1], 0, parts[1].length() - 1);
    // Log("Found number: " + number + " in: " + parts[1]);
    if(!StrToInt(number, num))
    {
        Log("ERR: Incorrect number string: " + number);
        return false;
    }

    // return msg string if in range
    if(num >= min && num <= max)
    {
        msgStr = substring(parts[3], 0, parts[3].length() - 2);
        return true;
    }
    else
        return false;
}

//
// Teleports target to some location (or target and his team)
//
void ExecTeleportCommand(array<string@>@ command, Critter@ player, Critter@ target, bool team)
{
    player.Say(SAY_NETMSG, "Teleporting");

    uint mapId = 0;
    uint entId = 0;
    int  hexX = -1, hexY = -1;
    bool toHex = false;
    if(command.length() > 2)
    {
        if(GetIndexOfString(command, "-f") == -1)
        {
            if(!StrToInt(command[2], mapId))
            {
                if(Maps.exists(command[2]))
                    Maps.get(command[2], mapId);
                else
                    mapId = 0;
            }
        }
        else     // Faction base
        {
            uint locid = 0;
            if(ParseFactionBaseLocationId(command[2], locid))
            {
                Location@ loc = GetLocation(locid);
                if(valid(loc))
                {
                    Map@ map = loc.GetMapByIndex(0);
                    if(valid(map))
                    {
                        mapId = map.Id;
                    }
                }
            }
            else
            {
                player.Say(SAY_NETMSG, "To teleport to faction base, command parameter must be in form:");
                player.Say(SAY_NETMSG, " teleport <factionId> -f (translated to <faction_id>.0)");
                player.Say(SAY_NETMSG, " teleport <factionId>.<baseNumber> -f (starting from 0)");
                player.Say(SAY_NETMSG, " teleport <factionId>.<baseName> -f (use _ instead of whitespace)");
                return;
            }
        }
    }
    if(mapId == 0)
    {
        if(target.GetMapId() != 0)
            mapId = target.GetMapId();
        else
        {
            player.Say(SAY_NETMSG, "Invalid parameters. Your current map is worldmap.");
            return;
        }
    }
    // try hexes
    StrToInt(GetParameterString(command, "-x"), hexX);
    StrToInt(GetParameterString(command, "-y"), hexY);
    if(hexX != -1 && hexY != -1)
        toHex = true;

    if(!toHex && command.length() > 3)
    {
        if(!StrToInt(command[3], entId))
            entId = 0;
    }

    if(team)
    {
        // make it so target is leader of the group our desired target belongs to(if any)
        if(valid(target.GetFollowLeader()))
            @target = @target.GetFollowLeader();

        array<Critter@> followers;
        uint            num = target.GetFollowGroup(FIND_ALL, followers);
        for(uint i = 0; i < num; i++)
        {
            if(toHex)
                followers[i].TransitToMap(mapId, hexX, hexY, followers[i].Dir);
            else
                followers[i].TransitToMap(mapId, entId);
        }
    }

    if(toHex)
    {
        if(target.TransitToMap(mapId, hexX, hexY, target.Dir))
            player.Say(SAY_NETMSG, "Teleported to location " + mapId + " at position: " + hexX + ", " + hexY);
        else
            player.Say(SAY_NETMSG, "Couldn't teleport to location " + mapId + " at position: " + hexX + ", " + hexY);
    }
    else
    {
        if(target.TransitToMap(mapId, entId))
            player.Say(SAY_NETMSG, "Teleported to location " + mapId + " at entrance: " + entId);
        else
            player.Say(SAY_NETMSG, "Couldn't teleport to location " + mapId + " at entrance: " + entId);
    }

}

/* TODO
   void ExecTeleporterCommand(array<string@>@ command, Critter@ player)
   {
        uint16 hx = player.HexX;
        uint16 hy = player.HexY;

        int dir = Random(0, 6);

    bool allowItems = false;

        bool _in = false;
        bool _out = false;

        cheatGetOption(command, _in, "-in" );
        cheatGetOption(command, _out, "-out" );

        if( !_in && !_out )
        {
                player.Say( SAY_NETMSG, "You must set -in or -out option" );
                return;
        }
        if( _in && _out )
        {
                player.Say( SAY_NETMSG, "You can't set -in and -out option at same time" );
                return;
        }

        Critter@ link;
        if( _in )
        {
                uint linkId = 0;
                string[] __in = { "-in" };
                if( !StrToInt( GetParameterString( command, __in ), linkId ))
                {
                        player.Say(SAY_NETMSG, "No link set. Use -in <outTeleporterId>");
                        return;
                }

                @link = GetCritter( linkId );
                if( !valid(link) )
                {
                        player.Say(SAY_NETMSG, "Invalid link<"+linkId+"> set (target invalid) Use -in <outTeleporterId>");
                        return;
                }

                if( link.Param[ST_DIALOG_ID] != ETP_DIALOG )
                {
                        player.Say(SAY_NETMSG, "Invalid link<"+linkId+"> set (target has wrong dialog) . Use -in <outTeleporterId>");
                        return;
                }

                if( !FLAG( link.Param[ETP_FLAGS], ETP_MODE_OUT ))
                {
                        player.Say(SAY_NETMSG, "Invalid link<"+linkId+"> set (target isn't in OUT mode). Use -in <outTeleporterId>");
                        return;
                }

                if( link.Param[ETP_LINK] != 0 )
                {
                        player.Say(SAY_NETMSG, "Invalid link<"+linkId+"> set (target is linked to <"+link.Param[ETP_LINK]+">). Use -in <outTeleporterId>");
                        return;
                }
        }

        cheatGetOption(command, hx, "-x");
    cheatGetOption(command, hy, "-y");
        cheatGetOption(command, dir, "-dir");
        dir=dir%6;

        Map@ map=player.GetMap();
        if(!valid(map))
        {
                player.Say(SAY_NETMSG, "You are not on valid map.");
                return;
        }

        SpawnEventTeleporter( player, link, map, hx, hy, dir, "Another Bad, Unbalanced, Silly Event" );
   }
 */

#define WT_NO_ITEMS        (0x01)
#define WT_DELETE_ITEMS    (0x02)
#define WT_NO_FOLLOWERS    (0x04)


void ExecTeleporterCommand(array<string@>@ command, Critter@ player)
{
    uint16 hx = player.HexX;
    uint16 hy = player.HexY;

    uint16 tx = 0;
    uint16 ty = 0;

    uint   mapId  = 0;

    int    dir = Random(0, 6);
	uint pid = 0;
    bool   allowItems = false;

    cheatGetOption(command, hx, "-x");
    cheatGetOption(command, hy, "-y");
    cheatGetOption(command, tx, "-tx");
    cheatGetOption(command, ty, "-ty");
    cheatGetOption(command, mapId, "-map");
    cheatGetOption(command, allowItems, "-it");
    cheatGetOption(command, dir, "-dir");
	cheatGetOption(command, pid, "-pid");
    dir = dir % 6;

    if(mapId == 0)
    {
        mapId = player.GetMap().Id;
    }

    if(tx == 0 || ty == 0)
    {
        player.Say(SAY_NETMSG, "No destination coordinates given. Use -tx <X> and -ty <Y>");
        return;
    }

    Map@ map = player.GetMap();
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "You are not on valid map.");
        return;
    }
	if(pid == 0)
	{
    pid = 319;
	}

    uint     dialogId = 10810;
    Critter@ npc = AddNpc(map, pid, hx, hy, dir,
                          dialogId, "", 0, 0, 0, 0, 0, false, 9999);

    if(!valid(npc))
    {
        player.Say(SAY_NETMSG, "Failed to create teleporter npc.");
        return;
    }
    int teleportPolicy = 0;
    SETFLAG(teleportPolicy, WT_NO_FOLLOWERS);
    if(!allowItems)
        SETFLAG(teleportPolicy, WT_NO_ITEMS);
    SetLvar(npc, LVAR_warzone_terminal_policy, teleportPolicy);
    SetLvar(npc, LVAR_warzone_terminal_destination, mapId);
    npc.ParamBase[ST_VAR1] = (((ty << 16) & 0xFFFF0000) | (tx & 0x0000FFFF));
    npc.SpawnedBy = player.Id;
}


//
// Shifts player (and his team) few hexes in the specific direction
//
void ExecShiftCommand(array<string@>@ command, Critter@ player, Critter@ target, bool team, bool random)
{
    player.Say(SAY_NETMSG, "Shifting");
    // hexes
    uint16 hexX, hexY;
    uint   amount = 2;

    if(command.length() > 2)
    {
        StrToInt(command[2], amount);
    }

    hexX = target.HexX;
    hexY = target.HexY;
    // calc target hexes
    if(random)
    {
        hexX += Random(-20, 20);
        hexY += Random(-20, 20);
    }
    else
        player.GetMap().MoveHexByDir(hexX, hexY, target.Dir, amount);

    if(team)
    {
        // make it so target is leader of the group our desired target belongs to(if any)
        if(valid(target.GetFollowLeader()))
            @target = @target.GetFollowLeader();
        hexX = target.HexX;
        hexY = target.HexY;
        // calc  target hexes
        if(random)
        {
            hexX += Random(-20, 20);
            hexY += Random(-20, 20);
        }
        else
            player.GetMap().MoveHexByDir(hexX, hexY, target.Dir, amount);

        array<Critter@> followers;
        uint            num = target.GetFollowGroup(FIND_ALL, followers);
        for(uint i = 0; i < num; i++)
            followers[i].TransitToHex(hexX, hexY, 0xff);
    }
    bool res = target.TransitToHex(hexX, hexY, 0xff);
    if(res)
        player.Say(SAY_NETMSG, "Shifted!");
    else
        player.Say(SAY_NETMSG, "Tsk, tsk");
}

//
// Summons target (and his team) near the player (summoner)
//
// helper
bool Teleport(Critter@ player, Critter@ target, bool Safe)
{
    int ModX = 0;
    int ModY = 0;
    if(Safe)
    {
        (Random(0, 1) == 0 ? ModX = 1 : ModX = -1);
        ModY = ModX;
        ModX *= Random(2, 10);
        ModY *= Random(2, 10);
    }

    if(player.GetMapId() == target.GetMapId() && player.GetMapId() != 0)
        return player.TransitToHex(target.HexX + ModX, target.HexY + ModY, 0xff);
    else if(target.GetMapId() != 0)
        return player.TransitToMap(target.GetMapId(), target.HexX + ModX, target.HexY + ModY, 0xff);
    else
    {
        // if player already on global
        if(player.GetMapId() == 0)
            player.TransitToMap(1, 0);
        return player.TransitToGlobalGroup(target.Id);
    }
}

void ExecSummonCommand(array<string@>@ command, Critter@ player, Critter@ target, bool team)
{
    if(WrathOfTheGod(target))
        @target = player;

    if(team)
        player.Say(SAY_NETMSG, "Summoning team");
    else
        player.Say(SAY_NETMSG, "Summoning");

    if(player.Id == target.Id)
    {
        player.Say(SAY_NETMSG, "Wrong target.");
        return;
    }
    // map id
    uint id = player.GetMapId();

    if(team)
    {
        // make it so target is leader of the group our desired target belongs to(if any)
        if(valid(target.GetFollowLeader()))
            @target = @target.GetFollowLeader();
    }
    // remember previous location
    target.ParamBase[ST_VAR7] = target.GetMapId();
    target.ParamBase[ST_VAR8] = target.HexX;
    target.ParamBase[ST_VAR9] = target.HexY;

    uint num = 0;

    if(team)
    {
        array<Critter@> followers;
        num = target.GetFollowGroup(FIND_ALL, followers);
        for(uint i = 0; i < num; i++)
        {
            // remember previous location
            followers[i].ParamBase[ST_VAR7] = followers[i].GetMapId();
            followers[i].ParamBase[ST_VAR8] = followers[i].HexX;
            followers[i].ParamBase[ST_VAR9] = followers[i].HexY;
            if(Teleport(followers[i], player, false))
                num++;
        }
    }
    // teleport
    if(Teleport(target, player, false))
        num++;
    player.Say(SAY_NETMSG, num + " players summoned");
}

//
// returns target (and his team) to location from which they were summoned
//
void ExecDismissCommand(array<string@>@ command, Critter@ player, Critter@ target, bool team)
{
    if(WrathOfTheGod(target))
        @target = player;

    if(team)
        player.Say(SAY_NETMSG, "Dismissing team");
    else
        player.Say(SAY_NETMSG, "Dismissing");

    if(player.Id == target.Id)
    {
        player.Say(SAY_NETMSG, "Wrong target.");
        return;
    }

    if(team)
    {
        // make it so target is leader of the group our desired target belongs to(if any)
        if(valid(target.GetFollowLeader()))
        {
            @target = @target.GetFollowLeader();
            DPlayerLog(player, "Group leader: " + GetSafePlayerName(target.Id));
        }
    }

    if(team)
    {
        array<Critter@> followers;
        uint            num = target.GetFollowGroup(FIND_ALL, followers);
        DPlayerLog(player, "Num followers: " + num);
        for(uint i = 0; i < num; i++)
        {
            if(followers[i].Param[ST_VAR7] != target.Param[ST_VAR7])
            {
                DPlayerLog(player, GetSafePlayerName(followers[i].Id) + " wasn't in team during summoning");
                followers[i].TransitToMap(target.Param[ST_VAR7], target.Param[ST_VAR8], target.Param[ST_VAR9], 0xff);
            }
            else
                // in most cases(or in all cases), this will go to the same map as above
                followers[i].TransitToMap(followers[i].Param[ST_VAR7], followers[i].Param[ST_VAR8], followers[i].Param[ST_VAR9], 0xff);
        }
    }
    // teleport
    target.TransitToMap(target.Param[ST_VAR7], target.Param[ST_VAR8], target.Param[ST_VAR9], 0xff);
    player.Say(SAY_NETMSG, "Dismissed");
}

/**
 * Teleports to given target critter.
 */
void ExecGoToCommand(array<string@>@ command, Critter@ player, Critter@ target, bool team)
{
    if(WrathOfTheGod(target))
        @target = player;

    if(team)
        player.Say(SAY_NETMSG, "Going to with team...");
    else
        player.Say(SAY_NETMSG, "Going to...");

    bool  Safe = (GetIndexOfString(command, "-s") != -1);

    int   ItemId = 0;
    StrToInt(GetParameterString(command, "-i"), ItemId);
    Item@ It = ItemId > 0 ? GetItem(ItemId) : null;
    if(ItemId > 0)
    {
        if(valid(It))
        {
            if(It.Accessory == ACCESSORY_CRITTER)
            {
                Critter@ ItCritter = GetCritter(It.CritId);
                @target = ItCritter;
                string@  carrier = GetSafePlayerName(It.CritId);
                player.Say(SAY_NETMSG, "Item is carried by critter " + It.CritId +
                           (valid(carrier) ? " (" + carrier + ")" : ""));
            }
            else
            {
                @target = null;
                if(player.GetMapId() == It.MapId && player.GetMapId() != 0)
                    player.TransitToHex(It.HexX, It.HexY, 0xff);
                else if(It.MapId != 0)
                    player.TransitToMap(It.MapId, It.HexX, It.HexY, 0xff);
            }
        }
        else
        {
            player.Say(SAY_NETMSG, "Item not valid");
            return;
        }
    }

    if((!valid(target) && !valid(It)) || (valid(target) && target.Id == player.Id))
    {
        player.Say(SAY_NETMSG, "Target not valid");
        return;
    }

    if(target.GetMapId() == 0 && (GetIndexOfString(command, "-f") == -1))
    {
        player.Say(SAY_NETMSG, "Target is on the worldmap. Use -f to go there anyway.");
        return;
    }

    uint num = 0;
    // teleport
    if(valid(target))
    {
        if(Teleport(player, target, Safe))
            num++;
    }
    if(team)
    {
        array<Critter@> followers;
        num = player.GetFollowGroup(FIND_ALL, followers);
        for(uint i = 0; i < num; i++)
        {
            if(Teleport(followers[i], player, false))
                num++;
        }
    }
    if(valid(target))
        player.Say(SAY_NETMSG, num + " players teleported to " + target.Name + " (" + target.GetMapId() + ")");
    else if(valid(It))
        player.Say(SAY_NETMSG, num + " players teleported to item " + It.Id + " (" + It.MapId + ")");
}

void ExecDamageCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    uint val = 0;

    int  damagetype = DAMAGE_NORMAL;
    if(GetParameterString(command, "-t") != "")
        StrToInt(GetParameterString(command, "-t"), damagetype);

    int direction = Random(0, 6);
    if(GetParameterString(command, "-dir") != "")
        StrToInt(GetParameterString(command, "-dir"), direction);

    int owner = 0;
    StrToInt(GetParameterString(command, "-o"), owner);

    int damage = 0;
    StrToInt(GetParameterString(command, "-d"), damage);

    InjureCritter(target, damage, damagetype, 0, 0);
}

void ExecSlapCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Slap that bitch up!");

    if(GodOfTheRealm(target.Id) && !GodOfTheRealm(player.Id))
        @target = player;

    uint damagetype = DAMAGE_NORMAL;

    if(GetParameterString(command, "-t") != "")
        StrToInt(GetParameterString(command, "-t"), damagetype);
    uint lostAp = 0;
    StrToInt(GetParameterString(command, "-a"), lostAp);

    // int direction = Random(0, 6);
    // if (GetParameterString(command, "-dir") != "")
    //    StrToInt(GetParameterString(command, "-dir"), direction);

    target.ToKnockout(KNOCKOUT_ANIM2_DEFAULT(Random(0, 1) == 0), lostAp, target.HexX, target.HexY);

    if(GodOfTheRealm(target.Id))
        target.Say(SAY_NETMSG, "You've been slapped by " + player.Name);
}
void ExecMassSlapCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Down on your knees faggots!");

    uint lostAp = 0;
    StrToInt(GetParameterString(command, "-a"), lostAp);
    int  r = 0;
    StrToInt(GetParameterString(command, "-r"), r);

    array<Critter@> crits;
    uint            num = player.GetCritters(false, FIND_ALL, crits);
    for(uint i = 0; i < num; i++)
    {
        if(!crits[i].IsDead() && !GodOfTheRealm(crits[i].Id))
            crits[i].ToKnockout(KNOCKOUT_ANIM2_DEFAULT(Random(0, 1) == 0), lostAp, crits[i].HexX + Random(-r, r), crits[i].HexY + Random(-r, r));
    }
}

void ExecSetHPCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    int hp = 0;
    GetParameterString(command, "-h");

    if(valid(target))
        _CritChangeHp(target, hp);
    else
        _CritChangeHp(player, hp);
}

void ExecExplodeCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(player.Id == target.Id)
    {
        player.Say(SAY_NETMSG, "You dont't want this.");
        return;
    }
    if(!valid(target))
    {
        player.Say(SAY_NETMSG, "Invalid player");
        return;
    }
    uint16 effectPid = PID_EXPLODE_ROCKET;
    uint   effectRadius = 2;
    uint   damage = Random(300, 400);
    uint   damageType = DAMAGE_EXPLODE;
    uint   damageRadius = 3;

    ExplodeEx(target.GetMap(), target.HexX, target.HexY, effectPid, effectRadius, damage, damageType, damageRadius, 0, 0);
    // Explode(target.GetMap(), target.HexX, target.HexY, PID_PLASTIC_EXPLOSIVES, 0);
}

void ExecAirstrikeCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(player.Id == target.Id)
    {
        player.Say(SAY_NETMSG, "You dont't want this.");
        return;
    }
    if(!valid(target))
    {
        player.Say(SAY_NETMSG, "Invalid player");
        return;
    }

    player.Say(SAY_NETMSG, "Airstrike target confirmed. Dropping the payload now.");

    int    amount = 0;

    uint16 effectPid = PID_EXPLODE_ROCKET;
    uint   effectRadius = 2;
    uint   damage = Random(1000, 5000);
    uint   damageType = DAMAGE_EXPLODE;
    uint   damageRadius = 3;

    for(int i = 0; i < 20; i++)
        ExplodeEx(target.GetMap(), target.HexX + Random(-10, 10), target.HexY + Random(-10, 10), effectPid, effectRadius, damage, damageType, damageRadius, 0, 0);
}

void ExecAltsCommand(array<string@>@ command, Critter@ player)
{
    uint optLocation = 0;
    cheatGetOption(command, optLocation, "-l");

    bool optOffline = false;
    cheatGetOption(command, optOffline, "-o");

    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);
    uint            totalNum = 0;

    array<uint>     checkedIp;             // Already checked IPs
    bool            nothingFound = true;   // No alts found

    if(optLocation == 0)
        player.Say(SAY_NETMSG, "Possible multilogs:");
    else
        player.Say(SAY_NETMSG, "Possible multilogs in location " + optLocation + ":");

    for(uint p = 0, q = num; p < q; p++)
    {
        if(optLocation > 0)
        {
            Map@ map = players[p].GetMap();
            if(valid(map))
            {
                Location@ loc = map.GetLocation();
                if(loc.Id != optLocation)
                    continue;
            }
            else
                continue;
        }

        totalNum += 1;

        uint ip = players[p].GetIp();
        bool checkAlts = true;
        for(uint i = 0, j = checkedIp.length; i < j; i++)
        {
            if(ip == checkedIp[i])     // This IP was already checked
            {
                checkAlts = false;
                break;
            }
        }
        if(checkAlts)
        {
            checkedIp.insertLast(ip);
            bool foundAlts = false;
            for(uint i = p + 1; i < num; i++)
            {
                if(optLocation > 0)
                {
                    Map@ map = players[i].GetMap();
                    if(valid(map))
                    {
                        Location@ loc = map.GetLocation();
                        if(loc.Id != optLocation)
                            continue;
                    }
                    else
                        continue;
                }

                if(!optOffline && _IsOffline(players[i]))
                    continue;
					
				if(players[i].Id < 5)
					continue;

                if(players[i].GetIp() == ip)
                {
                    if(!foundAlts)
                    {
                        foundAlts = true;
                        player.Say(SAY_NETMSG, "|0x009900 IP: " + IpToString(ip));
                        if(_IsOffline(players[p]))
                            player.Say(SAY_NETMSG, "|0x999999     " + players[p].Name + " (" + players[p].Id + ") in map " + players[p].GetMapId() + " [off]");
                        else
                            player.Say(SAY_NETMSG, "    " + players[p].Name + " (" + players[p].Id + ") in map " + players[p].GetMapId());
                    }
                    if(_IsOffline(players[i]))
                        player.Say(SAY_NETMSG, "|0x999999     " + players[i].Name + " (" + players[i].Id + ") in map " + players[i].GetMapId() + " [off]");
                    else
                        player.Say(SAY_NETMSG, "    " + players[i].Name + " (" + players[i].Id + ") in map " + players[i].GetMapId());
                    nothingFound = false;
                }
            }
        }
    }
    if(nothingFound)
        player.Say(SAY_NETMSG, "    None.");
}

void ExecListPlayersCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);

    for(uint i = 0; i < num; i++)
    {
        if(!valid(players[i]))
            continue;

        if(WrathOfTheGod(players[i]))
            continue;

        if((GetIndexOfString(command, "-f") != -1) && (players[i].GetMapId() == 0))
            continue;

        player.Say(SAY_NETMSG, GetSafePlayerName(players[i].Id) + " (" + players[i].Id + ")" + "(" + players[i].GetMapId() + ")" + "(" + GetPlayerFaction(players[i].Id) + ")");
    }
}

void ExecCritterInfoCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(!valid(target))
        return;

    if(WrathOfTheGod(target))
        @target = player;

    string what = "\n";
    if(target.IsPlayer())
        what += "PLAYER " + GetSafePlayerName(target.Id);
    else
        what += "NPC |dlgName" + target.Id + "|";
    // more details here?

    GameVar@ var = null;

    player.Say(SAY_NETMSG, what + " (" + target.Id + ")" + ":");

    player.Say(SAY_NETMSG, "Map ID: " + target.GetMapId());

    player.Say(SAY_NETMSG, "Map Position: " + "x:" + target.HexX + " y:" + target.HexY);

    if(target.IsNpc())
    {
        uint   mapId = 0;
        uint16 hexX = 0, hexY = 0;
        uint8  dir = 0;

        target.GetHomePos(mapId, hexX, hexY, dir);

        player.Say(SAY_NETMSG, "Home Position: (" + mapId + ") " + hexX + "," + hexY + "," + dir);
    }

    player.Say(SAY_NETMSG, "Worldmap position: " + "x:" + target.WorldX + " y:" + target.WorldY);

    if(target.IsNpc() && target.Param[ST_DIALOG_ID] > 0)
        player.Say(SAY_NETMSG, "Dialog: " + target.Param[ST_DIALOG_ID]);

    player.Say(SAY_NETMSG, "Level: " + target.Param[ST_LEVEL]);

    player.Say(SAY_NETMSG, "SPECIAL:" +
               " ST:" + target.Param[ST_STRENGTH] +
               " PE:" + target.Param[ST_PERCEPTION] +
               " EN:" + target.Param[ST_ENDURANCE] +
               " CH:" + target.Param[ST_CHARISMA] +
               " IN:" + target.Param[ST_INTELLECT] +
               " AG:" + target.Param[ST_AGILITY] +
               " LK:" + target.Param[ST_LUCK]
               );
    array<string> tag;
    for(uint t = TAG_BEGIN; t <= TAG_END; t++)
    {
        string skill = SkillName(target.Param[t]);
        if(skill.length() > 0)
            tag.insertLast(skill);
        else if(target.Param[t] != 0)
            tag.insertLast("UNKNOWN(" + target.Param[t] + ")");
    }

    if(tag.length() > 0)
    {
        string tagList = "Tag: ";
        tag.sortAsc();
        for(uint t = 0; t < tag.length; t++)
        {
            if(t != 0)
                tagList += ", ";
            tagList += tag[t];
        }
        player.Say(SAY_NETMSG, tagList);
    }

    @var = GetLocalVar(LVAR_factions_player_faction, target.Id);
    if(valid(var))
    {
        int fid = var.GetValue();
        int rank = 0;
        @var = GetLocalVar(LVAR_factions_player_rank, target.Id);
        if(valid(var))
            rank = var.GetValue();
        if(fid > 1 && FactionExists(fid))
        {
            string[] ranks_player =  { "UNKNOWN", "Rookie",   "Accepted",   "Trusted",    "Important", "Leader" };
            string[] ranks_bos =     { "UNKNOWN", "Initiate", "Apprentice", "Senior",     "Elder",     "LEADER" };
            string[] ranks_enclave = { "UNKNOWN", "Boot",     "Trooper",    "Sergeant",   "Officer",   "LEADER" };
            string[] ranks_unity =   { "UNKNOWN", "Initiate", "Child",      "Priest",     "Elder",     "LEADER" };
            string[] ranks_ncr =     { "UNKNOWN", "Democrat", "Citizen",    "Magistrate", "Marshal",   "LEADER" };
            string[] ranks_vc =      { "UNKNOWN", "Admitted", "Citizen",    "Regulator",  "Proconsul", "LEADER" };
            array<string> ranks = ranks_player;
            switch(fid)
            {
            case FACTION_BOS:
                ranks = ranks_bos;
                break;
            case FACTION_ENCLAVE:
                ranks = ranks_enclave;
                break;
            case FACTION_UNITY:
                ranks = ranks_unity;
                break;
            case FACTION_NCR:
                ranks = ranks_ncr;
                break;
            case FACTION_VAULT_CITY:
                ranks = ranks_vc;
                break;
            }

            if(FACTION_VALID(fid))
                player.Say(SAY_NETMSG, "Faction: " + GetFaction(fid).get_Name() + " (" + fid + ")");
            else
                player.Say(SAY_NETMSG, "INVALID FACTION <" + fid + ">");
            if(RANK_VALID(rank) && rank >= 0)
                player.Say(SAY_NETMSG, "Rank: " + ranks[rank] + " (" + rank + ")");
            else
                player.Say(SAY_NETMSG, "INVALID RANK <" + rank + ">");
        }

    }

    // if(target.IsNpc()) -- don't! maybe NPCs will get tents too some day
    @var = GetLocalVar(LVAR_tent_id, target.Id);
    if(valid(var))
    {
        int locId = var.GetValue();
        if(locId > 0)
        {
            Location@ loc = GetLocation(locId);
            if(valid(loc))
            {
                Map@ map = loc.GetMapByIndex(0);
                if(valid(map))
                {
                    player.Say(SAY_NETMSG,
                               "Tent map: " + map.Id + " (" + ZONE_X(loc.WorldX) + ":" + ZONE_Y(loc.WorldY) +
                               ", " + loc.WorldX + "," + loc.WorldY + ")"
                               );
                }
            }
        }
    }

    if(_IsFollower(target))
        player.Say(SAY_NETMSG, "Master: " + GetSafePlayerName(target.FollowerVar[FV_MASTER]) + " (" + target.FollowerVar[FV_MASTER] + ")");

    Critter@ leader = target.GetFollowLeader();
    if(valid(leader))
        player.Say(SAY_NETMSG, "Following: " + GetSafePlayerName(leader.Id) + " (" + leader.Id + ")");

    if(target.IsNpc() && target.SpawnedBy > 0)
        player.Say(SAY_NETMSG, "Spawned by: " + GetSafePlayerName(target.SpawnedBy));

    if(target.DisguisedBy > 0 && target.DisguisedBy != target.Id)
        player.Say(SAY_NETMSG, "Disguised by: " + GetSafePlayerName(target.DisguisedBy));

    bool achievementText = true;
    for(uint8 a = ACHIEVEMENT_MIN; a <= ACHIEVEMENT_MAX; a++)
    {
        if(HaveAchievement(target, a))
        {
            if(achievementText)
            {
                player.Say(SAY_NETMSG, "Achievements:");
                achievementText = false;
            }
            player.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, ACHIEVEMENT_MSG_TITLE(a));
        }
    }
}

void ExecZeroExtCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(!valid(target))
        return;
    if(!target.IsPlayer())
        return;

    for(uint i = STAT_EXT_BEGIN; i <= STAT_EXT_END; i++)
        target.ParamBase[i] = 0;
}
//
//
//
void ExecGodCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Praise");

    for(uint i = ST_STRENGTH; i <= ST_LUCK; i++)
        player.ParamBase[i] = 10;
    player.ParamBase[SK_SMALL_GUNS] = player.ParamBase[SK_BIG_GUNS] = player.ParamBase[SK_ENERGY_WEAPONS] =
                                                                          player.ParamBase[SK_UNARMED] = player.ParamBase[SK_LEARNING] = player.ParamBase[SK_THROWING] =
                                                                                                                                                  player.ParamBase[SK_FIRST_AID] = player.ParamBase[SK_DOCTOR] = player.ParamBase[SK_SNEAK] = player.ParamBase[SK_LOCKPICK] = player.ParamBase[SK_ENGINE] =
                                                                                                                                                                                                                                                                                  player.ParamBase[SK_TRAPS] = player.ParamBase[SK_SCIENCE] = player.ParamBase[SK_REPAIR] = player.ParamBase[SK_SPEECH] = player.ParamBase[SK_BARTER] =
                                                                                                                                                                                                                                                                                                                                                                                                              player.ParamBase[SK_CRAFTING] = player.ParamBase[SK_OUTDOORSMAN] = 300;

    player.ParamBase[ST_ACTION_POINTS] = 80;

    player.ParamBase[ST_CRITICAL_CHANCE] = 100;

    // and even more!
    player.ParamBase[MODE_INVULNERABLE] = 1;
}
void ExecIDKFACommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "IDDQD, IDKFA and send me to hell!");

    Item@ item = target.AddItem(PID_END_BOSS_PLASMA_GUN, 1);
    player.MoveItem(item.Id, 1, SLOT_HAND1);
    player.AddItem(PID_MICRO_FUSION_CELL, 500);
}

void ExecCleanupCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> crits;
    uint            num = player.GetCritters(false, FIND_ALL, crits);
    uint            count = 0;

    for(uint i = 0; i < num; i++)
    {
        if(crits[i].Cond == COND_DEAD)
        {
            if(crits[i].IsPlayer())
                continue;
            else
            {
                DeleteNpc(crits[i]);
                count++;
            }
        }
    }

    player.Say(SAY_NETMSG, count + " critters sucessfully removed.");
}

//
// Controling npcs
//
bool ControlNpc(Critter& npc, string& cmd, Critter& target, Critter& player, bool setHome)
{
    if(cmd == "move" || cmd == "run")
    {
        if(setHome)
            npc.SetHomePos(target.HexX, target.HexY, target.Dir);
        return AddWalkPlane(npc, 0, target.HexX, target.HexY, Random(0, 5), (cmd == "move") ? false : true, 0);
    }
    else if(cmd == "attack")
        return AttackCritter(npc, target);
    else if(cmd == "kill")
        return AttackCritter(npc, target);
    else if(cmd == "stop")
        return npc.ErasePlane(-1, true) > 0 ? true : false;
    else if(cmd == "halt")
        return npc.ErasePlane(AI_PLANE_WALK, true) > 0 ? true : false;
    return false;
}

//
// Controling npc
//
void ExecControlNpcCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Controling npc...");

    string npcTarget = GetParameterString(command, "-t");
    string cmd = GetParameterString(command, "-c");
    bool   setHome = false;
    if(GetIndexOfString(command, "-h") != -1)
        setHome = true;

    if(cmd == "" || !valid(npcTarget))
    {
        player.Say(SAY_NETMSG, "Incorrect parameters");
        return;
    }
    uint npcId = 0;
    StrToInt(npcTarget, npcId);

    Critter@ npc = GetCritter(NPC_ID(npcId));
    if(!valid(npc))
    {
        player.Say(SAY_NETMSG, "Couldn't obtain npc target");
        return;
    }
    if(ControlNpc(npc, cmd, target, player, setHome))
        player.Say(SAY_NETMSG, "OK");
    else
        player.Say(SAY_NETMSG, "Fail");
}

//
// Controling all npcs in sight
//
void ExecControlMobsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Controlling mobs");

    array<Critter@> crits;
    uint            num = player.GetCritters(false, FIND_ALL, crits);

    string          cmd = GetParameterString(command, "-c");
    bool            setHome = false;
    if(GetIndexOfString(command, "-h") != -1)
        setHome = true;

    if((cmd == "") || (!valid(target)))
        return;

    for(uint i = 0; i < num; i++)
    {
        if(crits[i].IsPlayer())
            continue;

        ControlNpc(crits[i], cmd, target, player, setHome);
    }
}

void ExecDeathmatchCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> crits;
    // Critter@[] alive;
    uint            num = player.GetCritters(false, FIND_LIFE_AND_KO, crits);

    /*for(uint z = 0; z < num; z++)
       {
        if(crits[z].Cond != COND_DEAD)
            alive.insertLast( crits[z] );
       }*/

    for(uint i = 0; i < num; i++)
    {
        if(crits[i].IsDead())
            continue;

        if(crits[i].IsPlayer())
            continue;

        for(uint y = Random(0, num); y < num; y++)
        {
            if(!crits[y].IsDead())
                AddAttackPlane(crits[i], 0, crits[y], -6);
        }
    }
}

//
// Sends debug message to nearby npcs
//
void ExecInspectCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Inspecting...");
    // get critters in sight
    array<Critter@> critters;
    uint            num = player.GetCritters(false, FIND_ALL, critters);

    for(uint i = 0; i < num; i++)
    {
        critters[i].Say(SAY_NORM_ON_HEAD, "Hp: " + critters[i].Param[ST_CURRENT_HP] /*GetStat(ST_MAX_LIFE)*/);
    }
    int val = 0;
    if(command.length() > 2)
        StrToInt(command[2], val);

    player.SendMessage(MSG_DEBUG, val, MESSAGE_TO_IAM_VISIBLE);
}

//
// Xp reward
//
void ExecXpCommand(array<string@>@ command, Critter& player, Critter@ target, bool team)
{
    if(team)
        player.Say(SAY_NETMSG, "Rewarding team " + GetSafePlayerName(target.Id) + " belongs to.");
    else
    {
        if(target.Id == player.Id)
            player.Say(SAY_NETMSG, "Rewarding myself...");
        else
            player.Say(SAY_NETMSG, "Rewarding " + GetSafePlayerName(target.Id));
    }

    uint amount = 1000;
    StrToInt(GetParameterString(command, "-a"), amount);

    string          msg = GetParameterString(command, "-m");

    array<Critter@> followers;
    uint            num = 0;

    if(team)
    {
        // make it so target is leader of the group our desired target belongs to(if any)
        if(valid(target.GetFollowLeader()))
            @target = @target.GetFollowLeader();

        num = target.GetFollowGroup(FIND_ALL, followers);
    }
    followers.insertLast(target);
    num++;
    // credit stuff
    if(GM_IsGameMaster(player.Id))
    {
        uint cr = GM_GetCredit(player.Id);
        if(amount * num > cr)
        {
            player.Say(SAY_NETMSG, "Not enough credit points");
            player.Say(SAY_NETMSG, "Required: " + amount * num + ", you have: " + cr);
            return;
        }
        else
            GM_DeduceCredit(player.Id, amount * num);
    }
    for(uint i = 0; i < num; i++)
    {
        if(msg != "")
            followers[i].Say(SAY_NETMSG, msg);
        followers[i].ParamBase[ST_EXPERIENCE] += amount;
        LogExperience(followers[i], amount, "Cheat");
    }
}

//
// Karma modification
//
void ExecKarmaCommand(array<string@>@ command, Critter& player, Critter@ target, bool team)
{
    if(team)
        player.Say(SAY_NETMSG, "Karming team " + GetSafePlayerName(target.Id) + " belongs to.");
    else
    {
        if(target.Id == player.Id)
            player.Say(SAY_NETMSG, "Karming myself...");
        else
            player.Say(SAY_NETMSG, "Karming " + GetSafePlayerName(target.Id));
    }

    uint amount = 10;
    StrToInt(GetParameterString(command, "-a"), amount);

    string          msg = GetParameterString(command, "-m");

    array<Critter@> followers;
    uint            num = 0;
    if(team)
    {
        // make it so target is leader of the group our desired target belongs to(if any)
        if(valid(target.GetFollowLeader()))
            @target = @target.GetFollowLeader();
        num = target.GetFollowGroup(FIND_ALL, followers);
    }
    followers.insertLast(target);
    num++;
    // credit stuff
    if(GM_IsGameMaster(player.Id))
    {
        uint cr = GM_GetCredit(player.Id);
        if(amount * num > cr)
        {
            player.Say(SAY_NETMSG, "Not enough credit points");
            player.Say(SAY_NETMSG, "Required: " + amount * num + ", you have: " + cr);
            return;
        }
        else
            GM_DeduceCredit(player.Id, amount * num);
    }

    for(uint i = 0; i < num; i++)
    {
        if(msg != "")
            followers[i].Say(SAY_NETMSG, msg);
        followers[i].ParamBase[ST_KARMA] += amount;
    }
}

void ExecPlayerKarmaCommand(array<string@>@ command, Critter& player, Critter@ target, bool team)
{
    uint amount = 10;
    StrToInt(GetParameterString(command, "-a"), amount);

    string msg = GetParameterString(command, "-m");

    if(target.Id == player.Id)
    {
        player.Say(SAY_NETMSG, "Karming myself...");
        player.ParamBase[ST_PLAYER_KARMA] = amount;
    }
    else
    {
        player.Say(SAY_NETMSG, "Karming " + GetSafePlayerName(target.Id));

        target.ParamBase[ST_PLAYER_KARMA] = amount;
        if(msg != "")
            target.Say(SAY_NETMSG, msg);
    }
}

//
// Radiation
//
void ExecIrradiateCommand(array<string@>@ command, Critter& player, Critter@ target)
{
    if(target.Id == player.Id)
        player.Say(SAY_NETMSG, "Irradiating myself...");
    else
        player.Say(SAY_NETMSG, "Irradiating " + GetSafePlayerName(target.Id));

    uint amount = 0;
    StrToInt(GetParameterString(command, "-a"), amount);

    if(amount != 0)
        AffectRadiation(target, amount);
    else
        player.Say(SAY_NETMSG, "RadiationLevel: " + target.Param[ST_RADIATION_LEVEL]);
}

//
// list factions
//
void ExecFactionInfoCommand(array<string@>@ command, Critter& player, Critter@ target, bool all)
{
    int id = -1;
    if(command[1] == "factioninfo")
    {
        if(valid(target) && target.Id != player.Id)
        {
            if(target.Param[ST_TEAM_ID] >= 2)
                id = target.Param[ST_TEAM_ID];
            else
            {
                player.Say(SAY_NETMSG, target.Name + "(" + target.Id + ") doesn't belong to any faction.");
                return;
            }
        }
        else if(!StrToInt(GetParameterString(command, "-f"), id))
        {
            player.Say(SAY_NETMSG, "You must specify faction id.");
            return;
        }
    }

    bool fullLog = false;
    if(GetIndexOfString(command, "-full") != -1)
        fullLog = true;

    uint begin = 2;
    uint end = FACTION_COUNT;
    if(command[1] == "listfactions")
    {
        StrToInt(GetParameterString(command, "-b"), begin);
        StrToInt(GetParameterString(command, "-e"), end);
        player.Say(SAY_NETMSG, "Listing factions from to " + begin + (end != FACTION_COUNT ? " to " + end : "end"));
    }

    string[] _rank   = { "UNKNOWN", "Rookie", "Accepted", "Trusted", "Important", "Leader" };
    string[] _status = { "UNKNOWN", "Friend", "Neutral",  "Enemy",   "Invited" };

    for(uint f = 0, fcount = GetFactionsCount(); f < fcount; f++)
    {
        IFaction@ faction = GetFactionByIdx(f);
        if(!valid(faction))
            continue;
        if((id > 0 && faction.get_Id() != id) ||
           (id < 0 && (faction.get_Id() < int(begin) || faction.get_Id() > int(end))))
            continue;

        int fid = (id > 0 ? id : faction.get_Id());

        player.Say(SAY_NETMSG, "\nFaction " + fid);
        player.Say(SAY_NETMSG, "Name: " + faction.get_Name());
        player.Say(SAY_NETMSG, "Score: " + GetFactionScore(fid));
        // player.Say( SAY_NETMSG, "TTL: "+ );
        player.Say(SAY_NETMSG, "Radio channel: " + GetFactionRadioChannel(fid));

        array<IFactionBase@> base;
        GetFactionBases(fid, base);
        if(base.length() > 0)
        {
            player.Say(SAY_NETMSG, "Base" + (base.length() > 1 ? "s" : "") + " (" + base.length() + "):");
            for(uint b = 0, bcount = base.length(); b < bcount; b++)
            {
                player.Say(SAY_NETMSG, " \"" + base[b].get_Name() + "\" (" + base[b].get_Id() + ")");
                string    _loc = "  Location: " + base[b].get_LocationId();
                Location@ loc = GetLocation(base[b].get_LocationId());
                if(valid(loc))
                {
                    player.Say(SAY_NETMSG, _loc + " " + ZONE_X(loc.WorldX) + ":" + ZONE_Y(loc.WorldY) + " " +
                               loc.WorldX + "," + loc.WorldY);
                    Map@ map = loc.GetMapByIndex(0);
                    if(valid(map))
                        player.Say(SAY_NETMSG, "  Map: " + map.Id);
                }
                else
                    player.Say(SAY_NETMSG, _loc + " (don't exists!)");
            }
        }

        if(!fullLog)
        {
            player.Say(SAY_NETMSG, "------------------------------");
            continue;
        }

        array<uint> member;
        faction.GetMembers(member);
        if(member.length() == 0)
        {
            player.Say(SAY_NETMSG, "No members.");
            continue;
        }

        player.Say(SAY_NETMSG, "Member" + (member.length() > 1 ? "s" : "") + " (" + member.length() + "):");
        for(uint m = 0, mcount = member.length(); m < mcount; m++)
        {
            if(m > 0)
                player.Say(SAY_NETMSG, "-------------------");

            int rank   = faction.GetRank(member[m]);
            int status = faction.GetStatus(member[m]);
            player.Say(SAY_NETMSG, " " + GetSafePlayerName(member[m]) + "(" + m + ")" +
                       (rank > 0 ? " " + _rank[rank] : "") +
                       ((rank > 0 && status > 0) ? "," : "") +
                       (status > 0 ? " " + _status[status] : "")
                       );

        }

        player.Say(SAY_NETMSG, "------------------------------");

    }

}

void ExecFactionOnlineCommand(array<string@>@ command, Critter& player)
{
    uint faction = 0;
    bool found = false;
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "You must specify a faction id.");
        return;
    }

    if(!StrToInt(command[2], faction))
    {
        player.Say(SAY_NETMSG, "You must specify a faction id.");
        return;
    }
    array<Critter@> crs;
    uint            num = GetAllOnlinePlayers(crs);
    uint            index = 0;
    for(uint i = 0; i < num; i++)
    {
        if(IsMember(faction, crs[i]))
        {
            if(!found)
            {
                found = true;
                player.Say(SAY_NETMSG, "Listing members from faction " + faction + " that are online:");
            }
            index++;
            player.Say(SAY_NETMSG, "[" + index + "] " + GetCritterInfo(crs[i]));
        }
    }

    if(!found)
        player.Say(SAY_NETMSG, "Found no members from faction " + faction + " online.");
}

void ExecFindItemsCommand(array<string@>@ command, Critter& player)
{
    int  owner = 0; // spawner, if 0, by game, if not specified, all.
    bool OwnerSpecified = false;
    StrToInt(GetParameterString(command, "-o"), owner);
    if(GetIndexOfString(command, "-o") != -1)
        OwnerSpecified = true;

    if(GetIndexOfString(command, "-pid") == -1)
    {
        player.Say(SAY_NETMSG, "No PID given. Use -pid <pid>");
        return;
    }

    uint   pid = 0;
    string pidString = GetParameterString(command, "-pid");

    uint   From = 0;
    StrToInt(GetParameterString(command, "-f"), From);

    uint KeyId = 0;
    StrToInt(GetParameterString(command, "-k"), KeyId);

    uint To = 0;
    StrToInt(GetParameterString(command, "-t"), To);

    uint Min = 0;
    StrToInt(GetParameterString(command, "-min"), Min);

    bool noInv = (GetIndexOfString(command, "-skipinventory") > 0);
    bool noCont = (GetIndexOfString(command, "-skipcontainer") > 0);
    bool noHex = (GetIndexOfString(command, "-skipground") > 0);

    bool parsed = StrToInt(pidString, pid);
    // otherwise, check in the global dictionary
    if(pidString == "")
        return;
    if(!parsed)
    {
        if(!GetItemPid(pidString, pid))
        {
            player.Say(SAY_NETMSG, "Item does not exist");
            return;
        }
    }


    if(pid == 0 && !OwnerSpecified)
        return;
    // ((FromPid>0&&ToPid>0)?("from "+ FromPid + " to "+ToPid):""+pid)
    player.Say(SAY_NETMSG, "Searching for items with PID " + pid + (owner > 0 ? " spawned by " + owner : "") + ".");

    array<Item@> items;
    uint         n = 0;
    n = GetAllItems(pid, items);

    if(To == 0)
        To = n;
    if(From == 0)
        From = 1;

    uint found = 0;
    uint count = 1;
    for(uint i = From - 1; i < To; i++)
    {
        if(i >= items.length())
            break;

        if(KeyId > 0 && items[i].LockerId != KeyId)
            continue;

        if(noInv && items[i].Accessory == ACCESSORY_CRITTER)
            continue;

        if(noCont && items[i].Accessory == ACCESSORY_CONTAINER)
            continue;

        if(noHex && items[i].Accessory == ACCESSORY_HEX)
            continue;

        if((!OwnerSpecified || _GetSpawner(items[i]) == owner))
        {
            string ownerInfo = "";
            int    spawnerId = _GetSpawner(items[i]);
            if(!OwnerSpecified && spawnerId > 0)
            {
                string sOwner = GetSafePlayerName(spawnerId);
                ownerInfo = " (spawned:" + (sOwner == "[player not found]" ? "" + spawnerId : sOwner + "(" + spawnerId + ")") + ")";
            }
            else if(pid == 0)
            {
                ownerInfo = " PID(" + items[i].GetProtoId() + ")";
            }

            count = items[i].GetCount();
            if(count >= Min)
            {
                found++;
                string pref = "[" + ((From - 1) + found) + "] ";


                if(items[i].Accessory == ACCESSORY_CRITTER)
                    player.Say(SAY_NETMSG, pref + count + " item" + (count > 1 ? "s" : "") + " (" + items[i].Id + ") on critter " + items[i].CritId + ownerInfo);
                else if(items[i].Accessory == ACCESSORY_CONTAINER)
                {
                    Item@ cont = GetItem(items[i].ContainerId);
                    player.Say(SAY_NETMSG, pref + count + " item" + (count > 1 ? "s" : "") + " (" + items[i].Id + ") in container " + items[i].ContainerId + (!valid(cont) ? "(bugged) " : "") + " in map " + cont.MapId + " [" + cont.HexX + "," + cont.HexY + "]" + ownerInfo);
                }
                else if(items[i].Accessory == ACCESSORY_HEX)
                    player.Say(SAY_NETMSG, pref + count + " item" + (count > 1 ? "s" : "") + " (" + items[i].Id + ") on ground in map " + items[i].MapId + " [" + items[i].HexX + "," + items[i].HexY + "]" + ownerInfo);
                else
                    player.Say(SAY_NETMSG, pref + "Didn't find item. Strange.");
            }
        }
    }
    if(found == 0)
        player.Say(SAY_NETMSG, "Found no items.");
}

//
// Forces target to say specific message
//
void ExecSayCommand(array<string@>@ command, Critter& player, Critter@ target, int sayType)
{
    if(sayType == SAY_FLASH_WINDOW)
        player.Say(SAY_NETMSG, "Flashing...");
    else
        player.Say(SAY_NETMSG, "Saying...");

    string msg = GetParameterString(command, "-m");

    if(sayType == SAY_FLASH_WINDOW)
    {
        target.Say(sayType, "flash");
        return;
    }
    if(msg != "")
        target.Say(sayType, msg);
    else
        player.Say(SAY_NETMSG, "Nothing to say");
}

//
// Forces animation
//
/*
   void ExecAnimateCommand(string@[]@ command, Critter& player, Critter@ target)
   {
    player.Say(SAY_NETMSG, "Dance, dance, dance!");

    string animation;

    if(command.length() > 2)
        animation = command[2];
    else
    {
        player.Say(SAY_NETMSG, "Incorrect animation type");
        return;
    }

    if(animation == "use")
        _CritAnimateUse(target);
    else if(animation == "sit")
        _CritAnimateSit(target);
    else if(animation == "punch")
        _CritAnimatePunch(target);
    else if(animation == "kick")
        _CritAnimateKick(target);
    else if(animation == "throw")
        _CritAnimateThrow(target);
    else if(animation == "thrust")
        _CritAnimateThrust(target);
    else if(animation == "swing")
        _CritAnimateSwing(target);
    else if(animation == "single")
        _CritAnimateSingle(target);
    else if(animation == "burst")
        _CritAnimateBurst(target);
        else
        {
                // more sophisticated
                string a1 = GetParameterString(command, "-a");
                string a2 = GetParameterString(command, "-b");
                uint8 anim1 = 0xFF;
                uint8 anim2 = ANIM2_USE;

                if(a1 == "empty")
                        anim1 = ANIM1_EMPTY;
                else if(a1 == "ko")
                        anim1 = ANIM1_KO;
                else if(a1 == "dead")
                        anim1 = ANIM1_DEAD;
                else if(a1 == "knife")
                        anim1 = ANIM1_KNIFE;
                else if(a1 == "club")
                        anim1 = ANIM1_CLUB;
                else if(a1 == "hammer")
                        anim1 = ANIM1_HAMMER;
                else if(a1 == "spear")
                        anim1 = ANIM1_SPEAR;
                else if(a1 == "pistol")
                        anim1 = ANIM1_PISTOL;
                else if(a1 == "uzi")
                        anim1 = ANIM1_UZI;
                else if(a1 == "shotgun")
                        anim1 = ANIM1_SHOOTGUN;
                else if(a1 == "rifle")
                        anim1 = ANIM1_RIFLE;
                else if(a1 == "minigun")
                        anim1 = ANIM1_MINIGUN;
                else if(a1 == "rl")
                        anim1 = ANIM1_ROCKET_LAUNCHER;
                else if(a1 == "rip")
                        anim1 = ANIM1_RIP;

                if(a2 == "ko_up")
                {
                        anim1 = ANIM1_KO;
                        anim2 = ANIM2_KO_UP;
                }
                else if(a2 == "ko_dw")
                {
                        anim1 = ANIM1_KO;
                        anim2 = ANIM2_KO_DW;
                }
                else if(a2 == "stay")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_STAY;
                }
                else if(a2 == "show")
                        anim2 = ANIM2_SHOW;
                else if(a2 == "hide")
                        anim2 = ANIM2_HIDE;
                else if(a2 == "miss_weap")
                        anim2 = ANIM2_MISS_WEAP;
                else if(a2 == "miss_empty")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_MISS_EMPTY;
                }
                else if(a2 == "act")
                        anim2 = ANIM2_ACT;
                else if(a2 == "unact")
                        anim2 = ANIM2_UNACT;
                else if(a2 == "walk")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_WALK;
                }
                else if(a2 == "run")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_RUN;
                }
                else if(a2 == "use")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_USE;
                }
                else if(a2 == "sit")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_SIT;
                }
                else if(a2 == "defeat_front")
                        anim2 = ANIM2_DEFEAT_FRONT;
                else if(a2 == "defeat_rear")
                        anim2 = ANIM2_DEFEAT_REAR;
                else if(a2 == "punch")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_PUNCH;
                }
                else if(a2 == "kick")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_KICK;
                }
                else if(a2 == "throw_weap")
                        anim2 = ANIM2_THROW_WEAP;
                else if(a2 == "throw_empty")
                {
                        anim1 = ANIM1_EMPTY;
                        anim2 = ANIM2_THROW_EMPTY;
                }
                else if(a2 == "thrust")
                        anim2 = ANIM2_THRUST;
                else if(a2 == "swing")
                        anim2 = ANIM2_SWING;
                else if(a2 == "shoot")
                        anim2 = ANIM2_SHOOT;
                else if(a2 == "burst")
                        anim2 = ANIM2_BRUST;
                else if(a2 == "dead_up")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_UP;
                }
                else if(a2 == "dead_down")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_DOWN;
                }
                else if(a2 == "dead_mess")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_MESS;
                }
                else if(a2 == "dead_burn")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_BURN;
                }
                else if(a2 == "dead_head")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_HEAD;
                }
                else if(a2 == "dead_burst")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_BRUST;
                }
                else if(a2 == "dead_pulse")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_PULSE;
                }
                else if(a2 == "dead_laser")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_LASER;
                }
                else if(a2 == "dead_burn2")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_BURN2;
                }
                else if(a2 == "dead_pulse2")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_PULSE2;
                }
                else if(a2 == "dead_explode")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_EXPLODE;
                }
                else if(a2 == "dead_fused")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_FUSED;
                }
                else if(a2 == "dead_burn_run")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_BURN_RUN;
                }
                else if(a2 == "dead_up2")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_UP2;
                }
                else if(a2 == "dead_down2")
                {
                        anim1 = ANIM1_DEAD;
                        anim2 = ANIM2_DEAD_DOWN2;
                }

                // even more sophisticated
                string ct = GetParameterString(command, "-c");
                uint8 crType = 0xFF;
                StrToInt(ct, crType);

                // finally, animate
                target.Animate(crType, anim1, anim2, 0xFF, 0, true, true, true);
        }
   }*/

void ExecSetAnimCommand(array<string@>@ command, Critter& player, Critter@ target, bool mass)
{
    if(command.length() < 4)
    {
        player.Say(SAY_NETMSG, "Missing arguments.");
        return;
    }

    int anim1 = 0;
    int anim2 = 0;

    StrToInt(command[2], anim1);
    StrToInt(command[3], anim2);

    player.Say(SAY_NETMSG, "Dance for me!");
    if(mass)
    {
        array<Critter@> crits;
        uint            num = player.GetCritters(false, FIND_ALL, crits);
        for(uint i = 0; i < num; i++)
        {
            if(!GodOfTheRealm(crits[i].Id))
                crits[i].SetAnims(0, anim1, anim2);
        }

    }
    else
        target.SetAnims(0, anim1, anim2);
}

//
// Changes critter sprites
//
void ExecDisguiseCommand(array<string@>@ command, Critter& player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Wearing disguise...");

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Incorrect number of parameters");
        return;
    }
	
    uint bt = player.CrType;
    bool res = false;

    bool parsed = StrToInt(command[2], bt);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetBaseType(command[2], bt))
        {
            player.Say(SAY_NETMSG, "Basetype does not exist");
            return;
        }
    }
	
	if(command.length() > 3)
	{
		int  control = 0;
		if(!StrToInt(command[3], control))
			{
				player.Say(SAY_NETMSG, "Wrong arguments.");
				return;
			}
			else
			{
				if(control > 0)
				{
					@target = GetCritter(control);
				}
				else
				{
					player.Say(SAY_NETMSG, "Invalid param group.");
					return;
				}
			}
	}
    player.Say(SAY_NETMSG, "Changing from: " + target.CrType + " to " + bt);
    res = target.ChangeCrType(bt);

    if(!res)
        player.Say(SAY_NETMSG, "Couldn't change appearance");
    else
    {
        target.ParamBase[ST_BASE_CRTYPE] = bt;
        target.DisguisedBy = player.Id;
    }
}

void ExecMassDisguiseCommand(array<string@>@ command, Critter& player)
{
	player.Say(SAY_NETMSG, "Wearing disguise...");
	int teama = 0;
    cheatGetOption(command, teama, "-a");
	uint teamb = 0;
    cheatGetOption(command, teamb, "-b");
	array<Critter@> critters;
    uint            num = player.GetMap().GetCritters(0, FIND_ALL | FIND_ONLY_NPC, critters);
	for(uint j = 0; j < num; j++)
		{
		if(critters[j].CrType != teamb)
			continue;
        critters[j].ChangeCrType(teama);
		critters[j].DisguisedBy = player.Id;
		}
}

void ExecDisguiseInfoCommand(array<string@>@ command, Critter& player)
{
    array<Critter@> players;
    uint            all = GetAllOnlinePlayers(players);
    for(uint p = 0; p < all; p++)
    {
        #ifndef __DEBUG__
        if(GodOfTheRealm(players[p].Id))
            continue;

        if(players[p].GetAccess() > ACCESS_CLIENT)
            continue;
        #endif

        if(players[p].ParamBase[ST_GENDER] == GENDER_MALE &&
           (players[p].ParamBase[ST_BASE_CRTYPE] == CRTYPE_MALE_DEFAULT ||
            players[p].ParamBase[ST_BASE_CRTYPE] == CRTYPE_MALE_JUMPSUIT ||
            players[p].ParamBase[ST_BASE_CRTYPE] == CRTYPE_LHD_JUMPSUIT ||
            players[p].ParamBase[ST_BASE_CRTYPE] == CRTYPE_BHD_JUMPSUIT))
            continue;

        if((players[p].ParamBase[ST_GENDER] == GENDER_FEMALE &&
            players[p].ParamBase[ST_BASE_CRTYPE] == CRTYPE_FEMALE_DEFAULT))
            continue;

        string info = players[p].Name + "(" + players[p].Id + "): CritterType " +
                      players[p].ParamBase[ST_BASE_CRTYPE];

        if(int(players[p].CrType) != players[p].ParamBase[ST_BASE_CRTYPE])
            info += " (" + players[p].CrType + ")";

        if(players[p].DisguisedBy > 0 && (players[p].DisguisedBy != players[p].Id))
        {
            info += " by ";
            string@ name = GetSafePlayerName(players[p].DisguisedBy);

            if(valid(name))
                info += name + " ";
            else
                info += "??? ";

            info += "(" + players[p].DisguisedBy + ")";
        }
        player.Say(SAY_NETMSG, info);
    }

}


void ExecConditionCommand(array<string@>@ command, Critter& player, Critter@ target)
{
    if(command.length() < 2)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }

    uint id = GetPlayerId(command[2]);

    if(id == 0)
    {
        player.Say(SAY_NETMSG, "Invalid player");
    }
    else
    {
        Critter@ target = GetCritter(id);
        if(!valid(target))
        {
            player.Say(SAY_NETMSG, "Invalid player");
        }
        else
        {
            player.Say(SAY_NETMSG, "Conditions of " + command[2] + ":");
            player.Say(SAY_NETMSG, "" + GetConditionOfCritter(target));
            player.Say(SAY_NETMSG, "" + GetExtConditionOfCritter(target));
        }
    }
}

void ExecBroadcastCommand(array<string@>@ command, Critter& player)
{
    /*
       string message;
       int showtime=10; // 10 seconds as default, 1337 = show forever.
       message = GetParameterString(command, "-m");
       StrToInt(GetParameterString(command, "-t"), showtime);

       if (message=="")
       {
       player.Say(SAY_NETMSG, "You didn't enter a message. Maybe you forgot to use '-m' ?");
       return;
       }

       bool Local = (GetIndexOfString(command, "-l")!=-1);

       Critter@[] players;
       uint num;
       if(Local)
       {
       if(player.GetMapId()==0)
       {
        player.Say(SAY_NETMSG, "Can't broadcast locally on worldmap.");
        return;
       }
        Map@ map = player.GetMap();
        if(!valid(map))
        {
            player.Say(SAY_NETMSG, "Invalid map.");
        return;
        }
        num = map.GetCritters(0, FIND_ALL | FIND_ONLY_PLAYERS, players);
       }
       else
       num = GetAllOnlinePlayers(players);

       for (uint i = 0; i < num; i++)
       {
       players[i].Say(SAY_NETMSG, "|4294901760 "+(!Local?"Server message: ":"")+message);
       players[i].RunClientScript("_BroadcastMessage", showtime, (Local?1:0), 0, message, null);
       }
     */
    IBroadcastBuffer@        msg;

    array<IBroadcastBuffer@> buf;
    FindBroadcastBufferByGM(player.Id, buf);
    string                   msgs = " broadcast message(s)";
    string                   no_msgs = "You don't have" + msgs + " in buffer.";

    // player.Say( SAY_NETMSG, "buf len = "+buf.length() );

    if(GetIndexOfString(command, "-delete") >= 0)
    {
        if(buf.length() == 0)
        {
            player.Say(SAY_NETMSG, no_msgs);
            return;
        }
        else
        {
            player.Say(SAY_NETMSG, "Deleting" + msgs);
            for(uint b = 0; b < buf.length(); b++)
            {
                buf[b].ResetStart();
                buf[b].SetLifetime(0);
                buf[b].ToDelete();
            }
        }
        return;
    }
    else if(GetIndexOfString(command, "-test") >= 0)
    {
        if(buf.length() == 0)
        {
            player.Say(SAY_NETMSG, no_msgs);
            return;
        }
        else
        {
            player.Say(SAY_NETMSG, "Testing" + msgs);
            for(uint b = 0; b < buf.length(); b++)
            {
                buf[b].ResetStart();
                buf[b].Send(player);
                buf[b].SetStart(-1);
            }
        }
        return;
    }
    else if(GetIndexOfString(command, "-send") >= 0)
    {
        if(buf.length() == 0)
        {
            player.Say(SAY_NETMSG, no_msgs);
            return;
        }
        else
        {
            player.Say(SAY_NETMSG, "Sending" + msgs);
            for(uint b = 0; b < buf.length(); b++)
            {
                buf[b].ResetStart();
                buf[b].SendToAll();
                buf[b].UnsetGM();
            }
        }
        return;
    }

    bool   wait = (GetIndexOfString(command, "-wait") != -1);

    string message = GetParameterString(command, "-m");
    if(message == "")
    {
        player.Say(SAY_NETMSG, "You didn't enter a message. Maybe you forgot to use -m ?");
        return;
    }

    array<int> data;
    if(buf.length() == 0)
    {
        @msg = AddBroadcastBuffer(BROADCAST_MESSAGE, 0, 0, "Server message: " + message, data, 0, BROADCAST_FILTER_NONE);
        if(wait)
            msg.SetStart(-1);
    }
    else if(buf.length() == 1)
    {
        @msg = @buf[0];
        msg.AppendMessage("\n" + message);
        wait = true;
    }
    else
    {
        player.Say(SAY_NETMSG, "More than one broadcast assigned to you, cannot continue.");
        return;
    }
    msg.SetGM(player.Id);

    int showtime = 0;
    string[] t = { "-t", "-time" };
    if(StrToInt(GetParameterString(command, t), showtime))
        showtime = REAL_SECOND(showtime);
    else
        showtime = REAL_SECOND(40) + REAL_MS(message.length() * 100);
    msg.SetTime(showtime);

    string[] sf = { "-f", "-filter" };
    string f = GetParameterString(command, sf);

    bool   ilog = true;

    if(f != "")
    {
        array<string@>@ filters = split(f, ",");
        if(filters.length() > 0)
        {
            ilog = false;
            for(uint f = 0; f < filters.length(); f++)
            {
                // easy flags
                if(filters[f] == "tester")
                    msg.SetFilter(BROADCAST_FILTER_TESTER);
                else if(filters[f] == "moder")
                    msg.SetFilter(BROADCAST_FILTER_MODER);
                else if(filters[f] == "admin")
                    msg.SetFilter(BROADCAST_FILTER_ADMIN);
                else if(filters[f] == "auth" || filters[f] == "authenticated")
                    msg.SetFilter(BROADCAST_FILTER_AUTHENTICATED);
                else if(filters[f] == "god")
                    msg.SetFilter(BROADCAST_FILTER_GOD);
                else if(filters[f] == "mortal")
                    msg.SetFilter(BROADCAST_FILTER_MORTAL);
                else if(filters[f] == "female")
                    msg.SetFilter(BROADCAST_FILTER_FEMALE);
                else if(filters[f] == "male")
                    msg.SetFilter(BROADCAST_FILTER_MALE);
                else if(filters[f] == "wm" || filters[f] == "worldmap")
                    msg.SetFilter(BROADCAST_FILTER_MODER);
                // things get worse
                else if(substring(filters[f], 0, 3) == "map")
                {
                    array<string@>@ map = split(filters[f], ":");
                    if(map.length() == 1)                         // map
                    {
                        if(valid(player.GetMap()))
                            msg.SetFilter(BROADCAST_FILTER_MAP, player.GetMap().Id);
                        else
                        {
                            player.Say(SAY_NETMSG, "Invalid map.");
                            return;
                        }
                    }
                    else if(map.length() == 2)                         // map:X
                    {
                        int mapId = 0;
                        StrToInt(map[1], mapId);
                        if(mapId > 0)
                        {
                            if(!valid(GetMap(mapId)))
                            {
                                player.Say(SAY_NETMSG, "Invalid map id: " + mapId);
                                return;
                            }
                            else
                                msg.SetFilter(BROADCAST_FILTER_MAP, mapId);
                        }
                        else
                        {
                            if(map[1] == "any")
                            {
                                msg.SetFilter(BROADCAST_FILTER_ANYMAP);
                            }
                            else
                            {
                                player.Say(SAY_NETMSG, "Invalid argument for filter 'map'");
                                return;
                            }
                        }
                    }
                    else
                    {
                        player.Say(SAY_NETMSG, "Wrong number of arguments for filter 'map'");
                        return;
                    }
                }
                else if(substring(filters[f], 0, 3) == "loc")
                {
                    array<string@>@ loc = split(filters[f], ":");
                    if(loc.length() == 1)                         // loc
                    {
                        if(valid(player.GetMap()) && valid(player.GetMap().GetLocation()))
                            msg.SetFilter(BROADCAST_FILTER_LOCATION, player.GetMap().GetLocation().Id);
                        else
                        {
                            player.Say(SAY_NETMSG, "Invalid map/location.");
                            return;
                        }
                    }
                    else if(loc.length() == 2)                         // loc:X
                    {
                        int locId = 0;
                        StrToInt(loc[1], locId);
                        if(locId > 0)
                        {
                            if(!valid(GetLocation(locId)))
                            {
                                player.Say(SAY_NETMSG, "Invalid location id: " + locId);
                                return;
                            }
                            else
                                msg.SetFilter(BROADCAST_FILTER_LOCATION, locId);
                        }
                        else
                        {
                            player.Say(SAY_NETMSG, "Invalid argument for filter 'loc'");
                            return;
                        }
                    }
                    else
                    {
                        player.Say(SAY_NETMSG, "Wrong number of arguments for filter 'loc'");
                        return;
                    }
                }
                else if(substring(filters[f], 0, 3) == "lvl")
                {
                    array<string@>@ lvl = split(filters[f], ":");
                    if(lvl.length() == 1)                         // lvl
                    {
                        player.Say(SAY_NETMSG, "Level not given.");
                        return;
                    }
                    else if(lvl.length() == 2)                         // lvl:X
                    {
                        int lvlNum = 0;
                        if(StrToInt(lvl[1], lvlNum))
                        {
                            if(lvlNum < 1)
                            {
                                player.Say(SAY_NETMSG, "Invalid level: " + lvlNum);
                                return;
                            }
                            else
                                msg.SetFilter(BROADCAST_FILTER_LEVEL, lvlNum);
                        }
                        else
                        {
                            player.Say(SAY_NETMSG, "Invalid argument for filter 'lvl'");
                            return;
                        }
                    }
                    else
                    {
                        player.Say(SAY_NETMSG, "Wrong number of arguments for filter 'lvl'");
                        return;
                    }
                }
                else if(substring(filters[f], 0, 7) == "faction" || substring(filters[f], 0, 4) == "gang")
                {
                    array<string@>@ faction = split(filters[f], ":");
                    if(faction.length() == 1)                         // faction/gang
                    {
                        player.Say(SAY_NETMSG, "Faction not given.");
                        return;
                    }
                    else if(faction.length() == 2)                         // faction:X
                    {
                        int factionId = 0;
                        if(StrToInt(faction[1], factionId))
                        {
                            if(factionId <= 1)                                 // don't send to 'Unknown' faction
                            {
                                player.Say(SAY_NETMSG, "Invalid faction id: " + factionId);
                                return;
                            }
                            else
                                msg.SetFilter(BROADCAST_FILTER_FACTION, factionId);
                        }
                        else
                        {
                            player.Say(SAY_NETMSG, "Invalid argument for filter 'faction'");
                            return;
                        }
                    }
                    else
                    {
                        player.Say(SAY_NETMSG, "Wrong number of arguments for filter 'faction'");
                        return;
                    }
                }
            }
        }
    }

    string[] cf = { "-c", "-color" };
    int c = 0;
    StrToInt(GetParameterString(command, cf), c);
    // if( c > 0 )
    msg.SetSetup(c);

    if(wait)
    {
        player.Say(SAY_NETMSG, "Broadcast buffered:");
        player.Say(SAY_NETMSG, msg.GetMessage());
    }
    else
    {
        if(ilog)
            ILog("broadcast", msg.GetMessage());
        msg.SendToAll();
    }
}


void ExecSetFactionCommand(array<string@>@ command, Critter& player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Setting faction on this map");
    if(command.length() < 3)
        player.Say(SAY_NETMSG, "Please, specify faction id");
    else
    {
        uint id = 0;
        if(StrToInt(command[2], id))
            player.GetMap().SetData(MAP_DATA_FACTION, id);
        else
            player.Say(SAY_NETMSG, "Wrong id");
    }
}
void prewipemadness(Critter& player, int fortest, int r, int)
{
	array<Critter@> players;
    uint            num = GetAllPlayers(players);
	array<Location@> locs;
	uint num2 = 0; 
	for(uint i = 0; i < 1000; i++)
    {
	num2 += GetAllLocations(i, locs);

	}
	for(uint i = 0; i < num2; i++)
	{
		locs[i].Visible = true;
	}

}




void ExecSetLocVisibility(array<string@>@ command, Critter& player)
{
    if(command.length() < 3)
        player.Say(SAY_NETMSG, "Choose visibility flag. 1=visible, 0=hidden.");

    uint flag = 0;
    if(!StrToInt(command[2], flag))
    {
        player.Say(SAY_NETMSG, "Error.");
        return;
    }

    Location@ loc = player.GetMap().GetLocation();
    if(!valid(loc))
    {
        player.Say(SAY_NETMSG, "Are you on the worldmap? This command can only be applied to a location.");
        return;
    }

    if(flag == 0)
    {
        loc.Visible = false;
    }
    else
    {
        loc.Visible = true;
    }

    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);

    // Hide for all players
    for(uint i = 0; i < num; i++)
    {
        if(!valid(players[i]))
            continue;
        if(!players[i].IsPlayer())
            continue;
        if(flag == 0)
            players[i].SetKnownLoc(false, loc.Id);
        else
            players[i].SetKnownLoc(true, loc.Id);
    }
    if(flag == 0)
        player.Say(SAY_NETMSG, "Location hidden.");
    else
        player.Say(SAY_NETMSG, "Location shown.");

    loc.Update();
}

void ExecSetRain(array<string@>@ command, Critter& player)
{
    player.Say(SAY_NETMSG, "Setting rain on this map");
    if(command.length() < 3)
        player.Say(SAY_NETMSG, "Please, specify rain intensity");
    else
    {
        uint intensity = 0;
        if(StrToInt(command[2], intensity))
            player.GetMap().SetRain(intensity);
        else
            player.Say(SAY_NETMSG, "Wrong intensity");
    }
}

void ExecSetMapDataCommand(array<string@>@ command, Critter& player)
{
    if(command.length() < 4)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    int  Index = 0;
    bool parsed = StrToInt(command[2], Index);
    if(!parsed)
    {
        if(!GetMapData(command[2], Index))
        {
            player.Say(SAY_NETMSG, "Mapdata define does not exist");
            return;
        }
    }
    int Value = 0;
    if(!StrToInt(command[3], Value))
    {
        player.Say(SAY_NETMSG, "Invalid value.");
        return;
    }
    Map@ map = player.GetMap();
    map.SetData(Index, Value);
    player.Say(SAY_NETMSG, "Mapdata set.");
}

void ExecSetTurnbasedCombat(Critter& player, bool enable)
{
    Map@ map = player.GetMap();
    if(valid(map))
    {
        map.SetTurnBasedAvailability(enable);
        if(enable)
            player.Say(SAY_NETMSG, "TB in the map enabled.");
        else
            player.Say(SAY_NETMSG, "TB in the map disabled.");
    }
}

void ExecMapDismantling(Critter& player, bool enable)
{
    Map@ map = player.GetMap();
    if(valid(map))
    {
        if((!enable &&  _MapHasMode(map, MAP_MODE_NO_DISMANTLING)) ||
           (enable  && !_MapHasMode(map, MAP_MODE_NO_DISMANTLING)))
        {
            player.Say(SAY_NETMSG, "Dismantling already " + (enable ? "en" : "dis") + "abled.");
            return;
        }
        if(enable)
            _MapUnsetMode(map, MAP_MODE_NO_DISMANTLING);
        else
            _MapSetMode(map, MAP_MODE_NO_DISMANTLING);
        player.Say(SAY_NETMSG, "Dismantling " + (enable ? "en" : "dis") + "abled.");
    }
    else
    {
        player.Say(SAY_NETMSG, "Not on worldmap.");
    }
}

uint SafeContainerId;

void ExecEventTimer(array<string@>@ command,Critter& player)
{
	string messagew = GetParameterString(command, "-w");
	string message = GetParameterString(command, "-m");
	int time = 0;
    cheatGetOption(command, time, "-t");
	
	int typeA = 0;
    cheatGetOption(command, typeA, "-a");
	int typeB = 0;
    cheatGetOption(command, typeB, "-b");
	if(time < 1)
		time = 5;
	int location = player.Id;
	string textA = " will start in ";
	string textB = " Join in ";
	switch(typeA)
	{
	case 1: textA = " will end in "; break;
	case 2: textA = " till "; break;
	case 3: textA = " join in "; break;
	case 4: textA = " "; break;
	case 5: textA = " Server Restart in "; break;
	default:
	textA = " will start in ";
	break;
	}
	switch(typeB)
	{
	case 1: textB = " Don't be late "; break;
	case 2: textB = " Zone "; break;
	case 3: textB = " no gear, no drugs, don't be late, join in "; break;
	case 4: textB = " "; break;
	case 5: textB = " Run Updater "; break;
	case 6: textB = " Own Gearm join in "; break;
	default:
	textB = " Join in ";
	break;
	}
	int type = EVENT_TYPE_TRADER_1;
	string messageE = "%COUNTDOWN%.";
	ServerEventCNTSet(message + textA +	messageE + textB + messagew, location, type, REAL_MINUTE(time));
	FLog(LOG_BROADCAST, message + textA +	messageE + textB + messagew);
	file f;
	f.open("logs/broadcast.txt", "w");
	f.writeString(message + textA +	time + " minutes " + textB + messagew);
	f.close();
}

void ExecMapPvp(Critter& player, bool enable)
{
    Map@ map = player.GetMap();
    if(valid(map))
    {
        if((!enable &&  _MapHasMode(map, MAP_MODE_NO_PVP)) ||
           (enable  && !_MapHasMode(map, MAP_MODE_NO_PVP)))
        {
            player.Say(SAY_NETMSG, "PvP already " + (enable ? "en" : "dis") + "abled.");
            return;
        }
        if(enable)
            _MapUnsetMode(map, MAP_MODE_NO_PVP);
        else
            _MapSetMode(map, MAP_MODE_NO_PVP);
        player.Say(SAY_NETMSG, "PvP " + (enable ? "en" : "dis") + "abled.");
    }
    else
    {
        player.Say(SAY_NETMSG, "Not on worldmap.");
    }
}

void ExecMapPve(Critter& player, bool enable)
{
    Map@ map = player.GetMap();
    if(valid(map))
    {
        if((!enable &&  _MapHasMode(map, MAP_MODE_NO_PVE)) ||
           (enable  && !_MapHasMode(map, MAP_MODE_NO_PVE)))
        {
            player.Say(SAY_NETMSG, "PvE already " + (enable ? "en" : "dis") + "abled.");
            return;
        }
        if(enable)
            _MapUnsetMode(map, MAP_MODE_NO_PVP);
        else
            _MapSetMode(map, MAP_MODE_NO_PVP);
        player.Say(SAY_NETMSG, "PvE " + (enable ? "en" : "dis") + "abled.");
    }
    else
    {
        player.Say(SAY_NETMSG, "Not on worldmap.");
    }
}

void ExecMapGrids(Critter& player, bool enable)
{
    Map@ map = player.GetMap();
    if(valid(map))
    {
        if((!enable &&  _MapHasMode(map, MAP_MODE_NO_GRIDS)) ||
           (enable  && !_MapHasMode(map, MAP_MODE_NO_GRIDS)))
        {
            player.Say(SAY_NETMSG, "Exit grids already " + (enable ? "en" : "dis") + "abled.");
            return;
        }
        if(enable)
        {
            _MapUnsetMode(map, MAP_MODE_NO_GRIDS);
            map.SetEvent(MAP_EVENT_LOOP_3, "_DoNothing");
            map.SetLoopTime(3, uint(-1));
            SetTimeoutForAll(map, TO_TRANSFER, 0);
        }
        else
        {
            // in case of changes, remember about editing main@start

            _MapSetMode(map, MAP_MODE_NO_GRIDS);
            map.SetEvent(MAP_EVENT_LOOP_3, "_LockMap");
            map.SetLoopTime(3, 500);
            SetTimeoutForAll(map, TO_TRANSFER, REAL_SECOND(2238));
        }

        player.Say(SAY_NETMSG, "Exit grids " + (enable ? "en" : "dis") + "abled.");
    }
    else
    {
        player.Say(SAY_NETMSG, "Not on worldmap.");
    }
}

void ExecClearEnemyStackCommand(array<string@>@ command, Critter& player, Critter@ target, bool all)
{
    if(!valid(player.GetMap()))          // worldmap
    {
        player.Say(SAY_NETMSG, "Not here.");
        return;
    }
    // Clear enemy stacks on all critters on the map command issuer is on
    if(all)
    {
        ClearEnemyStacksOnMap(player.GetMap());
        player.Say(SAY_NETMSG, "Cleared enemy stack of all critters on this map");
    }
    else
    {
        if(target.IsPlayer())
        {
            player.Say(SAY_NETMSG, "Target is not an NPC. Only NPCs have enemy stacks");
            return;
        }

        ClearEnemyStack(target);
        player.Say(SAY_NETMSG, "Cleared target enemy stack");
    }
}

void ExecCheckBankCommand(array<string@>@ command, Critter& player)
{
    string bankid = GetParameterString(command, "-b");
    int    id = 0;
    StrToInt(bankid, id);

    if(id > BANK_COUNT - 1 || id < 0)
    {
        player.Say(SAY_NETMSG, "Invalid bank ID");
        return;
    }

    string sid = "";
    switch(id)
    {
    case 0:
        sid = "Vault City";
        break;
    case 1:
        sid = "Redding";
        break;
    case 2:
        sid = "Broken Hills";
        break;
    case 3:
        sid = "San Francisco";
        break;
    case 4:
        sid = "Shady Sands";
        break;
    case 5:
        sid = "Hub";
        break;
    default:
        sid = "Unknown";
        break;
    }

    player.Say(SAY_NETMSG, "Bank " + id + " (" + sid + "):");
    player.Say(SAY_NETMSG, "Money reserves: " + "$" + BankGetTotalMoney(id));
    player.Say(SAY_NETMSG, "Accounts: " + BankGetNumberOfAccounts(id));
}

void ExecCheckBanksCommand(array<string@>@ command, Critter& player)
{
    command[1] = "checkbank";
    command.resize(3);

    for(uint b = 0; b < BANK_COUNT; b++)
    {
        command[3] = "" + b;
        ExecCheckBankCommand(command, player);
    }
}

void PrintAccountInfo(Critter& player, uint bank, uint acc, uint filtersum, bool verbose)
{
    if(BankGetAccountBalance(bank, acc) < int(filtersum))
        return;

    uint accountowner = BankGetAccountOwner(bank, acc);
    player.Say(SAY_NETMSG, "Owner: " + GetSafePlayerName(accountowner) + " (" + accountowner + ")");
    player.Say(SAY_NETMSG, "Balance: " + BankGetAccountBalance(bank, acc));

    if(verbose)
    {
        player.Say(SAY_NETMSG, "Account Type: " + BankGetAccountType(bank, acc));
        player.Say(SAY_NETMSG, "Access Count: " + BankGetAccessCount(bank, acc));
    }
}

void ExecCheckBankAccount(array<string@>@ command, Critter& player, bool All)
{
    string bankid = GetParameterString(command, "-b");
    string accid = GetParameterString(command, "-n");
    string filtersum = GetParameterString(command, "-f");
    int    id = 0;
    int    aid = 0;
    int    sum = 0;
    StrToInt(bankid, id);
    StrToInt(accid, aid);
    StrToInt(filtersum, sum);

    bool verbose = (GetIndexOfString(command, "-v") != -1);

    if(uint(id) > BANK_COUNT - 1 || id < 0)
    {
        player.Say(SAY_NETMSG, "Invalid bank ID");
        return;
    }

    if(All)
    {
        for(uint i = 0; i < BankGetNumberOfAccounts(id); i++)
        {
            PrintAccountInfo(player, id, i, sum, verbose);
        }
    }
    else
    {
        if(uint(id) > uint(BankGetNumberOfAccounts(id)) || id < 0)
        {
            player.Say(SAY_NETMSG, "Invalid account ID.");
            return;
        }

        PrintAccountInfo(player, id, aid, sum, verbose);
    }
}

void ExecBankMoney(array<string@>@ command, Critter& player, bool add)
{
    string bankid = GetParameterString(command, "-b");
    int    id = 0;
    StrToInt(bankid, id);

    if(id > BANK_COUNT - 1 || id < 0)
    {
        player.Say(SAY_NETMSG, "Invalid bank ID");
        return;
    }

    string stramount = GetParameterString(command, "-a");
    int    amount = 0;
    StrToInt(stramount, amount);

    if(add)
        BankAddMoney(id, amount);
    else
        BankRemoveMoney(id, amount);
}

void ExecCheckTownCommand(array<string@>@ command, Critter& player)
{
    string townid = GetParameterString(command, "-n");
    int    id = 0;
    StrToInt(townid, id);

    ITown@ town = GetTown(id);
    if(!(valid(town)))
    {
        player.Say(SAY_NETMSG, "Invalid town ID");
        return;
    }

    uint   faction = town.GetControllingFaction();
    string factionname;
    GetFactionNameStr(faction, factionname);

    if(faction == 0)
        player.Say(SAY_NETMSG, "Current controlling faction: None");
    else
    {
        player.Say(SAY_NETMSG, "Current controlling faction: " + factionname + " (" + faction + ")");
        player.Say(SAY_NETMSG, "Number of Controlcycles: " + town.GetControlCycles());
        player.Say(SAY_NETMSG, "Number of NPCs killed during this regime: " + town.GetNumberOfKilledNPCs());
    }
}

void ExecGainTownControlCommand(array<string@>@ command, Critter& player)
{
    string townid = GetParameterString(command, "-n");
    int    id = 0;
    StrToInt(townid, id);
    ITown@ town;

    if(id == 0)
        @town = RetrieveTown(player);
    else
        @town = GetTown(id);

    if(!valid(town))
        player.Say(SAY_NETMSG, "Invalid town");

    town.GainControl(player);
}

void ExecResetTownCommand(array<string@>@ command, Critter& player, bool all)
{
    if(!all)
    {
        string townid = GetParameterString(command, "-n");
        int    id = 0;
        StrToInt(townid, id);

        ITown@ town = GetTown(id);
        if(!(valid(town)))
        {
            player.Say(SAY_NETMSG, "Invalid town ID");
            return;
        }
        town.ResetControl();
        SetBestScore(TOWN_SCORE_BASE + id, null, "");
    }
    else
    {
        for(uint i = 1; i <= GetTownCount(); i++)
        {
            ITown@ town = GetTown(i);
            if valid(town)
            town.ResetControl();
            SetBestScore(TOWN_SCORE_BASE + i, null, "Unknown");
        }
    }
    player.Say(SAY_NETMSG, "Done.");
}

//
// Event handler for deathincarnate command
//
void _Kill(Critter& killer, Critter& victim)
{
    if(!GodOfTheRealm(victim.Id))
        victim.ToDead(GetRandomDeathAnimation(), null);
}

/*void _TrackingMapEntered(Map& map, Critter& cr)
   {
    Critter@ observer = GetCritter(GetLvar(cr, LVAR_command_tracking));
    if (!valid(observer))
        return;

    observer.Say(SAY_NETMSG, "> " + cr.Name + " has entered map " + map.GetProtoId());
   }

   void _TrackingMapLeft(Map& map, Critter& cr)
   {
    Critter@ observer = GetCritter(GetLvar(cr, LVAR_command_tracking));
    if (!valid(observer))
        return;

    observer.Say(SAY_NETMSG, "> " + cr.Name + " has left map " + map.GetProtoId());
   }

   void _TrackingCritterDead(Map& map, Critter& cr, Critter@ killer)
   {
    Critter@ observer = GetCritter(GetLvar(cr, LVAR_command_tracking));
    if (!valid(observer))
        return;

    observer.Say(SAY_NETMSG, "> " + cr.Name + " has died on map " + map.GetProtoId());
   }*/


//
// Perk cheats
//
void ExecSetPerkCommand(array<string@>@ command, Critter& player, Critter& target)
{
    player.Say(SAY_NETMSG, "Executing SetPerk command");

    int id = 0;
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    // parsing doesn't work properly, use numerical values instead (from _defines.fos)
    bool parsed = StrToInt(command[2], id);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetVarId(command[2], id))
        {
            player.Say(SAY_NETMSG, "LVAR does not exist");
            return;
        }
    }
    int val = 0;
    if(!StrToInt(command[3], val))
    {
        player.Say(SAY_NETMSG, "Wrong value");
        return;
    }
    player.ParamBase[id] = val;
}

void ExecPerkAdjust(array<string@>@ command, Critter@ player, Critter@ target)
{
    int perk = 0;
    StrToInt(GetParameterString(command, "-k"), perk);

    int level = 0;
    StrToInt(GetParameterString(command, "-l"), level);

    target.ParamBase[perk] = level;
    player.Say(SAY_NETMSG, "Perk " + perk + " set to level " + level);
}

void ExecProfAdjust(array<string@>@ command, Critter@ player, Critter@ target)
{
    int perk = 0;
    StrToInt(GetParameterString(command, "-k"), perk);

    int level = 0;
    StrToInt(GetParameterString(command, "-l"), level);

    target.ParamBase[perk] = level;
    player.Say(SAY_NETMSG, "Profession " + perk + " set to level " + level);
}

void ExecCriticalChance(array<string@>@ command, Critter@ player, Critter@ target)
{
    int level = 0;
    StrToInt(GetParameterString(command, "-l"), level);
    target.ParamBase[ST_CRITICAL_CHANCE] = level;
}

void ExecSetReputationCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Adjusting reputation for " + target.Name);

    int repIdx = 0;
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    StrToInt(command[2], repIdx);

    int inc = 0;
    StrToInt(GetParameterString(command, "-i"), inc);
    int dec = 0;
    StrToInt(GetParameterString(command, "-d"), dec);
    int val = 0;
    StrToInt(GetParameterString(command, "-v"), val);
    if(inc > 0)
        target.ReputationBase[repIdx] += inc;
    else if(dec > 0)
        target.ReputationBase[repIdx] -= dec;
    else
        target.ReputationBase[repIdx] = val;
}
void ExecResetReputationsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Resetting reputations for " + target.Name);
    for(uint i = 0; i < REPUTATION_COUNT; i++)
        target.ReputationBase[i] = int(0x80000000);
}

/**
 * Regenerates location, keeps rentable domiciles containers
 */
void ExecSafeRegenCommand(array<string@>@ command, Critter@ player)
{
    Map@ map = player.GetMap();
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "No matter how much you try, you can't regenerate the world.");
        return;
    }

    player.Say(SAY_NETMSG, "Safe-regenerating the location...");

    Location@   loc = map.GetLocation();
    array<Map@> maps;
    uint        numMaps = loc.GetMaps(maps);

    // buffer container
    Item@       buffer = player.AddItem(PID_LOCKER_CLEAN_LEFT, 1);
    // pids of containers
    array<uint> pids;

    // move items that we want to save
    for(uint i = 0; i < numMaps; i++)
    {
        for(uint16 x = 0; x < maps[i].GetWidth(); x++)
        {
            for(uint16 y = 0; y < maps[i].GetHeight(); y++)
            {
                array<Item@> items;
                uint         num = maps[i].GetItems(x, y, items);
                for(uint j = 0; j < num; j++)
                {
                    if(items[j].GetType() == ITEM_TYPE_CONTAINER)                       // TODO: additional checks
                    {
                        pids.insertLast(items[j].GetProtoId());
                        // move it to our container, with special id being calculated from coords
                        MoveItem(items[j], 0, buffer, maps[i].GetHeight() * y + x);
                    }
                }
            }
        }

        array<Critter@> crits;
        uint            num = maps[i].GetCritters(0, FIND_ALL | FIND_ONLY_NPC, crits);
        for(uint i = 0; i < num; i++)
        {
            if(!_IsFollower(crits[i]))
                continue;

            TransferToNPCMap(crits[i]);
        }
    }
    loc.Reload();
    // place them back
    for(uint i = 0; i < numMaps; i++)
    {
        array<Critter@> crits;
        uint            num = maps[i].GetCritters(0, FIND_ALL | FIND_ONLY_NPC, crits);
        for(uint i = 0; i < num; i++)
            crits[i].ChangeCrType(crits[i].ParamBase[ST_BASE_CRTYPE]);

        for(uint16 x = 0; x < maps[i].GetWidth(); x++)
        {
            for(uint16 y = 0; y < maps[i].GetHeight(); y++)
            {
                array<Item@> items;
                uint         num = maps[i].GetItems(x, y, items);
                if(num > 0)
                {
                    for(uint j = 0; j < num; j++)
                    {
                        if(items[j].GetType() == ITEM_TYPE_CONTAINER)                           // TODO: additional checks
                        {
                            // move it to our container, with special id being calculated from coords
                            Item@        oldContainer = buffer.GetItem(items[j].GetProtoId(), maps[i].GetHeight() * y + x);
                            array<Item@> content;
                            uint         contentCount = oldContainer.GetItems(0, content);
                            for(uint k = 0; k < contentCount; k++)
                            {
                                MoveItem(content[k], 0, items[j], 0);
                            }
                        }
                    }
                }
                // spawn new container
                else
                {
                    // Item@ item = maps[i].AddItem(x, y, pid, 1);
                    // move items to it
                    // MoveItemsContainers(buffer, item, maps[i].GetHeight() * y + x, 0);
                }
            }
        }
    }
    DeleteItem(buffer);
    player.Say(SAY_NETMSG, "Done.");
}

/**
 * Removes certain items from current map or globally.
 */
void ExecRemoveItemsCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Executing RemoveItems command");
    int pid = 0;
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }

    bool deleteAll = (GetIndexOfString(command, "-global") != -1);

    // try to parse pid if it was passed as number
    bool parsed = StrToInt(command[2], pid);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetItemPid(command[2], pid))
        {
            player.Say(SAY_NETMSG, "Item does not exist");
            return;
        }
    }
    uint num = 0;
    if(pid != 0)
    {
        array<Item@> items;
        if(deleteAll)
        {
            player.Say(SAY_NETMSG, "Removing ALL items with pid: " + pid);
            num = GetAllItems(pid, items);
        }
        else
        {
            player.Say(SAY_NETMSG, "Removing items with pid: " + pid);
            Map@ map = player.GetMap();
            if(!valid(map))
            {
                player.Say(SAY_NETMSG, "Can't delete local items while on worldmap.");
                return;
            }
            num = map.GetItems(pid, items);
        }

        DeleteItems(items);
        player.Say(SAY_NETMSG, "Done - removed " + num + " items.");
    }
    else
        player.Say(SAY_NETMSG, "Please specify proto id number.");
}
/**
 * Count items with given pid.
 */
void ExecCountItemsCommand(array<string@>@ command, Critter@ player)
{
    int pid = 0;
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong number of parameters");
        return;
    }
    // try to parse pid if it was passed as number
    bool parsed = StrToInt(command[2], pid);
    // otherwise, check in the global dictionary
    if(!parsed)
    {
        if(!GetItemPid(command[2], pid))
        {
            player.Say(SAY_NETMSG, "Item does not exist");
            return;
        }
    }
    uint num = 0;
    uint totalNum = 0;
    if(pid != 0)
    {
        array<Item@> items;
        num = GetAllItems(pid, items);
        if(num > 0)     // count number of items, not Item instances
        {
            for(uint i = 0; i < num; i++)
                totalNum += items[i].IsStackable() ? items[i].GetCount() : 1;
        }
        player.Say(SAY_NETMSG, "Number of items with pid(" + pid + "): |0xffffffff " + num + ".");
        uint totalCount = WorldItemCount(pid);
        if(totalNum > 0 || totalCount > 0)
            player.Say(SAY_NETMSG, "Total number: |0xffffffff " + totalNum + " or " + totalCount + ".");
    }
    else
        player.Say(SAY_NETMSG, "Please specify proto id number.");
}
/**
 * Counts the item of value kept in banks/encounter store.
 */
void ExecVirtualMoneyCommand(array<string@>@ command, Critter@ player)
{
    uint banks = BanksGetTotalMoney();
    int  encounters = WorldmapGetTotalValue();

    player.Say(SAY_NETMSG, "Money kept in banks: " + banks);
    player.Say(SAY_NETMSG, "Value in encounters store: " + encounters);
    player.Say(SAY_NETMSG, "--------");
    uint sum = banks + encounters;
    player.Say(SAY_NETMSG, "Total: " + sum);
}
/**
 * Checking/modifying zones' values.
 */
void ExecZoneCommand(array<string@>@ command, Critter@ player)
{
    int    v = 0;
    IZone@ zone = GetZone(player.WorldX, player.WorldY);
    // add value directly
    if(StrToInt(GetParameterString(command, "-a"), v))
    {
        zone.AddValue(v);
        player.Say(SAY_NETMSG, "Added " + v + " to zone's value.");
    }
    else if(StrToInt(GetParameterString(command, "-i"), v))
    {
        // InjectValue(player.WorldX, player.WorldY, v, INJECTVALUE_CHEATS);
        player.Say(SAY_NETMSG, "Injected " + v + " to nearby encounters' store.");
    }
    else if(StrToInt(GetParameterString(command, "-r"), v))
    {
        zone.SubValue(v);
        player.Say(SAY_NETMSG, "Substracted " + v + " from zone's value.");
    }
    else if(StrToInt(GetParameterString(command, "-s"), v))
    {
        zone.SetValue(v);
        player.Say(SAY_NETMSG, "Set zone's value to: " + v);
    }
    else
    {
        player.Say(SAY_NETMSG, "Current zone's value: " + zone.GetValue());
    }
}

void ExecSuicideCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Goodbye cruel world...");
    player.ToDead(GetRandomDeathAnimation(), null);
}

void ExecGetLeaderTimeCommand(array<string@>@ command, Critter@ player)
{
    uint faction = GetGroupIndex(player);
    if(faction == FACTION_NONE)
        player.Say(SAY_NETMSG, "You are not member of any faction");
    else
        player.Say(SAY_NETMSG, "Leader time left: " + (GetLeaderTime(faction) - ELAPSED_TIME));
}

void ExecGetClaimTimeCommand(array<string@>@ command, Critter@ player)
{
    uint faction = GetGroupIndex(player);
    if(faction == FACTION_NONE)
        player.Say(SAY_NETMSG, "You are not member of any faction");
    else
        player.Say(SAY_NETMSG, "Claim time left: " + (GetClaimTime(faction) - ELAPSED_TIME));
}

void ExecGetClaimCommand(array<string@>@ command, Critter@ player)
{
    uint faction = GetGroupIndex(player);
    if(faction == FACTION_NONE)
        player.Say(SAY_NETMSG, "You are not member of any faction");
    else
    {
        uint id = GetClaimId(faction);
        if(id == 0)
            player.Say(SAY_NETMSG, "No claim");
        else
            player.Say(SAY_NETMSG, "Claimee: " + GetSafePlayerName(id));
    }
}

void ExecMakeEncounterCommand(array<string@>@ command, Critter@ player)
{
    Map@ map = player.GetMap();
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "Not on the worldmap");
        return;
    }

    // verify the map
    if(map.GetData(MAP_DATA_FACTION) != 0)
    {
        player.Say(SAY_NETMSG, "This map belongs to a faction. Cannot force the encounter.");
        return;
    }

    map.SetEvent(MAP_EVENT_LOOP_4, "_ForceEncounter");
    map.SetLoopTime(4, 5000);
}

void ExecMapInfoCommand(array<string@>@ command, Critter@ player)
{
    int id = 0;
    StrToInt(GetParameterString(command, "-m"), id);

    player.Say(SAY_NETMSG, (id == 0 ? "Listing information about this map:" : "Listing information about map " + id + ":"));
    if(id == 0)
        id = player.GetMapId();
    Map@ map = GetMap(id);
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "Invalid map.");
        return;
    }
    Location@ loc = map.GetLocation();

    player.Say(SAY_NETMSG, "Map Id: " + id);
    player.Say(SAY_NETMSG, "Map PID: " + map.GetProtoId());
    player.Say(SAY_NETMSG, "Location PID: " + loc.GetProtoId());

    if(IsTent(map))
    {
        string@ owner = GetSafePlayerName(map.GetData(MAP_DATA_TENT_OWNER));
        player.Say(SAY_NETMSG, "This is a tent map, owned by: " + owner + " (" + map.GetData(MAP_DATA_TENT_OWNER) + ")");
    }
    if(map.GetData(MAP_DATA_SPAWNER) > 0)
    {
        string@ spawner = GetSafePlayerName(map.GetData(MAP_DATA_SPAWNER));
        player.Say(SAY_NETMSG, "This map was spawned by: " + spawner + " (" + map.GetData(MAP_DATA_SPAWNER) + ") " + ((ELAPSED_TIME - map.GetData(MAP_DATA_CREATED_ON)) / (60 * 60)) + " hours ago.");
    }
    if(_MapHasMode(map, MAP_MODE_SPECTATE_FREELY))
        player.Say(SAY_NETMSG, "Spectation is enabled on this map.");
    if(_MapHasMode(map, MAP_MODE_NO_DISMANTLING))
        player.Say(SAY_NETMSG, "Dismantling is disabled on this map.");
    if(_MapHasMode(map, MAP_MODE_NO_PVP))
        player.Say(SAY_NETMSG, "PvP is disabled on this map.");
    if(_MapHasMode(map, MAP_MODE_NO_GRIDS))
        player.Say(SAY_NETMSG, "Exit grids are disabled on this map.");
}

void ExecGetLeaderCommand(array<string@>@ command, Critter@ player)
{
    uint faction = GetGroupIndex(player);
    if(faction == FACTION_NONE)
        player.Say(SAY_NETMSG, "You are not member of any faction");
    else
    {
        uint id = GetLeaderId(faction);
        if(id == 0)
            player.Say(SAY_NETMSG, "No leader");
        else
            player.Say(SAY_NETMSG, "Leader: " + GetSafePlayerName(id));
    }
}

void ExecClearTimeoutsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Clearing timeouts");
    DropTimeouts(target);
}

void ExecClearAllTimeoutsCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Dropping timeouts for all online players.");
    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);
    for(uint i = 0; i < num; i++)
    {
        DropTimeouts(players[i]);
    }
    player.Say(SAY_NETMSG, "Done.");
}

void ExecDeathIncarnateCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Death walks the earth as " + target.Name);
    target.SetEvent(CRITTER_EVENT_SHOW_CRITTER, "_Kill");
}

void ExecNormalDeadlyCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, target.Name + " is now a mere mortal again");
    target.SetEvent(CRITTER_EVENT_SHOW_CRITTER, "");
}

void ExecMoveCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Move it, move it");
    // target.AddWalkPlane(player.HexX, player.HexY, 0, false, 0);
    target.MoveRandom();
}

void ExecKillMobsCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> critters;
    uint            num = player.GetCritters(false, FIND_ALL, critters);

    player.Say(SAY_NETMSG, "Killing all mobs in sight...");

    for(uint i = 0; i < num; i++)
    {
        if(critters[i].IsPlayer())
            continue;

        if(!critters[i].IsDead())
            critters[i].ToDead(GetRandomDeathAnimation(), null);
    }
}

void ExecRespawnCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(valid(target))
    {
        player.Say(SAY_NETMSG, "Raise!");
        if(target.IsPlayer() && target.GetAccess() == ACCESS_CLIENT)
            _CritUnsetMode(target, MODE_NO_LOOT);
        target.ToLife();
        Heal(target);
    }
}

void ExecRespawnAllCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> critters;
    uint            num = player.GetCritters(false, FIND_DEAD, critters);

    player.Say(SAY_NETMSG, "Respawning all critters in sight");
    for(uint i = 0; i < num; i++)
    {
        critters[i].ToLife();
        if(critters[i].IsPlayer() && critters[i].GetAccess() == ACCESS_CLIENT)
            _CritUnsetMode(critters[i], MODE_NO_LOOT);
    }
}

void ExecHealCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(valid(target))
    {
        player.Say(SAY_NETMSG, "Healing...");
        Heal(target);
    }
}

void ExecHealAllCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> critters;
    uint            num = player.GetCritters(false, FIND_LIFE, critters);

    player.Say(SAY_NETMSG, "Healing all critters in sight");

    for(uint i = 0; i < num; i++)
    {
        Heal(critters[i]);
    }
}

void ExecRespawnAllPlayersCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    array<Critter@> critters;
    uint            num = player.GetCritters(false, FIND_DEAD, critters);

    player.Say(SAY_NETMSG, "Respawning all players in sight");

    for(uint i = 0; i < num; i++)
    {
        if(!critters[i].IsPlayer())
            continue;
        critters[i].ToLife();
    }
}

void ExecDevEnableCommand(array<string@>@ command, Critter@ player)
{
    if(player.GetAccess() >= ACCESS_TESTER)
        player.RunClientScript("client_dev_menu@Authorize", 0, 0, 0, null, null);
}

void ExecAntiblockCommand(array<string@>@ command, Critter@ player)
{
    if(ItemOnHex(PID_TRIGGER, player.GetMap(), player.HexX, player.HexY))
    {
        player.Say(SAY_NETMSG, "Removing antiblock...");
        Item@ tr = player.GetMap().GetItem(player.HexX, player.HexY, PID_TRIGGER);
        if(GetTriggerFunction(tr) == TRIGGER_FUNC_ANTIBLOCK)
            DeleteItem(tr);
    }
    else
    {
        if(valid(player.GetMap()))
        {
            player.Say(SAY_NETMSG, "Placing antiblock...");
            Item@ tr = player.GetMap().AddItem(player.HexX, player.HexY, PID_TRIGGER, 1);
            TriggerInit(tr, TRIGGER_FUNC_ANTIBLOCK, 0, 2, 1);
        }
    }
}

void ExecgmCommand(array<string@>@ command, Critter@ cr)
{
	adminlook(cr,0,0,0);
	cr.ParamBase[PE_SILENT_RUNNING]=1;
}



void MapDayTime(Critter& cr, int teamwin, int reward, int exp)
{
	cr.GetMap().SetDayTime(teamwin,reward);
}	

void MapDayTimeColor(Critter& cr, int r, int g, int b)
{
	cr.GetMap().SetDayColor(0,r,g,b);
}

void Reno_event(Critter& cr, int r, int g, int b)
{
	Reno_event();
}

uint e_autobalance(array<uint>@ mobdata)
{
	Map@ map = GetMap(mobdata[0]);
	AutoBalance(map);
	return 0;
}

uint e_reno_event(array<uint>@ mobdata)
{
	Map@ map = GetMap(mobdata[0]);
	Reno_event(map);
	return 0;
}
void Reno_event()
{
	array<Critter@> players;
	uint            count = GetAllPlayers(players);
	int id = CreateLocation(519, 990, 875, players);
    Location@ loc = GetLocation(id);
    Map@ map = loc.GetMapByIndex(1);
	int type = EVENT_TYPE_TRADER_1;//values[0];
	//int time = REAL_MINUTE(20);
	int time = REAL_MINUTE(20); // test
	int time2 = REAL_SECOND(1205); // test
	loc.Color = COLOR_RGBA(0, 255, 255, 255);
    loc.Update();
	string message = "New Reno Wars will start in %COUNTDOWN%";
	ServerEventCNTSet(message, loc.Id, type, time);
	CreateTimeEvent(AFTER(time), "e_autobalance", map.Id, false);
	
	CreateTimeEvent(AFTER(time2), "e_reno_event", map.Id, false);
	
}

void dlg_recruiter(Critter& guard, bool firstTime)
{

    if(firstTime)
	{
    guard.ParamBase[MODE_NO_STEAL] = 1;
    guard.ParamBase[MODE_NO_LOOT] = 1;
    guard.ParamBase[MODE_NO_DROP] = 1;
    guard.ParamBase[MODE_NO_BARTER] = 0;
    guard.ParamBase[MODE_NO_TALK] = 0;
    guard.ParamBase[MODE_INVULNERABLE] = 0;
    guard.ParamBase[MODE_DLG_SCRIPT_BARTER] = 1;
	guard.ParamBase[PE_BONUS_RANGED_DAMAGE] = 305;
	guard.ParamBase[PE_BONUS_MOVE] = 1;
	guard.ParamBase[PE_BONUS_HTH_ATTACKS] = 1;
	guard.ParamBase[PE_BONUS_HTH_DAMAGE] = 1;
	guard.ParamBase[PE_DEATHCLAW] = 1;
	guard.ParamBase[ST_MELEE_DAMAGE] = 1000;
	}
}

void r_move_to_lobby(Critter& player, Critter@ npc)
{
	Map@ map = npc.GetMap();
	Map@ lobby = map.GetLocation().GetMapByIndex(1);

    array<Item@> items;
    uint         n = player.GetItems(-1, items);
    for(uint i = 0; i < n; i++)
        DeleteItem(items[i]);
	Log("lobby: " + lobby.Id + " Map: " + map.Id);
	player.TransitToMap(lobby.Id, 230);

	
}

void Reno_event(Map& lobby)
{
	int teama = 14;
	int teamb = 16;
	int teamc = 18;
	int teamd = 20;

	int reward = 20; //TODO reward in keys depends on results
	int exp = Random(100000, 250000);
	
	int howmany = 1;
	teamSALpoints = 0;
	teamBISpoints = 0;
	teamWRIpoints = 0;
	teamMORpoints = 0;
	array<Critter@> nobody;
	int id = CreateLocation(417, 1025, 925, nobody);
    Location@ loc = GetLocation(id);
    Map@ map = loc.GetMapByIndex(3);
//	Log("" + map.Id);
	uint16 x = 1;
	uint16 y = 2;
	map.GetEntireCoords(231, 0, x, y);
	createofficer(map,7,0,1,x,y);
	map.GetEntireCoords(232, 0, x, y);
	createofficer(map,8,0,0,x,y);
	map.GetEntireCoords(233, 0, x, y);
	createofficer(map,9,0,2,x,y);
	map.GetEntireCoords(234, 0, x, y);
	createofficer(map,10,0,3,x,y);
	array<Critter@> players;
	Critter@ cr = AddNpc(map, 1,1 , 1, 3, 0, "", 0, 0, 0, true, 1);
	uint n = lobby.GetCritters(0, FIND_ONLY_PLAYERS | FIND_ALL, players);
	int score = 300 * n;
	for(uint16 i = 0; i < players.length(); i++)
	{
	players[i].ParamBase[MODE_NO_LOOT] = 1;
	players[i].ParamBase[MODE_NO_DROP] = 1;
	players[i].AddItem(PID_BOTTLE_CAPS, 50000);
	players[i].TransitToMap(map.Id, players[i].Param[ST_NPC_ROLE]);
	}
	Item@ SafeContainer = map.AddItem(1, 1, PID_FRIDGE, 1);
	SafeContainerId = SafeContainer.Id;

	finished = false;
	eventAtak(cr, howmany, teama, teama);
	eventDef(cr, howmany, teamb, teamb);
	event3(cr, howmany, teamc, teamc);
	event4(cr, howmany, teamd, teamd);
	array<uint> filldata = { cr.Id, teama, teamb, score, reward, exp, teamc, teamd};
	CreateTimeEvent(AFTER(REAL_SECOND(10)), "e_startevent4", filldata, false);
	DeleteLocation(lobby.GetLocation().Id);

}	


void ExecEventCommand(array<string@>@ command, Critter@ cr)
{
	int teama = 0;
    cheatGetOption(command, teama, "-a");
	int teamb = 0;
    cheatGetOption(command, teamb, "-b");
	int teamc = 0;
    cheatGetOption(command, teamc, "-c");
	int teamd = 0;
    cheatGetOption(command, teamd, "-d");
	int reward = 0;
    cheatGetOption(command, reward, "-r");
	int exp = 0;
    cheatGetOption(command, exp, "-e");
	int score = 0;
	cheatGetOption(command, score, "-s");
	int howmany = 0;
	cheatGetOption(command, howmany, "-h");
	team1points = 0;
	team2points = 0;
	team3points = 0;
	team4points = 0;
	team5points = 0;
	team6points = 0;
	teamSALpoints = 0;
	teamBISpoints = 0;
	teamWRIpoints = 0;
	teamMORpoints = 0;
	array<Critter@> players;
	cr.GetMap().GetCritters(0, FIND_ONLY_PLAYERS | FIND_ALL, players);
	for(uint16 i = 0; i < players.length(); i++)
	{
	players[i].ParamBase[MODE_NO_LOOT] = 1;
	players[i].ParamBase[MODE_NO_DROP] = 1;
	//players[i].ParamBase[EVENT_WARMING] -= 3;
	}
	Item@ SafeContainer = cr.GetMap().AddItem(1, 1, PID_FRIDGE, 1);
	SafeContainerId = SafeContainer.Id;
	if(howmany==0)
	howmany = 1;
	finished = false;
	if(teamc == 0)
	{
		eventAtak(cr, howmany, teama, teama);
		eventDef(cr, howmany, teamb, teamb);
		array<uint> filldata = { cr.Id, teama, teamb, score, reward, exp};
		CreateTimeEvent(AFTER(REAL_SECOND(10)), "e_startevent", filldata, false);
	}
	else if(teamc>0 && teamd==0)
	{
		eventAtak(cr, howmany, teama, teama);
		eventDef(cr, howmany, teamb, teamb);
		event3(cr, howmany, teamc, teamc);
		array<uint> filldata = { cr.Id, teama, teamb, score, reward, exp, teamc};
		CreateTimeEvent(AFTER(REAL_SECOND(10)), "e_startevent3", filldata, false);
	}
	else if(teamd!=0)
	{
		eventAtak(cr, howmany, teama, teama);
		eventDef(cr, howmany, teamb, teamb);
		event3(cr, howmany, teamc, teamc);
		event4(cr, howmany, teamd, teamd);
		array<uint> filldata = { cr.Id, teama, teamb, score, reward, exp, teamc, teamd};
		CreateTimeEvent(AFTER(REAL_SECOND(10)), "e_startevent4", filldata, false);
	}
}
void preseason_war(Critter& cr, uint teamA, uint teamB, uint score, Map& lobby, Map& map)
{
	array<Critter@> players;
	lobby.GetCritters(0, FIND_ONLY_PLAYERS | FIND_ALL, players);
	for(uint16 i = 0; i < players.length(); i++)
	{
	players[i].ParamBase[MODE_NO_LOOT] = 1;
	players[i].ParamBase[MODE_NO_DROP] = 1;
	//players[i].ParamBase[EVENT_WARMING] -= 3;
	}
	Item@ SafeContainer = map.AddItem(1, 1, PID_FRIDGE, 1);
	SafeContainerId = SafeContainer.Id;
	array<uint> filldata = { cr.Id, teamA, teamB, score, 1, score*10};
	CreateTimeEvent(AFTER(REAL_SECOND(10)), "e_startevent", filldata, false);
}
void ItemRanking(Critter& cr, int armor, int reward, int exp)
{
	uint16       dummy = 0;
    array<Item@> items;
    uint         count = GetAllItems(dummy, items);
	string armore = "weaponID";	
	if(armor==1)
		armore = "armorID";
	for(uint i = 0; i < count; i++)
	{
	if(items[i].GetType() != ITEM_TYPE_WEAPON && armor == 0)
		continue;
	if(items[i].GetType() != ITEM_TYPE_ARMOR && armor == 1)
		continue;
	if(items[i].Val0 < 5000000)
		continue;
	
	cr.Say(SAY_NETMSG, armore + ": " + items[i].Id + " ProtoID: " + items[i].Proto.ProtoId + " exp: " + items[i].Val0);
	
	}
}

void finishevent(Critter& cr, int teamwin, int reward, int exp)
{
		finished = true;
}
int team1points = 0;
int team2points = 0;
int team3points = 0;
int team4points = 0;
int team5points = 0;
int team6points = 0;
int teamSALpoints = 0;
int teamBISpoints = 0;
int teamWRIpoints = 0;
int teamMORpoints = 0;
void updatescore(uint team, uint score, bool plus)
{
	switch(team)
	{
	case 1: {if(plus) team1points += score; else team1points -= score; break;}
	case 2: {if(plus) team2points += score; else team2points -= score; break;}
	case 3: {if(plus) team3points += score; else team3points -= score; break;}
	
	case 4: {if(plus) team4points += score; else team4points -= score; break;}
	case 5: {if(plus) team5points += score; else team5points -= score; break;}
	case 6: {if(plus) team6points += score; else team6points -= score; break;}
	case 7: {if(plus) teamSALpoints += score; else teamSALpoints -= score; break;}
	case 8: {if(plus) teamBISpoints += score; else teamBISpoints -= score; break;}
	case 9: {if(plus) teamWRIpoints += score; else teamWRIpoints -= score; break;}
	case 10: {if(plus) teamMORpoints += score; else teamMORpoints -= score; break;}
	}
}

void updatescore(Critter& cr, int team, int score, int pluss)
{
	bool plus = true;
	if(pluss<1)
		plus = false;
	switch(team)
	{
	case 1: {if(plus) team1points += score; else team1points -= score; break;}
	case 2: {if(plus) team2points += score; else team2points -= score; break;}
	case 3: {if(plus) team3points += score; else team3points -= score; break;}
	
	case 4: {if(plus) team4points += score; else team4points -= score; break;}
	case 5: {if(plus) team5points += score; else team5points -= score; break;}
	case 6: {if(plus) team6points += score; else team6points -= score; break;}
	case 7: {if(plus) teamSALpoints += score; else teamSALpoints -= score; break;}
	case 8: {if(plus) teamBISpoints += score; else teamBISpoints -= score; break;}
	case 9: {if(plus) teamWRIpoints += score; else teamWRIpoints -= score; break;}
	case 10: {if(plus) teamMORpoints += score; else teamMORpoints -= score; break;}
	}
}
bool finished = false;
// start for 2 teams
uint e_startevent4(array<uint>@ mobdata)
{
	if(!finished)
	{
	Critter@ cr = GetCritter(mobdata[0]);
	uint team1 = mobdata[1];
	uint team2 = mobdata[2];
	uint team3 = mobdata[6];
	uint team4 = mobdata[7];
	int score = mobdata[3];
	int reward = mobdata[4];
	int exp = mobdata[5];

	finished = false;
	Map@ map = cr.GetMap();
	string teamname;
	string teamname2;
	string teamname3;
	string teamname4;
	int team1score = 0;
	int team2score = 0;
	int team3score = 0;
	int team4score = 0;
	for(uint y = 0; y <= 5; y++)
	{
	array<Item@> items;
	uint n = map.GetItems(we_flags[y], items);
		switch(y)
			{
			case 0: team1points += 5 * n; break;
			case 1: team2points += 5 * n; team4points += 5 * n; break;
			case 2: team4points += 5 * n; team2points += 5 * n; break;
			case 3: team3points += 5 * n; break;
			case 4: team5points += 5 * n; break;
			case 5: team6points += 5 * n; break;
			case 6: teamSALpoints += 5 * n; break;
			case 7: teamBISpoints += 5 * n; break;
			case 8: teamWRIpoints += 5 * n; break;
			case 9: teamMORpoints += 5 * n; break;
			}
	}

	teamSALpoints += 5;
	teamBISpoints += 5;
	teamWRIpoints += 5;
	teamMORpoints += 5;
	switch(team1)
	{
	case 1: { teamname = "Enclave"; team1score = team1points; break; }
	case 2: { teamname = "Alliance"; team1score =  team2points + team4points; break; }
	case 4: { teamname = "Alliance"; team1score =  team2points + team4points; break; }
	case 3: { teamname = "Vault City"; team1score = team3points;  break; }
	case 9: { teamname = "Town Defenders"; team1score = team5points; break;  }
	case 5: { teamname = "Enclave"; team1score = team1points; break; }
	case 6: { teamname = "Alliance"; team1score =  team2points + team4points; break; }
	case 8: { teamname = "Vault City"; team1score = team3points; break; }
	case 7: { teamname = "Alliance"; team1score =  team2points + team4points;   break; }
	case 11: { teamname = "Master Army"; team1score = team6points;  break; }
	case 12: { teamname = "Master Army"; team1score = team6points;  break; }
	case 13:
	case 14: { teamname = "Salvatories"; team1score = teamSALpoints;  break; }
	case 15:
	case 16: { teamname = "Bishops"; team1score = teamBISpoints;  break; }
	case 17:
	case 18: { teamname = "Wrights"; team1score = teamWRIpoints;  break; }
	case 19:
	case 20: { teamname = "Mordinos"; team1score = teamMORpoints;  break; }
	default: { teamname = "Town Defenders"; team1score = team5points; break; }
	}
	switch(team2)
	{
	case 1: { teamname2 = "Enclave";  team2score = team1points;break; }
	case 2: { teamname2 = "Alliance"; team2score =  team2points + team4points; break; }
	case 4: { teamname2 = "Alliance"; team2score =  team2points + team4points; break; }
	case 3: { teamname2 = "Vault City"; team2score = team3points; break; }
	case 9: { teamname2 = "Town Defenders"; team2score = team5points; break; }
	case 5: { teamname2 = "Enclave";  team2score = team1points;break; }
	case 6: { teamname2 = "Alliance"; team2score = team2points; break; }
	case 8: { teamname2 = "Vault City"; team2score = team3points; break; }
	case 7: { teamname2 = "Alliance"; team2score =  team2points + team4points; break; }
	case 11: { teamname2 = "Master Army"; team2score = team6points; break; }
	case 12: { teamname2 = "Master Army"; team2score = team6points; break; }
	case 13:
	case 14: { teamname2 = "Salvatories"; team2score = teamSALpoints;  break; }
	case 15:
	case 16: { teamname2 = "Bishops"; team2score = teamBISpoints;  break; }
	case 17:
	case 18: { teamname2 = "Wrights"; team2score = teamWRIpoints;  break; }
	case 19:
	case 20: { teamname2 = "Mordinos"; team2score = teamMORpoints;  break; }
	default: { teamname2 = "Town Defenders"; team2score = team5points; break; }
	}
	switch(team3)
	{
	case 1: { teamname3 = "Enclave";  team3score = team1points;break; }
	case 2: { teamname3 = "Alliance"; team3score =  team2points + team4points; break; }
	case 4: { teamname3 = "Alliance"; team3score =  team2points + team4points; break; }
	case 3: { teamname3 = "Vault City"; team3score = team3points; break; }
	case 9: { teamname3 = "Town Defenders"; team3score = team5points; break; }
	case 5: { teamname3 = "Enclave";  team3score = team1points;break; }
	case 6: { teamname3 = "Alliance"; team3score =  team2points + team4points; break; }
	case 8: { teamname3 = "Vault City"; team3score = team3points; break; }
	case 7: { teamname3 = "Alliance"; team3score =  team2points + team4points; break; }
	case 11: { teamname3 = "Master Army"; team3score = team6points; break; }
	case 12: { teamname3 = "Master Army"; team3score = team6points; break; }
	case 13:
	case 14: { teamname3 = "Salvatories"; team3score = teamSALpoints;  break; }
	case 15:
	case 16: { teamname3 = "Bishops"; team3score = teamBISpoints;  break; }
	case 17:
	case 18: { teamname3 = "Wrights"; team3score = teamWRIpoints;  break; }
	case 19:
	case 20: { teamname3 = "Mordinos"; team3score = teamMORpoints;  break; }
	default: { teamname3 = "Town Defenders"; team3score = team5points; break; }

	}
	switch(team4)
	{
	case 1: { teamname4 = "Enclave";  team4score = team1points;break; }
	case 2: { teamname4 = "Alliance"; team4score =  team2points + team4points; break; }
	case 4: { teamname4 = "Alliance"; team4score =  team2points + team4points; break; }
	case 3: { teamname4 = "Vault City"; team4score = team3points; break; }
	case 9: { teamname4 = "Town Defenders"; team4score = team5points; break; }
	case 5: { teamname4 = "Enclave";  team4score = team1points;break; }
	case 6: { teamname4 = "Alliance"; team4score =  team2points + team4points; break; }
	case 8: { teamname4 = "Vault City"; team4score = team3points; break; }
	case 7: { teamname4 = "Alliance"; team4score =  team2points + team4points; break; }
	case 11: { teamname4 = "Master Army"; team4score = team6points; break; }
	case 12: { teamname4 = "Master Army"; team4score = team6points; break; }
	case 13:
	case 14: { teamname4 = "Salvatories"; team4score = teamSALpoints;  break; }
	case 15:
	case 16: { teamname4 = "Bishops"; team4score = teamBISpoints;  break; }
	case 17:
	case 18: { teamname4 = "Wrights"; team4score = teamWRIpoints;  break; }
	case 19:
	case 20: { teamname4 = "Mordinos"; team4score = teamMORpoints;  break; }
	default: { teamname4 = "Town Defenders"; team4score = team5points; break; }

	}
	
	
	
	array<int> data;
	AddBroadcastBuffer(BROADCAST_SERVER_EVENT_MSG, REAL_SECOND(10), 0, teamname + " [" + team1score + "] vs [" + team2score + "] " + teamname2 + " vs " + teamname3 + " [" + team3score + "] vs [" + team4score + "] " + teamname4, data, REAL_SECOND(9), BROADCAST_FILTER_NONE)
	.SendToAll();
   if(score < team1score)
   {
   int teamwin = 0;
   int allyteam =0;
   switch(team1)
		{
		case 1: { teamwin = 204; break; }
		case 2: { teamwin = 209; allyteam = 206; break; }
		case 4: { teamwin = 207; allyteam = 209; break; }
		case 3: { teamwin = 206; break; }
		case 9: { teamwin = 208; break; }
		case 5: { teamwin = 204; break; }
		case 6: { teamwin = 209; allyteam = 206; break; }
		case 8: { teamwin = 206;  break; }
		case 7: { teamwin = 207; allyteam = 209; break; }
		case 11:
		case 12: { teamwin = 212;  break; }
		case 13:
		case 14: { teamwin = 231;  break; }
		case 15:
		case 16: { teamwin = 232;  break; }
		case 17:
		case 18: { teamwin = 233;  break; }
		case 19:
		case 20: { teamwin = 234;  break; }
		}

   endevent(cr, teamwin + allyteam, reward, exp);
   }
   if(score < team2score)
   {
	int teamwin = 0;
	int allyteam = 0;
	switch(team2)
		{
		case 1: { teamwin = 204; break; }
		case 2: { teamwin = 209; allyteam = 206; break; }
		case 4: { teamwin = 207; allyteam = 209; break; }
		case 3: { teamwin = 206; break; }
		case 9: { teamwin = 208; break; }
		case 5: { teamwin = 204; break; }
		case 6: { teamwin = 209; allyteam = 206; break; }
		case 8: { teamwin = 206;  break; }
		case 7: { teamwin = 207; allyteam = 209; break; }
		case 11:
		case 12: { teamwin = 212;  break; }
		case 13:
		case 14: { teamwin = 231;  break; }
		case 15:
		case 16: { teamwin = 232;  break; }
		case 17:
		case 18: { teamwin = 233;  break; }
		case 19:
		case 20: { teamwin = 234;  break; }
		}

   endevent(cr, teamwin + allyteam, reward, exp);
   }
   if(score < team3score)
   {
	int teamwin = 0;
	int allyteam = 0;
	switch(team3)
		{
		case 1: { teamwin = 204; break; }
		case 2: { teamwin = 209; allyteam = 206; break; }
		case 4: { teamwin = 207; allyteam = 209; break; }
		case 3: { teamwin = 206; break; }
		case 9: { teamwin = 208; break; }
		case 5: { teamwin = 204; break; }
		case 6: { teamwin = 209; allyteam = 206; break; }
		case 8: { teamwin = 206;  break; }
		case 7: { teamwin = 207; allyteam = 209; break; }
		case 11:
		case 12: { teamwin = 212;  break; }
		case 13:
		case 14: { teamwin = 231;  break; }
		case 15:
		case 16: { teamwin = 232;  break; }
		case 17:
		case 18: { teamwin = 233;  break; }
		case 19:
		case 20: { teamwin = 234;  break; }
		}

   endevent(cr, teamwin + allyteam, reward, exp);
   }
   if(score < team4score)
   {
	int teamwin = 0;
	int allyteam = 0;
	switch(team4)
		{
		case 1: { teamwin = 204; break; }
		case 2: { teamwin = 209; allyteam = 206; break; }
		case 4: { teamwin = 207; allyteam = 209; break; }
		case 3: { teamwin = 206; break; }
		case 9: { teamwin = 208; break; }
		case 5: { teamwin = 204; break; }
		case 6: { teamwin = 209; allyteam = 206; break; }
		case 8: { teamwin = 206;  break; }
		case 7: { teamwin = 207; allyteam = 209; break; }
		case 11:
		case 12: { teamwin = 212;  break; }
		case 13:
		case 14: { teamwin = 231;  break; }
		case 15:
		case 16: { teamwin = 232;  break; }
		case 17:
		case 18: { teamwin = 233;  break; }
		case 19:
		case 20: { teamwin = 234;  break; }
		}

   endevent(cr, teamwin + allyteam, reward, exp);
   }
	array<Critter@> players;
	map.GetCritters(0, FIND_ONLY_PLAYERS | FIND_ALL, players);
	for(uint16 i = 0; i < players.length(); i++)
	{
	if(players[i].Param[ST_NPC_ROLE] == 204)
	{
	team(players[i], 1, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 206)
	{
	team(players[i], 4, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 207)
	{
	team(players[i], 3, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 208)
	{
	team(players[i], 5, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 209)
	{
	team(players[i], 2, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 212)
	{
	team(players[i], 6, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 231)
	{
	team(players[i], 7, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 232)
	{
	team(players[i], 8, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 233)
	{
	team(players[i], 9, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 234)
	{
	team(players[i], 10, 15, players[i].Id);
	}
	}
	array<uint> filldata = { cr.Id, team1, team2, score, reward, exp, team3, team4};
	return REAL_SECOND(10);
	}
	else return 0;
}

uint e_startevent3(array<uint>@ mobdata)
{
	if(!finished)
	{
	Critter@ cr = GetCritter(mobdata[0]);
	uint team1 = mobdata[1];
	uint team2 = mobdata[2];
	uint team3 = mobdata[6];
	int score = mobdata[3];
	int reward = mobdata[4];
	int exp = mobdata[5];
	//int team3 = mobdata[6];
	//int team4 = mobdata[7];
	//int its_really_started = mobdata[8];
	//int howmany = mobdata[9];
	//SetGvar(GVAR_event_env, 0);
	//eventscore(cr, score, team1, team2);
	finished = false;
	Map@ map = cr.GetMap();
	string teamname;
	string teamname2;
	string teamname3;
	int team1score = 0;
	int team2score = 0;
	int team3score = 0;
	for(uint y = 0; y <= 5; y++)
	{
	array<Item@> items;
	uint n = map.GetItems(we_flags[y], items);
		switch(y)
			{
			case 0: team1points += 5 * n; break;
			case 1: team2points += 5 * n; team4points += 5 * n; break;
			case 2: team4points += 5 * n; team2points += 5 * n; break;
			case 3: team3points += 5 * n; break;
			case 4: team5points += 5 * n; break;
			case 5: team6points += 5 * n; break;
			}
	}
	switch(team1)
	{
	case 1: { teamname = "Enclave"; team1score = team1points; break; }
	case 2: { teamname = "Alliance"; team1score =  team2points + team4points; break; }
	case 4: { teamname = "Alliance"; team1score =  team2points + team4points; break; }
	case 3: { teamname = "Vault City"; team1score = team3points;  break; }
	case 9: { teamname = "Town Defenders"; team1score = team5points; break;  }
	case 5: { teamname = "Enclave"; team1score = team1points; break; }
	case 6: { teamname = "Alliance"; team1score =  team2points + team4points; break; }
	case 8: { teamname = "Vault City"; team1score = team3points; break; }
	case 7: { teamname = "Alliance"; team1score =  team2points + team4points;   break; }
	case 11: { teamname = "Master Army"; team1score = team6points;  break; }
	case 12: { teamname = "Master Army"; team1score = team6points;  break; }
	default: { teamname = "Town Defenders"; team1score = team5points; break; }
	}
	switch(team2)
	{
	case 1: { teamname2 = "Enclave";  team2score = team1points;break; }
	case 2: { teamname2 = "Alliance"; team2score =  team2points + team4points; break; }
	case 4: { teamname2 = "Alliance"; team2score =  team2points + team4points; break; }
	case 3: { teamname2 = "Vault City"; team2score = team3points; break; }
	case 9: { teamname2 = "Town Defenders"; team2score = team5points; break; }
	case 5: { teamname2 = "Enclave";  team2score = team1points;break; }
	case 6: { teamname2 = "Alliance"; team2score = team2points; break; }
	case 8: { teamname2 = "Vault City"; team2score = team3points; break; }
	case 7: { teamname2 = "Alliance"; team2score =  team2points + team4points; break; }
	case 11: { teamname2 = "Master Army"; team2score = team6points; break; }
	case 12: { teamname2 = "Master Army"; team2score = team6points; break; }
	default: { teamname2 = "Town Defenders"; team2score = team5points; break; }
	}
	switch(team3)
	{
	case 1: { teamname3 = "Enclave";  team3score = team1points;break; }
	case 2: { teamname3 = "Alliance"; team3score =  team2points + team4points; break; }
	case 4: { teamname3 = "Alliance"; team3score =  team2points + team4points; break; }
	case 3: { teamname3 = "Vault City"; team3score = team3points; break; }
	case 9: { teamname3 = "Town Defenders"; team3score = team5points; break; }
	case 5: { teamname3 = "Enclave";  team3score = team1points;break; }
	case 6: { teamname3 = "Alliance"; team3score =  team2points + team4points; break; }
	case 8: { teamname3 = "Vault City"; team3score = team3points; break; }
	case 7: { teamname3 = "Alliance"; team3score =  team2points + team4points; break; }
	case 11: { teamname3 = "Master Army"; team3score = team6points; break; }
	case 12: { teamname3 = "Master Army"; team3score = team6points; break; }
	default: { teamname3 = "Town Defenders"; team3score = team5points; break; }

	}
	
	
	
	array<int> data;
	AddBroadcastBuffer(BROADCAST_SERVER_EVENT_MSG, REAL_SECOND(10), 0, teamname + " [" + team1score + "] vs [" + team2score + "] " + teamname2 + " vs " + teamname3 + " [" + team3score + "]", data, REAL_SECOND(9), BROADCAST_FILTER_NONE)
	.SendToAll();
   if(score < team1score)
   {
   int teamwin = 0;
   int allyteam =0;
   switch(team1)
		{
		case 1: { teamwin = 204; break; }
		case 2: { teamwin = 209; allyteam = 206; break; }
		case 4: { teamwin = 207; allyteam = 209; break; }
		case 3: { teamwin = 206; break; }
		case 9: { teamwin = 208; break; }
		case 5: { teamwin = 204; break; }
		case 6: { teamwin = 209; allyteam = 206; break; }
		case 8: { teamwin = 206;  break; }
		case 7: { teamwin = 207; allyteam = 209; break; }
		case 11:
		case 12: { teamwin = 212;  break; }
		}

   endevent(cr, teamwin + allyteam, reward, exp);
   }
   if(score < team2score)
   {
	int teamwin = 0;
	int allyteam = 0;
	switch(team2)
		{
		case 1: { teamwin = 204; break; }
		case 2: { teamwin = 209; allyteam = 206; break; }
		case 4: { teamwin = 207; allyteam = 209; break; }
		case 3: { teamwin = 206; break; }
		case 9: { teamwin = 208; break; }
		case 5: { teamwin = 204; break; }
		case 6: { teamwin = 209; allyteam = 206; break; }
		case 8: { teamwin = 206;  break; }
		case 7: { teamwin = 207; allyteam = 209; break; }
		case 11:
		case 12: { teamwin = 212;  break; }
		}

   endevent(cr, teamwin + allyteam, reward, exp);
   }
   if(score < team3score)
   {
	int teamwin = 0;
	int allyteam = 0;
	switch(team3)
		{
		case 1: { teamwin = 204; break; }
		case 2: { teamwin = 209; allyteam = 206; break; }
		case 4: { teamwin = 207; allyteam = 209; break; }
		case 3: { teamwin = 206; break; }
		case 9: { teamwin = 208; break; }
		case 5: { teamwin = 204; break; }
		case 6: { teamwin = 209; allyteam = 206; break; }
		case 8: { teamwin = 206;  break; }
		case 7: { teamwin = 207; allyteam = 209; break; }
		case 11:
		case 12: { teamwin = 212;  break; }
		}

   endevent(cr, teamwin + allyteam, reward, exp);
   }
	array<Critter@> players;
	map.GetCritters(0, FIND_ONLY_PLAYERS | FIND_ALL, players);
	for(uint16 i = 0; i < players.length(); i++)
	{
	if(players[i].Param[ST_NPC_ROLE] == 204)
	{
	team(players[i], 1, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 206)
	{
	team(players[i], 4, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 207)
	{
	team(players[i], 3, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 208)
	{
	team(players[i], 5, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 209)
	{
	team(players[i], 2, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 212)
	{
	team(players[i], 6, 15, players[i].Id);
	}
	}
	array<uint> filldata = { cr.Id, team1, team2, score, reward, exp, team3};
	return REAL_SECOND(10);
	}
	else return 0;
}

uint e_startevent(array<uint>@ mobdata)
{
	if(!finished)
	{
	Critter@ cr = GetCritter(mobdata[0]);
	uint team1 = mobdata[1];
	uint team2 = mobdata[2];
	int score = mobdata[3];
	int reward = mobdata[4];
	int exp = mobdata[5];
	//int team3 = mobdata[6];
	//int team4 = mobdata[7];
	//int its_really_started = mobdata[8];
	//int howmany = mobdata[9];
	//SetGvar(GVAR_event_env, 0);
	//eventscore(cr, score, team1, team2);
	finished = false;
	Map@ map = cr.GetMap();
	string teamname;
	string teamname2;
	int team1score = 0;
	int team2score = 0;
	array<Item@> itemse;
	uint e = map.GetItems(9204, itemse);
	team1points += 5 * e;
	array<Item@> itemsb;
	uint b = map.GetItems(9209, itemsb);
	team2points += 5 * b;
	array<Item@> itemsn;
	uint n = map.GetItems(9207, itemsn);
	team4points += 5 * n;
	array<Item@> itemsu;
	uint u = map.GetItems(9212, itemsu);
	team6points += 5 * u;
	array<Item@> itemsv;
	uint v = map.GetItems(9206, itemsv);
	team3points += 5 * v;
	array<Item@> itemsd;
	uint d = map.GetItems(9208, itemsd);
	team5points += 5 * d;
	switch(team1)
	{
	case 1: { teamname = "Enclave"; team1score = team1points; break; }
	case 2: { teamname = "Alliance"; team1score = team2points + team4points; break; }
	case 4: { teamname = "Alliance"; team1score =  team2points + team4points; break; }
	case 3: { teamname = "Vault City"; team1score = team3points; break; }
	case 9: { teamname = "Town Defenders"; team1score = team5points; break; }
	case 5: { teamname = "Enclave"; team1score = team1points; break; }
	case 6: { teamname = "Alliance"; team1score = team2points; break; }
	case 8: { teamname = "Vault City"; team1score = team3points; break; }
	case 7: { teamname = "Alliance"; team1score = team4points; break; }
	case 11: { teamname = "Master Army"; team1score = team6points; break; }
	case 12: { teamname = "Master Army"; team1score = team6points; break; }
	default: { teamname = "Town Defenders"; team1score = team5points; break; }
	}
	switch(team2)
	{
	case 1: { teamname2 = "Enclave";  team2score = team1points;break; }
	case 2: { teamname2 = "Alliance"; team2score =  team2points + team4points; break; }
	case 4: { teamname2 = "Alliance"; team2score =  team2points + team4points; break; }
	case 3: { teamname2 = "Vault City"; team2score = team3points; break; }
	case 9: { teamname2 = "Town Defenders"; team2score = team5points; break; }
	case 5: { teamname2 = "Enclave";  team2score = team1points;break; }
	case 6: { teamname2 = "Alliance"; team2score =  team2points + team4points; break; }
	case 8: { teamname2 = "Vault City"; team2score = team3points; break; }
	case 7: { teamname2 = "Alliance"; team2score =  team2points + team4points; break; }
	case 11: { teamname2 = "Master Army"; team2score = team6points; break; }
	case 12: { teamname2 = "Master Army"; team2score = team6points; break; }
	default: { teamname2 = "Town Defenders"; team2score = team5points; break; }

	}
	array<int> data;
	AddBroadcastBuffer(BROADCAST_SERVER_EVENT_MSG, REAL_SECOND(10), 0, teamname + " [" + team1score + "] vs [" + team2score + "] " + teamname2, data, REAL_SECOND(9), BROADCAST_FILTER_NONE)
	.SendToAll();
   if(score < team1score)
   {
   int teamwin = 0;
   int allyteam = 0;
   switch(team1)
		{
		case 1: { teamwin = 204; break; }
		case 2: { teamwin = 209; allyteam = 206; break; }
		case 4: { teamwin = 207; allyteam = 209; break; }
		case 3: { teamwin = 206; break; }
		case 9: { teamwin = 208; break; }
		case 5: { teamwin = 204; break; }
		case 6: { teamwin = 209; allyteam = 206; break; }
		case 8: { teamwin = 206;  break; }
		case 7: { teamwin = 207; allyteam = 209; break; }
		case 11:
		case 12: { teamwin = 212;  break; }
		}

   endevent(cr, teamwin + allyteam, reward, exp);
   }
   if(score < team2score)
   {
	int teamwin = 0;
	int allyteam = 0;
	switch(team2)
		{
			case 1: { teamwin = 204; break; }
		case 2: { teamwin = 209; allyteam = 206; break; }
		case 4: { teamwin = 207; allyteam = 209; break; }
		case 3: { teamwin = 206; break; }
		case 9: { teamwin = 208; break; }
		case 5: { teamwin = 204; break; }
		case 6: { teamwin = 209; allyteam = 206; break; }
		case 8: { teamwin = 206;  break; }
		case 7: { teamwin = 207; allyteam = 209; break; }
		case 11:
		case 12: { teamwin = 212;  break; }
		}

   endevent(cr, teamwin + allyteam, reward, exp);
   }
	array<Critter@> players;
	map.GetCritters(0, FIND_ONLY_PLAYERS | FIND_ALL, players);
	for(uint16 i = 0; i < players.length(); i++)
	{
	if(players[i].Param[ST_NPC_ROLE] == 204)
	{
	team(players[i], 1, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 206)
	{
	team(players[i], 4, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 207)
	{
	team(players[i], 3, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 208)
	{
	team(players[i], 5, 15, players[i].Id);
	}
	if(players[i].Param[ST_NPC_ROLE] == 209)
	{
	team(players[i], 2, 15, players[i].Id);
	}
		if(players[i].Param[ST_NPC_ROLE] == 212)
	{
	team(players[i], 6, 15, players[i].Id);
	}
	}
	array<uint> filldata = { cr.Id, team1, team2, score, reward, exp};
	return REAL_SECOND(10);
	}
	else return 0;
}
void giveweapon(Critter& player, Critter@ npc, int weapon)
{
	switch(weapon)
	{
	case 1: { Item@ weapon = player.AddItem(PID_223_PISTOL, 1); player.AddItem(PID_223_FMJ, 300); weapon.Val0 = 9999; break; }
	case 2: {Item@ weapon = player.AddItem(PID_NEEDLER_PISTOL, 1); player.AddItem(PID_HN_NEEDLER_CARTRIDGE, 100); player.AddItem(PID_HN_AP_NEEDLER_CARTRIDGE, 100); player.AddItem(PID_HN_HEAL_NEEDLER_CARTRIDGE, 100); weapon.Val0 = 9999; break; }
	case 3: {Item@ weapon = player.AddItem(PID_SNIPER_RIFLE, 1); player.AddItem(PID_223_FMJ, 300); weapon.Val0 = 9999; break; }
	case 4: {Item@ weapon = player.AddItem(PID_INDEPENDENT, 1); player.AddItem(PID_5MM_AP, 2500); weapon.Val0 = 9999; break; }
	case 5: {Item@ weapon = player.AddItem(PID_GRENADE_LAUNCHER, 1); player.AddItem(PID_40MM_GRENADE, 90); weapon.Val0 = 9999; break; }
	case 6: {Item@ weapon = player.AddItem(PID_HK_CAWS, 1); player.AddItem(PID_SHOTGUN_SHELLS_SLUG, 1000); weapon.Val0 = 9999; break; }
	case 7: {Item@ weapon = player.AddItem(PID_PANCOR_JACKHAMMER, 1); player.AddItem(PID_SHOTGUN_SHELLS_SLUG, 1000); weapon.Val0 = 9999; break; }
	case 8: {Item@ weapon = player.AddItem(PID_HK_P90C, 1); player.AddItem(PID_10MM_AP, 2500); weapon.Val0 = 9999; break; }
	case 9: {Item@ weapon = player.AddItem(PID_M16, 1); player.AddItem(PID_5MM_AP, 2500); weapon.Val0 = 9999; break; }
	case 10: {Item@ weapon = player.AddItem(PID_IMPROVED_FLAMETHROWER, 1); player.AddItem(PID_FLAMETHROWER_FUEL_MK_II, 100); weapon.Val0 = 9999; break; }
	case 11: {Item@ weapon = player.AddItem(PID_ROCKET_LAUNCHER, 1); player.AddItem(PID_ROCKET_AP, 80); weapon.Val0 = 9999; break; }
	case 12: {Item@ weapon = player.AddItem(PID_AVENGER_MINIGUN, 1); player.AddItem(PID_5MM_AP, 4000); weapon.Val0 = 9999; break; }
	case 13: {Item@ weapon = player.AddItem(PID_LIGHT_SUPPORT_WEAPON, 1); player.AddItem(PID_223_FMJ, 500); weapon.Val0 = 9999; break; }
	case 14: {Item@ weapon = player.AddItem(PID_M60, 1); player.AddItem(PID_7_62MM_AMMO, 3000); weapon.Val0 = 9999; break; }
	case 15: {Item@ weapon = player.AddItem(PID_MAGNETO_LASER_PISTOL, 1); player.AddItem(PID_SMALL_ENERGY_CELL, 300); weapon.Val0 = 9999; break; }
	case 16: {Item@ weapon = player.AddItem(PID_SOLAR_SCORCHER, 1);  weapon.Val0 = 9999; break; }
	case 17: {Item@ weapon = player.AddItem(PID_LASER_RIFLE_EXT_CAP, 1); player.AddItem(PID_MICRO_FUSION_CELL, 300); weapon.Val0 = 9999; break; }
	case 18: {Item@ weapon = player.AddItem(PID_GATLING_LASER, 1); player.AddItem(PID_MICRO_FUSION_CELL, 1000); weapon.Val0 = 9999; break; }
	case 19: {Item@ weapon = player.AddItem(PID_PLASMA_PISTOL_EXT_CART, 1); player.AddItem(PID_SMALL_ENERGY_CELL, 300); weapon.Val0 = 9999; break; }
	case 20: {Item@ weapon = player.AddItem(PID_PLASMA_RIFLE, 1); player.AddItem(PID_MICRO_FUSION_CELL, 300); weapon.Val0 = 9999; break; }
	case 21: {Item@ weapon = player.AddItem(PID_PLASMA_SMG, 1); player.AddItem(PID_SMALL_ENERGY_CELL, 1500); weapon.Val0 = 9999; break; }
	case 22: {Item@ weapon = player.AddItem(PID_YK32_PULSE_PISTOL, 1); player.AddItem(PID_SMALL_ENERGY_CELL, 300); weapon.Val0 = 9999; break; }
	case 23: {Item@ weapon = player.AddItem(PID_EL_ROCKET_LAUNCHER, 1); player.AddItem(PID_EL_ROCKET, 70); weapon.Val0 = 9999; break; }
	case 24: {player.AddItem(PID_MOLOTOV_COCKTAIL, 250);  break; }
	case 25: {player.AddItem(PID_FRAG_GRENADE, 250);  break; }
	case 26: {player.AddItem(PID_PLASMA_GRENADE, 250);  break; }
	case 27: {player.AddItem(PID_SHOCK_GRENADE, 250);  break; }
	case 28: {player.AddItem(PID_THROWING_KNIFE, 250); break; }
	case 29: {Item@ weapon = player.AddItem(PID_WAKIZASHI_BLADE, 1); weapon.Val0 = 9999;  break; }
	case 30: {Item@ weapon = player.AddItem(PID_SUPER_SLEDGE, 1); weapon.Val0 = 9999; break; }
	case 31: {Item@ weapon = player.AddItem(PID_RIPPER, 1); player.AddItem(PID_SMALL_ENERGY_CELL, 200); weapon.Val0 = 9999; break; }
	case 32: {Item@ weapon = player.AddItem(PID_SUPER_CATTLE_PROD, 1); player.AddItem(PID_SMALL_ENERGY_CELL, 300); weapon.Val0 = 9999; break; }
	case 33: {player.AddItem(PID_LASER_SPEAR, 75); break; }
	case 34: {Item@ weapon = player.AddItem(PID_MEGA_POWER_FIST, 1); player.AddItem(PID_SMALL_ENERGY_CELL, 300); weapon.Val0 = 9999; break; }
	case 420: {
	player.AddItem(PID_FIRE_SMG, 1); 
	player.AddItem(PID_TESLA_GATLING, 1); 
	player.AddItem(PID_LASER_LSW, 1); 
	player.AddItem(PID_ELECTRO_RIFLE, 1); 
	player.AddItem(PID_SNIPER_RIFLE_MK2, 1); 
	player.AddItem(PID_SUPER_DUPER_SLEDGE, 1); 
	player.AddItem(PID_AUTOAIM_ROCKET, 1); 
	player.AddItem(PID_PLASMA_FLAMER, 1); 
	player.AddItem(PID_SMALL_ENERGY_CELL, 300); 
	player.AddItem(PID_MICRO_FUSION_CELL, 300); 
	player.AddItem(PID_223_FMJ, 300); 
	player.AddItem(PID_ROCKET_AP, 30); 
	player.AddItem(PID_FLAMETHROWER_FUEL_MK_II, 30); 
	break; 
	}
	}
}

import void endevent() from "map_events";

void endevent(Critter& cr, int teamwin, int reward, int exp)
{
	endevent();
	finished = true;
	Map@ map = cr.GetMap();
	Location@ locwar = map.GetLocation();
	array<Map@> maps;
	locwar.GetMaps(maps);
	//rewardmap.Reload();
	array<Critter@> players;
	//int id = CreateLocation(421, 1725, 1375, players);
   // Location@ loc = GetLocation(id);
  //  Map@ rewardmap = loc.GetMapByIndex(0);
	team1points = 0;
	team2points = 0;
	team3points = 0;
	team4points = 0;
	team5points = 0;
	team6points = 0;
	teamSALpoints = 0;
	teamBISpoints = 0;
	teamWRIpoints = 0;
	teamMORpoints = 0;
	bool alliance = false;
	if(teamwin > 300)
		alliance = true;
	for(uint i = 0; i < maps.length(); i++)
		if(valid(maps[i]))
			maps[i].GetCritters(0, FIND_ALL | FIND_ONLY_PLAYERS , players);
	//map.GetCritters(0, FIND_ONLY_PLAYERS | FIND_ALL, players);
	for(uint16 i = 0; i < players.length(); i++)
	{
		array<Item@> items;
		uint         n = players[i].GetItems(-1, items);
		for(uint j = 0; j < n; j++)
			DeleteItem(items[j]);
		players[i].ToLife();
		UnsetMinigame(players[i]);
		players[i].ParamBase[MODE_NO_LOOT] = 0;
		players[i].ParamBase[MODE_NO_DROP] = 0;
		if(!alliance)
		{
		if(players[i].Param[ST_NPC_ROLE] == teamwin)
		{
		players[i].ParamBase[WE_RANKED_GAME] += 10000;
		AddScore(players[i], SCORE_EVENT_WAR, players[i].ParamBase[WE_RANKED_GAME]);
			players[i].ParamBase[ST_EXPERIENCE] += exp;
			switch(reward)
			{
				case 1: { players[i].ParamBase[ST_EXPERIENCE] += 1000 * players[i].Param[ST_LEVEL]; break; }
				case 2: { getImplant(players[i]); break; }
				case 3: { getT4part(players[i]); break; }
				case 4: { players[i].AddItem(currency(), exp); break; }
				case 5: { getStat(players[i]); break; }
				case 6: { getOPImplant(players[i]); break; }
				case 7: { getT4Realpart(players[i]); break; }
				case 8: { players[i].AddItem(PID_VAULT_TEC_BOX, 1); players[i].AddItem(PID_VAULT_TEC_KEY, 1); break; }
				case 9: { players[i].AddItem(tier4item(), 1); break; }
				case 10: { players[i].AddItem(tier4ammo(), Random(50,250)); break; }
				case 11: { players[i].AddItem(verti_parts(), 1); break; }
				
				case 20: { players[i].AddItem(PID_VAULT_TEC_KEY, 1); players[i].AddItem(familyArmor(), 1);break; } // TODO results depends on reward
				default: 
				{
					switch(Random(1,8))
					{
					case 1: { players[i].ParamBase[ST_EXPERIENCE] += 1000 * players[i].Param[ST_LEVEL]; break; }
					case 2: { getImplant(players[i]); break; }
					case 3: { getT4part(players[i]); break; }
					case 4: { players[i].AddItem(currency(), exp); break; }
					case 5: { getStat(players[i]); break; }
					case 6: { getOPImplant(players[i]); break; }
					case 7: { getT4Realpart(players[i]); break; }
					case 8: { players[i].AddItem(PID_VAULT_TEC_BOX, 1); players[i].AddItem(PID_VAULT_TEC_KEY, 1); break; }
					case 9: { players[i].AddItem(tier4item(), 1); break; }
					case 10: { players[i].AddItem(tier4ammo(), Random(50,250)); break; }
					case 11: { players[i].AddItem(verti_parts(), 1); break; }
					}
				break;
				}
			}
			players[i].ParamBase[ST_NPC_ROLE] = 0;
			if(reward != 20)
				players[i].TransitToMap(51, 0); //rewardroom
			else players[i].TransitToMap(87, 0); // new reno: stables, maybe new reward room?
		}
		else
		{
			players[i].ParamBase[ST_NPC_ROLE] = 0;
			players[i].ParamBase[ST_EXPERIENCE] += exp;
			if(reward != 20)
				players[i].TransitToMap(51, 0); //ncr
			else players[i].TransitToMap(87, 0); // new reno

			
		}
	CreateTimeEvent(AFTER(REAL_SECOND(5)), "e_showstats", players[i].Id, false);
	}
	else
	{
	if(players[i].Param[ST_NPC_ROLE] == 209 || players[i].Param[ST_NPC_ROLE] == 207)
		{
		AddScore(players[i], SCORE_EVENT_WAR, players[i].ParamBase[WE_RANKED_GAME]);
			players[i].ParamBase[ST_EXPERIENCE] += exp;
			switch(reward)
			{
				case 1: { players[i].ParamBase[ST_EXPERIENCE] += 1000 * players[i].Param[ST_LEVEL]; break; }
				case 2: { getImplant(players[i]); break; }
				case 3: { getT4part(players[i]); break; }
				case 4: { players[i].AddItem(currency(), exp); break; }
				case 5: { getStat(players[i]); break; }
				case 6: { getOPImplant(players[i]); break; }
				case 7: { getT4Realpart(players[i]); break; }
				case 8: { players[i].AddItem(PID_VAULT_TEC_BOX, 1); players[i].AddItem(PID_VAULT_TEC_KEY, 1); break; }
				default: 
				{
					switch(Random(1,8))
					{
					case 1: { players[i].ParamBase[ST_EXPERIENCE] += 1000 * players[i].Param[ST_LEVEL]; break; }
					case 2: { getImplant(players[i]); break; }
					case 3: { getT4part(players[i]); break; }
					case 4: { players[i].AddItem(currency(), exp); break; }
					case 5: { getStat(players[i]); break; }
					case 6: { getOPImplant(players[i]); break; }
					case 7: { getT4Realpart(players[i]); break; }
					case 8: { players[i].AddItem(PID_VAULT_TEC_BOX, 1); players[i].AddItem(PID_VAULT_TEC_KEY, 1); break; }
					}
				break;
				}
			}
			players[i].ParamBase[ST_NPC_ROLE] = 0;
			players[i].TransitToMap(51, 0); 
		}
		else
		{
			players[i].ParamBase[ST_NPC_ROLE] = 0;
			players[i].ParamBase[ST_EXPERIENCE] += exp;
			players[i].TransitToMap(51, 0);

			
		}
	CreateTimeEvent(AFTER(REAL_SECOND(5)), "e_showstats", players[i].Id, false);
	}
	}
	CreateTimeEvent(AFTER(REAL_SECOND(20)), "e_clear_map_again", map.Id, false);
}

uint familyArmor()
{
	switch(Random(1,4))
	{
	case 1: return PID_SALVATORIES_ARMOR;
	case 2: return PID_BISHOPS_ARMOR;
	case 3: return PID_WRITHS_ARMOR;
	case 4: return PID_MORDINOS_ARMOR;
	
	}
	return PID_SALVATORIES_ARMOR;
}

uint e_clear_map_again(array<uint>@ mobdata)
{
	Map@ map = GetMap(mobdata[0]);
	if(!valid(map))
		return 0;
	if(map.GetLocation().GetProtoId() == 421)
		return 0;
	Critter@ cr = AddNpc(map, 3,3 , 1, 3, 0, "", 0, 0, 0, true, 1);
	endevent(cr,69,69,69);
	//DeleteLocation(map.GetLocation().Id);
	return 0;
}
uint e_showstats(array<uint>@ mobdata)
{
	Critter@ players = GetCritter(mobdata[0]);
	players.Say(SAY_NETMSG, "NPCs Killed: |-256 " + players.GetScore(SCORE_WE_KILLS));
	players.Say(SAY_NETMSG, "Players Killed: |-256 " + players.GetScore(SCORE_WE_PLAYERS_KILLS));
	players.Say(SAY_NETMSG, "Deaths: |-256 " + players.GetScore(SCORE_WE_DEATHS));
	players.Say(SAY_NETMSG, "Gain Points: |-256 " + players.Param[WE_RANKED_GAME]);	
	players.ParamBase[WE_RANKED_TOTAL] += players.Param[WE_RANKED_GAME];
	players.Say(SAY_NETMSG, "Total Rating for this battle:");

	 array<Critter@> crs;
	 int            num = GetAllPlayers(crs);
	 for(int i = 0; i < num; i++)
	 {	
	 if(crs[i].Param[WE_RANKED_TOTAL] != 0)
		players.Say(SAY_NETMSG, crs[i].Name + " : |-1 " + crs[i].Param[WE_RANKED_GAME]);
	 
	 }
	 
	 players.Say(SAY_NETMSG, "Your Rating: |-256 " + players.Param[WE_RANKED_TOTAL]);	
	return 0;
	
}
void resetpoints(Critter& cr, int team, int howmuch, int cos)
{
	team1points = 0;
	team2points = 0;
	team3points = 0;
	team4points = 0;
	team5points = 0;
	team6points = 0;
	teamSALpoints = 0;
	teamBISpoints = 0;
	teamWRIpoints = 0;
	teamMORpoints = 0;
}

void checkpoints(Critter& cr, int team, int howmuch, int cos)
{
	cr.Say(SAY_NETMSG, "Enclave: " + team1points + " Brotherhood: " + team2points + " Vault City: " + team3points + " NCR: " + team4points + " Defenders: " + team5points + " Master Army: " + team6points + " Salvatories: " + teamSALpoints + " Bishops: " + teamBISpoints + " Wriths: " + teamWRIpoints + " moritinos: " + teamMORpoints);
}

void dlg_Teleport(Critter& player, Critter@ npc, int entire)
{
	switch(entire)
	{
	case 0: { player.TransitToMap(player.GetMap().Id, 70); break;}
	case 1: { player.TransitToMap(player.GetMap().Id, 10); break; }
	case 2: { player.TransitToMap(player.GetMap().Id, 40); break;}
	case 4: { player.TransitToMap(player.GetMap().Id, 100); break;}
	case 3: {  
	array<Item@> items;
    uint         n = player.GetItems(-1, items);
    for(uint i = 0; i < n; i++)
        DeleteItem(items[i]);
	player.ParamBase[ST_NPC_ROLE] = 0;
	UnsetMinigame(player);
	player.ParamBase[MODE_NO_LOOT] = 0;
	player.ParamBase[MODE_NO_DROP] = 0;
	player.TransitToMap(254, 0);
	//player.ParamBase[EVENT_WARMING] += 5;
		break;
		}
	}
	
}

void dlg_Upgrate_Weapon(Critter& player, Critter@ npc)
{
	Item@ Weapon = player.GetItem(0,SLOT_HAND1);
	if(!valid(Weapon))
		return;
	Weapon.Val0 += 10000;
	Weapon.Update();
	_weapon_perk(Weapon,true);
	player.ParamBase[WE_RANKED_GAME] += 10;
}

void dlg_Upgrate_Armor(Critter& player, Critter@ npc)
{
	Item@ Weapon = player.GetItem(0,SLOT_ARMOR);
	if(!valid(Weapon))
		return;
	Weapon.Val0 += 15000;
	Weapon.Update();
	_armor_perk(Weapon,true);
	player.ParamBase[WE_RANKED_GAME] += 10;
}

void dlg_Repair_Gear(Critter& player, Critter@ npc)
{
	Item@ Armor = player.GetItem(0,SLOT_ARMOR);
	Item@ Head = player.GetItem(0,SLOT_HEAD);
	Item@ Weapon = player.GetItem(0,SLOT_HAND1);
	Item@ Weapon2 = player.GetItem(0,SLOT_HAND2);
	Armor.BrokenCount = 0;
	Armor.Deterioration = 0;
	UNSETFLAG(Armor.BrokenFlags, BI_BROKEN);
	Armor.Update();
	Head.BrokenCount = 0;
	Head.Deterioration = 0;
	UNSETFLAG(Head.BrokenFlags, BI_BROKEN);
	Head.Update();
	Weapon.BrokenCount = 0;
	Weapon.Deterioration = 0;
	UNSETFLAG(Weapon.BrokenFlags, BI_BROKEN);
	Weapon.Update();
	Weapon2.BrokenCount = 0;
	Weapon2.Deterioration = 0;
	UNSETFLAG(Weapon2.BrokenFlags, BI_BROKEN);
	Weapon2.Update();
}

void dlg_Spawn_forces(Critter& player, Critter@ npc, int side)
{
	int team = 5;
	switch(npc.Param[ST_NPC_ROLE])
	{
	case 204: team = 5; break;
	case 206: team = 8; break;
	case 207: team = 7; break;
	case 208: team = 9; break;
	case 209: team = 6; break;
	case 212: team = 12; break;
	case 231: team = 14; break;
	case 232: team = 16; break;
	case 233: team = 18; break;
	case 234: team = 20; break;
	}
	switch(side)
	{
	case 0: { SpawnTeam(npc, Random(3,6), Random(63,75), team, false); break;}
	case 1: { SpawnTeam(npc, Random(3,6), Random(3,15), team, false); break; }
	case 2: { SpawnTeam(npc, Random(3,6), Random(33,45), team, false); break;}
	case 4: { SpawnTeam(npc, Random(3,6), Random(93,105), team, false); break;}
	}
	uint currency = PID_BOTTLE_CAPS;
	switch(npc.Param[ST_NPC_ROLE])
	{
	case 204: currency = PID_ENCLAVE_MONEY; break;
	case 206: currency = PID_VC_MONEY; break;
	case 207: currency = PID_NCR_MONEY; break;
	case 208: currency = PID_BOTTLE_CAPS; break;
	case 209: currency = PID_BOS_MONEY; break;
	case 212: currency = PID_MA_MONEY; break;
	default:  currency = PID_BOTTLE_CAPS; break;
	}
	uint count = npc.GetMap().GetNpcCount(npc.Param[ST_NPC_ROLE], FIND_LIFE_AND_KO | FIND_ONLY_NPC);
	r_RemoveMoney(player,npc,count*1000);
	player.ParamBase[WE_RANKED_GAME] += 5;
}

void dlg_Spawn_forces_cost_show(Critter& player, Critter@ npc, string@ text)
{
	uint count = npc.GetMap().GetNpcCount(npc.Param[ST_NPC_ROLE], FIND_LIFE_AND_KO | FIND_ONLY_NPC);
	text += ("$cost" + count*1000);
	text += ("$special" + count*1500);
}


bool dlg_Spawn_forces_cost(Critter& player, Critter@ npc)
{
	uint team = PID_BOTTLE_CAPS;
	switch(npc.Param[ST_NPC_ROLE])
	{
	case 204: team = PID_ENCLAVE_MONEY; break;
	case 206: team = PID_VC_MONEY; break;
	case 207: team = PID_NCR_MONEY; break;
	case 208: team = PID_BOTTLE_CAPS; break;
	case 209: team = PID_BOS_MONEY; break;
	case 212: team = PID_MA_MONEY; break;
	default:  team = PID_BOTTLE_CAPS; break;
	}
	uint count = npc.GetMap().GetNpcCount(npc.Param[ST_NPC_ROLE], FIND_LIFE_AND_KO | FIND_ONLY_NPC);
	if(_CritCountItem(player,team) >= count*1000)
	return true;
	
	
	return false;
}


bool dlg_Spawn_forces_cost_special(Critter& player, Critter@ npc)
{
	uint team = PID_BOTTLE_CAPS;
	switch(npc.Param[ST_NPC_ROLE])
	{
	case 204: team = PID_ENCLAVE_MONEY; break;
	case 206: team = PID_VC_MONEY; break;
	case 207: team = PID_NCR_MONEY; break;
	case 208: team = PID_BOTTLE_CAPS; break;
	case 209: team = PID_BOS_MONEY; break;
	case 212: team = PID_MA_MONEY; break;
	default:  team = PID_BOTTLE_CAPS; break;
	}
	uint count = npc.GetMap().GetNpcCount(npc.Param[ST_NPC_ROLE], FIND_LIFE_AND_KO | FIND_ONLY_NPC);
	if(_CritCountItem(player,team) >= count*1500)
	return true;
	
	
	return false;
}

void dlg_Spawn_forcesboss(Critter& player, Critter@ npc, int side)
{
	int team = 5;
	switch(npc.Param[ST_NPC_ROLE])
	{
	case 204: team = 5; break;
	case 206: team = 8; break;
	case 207: team = 7; break;
	case 208: team = 9; break;
	case 209: team = 6; break;
	case 212: team = 12; break;
	case 231: team = 14; break;
	case 232: team = 16; break;
	case 233: team = 18; break;
	case 234: team = 20; break;
	}
	switch(side)
	{
	case 0: { SpawnTeam(npc, Random(1,3), Random(63,75), team, true); break;}
	case 1: { SpawnTeam(npc, Random(1,3), Random(3,15), team, true); break; }
	case 2: { SpawnTeam(npc, Random(1,3), Random(33,45), team, true); break;}
	case 4: { SpawnTeam(npc, Random(3,6), Random(93,105), team, false); break;}
	}
	uint count = npc.GetMap().GetNpcCount(npc.Param[ST_NPC_ROLE], FIND_LIFE_AND_KO | FIND_ONLY_NPC);
	r_RemoveMoney(player,npc,count*1500);
	player.ParamBase[WE_RANKED_GAME] += 5;
}

void _flag(Item& item, bool firstTime)
{
	SETFLAG(item.Flags, ITEM_CAN_USE);
	item.Update();
    item.SetEvent(ITEM_EVENT_SKILL, "_UseN");
}
#include "flags_h.fos"
bool _UseN(Item& flag, Critter& cr, int skill)
{
	
	cr.ParamBase[MODE_HIDE] = 0;
	if(flag.Val0 != cr.Param[ST_NPC_ROLE] && flag.Val4 < 1 && flag.Val1 != cr.Param[ST_NPC_ROLE] )
		{
		//start taking
		flag.Val0 = cr.Param[ST_NPC_ROLE];
		cr.ParamBase[WE_RANKED_GAME] += 500;
		array<uint> filldata = { flag.Id, cr.Param[ST_NPC_ROLE], flag.Val1, flag.Val4, cr.GetMap().Id};
		CreateTimeEvent(AFTER(REAL_MS(500)), "e_flag", filldata, false);
		}
	return true;
}

uint e_flag(array<uint>@ LocData)
{
    Item@ flag = GetItem(LocData[0]);
	int team = LocData[1];
	int flagowner = LocData[2];
	int points = flag.Val4;
	Map@ map = GetMap(LocData[4]);
	int dys = 0;
	int members = 0;
	string teamname = "";
	int teamid = 0;
	switch(team)
	{
	case 204: teamname = "Enclave"; teamid = 0; break;
	case 206: teamname = "Vault City"; teamid = 3; break;
	case 207: teamname = "NCR"; teamid = 2; break;
	case 208: teamname = "Defenders"; teamid = 4; break;
	case 209: teamname = "Brotherhood of Steel"; teamid = 1; break;
	case 212: teamname = "Master Army"; teamid = 5; break;
	case 231: teamname = "Salvatories"; teamid = 6; break;
	case 232: teamname = "Bishops"; teamid = 7; break;
	case 233: teamname = "Wrights"; teamid = 8; break;
	case 234: teamname = "Mordinos"; teamid = 9; break;
	}
	int ally = 0;
	if(team == 207)
		ally = 209;
	if(team == 209)
		ally = 207;
	array<Critter@> players;
	int num = map.GetCritters(0, FIND_ONLY_PLAYERS | FIND_LIFE_AND_KO, players);
	for(int i = 0; i < num; i++)
		{
		if(players[i].Param[MODE_HIDE] > 0)
			continue;
		dys = GetDistantion(flag.HexX, flag.HexY,players[i].HexX, players[i].HexY);
		if(dys<21 && players[i].Param[ST_NPC_ROLE] == team)
			{
			points += 10;
			members += 1;
			flag.Val4 += 10;
			players[i].ParamBase[WE_RANKED_GAME] += 3;
			flag.Update();
			players[i].Say(SAY_NETMSG, teamname + " is Capturing " + points/10 + "%");
			}
		if(dys<21 && players[i].Param[ST_NPC_ROLE] != team && players[i].Param[ST_NPC_ROLE] != ally)
			{
			if(points>0)
			{
			points -= 10;
			flag.Val4 -= 10;
			players[i].ParamBase[WE_RANKED_GAME] += 3;
			flag.Update();
			players[i].Say(SAY_NETMSG, teamname + " is Defending " + points/10 + "%");
			}
			}
		}
	if(members == 0 && points < 1)
		{
		flag.Val0 = 0;
		flag.Val4 = 0;
		flag.Update();
		return 0; 
		}
	if(points > 999)
	{
	flag.ChangeProto(9000 + team);
	flag.Val1 = team;
	flag.Val0 = 0;
	flag.Val4 = 0;
	flag.Update();
	array<int> oilrig;
    AddBroadcastBuffer(BROADCAST_SERVER_EVENT_MSG, REAL_MS(1500), 0, teamname + " took control over Flag", oilrig, REAL_MS(1500), BROADCAST_FILTER_NONE)
    .SendToAll();
	//ServerEventCNTSet( flag.Id, EVENT_TYPE_TRADER_1, REAL_SECOND(5));
	return 0;
	}
    return REAL_MS(2500);
}
//old flag system
bool _UseP(Item& flag, Critter& cr, int skill)
{
	string teamname = "";
	int teamid = 0;
	switch(cr.Param[ST_NPC_ROLE])
	{
	case 204: teamname = "Enclave"; teamid = 0; break;
	case 206: teamname = "Vault City"; teamid = 3; break;
	case 207: teamname = "NCR"; teamid = 2; break;
	case 208: teamname = "Defenders"; teamid = 4; break;
	case 209: teamname = "Brotherhood of Steel"; teamid = 1; break;
	case 212: teamname = "Master Army"; teamid = 5; break;
	case 231: teamname = "Salvatories"; teamid = 6; break;
	case 232: teamname = "Bishops"; teamid = 7; break;
	case 233: teamname = "Wrights"; teamid = 8; break;
	case 234: teamname = "Mordinos"; teamid = 9; break;
	
	}
	if(cr.Param[ST_NPC_ROLE] == 209 && flag.Val1 == 207 && flag.Val2 < 0 || cr.Param[ST_NPC_ROLE] == 207 && flag.Val1 == 209 && flag.Val2 < 0) //bos alliance
	{
	cr.Say(SAY_NETMSG, teamname + "Its alliance flag");
	return true;
	}
	if(cr.Param[ST_NPC_ROLE] == 209 && flag.Val1 == 207 && flag.Val2 > 0 || cr.Param[ST_NPC_ROLE] == 207 && flag.Val1 == 209 && flag.Val2 > 0) //ncr alliance
	{
	flag.Val2 -= 100 + cr.Param[SK_SPEECH] ;
	cr.Say(SAY_NETMSG, teamname + " is Defending " + flag.Val2/100 + "/100");
	flag.Update();
	return true;
	}
	
	cr.ParamBase[MODE_HIDE] = 0;
	if(flag.Val0 != cr.Param[ST_NPC_ROLE] && flag.Val2 < 1 && flag.Val1 != cr.Param[ST_NPC_ROLE] )
		{
		flag.Val0 = cr.Param[ST_NPC_ROLE];
		flag.Val2 += 100 + cr.Param[SK_SPEECH];
		flag.Update();
		return true;
		}
	if(flag.Val0 != cr.Param[ST_NPC_ROLE] && flag.Val2 > 0  && flag.Val1 != cr.Param[ST_NPC_ROLE])
		{
		flag.Val2 -= 100 + cr.Param[SK_SPEECH] ;
		cr.Say(SAY_NETMSG, teamname + " is Defending " + flag.Val2/100 + "/100");
		flag.Update();
		return true;
		}
	if(flag.Val1 == cr.Param[ST_NPC_ROLE] && flag.Val2 > 0)
		{
		flag.Val2 -= 100 + cr.Param[SK_SPEECH] ;
		cr.Say(SAY_NETMSG, teamname + " is Defending " + flag.Val2/100 + "/100");
		flag.Update();
		return true;
		}
	if(flag.Val2<10000 && flag.Val0 == cr.Param[ST_NPC_ROLE]  && flag.Val1 != cr.Param[ST_NPC_ROLE])
	{	
	flag.Val2 += 100 + cr.Param[SK_SPEECH];
	cr.Say(SAY_NETMSG, teamname + " is Capturing " + flag.Val2/100 + "/100");
	flag.Update();
	return true;
	}
	if(flag.Val2>9999 && flag.Val0 == cr.Param[ST_NPC_ROLE] )
	{
	flag.ChangeProto(9000 + cr.Param[ST_NPC_ROLE]);
	flag.Val1 = cr.Param[ST_NPC_ROLE];
	flag.Val0 = 0;
	flag.Val2 = 0;
	flag.Update();
	
	ServerEventCNTSet(teamname + " took control over Flag", cr.Id, EVENT_TYPE_TRADER_1, REAL_SECOND(5));

	return true;
	}
	return false;
}
void ExeccreateofficerCommand(array<string@>@ command, Critter@ cr)
{
	int type = 0;
    cheatGetOption(command, type, "-a");
	int typeB = 0;
    cheatGetOption(command, typeB, "-b");
	int typeC = 0;
    cheatGetOption(command, typeC, "-c");
	createofficer(cr,type,typeB,typeC);
}
void createofficer(Critter& cr, int team, int t4, int attack)
{
	Map@ map = cr.GetMap();
	string teamo = "";
	uint16 pid = Random(888,889);
	uint8 dir = Random(0,5);
	uint aiPack = 0;
	uint bagId = 0;
	uint teamIdPack = 0;
	uint weaponforgroup = 1;
	uint16 x = 1;
	uint16 y = 2;
	switch(team)
		{
		case 1: { pid = Random(888,889); break;}
		case 2: { pid = Random(886,887); break; }
		case 3: { pid = Random(904,905); break; }
		case 4: { pid = Random(902,903); break; }
		case 6: { pid = Random(590,591); break; }
		case 7: { pid = 422; break; }
		case 8: { pid = 438; break; }
		case 9: { pid = 415; break; }
		case 10: { pid = 439; break; }
		default: { pid = Random(888,889); break;}
		}
	
	Critter@ item = AddNpc(map, pid,cr.HexX + x , cr.HexY + y, 3, DIALOG_war_officer, "", aiPack, 0, teamIdPack, true, 120);
	item.ParamBase[SK_BARTER] = 150;
	item.ParamBase[MODE_NO_BARTER] = 0;
	switch(attack)
	{
	case 0: {item.ParamBase[SK_SPEECH] = 150; break;}
	case 1: {item.ParamBase[SK_SPEECH] = 300; break;}
	case 2: {item.ParamBase[SK_SPEECH] = 200; break;}
	case 3: {item.ParamBase[SK_SPEECH] = 250; break;}
	}
	item.ParamBase[MODE_NO_STEAL] = 1;
	item.ParamBase[MODE_NO_LOOT] = 1;
	item.ParamBase[MODE_NO_TALK] = 0;
	item.ParamBase[MODE_INVULNERABLE] = 1;
	item.ParamBase[MODE_DLG_SCRIPT_BARTER] = 1;
	item.ParamBase[ST_MELEE_DAMAGE] = 9999;
	switch(team)
		{
		case 1: { item.ParamBase[ST_NPC_ROLE] = 204; item.ParamBase[ST_DESCRIPTION2] = 1; break;}
		case 2: { item.ParamBase[ST_NPC_ROLE] = 209; item.ParamBase[ST_DESCRIPTION2] = 2; break; }
		case 3: { item.ParamBase[ST_NPC_ROLE] = 207;  item.ParamBase[ST_DESCRIPTION2] = 3; break; }
		case 4: { item.ParamBase[ST_NPC_ROLE] = 206; item.ParamBase[ST_DESCRIPTION2] = 4; break; }
		case 6: { item.ParamBase[ST_NPC_ROLE] = 212; item.ParamBase[ST_DESCRIPTION2] = 5; break; }
		default: { item.ParamBase[ST_NPC_ROLE] = 208; item.ParamBase[ST_DESCRIPTION2] = 0; break;}
		}
		
	for( int i =1; i <= 500; i++ )
		{
		SpawnBuffItem(item, tier3armor());
        SpawnBuffItem(item, tier3helmet());
		SpawnBuffItem(item, tier3weapon());
        item.AddItem(tier3ammo(), Random(50 , 120));
		item.AddItem(tier3drugs(),  Random(5 , 25));
		item.AddItem(tier4parts(), Random(1 , 2));
	item.AddItem(PID_STEALTH_BOY, Random(1 , 30));
	item.AddItem(PID_SHOVEL, Random(1 , 100));
	item.AddItem(PID_FIREWOOD, Random(1 , 200));
	item.AddItem(PID_BRAHMIN_HIDE, Random(1 , 200));
	item.AddItem(PID_METAL_PARTS, Random(1 , 200));
	item.AddItem(PID_GUNPOWDER2, Random(1 , 30));
	item.AddItem(PID_SUPER_TOOL_KIT,  Random(11 , 24));
	item.AddItem(PID_FIELD_MEDIC_KIT,  Random(11 , 25));
	item.AddItem(tier4ammo(),  Random(10 , 50));
	item.AddItem(PID_LASER_SPEAR,  Random(100 , 200));
	item.AddItem(PID_MOTION_SENSOR_WE, Random(1 , 30));
	
			}
}

void createofficer(Map& map, int team, int t4, int attack, uint16 x, uint16 y)
{
	string teamo = "";
	uint16 pid = Random(888,889);
	uint8 dir = Random(0,5);
	uint aiPack = 0;
	uint bagId = 0;
	uint teamIdPack = 0;
	uint weaponforgroup = 1;
	switch(team)
		{
		case 1: { pid = Random(888,889); break;}
		case 2: { pid = Random(886,887); break; }
		case 3: { pid = Random(904,905); break; }
		case 4: { pid = Random(902,903); break; }
		case 6: { pid = Random(590,591); break; }
		case 7: { pid = 422; break; }
		case 8: { pid = 438; break; }
		case 9: { pid = 415; break; }
		case 10: { pid = 439; break; }
		default: { pid = Random(888,889); break;}
		}
	
	Critter@ item = AddNpc(map, pid,x , y, 3, DIALOG_war_officer, "", aiPack, 0, teamIdPack, true, 120);
	item.ParamBase[SK_BARTER] = 150;
	item.ParamBase[MODE_NO_BARTER] = 0;
	switch(attack)
	{
	case 0: {item.ParamBase[SK_SPEECH] = 150; break;}
	case 1: {item.ParamBase[SK_SPEECH] = 300; break;}
	case 2: {item.ParamBase[SK_SPEECH] = 200; break;}
	case 3: {item.ParamBase[SK_SPEECH] = 250; break;}
	}
	item.ParamBase[MODE_NO_STEAL] = 1;
	item.ParamBase[MODE_NO_LOOT] = 1;
	item.ParamBase[MODE_NO_TALK] = 0;
	item.ParamBase[MODE_INVULNERABLE] = 1;
	item.ParamBase[MODE_DLG_SCRIPT_BARTER] = 1;
	item.ParamBase[ST_MELEE_DAMAGE] = 9999;
	switch(team)
		{
		case 1: { item.ParamBase[ST_NPC_ROLE] = 204; item.ParamBase[ST_DESCRIPTION2] = 1; break;}
		case 2: { item.ParamBase[ST_NPC_ROLE] = 209; item.ParamBase[ST_DESCRIPTION2] = 2; break; }
		case 3: { item.ParamBase[ST_NPC_ROLE] = 207;  item.ParamBase[ST_DESCRIPTION2] = 3; break; }
		case 4: { item.ParamBase[ST_NPC_ROLE] = 206; item.ParamBase[ST_DESCRIPTION2] = 4; break; }
		case 6: { item.ParamBase[ST_NPC_ROLE] = 212; item.ParamBase[ST_DESCRIPTION2] = 5; break; }
		case 7: { item.ParamBase[ST_NPC_ROLE] = 231; item.ParamBase[ST_DESCRIPTION2] = 0; break; }
		case 8: { item.ParamBase[ST_NPC_ROLE] = 232; item.ParamBase[ST_DESCRIPTION2] = 0; break; }
		case 9: { item.ParamBase[ST_NPC_ROLE] = 233; item.ParamBase[ST_DESCRIPTION2] = 0; break; }
		case 10: { item.ParamBase[ST_NPC_ROLE] = 234; item.ParamBase[ST_DESCRIPTION2] = 0; break; }
		
		default: { item.ParamBase[ST_NPC_ROLE] = 208; item.ParamBase[ST_DESCRIPTION2] = 0; break;}
		}
		
		for( int i =1; i <= 500; i++ )
		{
		SpawnBuffItem(item, tier3armor());
        SpawnBuffItem(item, tier3helmet());
		SpawnBuffItem(item, tier3weapon());
        item.AddItem(tier3ammo(), Random(50 , 120));
		item.AddItem(tier4parts(), Random(1 , 2));
		item.AddItem(tier3drugs(),  Random(5 , 25));
	item.AddItem(PID_STEALTH_BOY, Random(1 , 30));
	item.AddItem(PID_SHOVEL, Random(1 , 100));
	item.AddItem(PID_FIREWOOD, Random(1 , 200));
	item.AddItem(PID_BRAHMIN_HIDE, Random(1 , 200));
	item.AddItem(PID_METAL_PARTS, Random(1 , 200));
	item.AddItem(PID_GUNPOWDER2, Random(1 , 30));
	item.AddItem(PID_SUPER_TOOL_KIT,  Random(11 , 24));
	item.AddItem(PID_FIELD_MEDIC_KIT,  Random(11 , 25));
	item.AddItem(tier4ammo(),  Random(10 , 50));
	item.AddItem(PID_LASER_SPEAR,  Random(100 , 200));
	item.AddItem(PID_MOTION_SENSOR_WE, Random(1 , 30));
	
			}
	
}

import void AddSpecialBonus(Item@ it) from "item_bonus";
void SpawnBuffItem(Critter& cr, uint pid)
{
	Item@ it = cr.AddItem(pid, 1);
	it.Val0 = Random(1,50000);
	it.Update();
	if(it.GetType() == ITEM_TYPE_WEAPON)
		_weapon_perk(it, false);

	if(it.GetType() == ITEM_TYPE_ARMOR)
		_armor_perk(it, false);
}

void init(Map& map, bool firsttime)
{
	CreateTimeEvent(AFTER(REAL_HOUR(24)), "e_deletemap", map.GetLocation().Id, false);
    map.SetEvent(MAP_EVENT_CRITTER_DEAD, "_DeadCritter");
}

uint e_deletemap(array<uint>@ LocData)
{
    Location@ loc = GetLocation(LocData[0]);
    if(!valid(loc)) return 0;

    DeleteLocation(loc.Id);
    return 0;
}

void RestoreItems(Critter& cr)
{
    Item@        SafeContainer = GetItem(SafeContainerId);
	array<Item@> items;
    uint         num = cr.GetItems(-1, items);
    for(uint i = 0; i < num; i++)
    {
        MoveItem(items[i], items[i].GetCount(), SafeContainer, cr.Id);
    }
	array<Item@> items2;
    SafeContainer.GetItems(cr.Id, items2);
    MoveItems(items, cr);
}

void _DeadCritter(Map& map, Critter& cr, Critter@ killer)
{
	array<uint> filldata = { cr.Id, map.Id};
	CreateTimeEvent(AFTER(REAL_SECOND(Random(1,2))), "e_TrySpawngear", filldata, false);
	if(cr.IsPlayer())
		RestoreItems(cr);
	if(!valid(cr) || !valid(map))
		return;
	
	//if(cr.IsPlayer() && killer.IsPlayer())
	//	AddScore(killer, SCORE_EVENT_WAR, 4);
	//if(!cr.IsPlayer() && killer.IsPlayer())
	//	AddScore(killer, SCORE_EVENT_WAR, 1);
	if(!cr.IsPlayer())
	{
		switch(killer.Param[ST_NPC_ROLE])
		{
		case 204: {if(cr.Param[ST_NPC_ROLE]==204) team1points -= 1; else team1points += 1; break;}
		case 209: {if(cr.Param[ST_NPC_ROLE]==209 || cr.Param[ST_NPC_ROLE]==207) team2points -= 1; else team2points += 1;  break;}
		case 206: {if(cr.Param[ST_NPC_ROLE]==206) team3points -= 1; else team3points += 1;  break;}
		case 207: {if(cr.Param[ST_NPC_ROLE]==207 || cr.Param[ST_NPC_ROLE]==209) team4points -= 1; else team4points += 1;  break;}
		case 208: {if(cr.Param[ST_NPC_ROLE]==208) team5points -= 1; else team5points += 1;  break;}
		case 212: {if(cr.Param[ST_NPC_ROLE]==212) team6points -= 1; else team6points += 1;  break;}
		case 231: {if(cr.Param[ST_NPC_ROLE]==231) teamSALpoints -= 1; else teamSALpoints += 1;  break;}
		case 232: {if(cr.Param[ST_NPC_ROLE]==232) teamBISpoints -= 1; else teamBISpoints += 1;  break;}
		case 233: {if(cr.Param[ST_NPC_ROLE]==233) teamWRIpoints -= 1; else teamWRIpoints += 1;  break;}
		case 234: {if(cr.Param[ST_NPC_ROLE]==234) teamMORpoints -= 1; else teamMORpoints += 1;  break;}
		}
		killer.ParamBase[WE_RANKED_GAME] += 50;
	}
	else
	{
		switch(killer.Param[ST_NPC_ROLE])
		{
		case 204: {if(cr.Param[ST_NPC_ROLE]==204) team1points -= 25; else team1points += 50; break;}
		case 209: {if(cr.Param[ST_NPC_ROLE]==209 || cr.Param[ST_NPC_ROLE]==207) team2points -= 25; else team2points += 50;  break;}
		case 206: {if(cr.Param[ST_NPC_ROLE]==206) team3points -= 25; else team3points += 50;  break;}
		case 207: {if(cr.Param[ST_NPC_ROLE]==207 || cr.Param[ST_NPC_ROLE]==209) team4points -= 25; else team4points += 50;  break;}
		case 208: {if(cr.Param[ST_NPC_ROLE]==208) team5points -= 25; else team5points += 50;  break;}
		case 212: {if(cr.Param[ST_NPC_ROLE]==212) team6points -= 25; else team6points += 50;  break;}
		case 231: {if(cr.Param[ST_NPC_ROLE]==231) teamSALpoints -= 25; else teamSALpoints += 50;  break;}
		case 232: {if(cr.Param[ST_NPC_ROLE]==232) teamBISpoints -= 25; else teamBISpoints += 50;  break;}
		case 233: {if(cr.Param[ST_NPC_ROLE]==233) teamWRIpoints -= 25; else teamWRIpoints += 50;  break;}
		case 234: {if(cr.Param[ST_NPC_ROLE]==234) teamMORpoints -= 25; else teamMORpoints += 50;  break;}
		}
		killer.ParamBase[WE_RANKED_GAME] += 1000;
		cr.ParamBase[WE_RANKED_GAME] -= 1250;
		if(cr.Param[ST_NPC_ROLE] == killer.Param[ST_NPC_ROLE])
			{
			//if(killer.IsPlayer())
			//	killer.ParamBase[EVENT_WARMING] += 1;
		//	if(!killer.IsPlayer())
			//	cr.ParamBase[EVENT_WARMING] += 1;	
			
			}
	}
	
	//if(cr.Param[EVENT_WARMING] > 10 && cr.IsPlayer())
	//	AddBan(killer, cr.Id, 0, 24, "Autoban: War Event Feeding");
	//if(killer.Param[EVENT_WARMING] > 10 && cr.IsPlayer())
	//	AddBan(cr, killer.Id, 0, 24, "Autoban: War Event Friendly fire");
	
	if(killer.IsPlayer())
	{
		if(cr.IsPlayer())
		{
		if(cr.Param[ST_NPC_ROLE] != killer.Param[ST_NPC_ROLE])
		AddScore(killer, SCORE_WE_PLAYERS_KILLS, 1);
		else AddScore(killer, SCORE_WE_PLAYERS_FF, 1);
		AddScore(cr, SCORE_WE_DEATHS, 1);
		announce(killer,cr);
		switch(killer.Param[ST_NPC_ROLE])
			{
		case 204: {	killer.AddItem(PID_ENCLAVE_MONEY, 5000); break; }
		case 209: {	killer.AddItem(PID_BOS_MONEY, 5000); break; }
		case 207: {	killer.AddItem(PID_NCR_MONEY, 5000);break; }
		case 206: {	killer.AddItem(PID_VC_MONEY, 5000 ); break; }
		case 208: {	killer.AddItem(PID_BOTTLE_CAPS, 5000 ); break; }
		case 212: {	killer.AddItem(PID_MA_MONEY, 5000 ); break; }
		default: {	killer.AddItem(PID_BOTTLE_CAPS, 5000 ); break; }
			}
		}
		if(!cr.IsPlayer())
		{
		if(cr.Param[ST_NPC_ROLE] != killer.Param[ST_NPC_ROLE])
		AddScore(killer, SCORE_WE_KILLS, 1);
		else AddScore(killer, SCORE_WE_FF, 1);
		switch(killer.Param[ST_NPC_ROLE])
			{
		case 204: {	killer.AddItem(PID_ENCLAVE_MONEY, 500); break; }
		case 209: {	killer.AddItem(PID_BOS_MONEY, 500); break; }
		case 207: {	killer.AddItem(PID_NCR_MONEY, 500);break; }
		case 206: {	killer.AddItem(PID_VC_MONEY, 500 ); break; }
		case 208: {	killer.AddItem(PID_BOTTLE_CAPS, 500 ); break; }
		case 212: {	killer.AddItem(PID_MA_MONEY, 500 ); break; }
		default: {	killer.AddItem(PID_BOTTLE_CAPS, 500 ); break; }
			}
		}
	}
	string prefix = "|";
	string prefix2 = "|";
	string weaponname = "";
	switch(cr.Param[ST_NPC_ROLE])
		{
		case 204: {	prefix += COLOR_RGB(88, 88, 88) + " "; break; }
		case 209: {	prefix += COLOR_RGB(255, 255, 255) + " "; break; }
		case 207: {	prefix += COLOR_RGB(230, 150, 14) + " ";break; }
		case 206: {	prefix += COLOR_RGB(14, 88, 203) + " "; break; }
		case 208: {	prefix += COLOR_RGB(54, 200, 54) + " "; break; }
		case 212: {	prefix += COLOR_RGB(255, 0, 0) + " "; break; }
		case 231: {	prefix += COLOR_RGB(0, 255, 255) + " "; break; }
		case 232: {	prefix += COLOR_RGB(153, 102, 51) + " "; break; }
		case 233: {	prefix += COLOR_RGB(255, 255, 0) + " "; break; }
		case 234: {	prefix += COLOR_RGB(153, 0, 153) + " "; break; }
		}
	switch(killer.Param[ST_NPC_ROLE])
		{
		case 204: {	prefix2 += COLOR_RGB(88, 88, 88) + " "; break; }
		case 209: {	prefix2 += COLOR_RGB(255, 255, 255) + " "; break; }
		case 207: {	prefix2 += COLOR_RGB(230, 150, 14) + " ";break; }
		case 206: {	prefix2 += COLOR_RGB(14, 88, 203) + " "; break; }
		case 208: {	prefix2 += COLOR_RGB(54, 200, 54) + " "; break; }
		case 212: {	prefix2 += COLOR_RGB(255, 0, 0) + " "; break; }
		case 231: {	prefix2 += COLOR_RGB(0, 255, 255) + " "; break; }
		case 232: {	prefix2 += COLOR_RGB(153, 102, 51) + " "; break; }
		case 233: {	prefix2 += COLOR_RGB(255, 255, 0) + " "; break; }
		case 234: {	prefix2 += COLOR_RGB(153, 0, 153) + " "; break; }
		}
	if(!killer.IsPlayer() && cr.IsPlayer())
		ServerEventCNTSet(prefix + cr.Name + "|-16711936  was killed by " + prefix2 + "NPC", cr.Id, EVENT_TYPE_TRADER_1, REAL_SECOND(5));

	if(cr.IsPlayer())
	{
	 array<Item@> items;
    uint         n = cr.GetItemsByType(ITEM_TYPE_WEAPON, items);
    for(uint i = 0; i < 5; i++)
    {
        Item@ item = items[i];
        uint rounds = MAX(item.Proto.Weapon_Round_0, item.Proto.Weapon_Round_1);
      //  item.AmmoCount = item.Proto.Weapon_MaxAmmoCount;
        switch(item.Proto.Weapon_DefaultAmmoPid)
        {
        case 0:
            break;
        case PID_10MM_JHP:
        {
            Item@ it = cr.AddItem(PID_10MM_JHP, rounds * Random(7,14));
            @it = cr.AddItem(PID_10MM_AP, rounds * Random(25,35));
            break;
        }
        case PID_5MM_JHP:
        {
            Item@ it = cr.AddItem(PID_5MM_JHP, rounds * Random(7,14));
            @it = cr.AddItem(PID_5MM_AP, rounds * Random(35,45));
            break;
        }
		
		case PID_EXPLOSIVE_ROCKET:
         {
            Item@ it = cr.AddItem(PID_EXPLOSIVE_ROCKET, rounds * Random(7,14));
            @it = cr.AddItem(PID_ROCKET_AP, rounds * Random(20,30));
            break;
         }
		
		case PID_SHOTGUN_SHELLS:
         {
            Item@ it = cr.AddItem(PID_SHOTGUN_SHELLS_FLECHETTE, rounds * Random(15,20));
            @it = cr.AddItem(PID_SHOTGUN_SHELLS_SLUG, rounds * Random(15,20));
            @it = cr.AddItem(PID_SHOTGUN_SHELLS, rounds * Random(15,25));
            break;
         }
		 
         case PID_FLAMETHROWER_FUEL:
         {
            Item@ it = cr.AddItem(PID_FLAMETHROWER_FUEL, rounds * Random(10,20));
            @it = cr.AddItem(PID_FLAMETHROWER_FUEL_MK_II, rounds * Random(45,55));
            break;
         }

         case PID_HN_NEEDLER_CARTRIDGE:
         {
            Item@ it = cr.AddItem(PID_HN_NEEDLER_CARTRIDGE, rounds * Random(25,35));
            Item@ it2 = cr.AddItem(PID_HN_AP_NEEDLER_CARTRIDGE, rounds * Random(25,35));
			Item@ it3 = cr.AddItem(PID_HN_HEAL_NEEDLER_CARTRIDGE, rounds * Random(25,35));
            break;
         }
		 
		 
        default:
        {
            Item@ it = cr.AddItem(item.Proto.Weapon_DefaultAmmoPid, rounds * Random(25,35));
            break;
        }
        }
    }
	}
}
void announce(Critter& cr, Critter@ killer)
{
	string prefix = "|";
	string prefix2 = "|";
	string weaponname = "";
	switch(cr.Param[ST_NPC_ROLE])
		{
		case 204: {	prefix += COLOR_RGB(88, 88, 88) + " "; break; }
		case 209: {	prefix += COLOR_RGB(255, 255, 255) + " "; break; }
		case 207: {	prefix += COLOR_RGB(230, 150, 14) + " ";break; }
		case 206: {	prefix += COLOR_RGB(14, 88, 203) + " "; break; }
		case 208: {	prefix += COLOR_RGB(54, 200, 54) + " "; break; }
		case 212: {	prefix += COLOR_RGB(255, 0, 0) + " "; break; }
		case 231: {	prefix += COLOR_RGB(0, 255, 255) + " "; break; } //sal
		case 232: {	prefix += COLOR_RGB(153, 102, 51) + " "; break; } //bis
		case 233: {	prefix += COLOR_RGB(255, 255, 0) + " "; break; } //wri
		case 234: {	prefix += COLOR_RGB(153, 0, 153) + " "; break; }// mor
		}
	switch(killer.Param[ST_NPC_ROLE])
		{
		case 204: {	prefix2 += COLOR_RGB(88, 88, 88) + " "; break; }
		case 209: {	prefix2 += COLOR_RGB(255, 255, 255) + " "; break; }
		case 207: {	prefix2 += COLOR_RGB(230, 150, 14) + " ";break; }
		case 206: {	prefix2 += COLOR_RGB(14, 88, 203) + " "; break; }
		case 208: {	prefix2 += COLOR_RGB(54, 200, 54) + " "; break; }
		case 212: {	prefix2 += COLOR_RGB(255, 0, 0) + " "; break; }
		case 231: {	prefix2 += COLOR_RGB(0, 255, 255) + " "; break; } //sal
		case 232: {	prefix2 += COLOR_RGB(153, 102, 51) + " "; break; } //bis
		case 233: {	prefix2 += COLOR_RGB(255, 255, 0) + " "; break; } //wri
		case 234: {	prefix2 += COLOR_RGB(153, 0, 153) + " "; break; }// mor
		}
	if(killer.Param[ST_NPC_ROLE] == cr.Param[ST_NPC_ROLE] || killer.Param[ST_NPC_ROLE] == 209 && cr.Param[ST_NPC_ROLE] == 207 || killer.Param[ST_NPC_ROLE] == 207 && cr.Param[ST_NPC_ROLE] == 209)
	prefix += " [!!!] ";
	Item@ Weapon = cr.GetItem(0,SLOT_HAND1);
	switch(Weapon.Proto.ProtoId)
	{
	case PID_ZIP_GUN: weaponname = "Zipgun"; break;
	case PID_9MM_MAUSER: weaponname = "9mm Mauser"; break;
	case PID_10MM_PISTOL: weaponname = "10mm Pistol"; break;
	case PID_14MM_PISTOL: weaponname = "14mm Pistol"; break;
	case PID_DESERT_EAGLE: weaponname = "Desert Eagle"; break;
	case PID_DESERT_EAGLE_EXT_MAG: weaponname = "Desert Eagle"; break;
	case PID_223_PISTOL: weaponname = "223 Pistol"; break;
	case PID_44_MAGNUM_REVOLVER: weaponname = "Magnum"; break;
	case PID_44_MAGNUM_SPEEDLOADER: weaponname = "Magnum"; break;
	case PID_NEEDLER_PISTOL: weaponname = "Needler Pistol"; break;
	case PID_PK12_GAUSS_PISTOL: weaponname = "PK12 Gauss Pistol"; break;
	case PID_GRENADE_PISTOL: weaponname = "Grenade Pistol"; break;

    //Rifles
	case PID_HUNTING_RIFLE: weaponname = "Hunting Rifle"; break;
	case PID_SCOPED_HUNTING_RIFLE: weaponname = "Scoped Hunting Rifle"; break;
	case PID_SPRINGER_RIFLE: weaponname = "Pipe Rifle"; break;
	case PID_ASSAULT_RIFLE: weaponname = "Assault Rifle"; break;
	case PID_ASSAULT_RIFLE_EXT_MAG: weaponname = "Assault Rifle"; break;
	case PID_SNIPER_RIFLE: weaponname = "Sniper Rifle"; break;
	case PID_FN_FAL: weaponname = "FN Fal"; break;
	case PID_FN_FAL_NIGHT_SCOPE: weaponname = "FN Fal"; break;
	case PID_FN_FAL_HPFA: weaponname = "FN Fal"; break;
	case PID_RED_RYDER_BB_GUN: weaponname = "BB Gun"; break;
	case PID_RED_RYDER_LE_BB_GUN: weaponname = "BB Gun"; break;
	case PID_JONNY_BB_GUN: weaponname = "BB Gun"; break;
	case PID_INDEPENDENT: weaponname = "XL70E"; break;
	case PID_AK47: weaponname = "AK-47"; break;
	case PID_M72_GAUSS_RIFLE: weaponname = "M72 Gauss Rifle"; break;
	case PID_GRENADE_LAUNCHER: weaponname = "Grenade Launcher"; break;
    //Shotguns
	case PID_SHOTGUN: weaponname = "Shotgun"; break;
	case PID_SAWED_OFF_SHOTGUN: weaponname = "Shotgun"; break;
	case PID_COMBAT_SHOTGUN: weaponname = "Combat Shotgun"; break;
	case PID_HK_CAWS: weaponname = "HK Caws"; break;
	case PID_PANCOR_JACKHAMMER: weaponname = "Pancor Jackhammer"; break;
	case PID_SAIGA12: weaponname = "Saiga"; break;
    //Pistol-machine gun
	case PID_10MM_SMG: weaponname = "10mm SMG"; break;
	case PID_HK_P90C: weaponname = "HK P90C"; break;
	case PID_TOMMY_GUN: weaponname = "Tommy Gun"; break;
	case PID_HK_G11: weaponname = "HK G11"; break;
	case PID_HK_G11E: weaponname = "HK G11E"; break;
	case PID_GREASE_GUN: weaponname = "Grease Gun"; break;

//Big guns
	case PID_FLAMER: weaponname = "Flamer"; break;
	case PID_IMPROVED_FLAMETHROWER: weaponname = "Incinerator"; break;
	case PID_ROCKET_LAUNCHER: weaponname = "Rocket Launcher"; break;
	case PID_MINIGUN: weaponname = "Minigun"; break;
	case PID_AVENGER_MINIGUN: weaponname = "Avenger Minigun"; break;
	case PID_VINDICATOR_MINIGUN: weaponname = "Vindicator Minigun"; break;
	case PID_BOZAR: weaponname = "Bozar"; break;
	case PID_LIGHT_SUPPORT_WEAPON: weaponname = "LSW"; break;
	case PID_M60: weaponname = "M60"; break;
	case PID_M203: weaponname = "M203"; break;
	case PID_CRUSADER: weaponname = "Crusader"; break;

//Energo
    //Laser
	case PID_LASER_PISTOL: weaponname = "Laser Pistol"; break;
	case PID_MAGNETO_LASER_PISTOL: weaponname = "Laser Pistol"; break;
	case PID_SOLAR_SCORCHER: weaponname = "Solar Scorcher"; break;
	case PID_LASER_RIFLE: weaponname = "Laser Rifle"; break;
	case PID_LASER_RIFLE_EXT_CAP: weaponname = "Laser Rifle"; break;
	case PID_GATLING_LASER: weaponname = "Gatling Laser"; break;
	case PID_ALIEN_LASER_PISTOL: weaponname = "Aline Blaster"; break;
    //Plasma
	case PID_PLASMA_PISTOL: weaponname = "Plasma Pistol"; break;
	case PID_PLASMA_PISTOL_EXT_CART: weaponname = "Plasma Pistol"; break;
	case PID_PLASMA_RIFLE: weaponname = "Plasma Rifle"; break;
	case PID_TURBO_PLASMA_RIFLE: weaponname = "Plasma Rifle"; break;
	case PID_PLASMA_GATLING: weaponname = "Plasma Gatling"; break;
	case PID_PLASMA_SMG: weaponname = "Plasma SMG"; break;
    //Pulse
	case PID_YK32_PULSE_PISTOL: weaponname = "Pulse Pistol"; break;
	case PID_YK42B_PULSE_RIFLE: weaponname = "YK42B Pulse Rifle"; break;
	case PID_KNOCKBACK_RIFLE: weaponname = "Prototype 14"; break;

//Throwing
    //Grenade
	case PID_MOLOTOV_COCKTAIL: weaponname = "Molotov"; break;
	case PID_FRAG_GRENADE: weaponname = "Grenade"; break;
	case PID_PLASMA_GRENADE: weaponname = "Plasma Nade"; break;
	case PID_PULSE_GRENADE: weaponname = "Pulse Nade"; break;
 	case PID_SHOCK_GRENADE: weaponname = "Shock Nade"; break;
    //Other
	case PID_THROWING_KNIFE: weaponname = "Thowing Knife"; break;
	case PID_DYNACORD: weaponname = "Dynacord"; break;
//Melee
    //Cutting
	case PID_KNIFE: weaponname = "Knife"; break;
	case PID_COMBAT_KNIFE: weaponname = "Combat Knife"; break;
	case PID_LIL_JESUS_WEAPON: weaponname = "Knife"; break;
	case PID_SHIV: weaponname = "Knife"; break;
	case PID_SWITCHBLADE: weaponname = "Knife"; break;
	case PID_WAKIZASHI_BLADE: weaponname = "Wakizashi"; break;
    //Pricking
	case PID_SPEAR: weaponname = "Spear"; break;
	case PID_SHARP_SPEAR: weaponname = "Spear"; break;
	case PID_SHARPENED_POLE: weaponname = "Spear"; break;
    //Shock
	case PID_CLUB: weaponname = "Club"; break;
	case PID_CROWBAR: weaponname = "Club"; break;
	case PID_WRENCH: weaponname = "Club"; break;
	case PID_SLEDGEHAMMER: weaponname = "Sledgehammer"; break;
	case PID_LOUISVILLE_SLUGGER: weaponname = "Baseball"; break;
	case PID_SUPER_SLEDGE: weaponname = "Super Sledge"; break;
	case PID_MEGA_SLEDGE: weaponname = "Mega Sledge"; break;
    //Electric
	case PID_CATTLE_PROD: weaponname = "Cattle Prod"; break;
	case PID_SUPER_CATTLE_PROD: weaponname = "Supper Cattle Prod"; break;
	case PID_RIPPER: weaponname = "Ripper"; break;
//laser
	case PID_LASER_SPEAR: weaponname = "Laser Spear"; break;
    // Plasma
	case PID_PLASMA_TORCH: weaponname = "Plasma Torch"; break;

//Unarmed
	case PID_BOXING_GLOVES: weaponname = "Gloves"; break;
	case PID_PLATED_BOXING_GLOVES: weaponname = "Gloves"; break;
	case PID_RING_BOXING_GLOVES: weaponname = "Gloves"; break;
	case PID_RING_PLATED_BOXING_GLOVES: weaponname = "Gloves"; break;
	case PID_POWER_FIST: weaponname = "Power Fist"; break;
	case PID_BRASS_KNUCKLES: weaponname = "Knickles"; break;
	case PID_SPIKED_KNUCKLES: weaponname = "Knickles"; break;
	case PID_MEGA_POWER_FIST: weaponname = "Mega Power Fist"; break;

//Specia
	case PID_PHAZER: weaponname = "Phazer"; break;
	case PID_HOLY_HAND_GRENADE: weaponname = "HOLY HAND GRENADE"; break;
	case PID_BAN_HAMMER: weaponname = "Ban Hammer heh"; break;
	case PID_HOLY_SPEAR: weaponname = "Holy Spear"; break;
//fonline3
 	case PID_M16: weaponname = "M16"; break;
 	case PID_EL_ROCKET_LAUNCHER: weaponname = "ELECTRO RL"; break;

 	case PID_NAPALM: weaponname = "Napalm"; break;
	default: weaponname = "Unknown Weapon"; break;
	}
	ServerEventCNTSet(prefix + cr.Name + "|-16711936  killed " + prefix2 + killer.Name + " |-16711936 with " + weaponname, cr.Id, EVENT_TYPE_TRADER_1, REAL_SECOND(5));

}

uint e_TrySpawngear(array<uint>@ mobdata)
{
	uint16 x = 1;
	uint16 y = 2;
	Critter@ cr = GetCritter(mobdata[0]);
	Map@ map = GetMap(mobdata[1]);
	if(cr.IsPlayer())
	{
	map.GetEntireCoords(cr.Param[ST_NPC_ROLE], Random(0,1), x, y);
	cr.TransitToMap(map.Id, x, y, 3, false);
	cr.ToLife();
	
	}

	int money = 0;
	int capsmultipler = 3;
	switch(cr.Param[ST_NPC_ROLE])
	{
		case 204: {	money = (team2points + team3points + team4points + team5points + team6points) * capsmultipler; break; }
		case 209: {	money = (team1points + team4points + team5points + team6points) * capsmultipler; break; }
		case 207: {	money = (team1points + team4points + team5points + team6points) * capsmultipler;break; }
		case 206: {	money = (team2points + team3points + team1points + team5points + team6points) * capsmultipler; break; }
		case 208: {	money = (team2points + team3points + team4points + team1points + team6points) * capsmultipler; break; }
		case 212: {	money = (team2points + team3points + team4points + team1points  + team5points) * capsmultipler; break; }
		case 231: {	money = (teamBISpoints + teamWRIpoints + teamMORpoints) * capsmultipler; break; }
		case 232: {	money = (teamSALpoints + teamWRIpoints + teamMORpoints) * capsmultipler; break; }
		case 233: {	money = (teamBISpoints + teamSALpoints + teamMORpoints) * capsmultipler; break; }
		case 234: {	money = (teamBISpoints + teamWRIpoints + teamSALpoints) * capsmultipler; break; }
	}
	
	if(money<1)
		money = 50;
	bool sneak = false;
	Heal(cr);
	
	switch(cr.Param[ST_NPC_ROLE])
	{
		case 204: {	cr.AddItem(PID_ENCLAVE_MONEY,money); break; }
		case 209: {	cr.AddItem(PID_BOS_MONEY,money); break; }
		case 207: {	cr.AddItem(PID_NCR_MONEY,money);break; }
		case 206: {	cr.AddItem(PID_VC_MONEY,money); break; }
		case 208: {	cr.AddItem(PID_BOTTLE_CAPS,money); break; }
		case 212: {	cr.AddItem(PID_MA_MONEY,money); break; }
		case 231: {	cr.AddItem(PID_BOTTLE_CAPS,money); break; }
		case 232: {	cr.AddItem(PID_BOTTLE_CAPS,money); break; }
		case 233: {	cr.AddItem(PID_BOTTLE_CAPS,money); break; }
		case 234: {	cr.AddItem(PID_BOTTLE_CAPS,money); break; }
	}
	if(cr.Trait[TRAIT_CHEM_RESISTANT] == 0)
	cr.AddItem(PID_SUPER_STIMPAK, 5);
	else 
	cr.AddItem(PID_BLOODPACK, 5);
	return 0;
}

void givearmor(Critter& cr, bool sneak)
{
	if(!sneak)
	{
		switch(Random(1,5))
		{
			case 1: { Item@ armor = cr.AddItem(PID_METAL_ARMOR_MK_II,1); armor.Val0 = 14999; break; }
			case 2: { Item@ armor = cr.AddItem(PID_TESLA_ARMOR,1); armor.Val0 = 14999; break; }
			case 3: { Item@ armor = cr.AddItem(PID_METAL_ARMOR_MK_III,1); armor.Val0 = 14999; break; }
			case 4: { Item@ armor = cr.AddItem(PID_MUT_METAL,1); armor.Val0 = 14999; break; }
			case 5: { Item@ armor = cr.AddItem(PID_INFERNO_ARMOR,1); armor.Val0 = 14999; break; }
		}
	}
	else
	{
		switch(Random(1,3))
		{
		case 1: { Item@ armor = cr.AddItem(PID_LEATHER_ARMOR_MK_II,1); armor.Val0 = 14999; break; }
		case 2: { Item@ armor = cr.AddItem(PID_CURED_LEATHER_ARMOR,1); armor.Val0 = 14999; break; }
		case 3: { Item@ armor = cr.AddItem(PID_FIREGECKO_JACKET,1); armor.Val0 = 14999; break; }
		}
	}
}

void addbestweapon(Critter& cr)
{
	if(cr.Param[SK_SMALL_GUNS] > cr.Param[SK_BIG_GUNS] &&
		cr.Param[SK_SMALL_GUNS] > cr.Param[SK_ENERGY_WEAPONS] &&
		cr.Param[SK_SMALL_GUNS] > cr.Param[SK_UNARMED] &&
		cr.Param[SK_SMALL_GUNS] > cr.Param[SK_THROWING])
	getSG(cr);
	else if(cr.Param[SK_BIG_GUNS] > cr.Param[SK_SMALL_GUNS] &&
		cr.Param[SK_BIG_GUNS] > cr.Param[SK_ENERGY_WEAPONS] &&
		cr.Param[SK_BIG_GUNS] > cr.Param[SK_UNARMED] &&
		cr.Param[SK_BIG_GUNS] > cr.Param[SK_THROWING])
	getBG(cr);
	else if(cr.Param[SK_ENERGY_WEAPONS] > cr.Param[SK_BIG_GUNS] &&
		cr.Param[SK_ENERGY_WEAPONS] > cr.Param[SK_SMALL_GUNS] &&
		cr.Param[SK_ENERGY_WEAPONS] > cr.Param[SK_UNARMED] &&
		cr.Param[SK_ENERGY_WEAPONS] > cr.Param[SK_THROWING])
	getEW(cr);
	else if(cr.Param[SK_UNARMED] > cr.Param[SK_BIG_GUNS] &&
		cr.Param[SK_UNARMED] > cr.Param[SK_ENERGY_WEAPONS] &&
		cr.Param[SK_UNARMED] > cr.Param[SK_SMALL_GUNS] &&
		cr.Param[SK_UNARMED] > cr.Param[SK_THROWING])
	getCC(cr);
	else if(cr.Param[SK_THROWING] > cr.Param[SK_BIG_GUNS] &&
		cr.Param[SK_THROWING] > cr.Param[SK_ENERGY_WEAPONS] &&
		cr.Param[SK_THROWING] > cr.Param[SK_SMALL_GUNS] &&
		cr.Param[SK_THROWING] > cr.Param[SK_UNARMED])
	getTH(cr);
	else switch(Random(0,2))
	{
	case 0: { getSG(cr); break; }
	case 1: { getBG(cr); break; }
	case 2: { getEW(cr); break; }
	}
}

void getSG(Critter& cr)
{
	if(cr.Param[SK_SMALL_GUNS] < 220)
	switch(Random(0,6))
	{
	case 0: { cr.AddItem(PID_223_PISTOL,1); cr.AddItem(PID_223_FMJ,  Random(100, 200)); break; }
	case 1: { cr.AddItem(PID_GRENADE_LAUNCHER,1); cr.AddItem(PID_40MM_GRENADE,  Random(20, 60)); break; }
	case 2: { cr.AddItem(PID_PANCOR_JACKHAMMER,1); cr.AddItem(PID_SHOTGUN_SHELLS_SLUG,  Random(150, 300)); break; }
	case 3: { cr.AddItem(PID_HK_CAWS,1); cr.AddItem(PID_SHOTGUN_SHELLS_SLUG,  Random(150, 300));break; }
	case 4: { cr.AddItem(PID_HK_P90C,1); cr.AddItem(PID_10MM_AP,  Random(250, 1500)); break; }
	case 5: { cr.AddItem(PID_M16,1); cr.AddItem(PID_5MM_AP,  Random(200, 400)); break; }
	case 6: { cr.AddItem(PID_NEEDLER_PISTOL,1); cr.AddItem(PID_HN_NEEDLER_CARTRIDGE,  Random(200, 400)); cr.AddItem(PID_HN_AP_NEEDLER_CARTRIDGE,  Random(200, 400)); break; }
	}
	else switch(Random(0,1))
	{
	case 0: { cr.AddItem(PID_SNIPER_RIFLE,1); cr.AddItem(PID_223_FMJ,  Random(100, 200)); break; }
	case 1: { cr.AddItem(PID_INDEPENDENT,1); cr.AddItem(PID_5MM_AP, Random(500 , 1000));break; }
	}
}

void getBG(Critter& cr)
{
	if(cr.Param[SK_BIG_GUNS] < 220)
	switch(Random(0,3))
	{
	case 0: { cr.AddItem(PID_IMPROVED_FLAMETHROWER,1); cr.AddItem(PID_FLAMETHROWER_FUEL_MK_II,  Random(20, 70));break; }
	case 2: { cr.AddItem(PID_AVENGER_MINIGUN,1); cr.AddItem(PID_5MM_AP, Random(1000 , 2000));break; }
	case 3: { cr.AddItem(PID_LIGHT_SUPPORT_WEAPON,1); cr.AddItem(PID_223_FMJ,  Random(300, 500)); break; }
	}
	else switch(Random(0,1))
	{
	case 0: { cr.AddItem(PID_LIGHT_SUPPORT_WEAPON,1); cr.AddItem(PID_223_FMJ,  Random(300, 500)); break; }
	case 1: { cr.AddItem(PID_ROCKET_LAUNCHER,1); cr.AddItem(PID_ROCKET_AP,  Random(20, 40)); break; }
	}
}

void getEW(Critter& cr)
{
	if(cr.Param[SK_ENERGY_WEAPONS] < 220)
	switch(Random(0,6))
	{
	case 0: { cr.AddItem(PID_SOLAR_SCORCHER,1); break; }
	case 1: { cr.AddItem(PID_GATLING_LASER,1); cr.AddItem(PID_MICRO_FUSION_CELL,  Random(300, 500)); break; }
	case 2: { cr.AddItem(PID_YK32_PULSE_PISTOL,1); cr.AddItem(PID_SMALL_ENERGY_CELL,  Random(100, 200)); break; }
	case 3: { cr.AddItem(PID_EL_ROCKET_LAUNCHER,1); cr.AddItem(PID_EL_ROCKET,  Random(25, 50));break; }
	case 4: { cr.AddItem(PID_MAGNETO_LASER_PISTOL,1); cr.AddItem(PID_SEC,  Random(100, 200));break; }
	case 5: { cr.AddItem(PID_PLASMA_PISTOL_EXT_CART,1); cr.AddItem(PID_SEC,  Random(100, 200));break; }
	case 6: { cr.AddItem(PID_PLASMA_SMG,1); cr.AddItem(PID_SEC, Random(200, 300));break; }
	}
	else switch(Random(0,1))
	{
	case 0: { cr.AddItem(PID_LASER_RIFLE_EXT_CAP,1); cr.AddItem(PID_MICRO_FUSION_CELL,  Random(100, 200));break; }
	case 1: { cr.AddItem(PID_PLASMA_RIFLE,1); cr.AddItem(PID_MICRO_FUSION_CELL,  Random(100, 200)); break; }
	}
}

void getCC(Critter& cr)
{
	switch(Random(0,3))
	{
	case 0: { cr.AddItem(PID_WAKIZASHI_BLADE,1); break; }
	case 1: { cr.AddItem(PID_SUPER_SLEDGE,1); break; }
	case 2: { cr.AddItem(PID_SUPER_CATTLE_PROD,1); cr.AddItem(PID_SMALL_ENERGY_CELL,  Random(100, 200)); break; }
	case 3: { cr.AddItem(PID_MEGA_POWER_FIST,1); cr.AddItem(PID_SMALL_ENERGY_CELL,  Random(100, 200)); break; }
	}
}

void getTH(Critter& cr)
{
	switch(Random(0,3))
	{
	case 0: { cr.AddItem(PID_MOLOTOV_COCKTAIL,50); break; }
	case 1: { cr.AddItem(PID_FRAG_GRENADE,50); break; }
	case 2: { cr.AddItem(PID_PLASMA_GRENADE,50); break; }
	case 3: { cr.AddItem(PID_SHOCK_GRENADE,50); break; }
	}
}

void getMisc(Critter& item)
{
	if(item.Trait[TRAIT_CHEM_RESISTANT]>0)
	{
	item.AddItem(PID_BLOODPACK,Random(10, 25));
	item.AddItem(PID_HEART,2);
	item.AddItem(PID_LIVER,2);
	item.AddItem(PID_BRAIN,2);
	item.AddItem(PID_EAR,2);
	item.AddItem(PID_EYE,2);
	}
	else
	{
	item.AddItem(PID_SUPER_STIMPAK,Random(10, 25));
	for( int i =1; i <= Random(6,9); i++ )
	{
	switch(Random(1,19))
			{			
			case 1: 	{item.AddItem(PID_RADAWAY,  1); break;}
			case 2: 	{item.AddItem(PID_RAD_X,  1); break;}
			case 3: 	{item.AddItem(PID_SUPER_STIMPAK,  1); break;}
			case 4: 	{item.AddItem(PID_JET_ANTIDOTE,  1); break;}
			case 5: 	{item.AddItem(PID_NUKA_COLA,  1); break;}			
			case 6: 	{item.AddItem(PID_BEER,  1); break;}
			case 7: 	{item.AddItem(PID_BOOZE,  1); break;}
			case 8: 	{item.AddItem(PID_GAMMA_GULP_BEER,  1); break;}
			case 9: 	{item.AddItem(PID_ROENTGEN_RUM,  1); break;}
			case 10: 	{item.AddItem(PID_ROT_GUT, 1); break;}
			case 11: 	{item.AddItem(PID_MENTATS, 1); break;}
			case 12: 	{item.AddItem(PID_BUFFOUT,  1); break;}
			case 13: 	{item.AddItem(PID_PSYCHO, 1); break;}
			case 14: 	{item.AddItem(PID_JET,  1); break;}		
			case 15: 	{item.AddItem(PID_GUM,  1); break;}	
			case 16: 	{item.AddItem(PID_MUTIE,  1); break;}	
			case 17: 	{item.AddItem(PID_VOODOO,  1); break;}	
			case 18: 	{item.AddItem(PID_HEALING_POWDER,  1); break;}	
			case 19: 	{item.AddItem(PID_CIGARETTES,  1); break;}		
			}	
	}
	}
}

void reward(Item& item, bool firstTime)
{
	for( int i =1; i <= Random(2,4); i++ )
	{
	SpawnBuffItem(item, tier3armor());
        SpawnBuffItem(item, tier3helmet());
		SpawnBuffItem(item, tier3weapon());
		item.AddItem(tier3ammo(), Random(20,70), 0);
		item.AddItem(tier3drugs(), Random(1,20) , 0);
		item.AddItem(tier3bp(), Random(5,25) , 0);
	if(Random(0,99)<50)
		{
		switch (Random(1,2))
			{			
			case 1: 	{item.AddItem(tier4ammo(),Random(1,5), 5); break;}
			case 2: 	{item.AddItem(rareitem(), 1, 0);}		
			}
		}
	}
	item.AddItem(currency(), Random(1,10000) , 0);
}

void getImplant(Critter& item)
{
	item.AddItem(implant(),  1);
}
void getOPImplant(Critter& item)
{
	item.AddItem(implant_combat(), 1);
}
void getT4Realpart(Critter& item)
{
	item.AddItem(tier4parts(), 1);
}
void getT4part(Critter& item)
{
		item.AddItem(tier4bp(),1);		
}

void getStat(Critter& player)
{
	switch(Random(1,35))
	{
	case 1: { player.ParamBase[ST_STRENGTH] += 1; player.Say(SAY_NETMSG, "You got 1 Strength "); break; }
	case 2: { player.ParamBase[ST_PERCEPTION] += 1; player.Say(SAY_NETMSG, "You got 1 Perception");break; }
	case 3: { player.ParamBase[ST_ENDURANCE] += 1; player.Say(SAY_NETMSG, "You got 1 Endurance");break; }
	case 4: { player.ParamBase[ST_CHARISMA] += 1; player.Say(SAY_NETMSG, "You got 1 Charisma");break; }
	case 5: { player.ParamBase[ST_INTELLECT] += 1; player.Say(SAY_NETMSG, "You got Intellect");break; }
	case 6: { player.ParamBase[ST_AGILITY] += 1; player.Say(SAY_NETMSG, "You got 1 Agility");break; }
	case 7: { player.ParamBase[ST_LUCK] += 1; player.Say(SAY_NETMSG, "You got luck");break; }
	case 8: { player.ParamBase[ST_MAX_LIFE] += 10; player.Say(SAY_NETMSG, "You got 10 Hit points");break; }
	case 9: { player.ParamBase[ST_ACTION_POINTS] += 1; player.Say(SAY_NETMSG, "You got 1 action point");break; }
	case 10: { player.ParamBase[ST_ARMOR_CLASS] += 5; player.Say(SAY_NETMSG, "You got 5 armor class");break; }
	case 11: { player.ParamBase[ST_MELEE_DAMAGE] += 3; player.Say(SAY_NETMSG, "You got 3 melee damage");break; }
	case 12: { player.ParamBase[ST_CARRY_WEIGHT] += 30000; player.Say(SAY_NETMSG, "You got 30 Carry Weight");break; }
	case 13: { player.ParamBase[ST_SEQUENCE] += 3; player.Say(SAY_NETMSG, "You got 3 sequence");break; }
	case 14: { player.ParamBase[ST_HEALING_RATE] += 5; player.Say(SAY_NETMSG, "You got 5 healing rate");break; }
	case 15: { player.ParamBase[ST_CRITICAL_CHANCE] += 3; player.Say(SAY_NETMSG, "You got 3 critical chance");break; }
	case 16: { player.ParamBase[ST_MAX_CRITICAL] += 1; player.Say(SAY_NETMSG, "You got 1 critical power");break; }
	case 17: { player.ParamBase[ST_NORMAL_ABSORB] += 1; player.Say(SAY_NETMSG, "You got 1 normal DT");break; }
	case 18: { player.ParamBase[ST_LASER_ABSORB] += 1; player.Say(SAY_NETMSG, "You got 1 laser DT");break; }
	case 19: { player.ParamBase[ST_FIRE_ABSORB] += 1; player.Say(SAY_NETMSG, "You got 1 fire DT");break; }
	case 20: { player.ParamBase[ST_PLASMA_ABSORB] += 1; player.Say(SAY_NETMSG, "You got 1 plasma DT");break; }
	case 21: { player.ParamBase[ST_ELECTRO_ABSORB] += 1; player.Say(SAY_NETMSG, "You got 1 electro DT");break; }
	case 22: { player.ParamBase[ST_EMP_ABSORB] += 1; player.Say(SAY_NETMSG, "You got 1 EMP DT");break; }
	case 23: { player.ParamBase[ST_EXPLODE_ABSORB] += 1; player.Say(SAY_NETMSG, "You got 1 Explode DT");break; }
	case 24: { player.ParamBase[ST_NORMAL_RESIST] += 3; player.Say(SAY_NETMSG, "You got 3 Normal DR");break; }
	case 25: { player.ParamBase[ST_LASER_RESIST] += 3; player.Say(SAY_NETMSG, "You got 3 Laser DR");break; }
	case 26: { player.ParamBase[ST_FIRE_RESIST] += 3; player.Say(SAY_NETMSG, "You got 3 fire DR");break; }
	case 27: { player.ParamBase[ST_PLASMA_RESIST] += 3; player.Say(SAY_NETMSG, "You got 3 Plasma DR");break; }
	case 28: { player.ParamBase[ST_ELECTRO_RESIST] += 3; player.Say(SAY_NETMSG, "You got 3 electro DR");break; }
	case 29: { player.ParamBase[ST_EMP_RESIST] += 75; player.Say(SAY_NETMSG, "You got 75 EMP DR");break; }
	case 30: { player.ParamBase[ST_EXPLODE_RESIST] += 3; player.Say(SAY_NETMSG, "You got 3 Explode DR");break; }
	case 31: { player.ParamBase[ST_RADIATION_RESISTANCE] += 25; player.Say(SAY_NETMSG, "You got 25 rad resistance");break; }
	case 32: { player.ParamBase[ST_POISON_RESISTANCE] += 50; player.Say(SAY_NETMSG, "You got 50 poison resistance");break; }
	case 33: { player.ParamBase[ST_EXPERIENCE] += 5000000; player.Say(SAY_NETMSG, "You got extra 5 milions exp");break; }
	case 34: { player.ParamBase[ST_UNSPENT_SKILL_POINTS] += 100; player.Say(SAY_NETMSG, "You got 100 skill points");break; }
	case 35: { player.ParamBase[ST_MAX_MOVE_AP] += 1; player.Say(SAY_NETMSG, "You got 1 AP for turn base");break; }
	}
}

/**
 * Places dynamic spawnpoint.
 */
void ExecSpawnPointCommand(array<string@>@ command, Critter@ player)
{

    Map@ map = player.GetMap();
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "Dynamic spawnpoints can't be created here.");
        return;
    }

    uint16 hx = player.HexX;
    uint16 hy = player.HexY;

    int    minigameTeam  = 0;
    int    minigameId    = 0;

    uint   capturableBy = 0;
    uint   captureFlags = 0;
    uint   captureTime  = 30;
	//string& teamevent = "";
	//uint eventTeam = 0;
	//uint spawnteam = 0;
    bool   visible  = false;

    bool   link = false;     // If true then link the new spawnpoint with spawnpoint
                             // with highest ID on the map. The new spawnpoint will
                             // have the other one set as "previous" and the previous
                             // one will have the new spawnpoint set as "next". This
                             // allows to create simple chains of spawnpoints without
                             // specifying IDs of previous/next spawnpoints.

    uint transportToMap = 0; // If > 0 and the spawnpoint is the last spawnpoint for
    // the team in the chain, then re-check spawnpoints on
    // linked map

    cheatGetOption(command, hx, "-x");
    cheatGetOption(command, hy, "-y");
    cheatGetOption(command, capturableBy, "-c");
    cheatGetOption(command, captureFlags, "-o");
    cheatGetOption(command, captureTime, "-s");
    cheatGetOption(command, visible, "-v");
    cheatGetOption(command, link, "-l");
    cheatGetOption(command, transportToMap, "-m");
	//cheatGetOption(command, eventTeam, "-h");
	//StrToInt(spawnteam, teamevent);
    // Spawnpoint teams, minigame id 15 is used.
    string team = GetParameterString(command, "-t");
    if(team == "spectator" || team == "s")
        minigameId = 15;
    else if(StrToInt(team, minigameTeam))
    {
        minigameId = 15;
        minigameTeam = CLAMP(minigameTeam, 0, 15);
    }
	/*	if(teamevent== "enclave")
	{
		spawnteam = 204;
	}
	if(teamevent== "bos")
	{
		spawnteam = 205;
	}
	if(teamevent== "vc")
	{
		spawnteam = 206;
	}
	if(teamevent== "ncr")
	{
		spawnteam = 207;
	}
	if(teamevent== "green")
	{
		spawnteam = 208;
	}
	if(teamevent== "all")
	{
		spawnteam = 0;
	}*/
    Item@ existing = map.GetItem(hx, hy, PID_RESPAWN_POINT);
    if(!valid(existing))
    {
        player.Say(SAY_NETMSG, "Placing respawn point...");

        // Grab the last spawnpoint on the map to create chains with -l
        Item@ lastDSpawn = null;
        if(link)
        {
            array<Item@> dSpawns;
            uint         dSpawnsNum = map.GetItems(PID_RESPAWN_POINT, dSpawns);
            if(dSpawnsNum > 0)
            {
                uint dSpawnsHighestId = 0;
                for(uint i = 0; i < dSpawnsNum; i++)
                {
                    if(dSpawns[i].Id > dSpawnsHighestId)
                        dSpawnsHighestId = dSpawns[i].Id;
                }
                @lastDSpawn = map.GetItem(dSpawnsHighestId);
            }
        }

        // Spawnpoints settings
        Item@ spawn = map.AddItem(hx, hy, PID_RESPAWN_POINT, 1);
        spawn.Val0 = (minigameId << 4) | minigameTeam;
        spawn.Val1 = (captureTime << 24) | (captureFlags << 16) | capturableBy;
        if(valid(lastDSpawn))
        {
            spawn.Val3 = lastDSpawn.Id;
            lastDSpawn.Val4 = spawn.Id;
        }
        spawn.Val5 = transportToMap;

        // Spawnpoint Colorization
        spawn.AnimStayBegin = minigameTeam;
        spawn.AnimStayEnd   = minigameTeam;
        spawn.AnimShowBegin = minigameTeam;
        spawn.AnimShowEnd   = minigameTeam;
        spawn.AnimHideBegin = minigameTeam;
        spawn.AnimHideEnd   = minigameTeam;

        // Initialize
        if(capturableBy > 0)
        {
            SETFLAG(spawn.Flags, ITEM_CAN_USE);
            // _DSpawn(spawn, true); // moved to proto
        }

        // Visibility
        if(visible)
        {
            UNSETFLAG(spawn.Flags, ITEM_HIDDEN);
            spawn.Update();
        }
    }
    else
    {
        player.Say(SAY_NETMSG, "Removing spawn point...");
        DeleteItem(existing);
    }
}

void ExecKillerAdminCommand(array<string@>@ command, Critter@ player)
{
    if(player.Param[MODE_KILLER_ADMIN] > 0)
    {
        player.Say(SAY_NETMSG, "Normal admin");
        player.ParamBase[MODE_KILLER_ADMIN] = 0;

    }
    else
    {
        player.Say(SAY_NETMSG, "Killer admin");
        player.ParamBase[MODE_KILLER_ADMIN] = 1;
    }
}

void ExecHideMapCommand(array<string@>@ command, Critter@ player)
{
    Location@ loc = player.GetMap().GetLocation();
    loc.GeckVisible = false;
    loc.Visible = false;
    // loc.Save(true);

    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);

    // Hide for all players
    for(uint i = 0; i < num; i++)
    {
        if(!valid(players[i]))
            continue;
        if(!players[i].IsPlayer())
            continue;

        players[i].SetKnownLoc(false, loc.Id);
    }
}

void ExecClearAllIllegalFlagsCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);
    for(uint i = 0; i < num; i++)
    {
        ClearIllegalFlags(players[i]);
    }
}

void ExecListAuthenticatedCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);
    for(uint i = 0; i < num; i++)
    {
        if(!GodOfTheRealm(player.Id) && GodOfTheRealm(players[i].Id) && _CritHasExtMode(players[i], MODE_EXT_GOD))
            continue;

        if(players[i].GetAccess() == ACCESS_CLIENT)
            continue;

        if(player.GetAccess() < players[i].GetAccess())
            continue;

        player.Say(SAY_NETMSG, GetSafePlayerName(players[i].Id) + " (" + players[i].Id + ")" + "(" + players[i].GetMapId() + ") - " + GetAuthString(players[i]));
    }
}

void ExecResetAllDisguisesCommand(array<string@>@ command, Critter@ player)
{
    player.Say(SAY_NETMSG, "Resetting basetypes for all players online...");
    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);
    for(uint i = 0; i < num; i++)
    {
        bool  isMale = (players[i].ParamBase[ST_GENDER] == GENDER_MALE);
        uint  baseType = (isMale ? CRTYPE_MALE_DEFAULT : CRTYPE_FEMALE_DEFAULT);
        uint  crType = baseType;
        Item@ armor = players[i].GetItem(0, SLOT_ARMOR);

        if(valid(armor))
        {
            switch(GetCritterAnimType(crType))
            {
            case ANIM_TYPE_FALLOUT:
                crType = (isMale ? armor.Proto.Armor_CrTypeMale : armor.Proto.Armor_CrTypeFemale);
                break;
                /*
                   case ANIM_TYPE_3D:
                        crType = ???;
                        break;
                 */
            }
        }

        players[i].ChangeCrType(crType);
        players[i].ParamBase[ST_BASE_CRTYPE] = baseType;
        players[i].DisguisedBy = 0;
    }
    player.Say(SAY_NETMSG, "Done.");
}

//
// TODO: abused, addictions should be kept or command disabled
//
void ExecDropDrugsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Removing drug effects from: " + target.Name);
    DropDrugEffects(target, true);
}

void ExecZonePlayersCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@>@ players = WorldmapGetPlayers(ZONE_X(player.WorldX), ZONE_Y(player.WorldY));
    player.Say(SAY_NETMSG, "" + players.length() + " players in zone:");
    for(uint i = 0, j = players.length(); i < j; i++)
        player.Say(SAY_NETMSG, players[i].Name);
}

void ExecListCommandsCommand(array<string@>@ command, Critter@ player)
{
    if(IsAdmin(player))
    {
        for(uint i = 0, j = commandlist.length(); i < j; i++)
            player.Say(SAY_NETMSG, commandlist[i]);
    }
    else if(IsGM(player))
    {
        for(uint i = 0, j = gmcommandlist.length(); i < j; i++)
            player.Say(SAY_NETMSG, gmcommandlist[i]);
    }
    else
    {
        for(uint i = 0, j = testercommandlist.length(); i < j; i++)
            player.Say(SAY_NETMSG, testercommandlist[i]);
    }
}

uint GMTrack(uint targetId, string@ message)   // Export
{
    if(targetId == 0 || GodOfTheRealm(targetId) ||
       !valid(message) || message.length() == 0)
        return(0);

    IConfigVar@ var = GetConfigVar(CHEATS_CFG, CFG_TRACKING, "" + targetId);

    if(!valid(var))
        return(0);

    array<string@>@ hunters = split(var.GetValue(), ",");
    if(hunters.length() == 0)
        return(0);

    Critter@ target = GetCritter(targetId);
    if(!valid(target))
        return(0);

    uint color = uint(4291317840);
    stringReplaceText(message, "TARGET", target.Name + "(" + target.Id + ")");

    uint huntersFound = 0;
    for(uint h = 0, hcount = hunters.length(); h < hcount; h++)
    {
        uint hunterId = 0;
        if(!StrToInt(hunters[h], hunterId))
            continue;

        if(hunterId == 0)
            continue;

        Critter@ hunter = GetCritter(hunterId);
        if(!valid(hunter))
            continue;

        if(GodOfTheRealm(target.Id) || target.GetAccess() > target.GetAccess())
        {
            target.Say(SAY_NETMSG, "|" + color + " > " + hunter.Name + " was trying to track you when you was offline.");
            IConfigVar@ var = GetConfigVar(CHEATS_CFG, CFG_TRACKING, "" + target.Id);
            if(!valid(var))
            {
                target.Say(SAY_NETMSG, "|" + color + " > Error #1 during removing you from list.");
            }
            else
            {
                array<string> innocent = var.GetValueAsArray(",");
                remove_all_from_array(innocent, "" + target.Id);
                if(Present("" + target.Id, innocent))
                {
                    target.Say(SAY_NETMSG, "|" + color + "> Error #2 during removing you from list.");
                }
                else
                {
                    remove_duplicates_from_array(innocent, array<string>);
                    innocent.sortAsc();
                    var.SetValue(innocent);
                    SaveConfig(CHEATS_CFG);
                    target.Say(SAY_NETMSG, "|" + color + "> Successfully removed you from list.");
                }
            }
            continue;
        }

        hunter.Say(SAY_NETMSG, "|" + color + " > " + message);
        huntersFound++;
    }

    return(huntersFound);
}

Critter@ GetCritterArgument(array<string@>& command)
{
    Critter@ target = null;

    uint     id = 0;
    string   targetName = GetParameterString(command, "-p");
    string   npcId = GetParameterString(command, "-n");
    StrToInt(targetName, id);

    if(targetName != "")
    {
        if(id == 0)
            @target = GetPlayer(targetName);
        else
            @target = GetCritter(id);

    }
    if(npcId != "")
    {
        StrToInt(npcId, id);
        if(id != 0)
            @target = GetCritter(NPC_BASE_ID + id);
    }

    return(target);
}

void ExecTrackPlayerCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    string offline = GetParameterString(command, "-offline");

    if(offline.length() == 0)
    {
        if(player.Id == target.Id)
        {
            player.Say(SAY_NETMSG, "Invalid target. Use trackplayer -offline [target name] to track not logged player.");
            return;
        }
    }
    else
    {
        uint id = GetPlayerId(offline);
        if(id == 0)
        {
            player.Say(SAY_NETMSG, "No such player exists in this world.");
            return;
        }

        return;
    }

    if(GodOfTheRealm(target.Id) || player.GetAccess() < target.GetAccess())
    {
        player.Say(SAY_NETMSG, "You are not authorized to track this person.");
        target.Say(SAY_NETMSG, player.Name + " was trying to track you.");
        return;
    }

    IConfigVar@   var = GetConfigVar(CHEATS_CFG, CFG_TRACKING, "" + target.Id);
    array<string> hunters = var.GetValueAsArray(",");

    if(Present("" + player.Id, hunters))
    {
        player.Say(SAY_NETMSG, "You are already tracking that person.");
        return;
    }

    hunters.insertLast("" + player.Id);
    remove_duplicates_from_array(hunters, array<string>);
    hunters.sortAsc();
    var.SetValue(hunters);
    SaveConfig(CHEATS_CFG);

    player.Say(SAY_NETMSG, "You are now tracking " + target.Name);
}

void ExecStopTrackPlayerCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(player.Id == target.Id)
    {
        player.Say(SAY_NETMSG, "Target not found.");
        return;
    }

    player.Say(SAY_NETMSG, "You've now stopped tracking " + target.Name);
    SetLvar(target, LVAR_command_tracking, 0);
}

void ExecListTrackedPlayersCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);

    for(uint i = 0; i < num; i++)
    {
        if(players[i].GetAccess() == ACCESS_ADMIN)
            continue;

        uint id = GetLvar(players[i], LVAR_command_tracking);
        if(id != 0)
        {
            Critter@ tracker = GetCritter(id);
            if(valid(tracker) && player.GetAccess() < tracker.GetAccess())
                continue;

            player.Say(SAY_NETMSG, GetSafePlayerName(players[i].Id) + " is tracked by " + GetSafePlayerName(id));
        }
    }
}

void ExecRotateCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    int dir = Random(0, 5);
    StrToInt(GetParameterString(command, "-dir"), dir);

    if(target.IsNpc())
        target.SetHomePos(target.HexX, target.HexY, dir);
    target.SetDir(dir);
}

void ExecStartEventCommand(array<string@>@ command, Critter@ player)
{
    SetGvar(GVAR_event_status, 1);
    player.Say(SAY_NETMSG, "Event started, all critters and items added from this point can be deleted by stopping event.");
}

void ExecStopEventCommand(array<string@>@ command, Critter@ player)
{
    SetGvar(GVAR_event_status, 0);
    uint numdelete = 0;
    for(uint i = 0; i < eventCritters.length(); i++)
    {
        Critter@ cr = GetCritter(eventCritters[i]);
        if(valid(cr))
        {
            DeleteNpc(cr);
            numdelete++;
        }
    }
    eventCritters.resize(0);

    player.Say(SAY_NETMSG, "Deleted " + numdelete + " critter that were part of the event.");

    numdelete = 0;
    for(uint y = 0; y < eventItems.length(); y++)
    {
        Item@ item = ::GetItem(eventItems[y]);
        if(valid(item))
        {
            DeleteItem(item);
            numdelete++;
        }
    }
    eventItems.resize(0);

    player.Say(SAY_NETMSG, "Deleted " + numdelete + " items that were part of the event.");
    player.Say(SAY_NETMSG, "Event cleanup completed.");
}

void PrintTentList(Critter& player, Critter& target, bool short)
{
    int tentid = GetLvar(target, LVAR_tent_id);
    if(tentid == 0)
        player.Say(SAY_NETMSG, target.Name + " has no tent.");
    else
    {
        Location@ loc = GetLocation(tentid);
        if(valid(loc))
        {
            Map@ map = loc.GetMapByIndex(0);
            if(valid(map))
            {
                if(short)
                    player.Say(SAY_NETMSG, target.Name + " - (" + map.Id + ")(" + map.GetProtoId() + ")");
                else
                {
                    player.Say(SAY_NETMSG, "Tent info for " + target.Name + ": ");
                    player.Say(SAY_NETMSG, "Map ID: " + map.Id);
                    player.Say(SAY_NETMSG, "Map PID: " + map.GetProtoId());
                }
            }
        }
        else
        {
            player.Say(SAY_NETMSG, target.Name + " has no tent.");
        }
    }
}

void ExecTentInfoCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    PrintTentList(player, target, false);
}

void ExecTentListCommand(array<string@>@ command, Critter@ player)
{
    array<Critter@> players;
    uint            num = GetAllOnlinePlayers(players);
    player.Say(SAY_NETMSG, "<Name> - (<MapID>)(<MapPID>)");
    for(uint i = 0; i < num; i++)
        PrintTentList(player, players[i], true);
}

void ExecListMapsCommand(array<string@>@ command, Critter@ player)
{
    uint pid = 0;
    StrToInt(GetParameterString(command, "-pid"), pid);

    if(pid > 0)
    {
        array<Map@> maps;
        uint        num = GetAllMaps(0, maps);
        if(num == 0)
        {
            player.Say(SAY_NETMSG, "No maps found for PID " + pid);
            return;
        }
        if(valid(maps))
        {
            for(uint x = 0; x < num; x++)
            {
                if(valid(maps[x]))
                {
                    if(maps[x].GetProtoId() == pid)
                    {
                        player.Say(SAY_NETMSG, "PID " + pid + ": " + maps[x].Id);
                    }
                }
            }
        }
    }
}

void ExecShowHandsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    uint8 dummy = 0;
    for(int s = SLOT_HAND1; s < SLOT_GROUND; s++)
    {
        Item@ item = target.GetItem(0, s);
        if(valid(item))
        {
            string slot = "Slot";
            switch(s)
            {
            case SLOT_HAND1:
                slot = "Active hand";
                break;
            case SLOT_HAND2:
                slot = "Second hand";
                break;
            case SLOT_ARMOR:
                slot = "Armor";
                break;
            case SLOT_HEAD:
                slot = "Helmet";
                break;
            case SLOT_TROPHY:
                slot = "Trophy";
                break;
            }
            string name = "";             // TODO
            player.Say(SAY_NETMSG, slot + "(" + s + "): " + name + " (" + item.GetProtoId() + "," + item.Id + ")");
        }
    }
}

void ExecNameToIdCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(target.Id > 0)
        player.Say(SAY_NETMSG, "Player(" + GetSafePlayerName(target.Id) + "): " + target.Id);
    else
        player.Say(SAY_NETMSG, "Player doesn't exist.");
}

void ExecIdToNameCommand(array<string@>@ command, Critter@ player)
{
    uint id = 0;
    if(command.length() < 3)
        return;
    StrToInt(command[2], id);
    string name = GetSafePlayerName(id);
    if(name == "[player not found]")
        player.Say(SAY_NETMSG, "Player don't exists.");
    else
        player.Say(SAY_NETMSG, "Player(" + id + "): " + name);
}

void ExecListFollowersCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    uint count = 0;
    bool first = true;
    for(uint i = FOLLOWER_BEGIN; i <= FOLLOWER_END; i++)
    {
        if(target.Followers[i] != 0)
        {
            Critter@ cr = GetCritter(target.Followers[i]);
            if(!valid(cr))
            {
                target.FollowersBase[i] = 0;
                continue;
            }

            if(first)
            {
                player.Say(SAY_NETMSG, "Listing " + GetSafePlayerName(target.Id) + "'s followers:");
                first = false;
            }
            player.Say(SAY_NETMSG, "Follower #" + (i - FOLLOWER_BEGIN + 1) + ": " + (target.Followers[i]));   // removed that -5000000 it's not intuitive
            count++;
        }
    }
    if(first)
        player.Say(SAY_NETMSG, GetSafePlayerName(target.Id) + " has no followers.");
}

#define BLOCKER_VIS      (PID_PLAYERS_EAR)
#define BLOCKER_INVIS    (PID_UNVISIBLE_BLOCK)

// SAY COLORS
//
#define SCOLOR_ERROR     "|0xCC0000 "    // Error message
#define SCOLOR_ERRORB    "|0xFF4400 "    // Strong error emphasis ("bold")

#define SCOLOR_HELP      "|0xBBBBBB "    // Help message
#define SCOLOR_HELPH     "|0xFFFFFF "    // Healp header
#define SCOLOR_HELPB     "|0x00FFFF "    // Strong help emphasis ("bold")
#define SCOLOR_HELPI     "|0x00BBBB "    // Weak help emphasis ("italic")


////////////////////////////////////////////////////////////////////////////////
//
//  B L O C K E R S
//
////////////////////////////////////////////////////////////////////////////////

//  Sets / changes prototype of a blocker: visible oe invisible
//  Called after a blocker is created or when visibility changes
//  Returns false if can't change prototype
//
bool BlockerSetProto(Item@ blocker, bool visible)
{
    bool success = false;

    if(visible)
    {
        if(blocker.ChangeProto(BLOCKER_VIS))
        {
            SETFLAG(blocker.Flags, ITEM_BAD_ITEM);
            success = true;
        }
    }
    else
    {
        if(blocker.ChangeProto(BLOCKER_INVIS))
        {
            UNSETFLAG(blocker.Flags, ITEM_BAD_ITEM);
            success = true;
        }
    }
    UNSETFLAG(blocker.Flags, ITEM_NO_BLOCK);
    UNSETFLAG(blocker.Flags, ITEM_CAN_USE);
    UNSETFLAG(blocker.Flags, ITEM_CAN_PICKUP);
    blocker.Val8 = SPECIAL_ITEM_BLOCKER;
    blocker.Update();
    return success;
}

//  Creates a single blocker
//  This function should be used by all methods of creating blockers
//  Returns false if fails to create a blocker.
//
bool BlockerCreate(Critter@ creator, Map@ map, uint16 x, uint16 y, int group, bool safe, bool visible)
{
    Item@ blocker = map.AddItem(x, y, BLOCKER_INVIS, 1);

    if(valid(blocker))
    {
        blocker.Val4 = group;
        creator.Say(SAY_NETMSG, "      Blocker created at hex " + x + "," + y);
        if(BlockerSetProto(blocker, visible) == false)
        {
            creator.Say(SAY_NETMSG, SCOLOR_ERROR + "WARNING: Can't change proto of blocker at hex: " + x + "," + y);
        }
        if(safe)
        {
            UNSETFLAG(blocker.Flags, ITEM_SHOOT_THRU);
        }
        return true;
    }
    else
    {
        creator.Say(SAY_NETMSG, SCOLOR_ERROR + "WARNING: Can't spawn blocker at hex: " + x + "," + y);
        return false;
    }
}

//  Deletes a group of blockers or all blockers with specific pid
//
void BlockerDelete(Critter@ deleter, uint16 pid, uint group, bool deleteAll)
{

    Map@         blockerMap = deleter.GetMap();

    array<Item@> blockers;
    uint         blockersNum = blockerMap.GetItems(pid, blockers);

    for(uint i = 0; i < blockersNum; i++)
    {
        if(uint(blockers[i].Val8) == SPECIAL_ITEM_BLOCKER && (deleteAll || uint(blockers[i].Val4) == group))
        {
            deleter.Say(SAY_NETMSG, "Removing blocker [" + blockers[i].Val4 + "]: " + blockers[i].HexX + "," + blockers[i].HexY);
            blockerMap.RunEffect(PID_EXPLODE_EMP, blockers[i].HexX, blockers[i].HexY, 0);
            DeleteItem(blockers[i]);
        }
    }

}

//    Execute Blockers Command
//
void ExecBlockersCommand(array<string@>@ command, Critter@ player, Critter@ target)
{

    //    Default arguments
    //
    string argSubcommand = "help";

    //    Read the arguments
    //
    if(command.length() > 2)
    {
        argSubcommand = command[2];
    }

    //    Special warning, detects old "all" format
    //    Can be removed in the future.
    //
    if(command.length() > 3)
    {
        if(command[3] == "all")
        {
            player.Say(SAY_NETMSG, SCOLOR_ERROR + "WARNING: Deprecated argument.");
            player.Say(SAY_NETMSG, SCOLOR_ERROR + "Use " + SCOLOR_ERRORB + "-all " + SCOLOR_ERROR + "option instead to select all blockers.");
            return;
        }
    }

    //    Default options
    //
    Map@   optMap      = player.GetMap();
    uint16 optX      = target.HexX;
    uint16 optY      = target.HexY;
    uint   optGroup    = 0;
    uint   optRadius   = 1;
    bool   optSafe     = false;
    bool   optVisible  = false;
    bool   optAll      = false;

    /////////////////////////////////////////////////////////////////////////////////////////
    //
    //    COMMAND BLOCKERS HELP
    //    In-game help.    Termporary, to be replaced by proper help system.
    //
    if(argSubcommand == "help" || argSubcommand == "-help")
    {
        player.Say(SAY_NETMSG, "------------------------------------------\n" + SCOLOR_HELPH + "   command blockers");
        string shelp =      "------------------------------------------\n"
                       SCOLOR_HELP +   "Allows blocking hexes to prevent players from accessing places, critters or items on a map.\n"
                       SCOLOR_HELPH +  "Syntax:\n"
                       SCOLOR_HELPB +  "`blockers [subcommand] (options)\n"
                       SCOLOR_HELPH +  "Arguments:\n"
                       SCOLOR_HELPB +  "[subcommand]"
                       SCOLOR_HELP +   " : Specifies blocker action to perform. Possible values:\n"
                       SCOLOR_HELPI +  "    add"
                       SCOLOR_HELP +   " : Create a single blocker on a hex\n"
                       SCOLOR_HELPI +  "    around"
                       SCOLOR_HELP +   " : Create blockers around a hex\n"
                       SCOLOR_HELPI +  "    to"
                       SCOLOR_HELP +   " : Create line of blockers to a hex\n"
                       SCOLOR_HELPI +  "    delete"
                       SCOLOR_HELP +   " : Delete blockers\n"
                       SCOLOR_HELPI +  "    show"
                       SCOLOR_HELP +   " : Make blockers visible\n"
                       SCOLOR_HELPI +  "    hide"
                       SCOLOR_HELP +   " : Make blockers invisible\n"
                       SCOLOR_HELPI +  "    list"
                       SCOLOR_HELP +   " : Display list of blockers\n"
                       SCOLOR_HELPH +  "Options:\n"
                       SCOLOR_HELPB +  "-g [group]"
                       SCOLOR_HELP +   " : Specify group of created blockers (add, around) or perform a command on all blockers in the group (delete, show, hide, list)\n"
                       SCOLOR_HELPB +  "-all"
                       SCOLOR_HELP +   " : Perform a command on all blockers in the map (delete, show, hide, list)\n"
                       SCOLOR_HELPB +  "-x [hexx] -y [hexy]"
                       SCOLOR_HELP +   " : Coordinates of created blocker (add) or center of blocker hexagon (around) or end of blocker line (to)\n"
                       SCOLOR_HELPB +  "-r [radius]"
                       SCOLOR_HELP +   " : Radius of blocker hexagon (around)\n"
                       SCOLOR_HELPB +  "-p [id]"
                       SCOLOR_HELP +   " : Id of player to block or use the player coords as line end (around, to)\n"
                       SCOLOR_HELPB +  "-n [id]"
                       SCOLOR_HELP +   " : Id of NPC to block or use the NPC coords as line end (around, to)\n"
                       SCOLOR_HELPB +  "-s"
                       SCOLOR_HELP +   " : Created blockers will block aim (add, around)\n"
                       SCOLOR_HELPB +  "-v"
                       SCOLOR_HELP +   " : Created blockers will be visible (add, around, to)";
        player.Say(SAY_NETMSG, shelp);
        return;
    }

    //  If player is on global map, return
    //
    if(!valid(optMap))
    {
        player.Say(SAY_NETMSG, SCOLOR_ERROR + "WARNING: Can't block whole California, sorry.");
        return;
    }

    //  COMMAND BLOCKERS ADD
    //  Place a single blocker on target hex.
    //
    else if(argSubcommand == "add")
    {
        cheatGetOption(command, optX, "-x");
        cheatGetOption(command, optY, "-y");
        player.Say(SAY_NETMSG, "Placing a blocker at hex " + optX + "," + optY);
        player.Say(SAY_NETMSG, "   Group: " + cheatGetOption(command, optGroup, "-g"));
        player.Say(SAY_NETMSG, "   Safe: " + cheatGetOption(command, optSafe, "-s"));
        player.Say(SAY_NETMSG, "   Visible: " + cheatGetOption(command, optVisible, "-v"));

        BlockerCreate(player, optMap, optX, optY, optGroup, optSafe, optVisible);
    }

    //  COMMAND BLOCKERS AROUND
    //  Place a hexagon of blockers around the target hex.
    //
    else if(argSubcommand == "around")
    {
        cheatGetOption(command, optX, "-x");
        cheatGetOption(command, optY, "-y");
        player.Say(SAY_NETMSG, "Placing blockers around hex " + optX + "," + optY);
        player.Say(SAY_NETMSG, "   Group: " + cheatGetOption(command, optGroup, "-g"));
        player.Say(SAY_NETMSG, "   Radius: " + cheatGetOption(command, optRadius, "-r"));
        player.Say(SAY_NETMSG, "   Safe: " + cheatGetOption(command, optSafe, "-s"));
        player.Say(SAY_NETMSG, "   Visible: " + cheatGetOption(command, optVisible, "-v"));

        //  Prevent GM abuse: if radius == 0 hexagon can't be created
        //
        if(optRadius == 0)
        {
            player.Say(SAY_NETMSG, SCOLOR_ERROR + "ERROR: Can't create hexagon with radius 0");
            return;
        }

        uint16 stepX = optX;
        uint16 stepY = optY;

        //  Spawn hexagon of blockers
        //
        optMap.MoveHexByDir(stepX, stepY, 4, optRadius);
        for(uint8 stepDir = 0; stepDir < 6; stepDir++)
        {
            for(uint step = 0; step < optRadius; step++)
            {
                optMap.MoveHexByDir(stepX, stepY, stepDir, 1);
                BlockerCreate(player, optMap, stepX, stepY, optGroup, optSafe, optVisible);
            }
        }
    }

    //  COMMAND BLOCKERS TO
    //  Place a line of blockers from abuser to a x/y or other player/npc.
    //  The line will stop on walls.
    //
    else if(argSubcommand == "to")
    {
        cheatGetOption(command, optX, "-x");
        cheatGetOption(command, optY, "-y");
        player.Say(SAY_NETMSG, "Placing line of blockers to hex " + optX + "," + optY);
        player.Say(SAY_NETMSG, "   Group: " + cheatGetOption(command, optGroup, "-g"));
        player.Say(SAY_NETMSG, "   Visible: " + cheatGetOption(command, optVisible, "-v"));

        uint distance = GetDistantion(player.HexX, player.HexY, optX, optY);

        if(distance < 1)
        {
            player.Say(SAY_NETMSG, SCOLOR_ERROR + "ERROR: Can't create line with length 0");
            return;
        }

        //  Preserve the values because GetHexCoord will change them by reference.
        //
        uint16 saveX = optX;
        uint16 saveY = optY;

        //  Coords of previous hex, to check if it's the same (which means line hit an obstacle).
        //
        uint16 lastX = 0;
        uint16 lastY = 0;

        for(uint8 step = 1; step <= distance; step++)
        {
            optMap.GetHexCoord(player.HexX, player.HexY, optX, optY, 0.0f, step);
            if(lastX == optX && lastY == optY)
            {
                break;
            }
            BlockerCreate(player, optMap, optX, optY, optGroup, optSafe, optVisible);
            lastX = optX;
            lastY = optY;
            optX = saveX;
            optY = saveY;
        }
    }

    //  COMMAND BLOCKERS DELETE
    //  Removes blockers from current map
    //
    else if(argSubcommand == "delete" || argSubcommand == "remove")
    {
        cheatGetOption(command, optGroup, "-g");
        cheatGetOption(command, optAll, "-all");

        BlockerDelete(player, BLOCKER_VIS, optGroup, optAll);
        BlockerDelete(player, BLOCKER_INVIS, optGroup, optAll);
    }

    //  COMMAND BLOCKERS SHOW / COMMAND BLOCKERS HIDE
    //  Changing blocker proto
    //
    else if(argSubcommand == "show" || argSubcommand == "hide")
    {
        cheatGetOption(command, optGroup, "-g");
        cheatGetOption(command, optAll, "-all");

        uint16 proto = BLOCKER_INVIS;
        bool   show = true;
        if(argSubcommand == "hide")
        {
            proto = BLOCKER_VIS;
            show = false;
        }

        array<Item@> blockers;
        uint         blockersNum = optMap.GetItems(proto, blockers);

        for(uint i = 0; i < blockersNum; i++)
        {
            if(uint(blockers[i].Val8) == SPECIAL_ITEM_BLOCKER && (optAll || uint(blockers[i].Val4) == optGroup))
            {
                BlockerSetProto(blockers[i], show);
            }
        }
    }

    //  COMMAND BLOCKERS LIST
    //  Listing blockers
    //
    else if(argSubcommand == "list")
    {
        cheatGetOption(command, optGroup, "-g");
        cheatGetOption(command, optAll, "-all");

        array<Item@> blockers;
        uint         blockersNum = optMap.GetItems(0, blockers);
        uint         count = 0;

        for(uint i = 0; i < blockersNum; i++)
        {
            if(uint(blockers[i].Val8) == SPECIAL_ITEM_BLOCKER && (optAll || uint(blockers[i].Val4) == optGroup))
            {
                count += 1;
                player.Say(SAY_NETMSG, count + ". Blocker [" + blockers[i].Val4 + "]: " + blockers[i].HexX + "," + blockers[i].HexY);
            }
        }
    }

    //  UNKNOWN COMMAND
    //
    else
    {
        player.Say(SAY_NETMSG, SCOLOR_ERROR + "ERROR: Unknown argument: " + SCOLOR_ERRORB + argSubcommand);
        player.Say(SAY_NETMSG, SCOLOR_ERROR + "Type " + SCOLOR_ERRORB + "`blockers -help " + SCOLOR_ERROR + "to display command help.");
        return;
    }
}


void ExecLogCommand(array<string@>@ command, Critter@ player)
{
    string s = GetParameterString(command, "-m");
    if(s == "")
        player.Say(SAY_NETMSG, "No text specified. Did you forget to use -m?");
    FLog(LOG_COMMANDS, s);
    GMLog(player, " log call: " + s);
    /*file f;
       f.open("logs/gms/"+player.Name+".log", "a");
       f.writeString(GetCurrentDateTimeString()+" log call: "+s);
       f.close();*/
}

void ExecClearInventoryCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    array<Item@> items;
    int          count = target.GetItems(SLOT_INV, items);
    if(count > 0)
    {
        player.Say(SAY_NETMSG, "Removing " + count + " items from " + target.Name);
        _CritAnimateUse(player);
        DeleteItems(items);
    }
    else
        player.Say(SAY_NETMSG, target.Name + " has no items!");
}

void ExecDropItemsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    array<Item@> items;
    int          count = target.GetItems(SLOT_INV, items);
    if(count > 0)
    {
        player.Say(SAY_NETMSG, "Dropping " + count + " items from " + target.Name);
        _CritAnimatePickup(player);
        MoveItems(items, player.GetMap(), player.HexX, player.HexY);
    }
    else
        player.Say(SAY_NETMSG, "Nothing to drop.");
}

void ExecPickItemsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    Map@         map = target.GetMap();
    array<Item@> items;
    if(valid(map))
    {
        int count = map.GetItems(target.HexX, target.HexY, items);
        if(count > 0)
        {
            player.Say(SAY_NETMSG, "Picking " + count + " items for " + target.Name);
            if(target.Id == player.Id)
                _CritAnimatePickup(player);
            else
                _CritAnimateUse(player);
            MoveItems(items, player);
        }
        else
            player.Say(SAY_NETMSG, "Nothing to pick up for " + target.Name + ".");
    }
    else
    {
        player.Say(SAY_NETMSG, "Target on worldmap.");
    }
}

// helper
// order: player -> [if not on worldmap -> [current map -> current location]] -> world
Item@ FindItem(Critter@ player, uint itemId)
{
    // check Mr.Hilary first
    Item@ item = player.GetItemById(itemId);
    if(valid(item))
    {
        #ifdef __DEBUG__
        player.Say(SAY_NETMSG, "Item found: inventory");
        #endif
        return(item);
    }

    // search on map...
    Map@ map = player.GetMap();
    if(valid(map))
    {
        uint homeMap = map.Id;
        @item = map.GetItem(itemId);
        if(valid(item))
        {
            #ifdef __DEBUG__
            player.Say(SAY_NETMSG, "Item found: current map");
            #endif
            return(item);
        }
        // ...location...
        Location@ location = map.GetLocation();
        if(valid(location))
        {
            for(uint m = 0; m < location.GetMapCount(); m++)
            {
                Map@ checkmap = location.GetMapByIndex(m);
                // don't waste time on already checked map
                if(checkmap.Id == homeMap)
                    continue;
                @item = checkmap.GetItem(itemId);
                if(valid(item))
                {
                    #ifdef __DEBUG__
                    player.Say(SAY_NETMSG, "Item found: current location, map " + m);
                    #endif
                    return(item);
                }
            }
        }
    }

    // ...and finally, whole world
    uint16       dummy = 0;
    array<Item@> items;
    uint         count = GetAllItems(dummy, items);
    for(uint i = 0; i < count; i++)
    {
        if(items[i].Id == itemId)
        {
            #ifdef __DEBUG__
            player.Say(SAY_NETMSG, "Item found: somewhere...");
            #endif
            return(items[i]);
        }
    }
    return(null);
}

uint[] item_flags =
{
    ITEM_HIDDEN,
    ITEM_FLAT,
    ITEM_NO_BLOCK,
    ITEM_SHOOT_THRU,
    ITEM_LIGHT_THRU,
    ITEM_MULTI_HEX,
    ITEM_WALL_TRANS_END,
    ITEM_TWO_HANDS,
    ITEM_BIG_GUN,
    ITEM_ALWAYS_VIEW,
    ITEM_HAS_TIMER,
    ITEM_BAD_ITEM,
    ITEM_NO_HIGHLIGHT,
    ITEM_SHOW_ANIM,
    ITEM_SHOW_ANIM_EXT,
    ITEM_LIGHT,
    ITEM_GECK,
    ITEM_TRAP,
    ITEM_NO_LIGHT_INFLUENCE,
    ITEM_NO_LOOT,
    ITEM_NO_STEAL,
    ITEM_GAG,
    ITEM_COLORIZE,
    ITEM_COLORIZE_INV,
    ITEM_CAN_USE_ON_SMTH,
    ITEM_CAN_LOOK,
    ITEM_CAN_TALK,
    ITEM_CAN_PICKUP,
    ITEM_CAN_USE,
    ITEM_HOLODISK,
    ITEM_RADIO,
    ITEM_CACHED
};

string[] item_flagnames =
{
    "hidden",
    "flat",
    "no_block",
    "shoot_thru",
    "light_thru",
    "multi_hex",
    "wall_trans_end",
    "two_hands",
    "big_gun",
    "always_view",
    "has_timer",
    "bad_item",
    "no_highlight",
    "show_anim",
    "show_anim_ext",
    "light",
    "geck",
    "trap",
    "no_light_influence",
    "no_loot",
    "no_steal",
    "gag",
    "colorize",
    "colorize_inv",
    "can_use_on_smth",
    "can_look",
    "can_talk",
    "can_pickup",
    "can_use",
    "holodisk",
    "radio",
    "cached"
};

// let it be here for now...
string GetParameterString(array<string@>@ search, array<string>& this)
{
    if(this.length() == 0)
        return("");

    for(uint i = 0; i < search.length(); i++)
    {
        if(search.length() < (i + 1))
            break;
        for(uint t = 0; t < this.length(); t++)
        {
            if(search[i] == this[t] && search.length() > (i + 1))
            {
                return(search[i + 1]);
            }
        }

    }
    return("");
}

// ...this...
int GetIndexOfString(array<string>& search, string& this)
{
    for(uint i = 0; i < search.length(); i++)
    {
        if(search[i] == this)
            return(i);
    }
    ;
    return(-1);
}

// ...and this
int GetIndexOfString(array<string@>@ search, array<string>& this)
{
    for(uint i = 0; i < search.length(); i++)
    {
        for(uint t = 0; t < this.length(); t++)
        {
            if(search[i] == this[t])
            {
                return(i);
            }
        }
    }
    ;
    return(-1);
}
void ExecItemFlagsCommand(array<string@>@ command, Critter@ player)
{
    if(item_flags.length() != item_flagnames.length())
    {
        player.Say(SAY_NETMSG, "Internal error: item_flags.length() != item_flagnames.length() -> " + item_flags.length() + " != " + item_flagnames.length());
        player.Say(SAY_NETMSG, "Blame random dev.");
        return;
    }

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Missing arguments.");
        return;
    }

    int   itemId = 0;
    Item@ item;
    if(command[2] == "get" || command[2] == "set" || command[2] == "unset")
    {
        if(command.length() < 4)
        {
            player.Say(SAY_NETMSG, "Missing arguments for '" + command[2] + "'");
            return;
        }
        if(StrToInt(command[3], itemId))
        {
            @item = FindItem(player, itemId);
            if(!valid(item))
            {
                player.Say(SAY_NETMSG, "Can't find item, id " + itemId);
                return;
            }
        }
        else
        {
            player.Say(SAY_NETMSG, "Wrong item id.");
            return;
        }
    }

    if(command[2] == "get")
    {
        player.Say(SAY_NETMSG, "Item " + itemId + " flags (" + item.Flags + "):");
        for(uint f = 0; f < item_flags.length(); f++)
        {
            if(FLAG(item.Flags, item_flags[f]))
            {
                player.Say(SAY_NETMSG, "  " + (item_flagnames.length() >= (f + 1) ? item_flagnames[f] : "???") + " (" + item_flags[f] + ")");
            }
        }
    }
    else if(command[2] == "set" || command[2] == "unset")
    {
        if(command.length() != 5)
        {
            player.Say(SAY_NETMSG, "Wrong number of arguments");
            return;
        }

        int index = GetIndexOfString(item_flagnames, command[4]);
        if(index == -1)
        {
            player.Say(SAY_NETMSG, "Unknown flag: " + command[4]);
            return;
        }

        player.Say(SAY_NETMSG, (command[2] == "set" ? "S" : "Uns") + "etting flag " + command[4] + " for item " + itemId);
        if(command[2] == "set")
            SETFLAG(item.Flags, item_flags[index]);
        else
            UNSETFLAG(item.Flags, item_flags[index]);
        item.Update();

        #ifdef SDK2238
        ExecCommand(player, 0, 0, 0, "command itemflags get " + itemId, null);
        #endif
    }
    else if(command[2] == "list")
    {
        player.Say(SAY_NETMSG, "Item flags list:");
        for(uint f = 0; f < item_flags.length(); f++)
        {
            player.Say(SAY_NETMSG, "  " + item_flagnames[f] + " (" + item_flags[f] + ")");
        }
        return;
    }
    else
    {
        player.Say(SAY_NETMSG, "Unknown mode " + command[2]);
        return;
    }
}

void ExecItemProtoCommand(array<string@>@ command, Critter@ player)
{
    int itemId = 0;
    string[] sitem = { "-i", "-item" };

    if(StrToInt(GetParameterString(command, sitem), itemId))
    {
        Item@ item = FindItem(player, itemId);
        if(valid(item))
        {
            uint16 proto = 0;
            string[] sproto = { "-pid", "-proto", "-protoid" };
            uint16 ammocount = 0;
            string[] sammocount = { "-ammocount" };
            int16  dir = 0;
            string[] sdir = { "-dir", "-direction" };
            int16  offsetx = 0, offsety = 0;
            string[] soffsetx = { "-ox", "-offsetx" };
            string[] soffsety = { "-oy", "-offsety" };

            string[] spicmap = { "-picmap" };
            string[] spicinv = { "-picinv" };
            string[] spic    = { "-pic" };

            int wear = 0;
            string[] swear   = { "-w", "-wear" };

            string picmap = GetParameterString(command, spicmap);
            string picinv = GetParameterString(command, spicinv);
            string pic = GetParameterString(command, spic);
            if(pic != "")
            {
                picmap = pic;
                picinv = pic;
            }

            if(StrToInt(GetParameterString(command, sproto), proto))
            {
                player.Say(SAY_NETMSG, "Changing item proto to: " + proto);
                if(item.ChangeProto(proto))
                {
                    player.Say(SAY_NETMSG, "Sim salabim!");
                    item.Update();
                }
                else
                    player.Say(SAY_NETMSG, "Can't change item proto");
            }
            else
                DPlayerLog(player, "Invalid parameter for sproto");

            if(StrToInt(GetParameterString(command, sammocount), ammocount))
            {
                player.Say(SAY_NETMSG, "Changing item ammo count to: " + ammocount);
                item.AmmoCount = ammocount;
                item.Update();
            }
            else
                DPlayerLog(player, "Invalid parameter for sammocount");

            if(picmap != "")
            {
                player.Say(SAY_NETMSG, "Changing map picture to: " + picmap);
                item.PicMap = GetStrHash(picmap);
                item.Update();
            }

            if(picinv != "")
            {
                player.Say(SAY_NETMSG, "Changing inventory picture to: " + picinv);
                item.PicInv = GetStrHash(picinv);
                item.Update();
            }
            else
                DPlayerLog(player, "Invalid parameter for spicinv");


            if(StrToInt(GetParameterString(command, sdir), dir))
            {
                player.Say(SAY_NETMSG, "Changing item directory to: " + dir);
                item.Dir = dir;
                item.Update();
            }
            else
                DPlayerLog(player, "Invalid parameter for soffsetx");

            if(StrToInt(GetParameterString(command, soffsetx), offsetx))
            {
                player.Say(SAY_NETMSG, "Changing item offset x to: " + offsetx);
                item.OffsetX = offsetx;
                item.Update();
            }
            else
                DPlayerLog(player, "Invalid parameter for soffsetx");

            if(StrToInt(GetParameterString(command, soffsety), offsety))
            {
                player.Say(SAY_NETMSG, "Changing item offset y to: " + offsety);
                item.OffsetY = offsety;
                item.Update();
            }
            else
                DPlayerLog(player, "Invalid parameter for soffsety");

            if(StrToInt(GetParameterString(command, swear), wear))
            {
                wear = CLAMP(wear, 0, 100);
                player.Say(SAY_NETMSG, "Changing wear to: " + wear + "%");
                SetWear(item, wear);
                item.Update();
            }
            else
                DPlayerLog(player, "Invalid parameter for sdir");
        }
        else
        {
            player.Say(SAY_NETMSG, "Item not found. ");
            return;
        }
    }
}

void ExecItemLightCommand(array<string@>@ command, Critter@ player)
{
    int itemId = 0;
    string[] sitem = { "-i", "-item" };

    if(StrToInt(GetParameterString(command, sitem), itemId))
    {
        Item@ item = FindItem(player, itemId);
        if(valid(item))
        {
            int arg = 0;
            string[] sintensity = { "-int", "-intensity" };
            string[] sradius = { "-r", "-radius" };
            string[] sflags = { "-f", "-flags" };
            string[] scolor = { "-c", "-color" };
            if(StrToInt(GetParameterString(command, sintensity), arg))
                item.LightIntensity = arg;
            if(StrToInt(GetParameterString(command, sradius), arg))
                item.LightDistance = arg;
            if(StrToInt(GetParameterString(command, sflags), arg))
                item.LightFlags = arg;
            if(StrToInt(GetParameterString(command, scolor), arg))
                item.LightColor = arg;
            item.Update();
        }
        else
        {
            player.Say(SAY_NETMSG, "Item not found. ");
            return;
        }
    }
    else
        player.Say(SAY_NETMSG, "Missing -i argument.");
}

void ExecSetLexemCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    int itemId = 0;
    string[] sitem = { "-i", "-item" };

    string[] slexem = { "-l", "-lexem" };
    string lexem = GetParameterString(command, slexem);
    string what = GetParameterString(command, "-m");

    if(lexem.rawLength() == 0)
    {
        player.Say(SAY_NETMSG, "No lexem given.");
        return;
    }
    else if(lexem.rawGet(0) != '$')
    {
        player.Say(SAY_NETMSG, "Invalid lexem name <" + lexem + ">");
        return;
    }

    if(StrToInt(GetParameterString(command, sitem), itemId))
    {
        Item@ item = FindItem(player, itemId);
        if(valid(item))
        {
            if(what.rawLength() == 0)
            {
                player.Say(SAY_NETMSG, "Removing item lexem " + lexem);
                UnsetLexem(item, lexem);
            }
            else
            {
                if(what.rawLength() >= 127)
                {
                    player.Say(SAY_NETMSG, "Lexem too long");
                    return;
                }
                player.Say(SAY_NETMSG, "Setting item lexem " + lexem + ": " + what);
                SetLexem(item, lexem, what);
            }
        }
        else
        {
            player.Say(SAY_NETMSG, "Item not found. ");
            return;
        }
    }
    else
    {
        if(what.rawLength() == 0)
        {
            player.Say(SAY_NETMSG, "Removing " + target.Name + "(" + target.Id + ") lexem " + lexem);
            UnsetLexem(target, lexem);
        }
        else
        {
            if(target.Id != player.Id && target.IsPlayer() &&
               !GodOfTheRealm(player.Id))
            {
                player.Say(SAY_NETMSG, "Invalid target.");
                return;
            }

            if(what.rawLength() >= 127)
            {
                player.Say(SAY_NETMSG, "Lexem too long");
                return;
            }

            player.Say(SAY_NETMSG, "Setting " + target.Name + "(" + target.Id + ") lexem " + lexem + ": " + what);
            SetLexem(target, lexem, what);
        }
    }
}

void ExecLockCarCommand(array<string@>@ command, Critter@ player, bool lock)
{
    int itemId = 0;
    string[] sitem = { "-i", "-item" };

    if(StrToInt(GetParameterString(command, sitem), itemId))
    {
        Item@ item = FindItem(player, itemId);
        if(valid(item))
        {
            if(item.GetType() != ITEM_TYPE_CAR)
            {
                player.Say(SAY_NETMSG, "It's not a car.");
                return;
            }

            string un = "";
            if(lock)
                SETFLAG(item.Val0, CAR_NO_LOCKPICK);
            else
            {
                un = "un";
                UNSETFLAG(item.Val0, CAR_NO_LOCKPICK);
            }
            player.Say(SAY_NETMSG, "Car " + un + "locked.");

        }
        else
            player.Say(SAY_NETMSG, "Car not found. ");
    }
    else
        player.Say(SAY_NETMSG, "Missing -item argument.");
}

void ExecGetItemsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(player.Id == target.Id)
    {
        player.Say(SAY_NETMSG, "Invalid target.");
        return;
    }

    string[] sinv   = { "-i", "-inv", "-inventory", "-all" };
    string[] sarmor = { "-a", "-armor", "-all" };
    string[] shead  = { "-h3", "-head", "-helmet", "-all" };
    string[] shand1 = { "-h1", "-hand1", "-hands", "-all" };
    string[] shand2 = { "-h2", "-hand2", "-hands", "-all" };

    bool inv                = (GetIndexOfString(command, sinv) != -1);
    bool armor              = (GetIndexOfString(command, sarmor) != -1);
    bool head               = (GetIndexOfString(command, shead) != -1);
    bool hand1              = (GetIndexOfString(command, shand1) != -1);
    bool hand2              = (GetIndexOfString(command, shand2) != -1);

    if(!inv && !armor && !hand1 && !hand2 && !head)
    {
        player.Say(SAY_NETMSG, "Nothing to transfer.");
        return;
    }

    #ifdef __DEBUG__
    player.Say(SAY_NETMSG, "ExecGetItemsCommand:" + (inv ? " inv" : "") + (head ? " helmet" : "") + (armor ? " armor" : "") + (hand1 ? "hand1" : "") + (hand2 ? "hand2" : ""));
    #endif

    array<Item@> items;
    uint         count = 0;

    if(inv)
        count += target.GetItems(SLOT_INV, items);
    if(armor)
        count += target.GetItems(SLOT_ARMOR, items);
    if(head)
        count += target.GetItems(SLOT_HEAD, items);
    if(hand1)
        count += target.GetItems(SLOT_HAND1, items);
    if(hand2)
        count += target.GetItems(SLOT_HAND2, items);

    if(count > 0)
    {
        player.Say(SAY_NETMSG, "Transfering " + count + " items from " + target.Name);
        _CritAnimateUse(player);
        MoveItems(items, player);
    }
    else
        player.Say(SAY_NETMSG, target.Name + " has no items in given slot(s)");
}

// built-in client cheats
void ExecCoreCheats(array<string@>@ command, Critter@ player)
{
    int cheats = 0;

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Wrong numer of arguments.");
        return;
    }
    else if(command[2] == "set" && command.length() < 4)
    {
        player.Say(SAY_NETMSG, "Wrong numer of arguments for 'set' mode.");
        return;
    }

    if(command[2] == "reset" || command[2] == "set")
    {
        SETFLAG(cheats, CC_TILE | CC_ROOF | CC_ITEM | CC_SCEN | CC_WALL | CC_CRIT | CC_NPCNAMES);
    }

    if(command[2] == "reset")
    {
        /* foo!=bar */
    }
    else if(command[2] == "set")
    {
        SET_CORECHEAT(command, cheats, "tile",                 CC_TILE);
        SET_CORECHEAT(command, cheats, "roof",                 CC_ROOF);
        SET_CORECHEAT(command, cheats, "item",                 CC_ITEM);
        SET_CORECHEAT(command, cheats, "scen",                 CC_SCEN);
        SET_CORECHEAT(command, cheats, "wall",                 CC_WALL);
        SET_CORECHEAT(command, cheats, "crit",                 CC_CRIT);
        SET_CORECHEAT(command, cheats, "fast",                 CC_FAST);           // what is that?
        SET_CORECHEAT(command, cheats, "npcnames",             CC_NPCNAMES);
        SET_CORECHEAT(command, cheats, "critid",               CC_CRITID);
        /*
           SET_CORECHEAT( command, cheats, "debuginfo",	CC_DEBUGINFO );
           SET_CORECHEAT( command, cheats, "debugnet",		CC_DEBUGNET );
           SET_CORECHEAT( command, cheats, "debugsprites",	CC_DEBUGSPRITES );
         */
    }
    else
    {
        player.Say(SAY_NETMSG, "Invalid switch: " + command[2]);
        return;
    }

    player.RunClientScript("_CC", cheats, 0, 0, " ", null);
}

void ExecFindCharsCommand(array<string@>@ command, Critter@ player)
{
    string halp = "Usage: findchars [param] [< <= == != >= >] [value]";
    int    param = 0;
    int    value = 0;

    // check arguments

    if(command.length() < 3 || !StrToInt(command[2], param))
    {
        player.Say(SAY_NETMSG, halp);
        return;
    }
    if(param < 0)
    {
        player.Say(SAY_NETMSG, halp);
        player.Say(SAY_NETMSG, "[param] cannot be less than 0");
        return;
    }
    if(!(command[3] == "<" || command[3] == ">" ||       // command[3] == "=" ||
         command[3] == "<=" || command[3] == ">=" || command[3] == "==" ||
         command[3] == "!="))
    {
        player.Say(SAY_NETMSG, halp);
        return;
    }
    if(!StrToInt(command[4], value))
    {
        player.Say(SAY_NETMSG, halp);
        return;
    }

    // make some output
    array<Critter@> players;
    uint            n = GetAllOnlinePlayers(players);
    uint            found = 0;
    for(uint p = 0; p < players.length(); p++)
    {
        #define _PrintPlayer    # (array, idx)GetSafePlayerName(array[idx].Id) + " (" + array[idx].Id + ")" + "(" + array[idx].GetMapId() + ") - " + GetAuthString(array[idx])

        #ifndef __DEBUG__
        if(GodOfTheRealm(players[p].Id) && _CritHasExtMode(players[p], MODE_EXT_GOD))
            continue;
        #endif

        if(player.GetAccess() < players[p].GetAccess())
            continue;

        if(command[3] == "<" && players[p].Param[param] < value)
        {
            player.Say(SAY_NETMSG, _PrintPlayer(players, p));
            found++;
        }
        else if(command[3] == "<=" && players[p].Param[param] <= value)
        {
            player.Say(SAY_NETMSG, _PrintPlayer(players, p));
            found++;
        }
        else if(command[3] == ">" && players[p].Param[param] > value)
        {
            player.Say(SAY_NETMSG, _PrintPlayer(players, p));
            found++;
        }
        else if(command[3] == ">=" && players[p].Param[param] >= value)
        {
            player.Say(SAY_NETMSG, _PrintPlayer(players, p));
            found++;
        }
        else if((/*command[3] == "=" ||*/ command[3] == "==") && players[p].Param[param] == value)
        {
            player.Say(SAY_NETMSG, _PrintPlayer(players, p));
            found++;
        }
        else if(command[3] == "!=" && players[p].Param[param] != value)
        {
            player.Say(SAY_NETMSG, _PrintPlayer(players, p));
            found++;
        }
    }
    player.Say(SAY_NETMSG, "Found " + found + " player" + (found == 1 ? "" : "s") + ".");
}

void ExecFindNpcCommand(array<string@>@ command, Critter@ player)
{
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Missing arguments");
        return;
    }

    if(command[2] == "list")
    {
        if(INPC.length() > 0)
        {
            player.Say(SAY_NETMSG, "\nImportant NPCs:");
            for(uint i = 0; i < INPC.length(); i++)
            {
                string names = "";
                for(uint n = 0; n < INPC[i].names.length(); n++)                 // becouse join() is a joke
                {
                    if(n > 0)
                        names += ",";
                    names += INPC[i].names[n];
                }

                player.Say(SAY_NETMSG,
                           "[" +
                           (INPC[i].protoId < 1000  ? " " : "") +
                           (INPC[i].protoId < 100   ? " " : "") +
                           (INPC[i].protoId < 10    ? " " : "") +
                           INPC[i].protoId +
                           "," +
                           (INPC[i].dialogId < 10000 ? " " : "") +
                           (INPC[i].dialogId < 1000  ? " " : "") +
                           (INPC[i].dialogId < 100   ? " " : "") +
                           (INPC[i].dialogId < 10    ? " " : "") +
                           INPC[i].dialogId +
                           "] " +
                           names);
            }
            player.Say(SAY_NETMSG, "Total " + INPC.length() + " NPCs");
        }
    }
    else
    {
        array<CNPC@> list;
        for(uint i = 0; i < INPC.length(); i++)
        {
            for(uint n = 0; n < INPC[i].names.length(); n++)
            {
                if(strlwr(INPC[i].names[n]) == strlwr(command[2]))
                {
                    list.insertLast(INPC[i]);
                    break;
                }
            }
        }
        if(list.length() > 0)
        {
            player.Say(SAY_NETMSG, "NPC \"" + command[2] + "\" (" + list.length() + ")");
            for(uint l = 0; l < list.length(); l++)
            {
                if(!valid(list[l]))
                    continue;
                array<Critter@> npcs;
                GetAllNpc(list[l].protoId, npcs);
                if(npcs.length() > 0)
                {
                    for(uint n = 0; n < npcs.length(); n++)
                    {
                        if(list[l].IsImportant(npcs[n]))
                        {
                            uint map = npcs[n].GetMapId();
                            player.Say(SAY_NETMSG, " " +
                                       npcs[n].Id +
                                       (map > 0
                                        ? " map:" + map + ":" + npcs[n].HexX + "," + npcs[n].HexY
                                        : "worldmap:" + npcs[n].WorldX + "," + npcs[n].WorldY)
                                       );
                        }
                    }
                }
                else
                {
                    player.Say(SAY_NETMSG, "Can't find any \"" + command[2] + "\"");
                }
            }
        }
        else
        {
            player.Say(SAY_NETMSG, "Unknown NPC \"" + command[2] + "\"");
        }
    }
}


void ExecResetWorldMapCommand(array<string@>@ command, Critter@ player)
{
    for(uint x = 0; x < __GlobalMapWidth; x++)
    {
        for(uint y = 0; y < __GlobalMapHeight; y++)
        {
            player.SetFog(x, y, FOG_NONE);
        }
    }
}

void ExecPlayMusicCommand(array<string@>@ command, Critter@ player)
{
    string[] smusic = { "-m", "-music" };
    string music = GetParameterString(command, smusic);
    if(music == "")
    {
        player.Say(SAY_NETMSG, "Missing music filename.");
        return;
    }
    else
    {
        if(valid(player.GetMap()))
        {
            player.Say(SAY_NETMSG, "Playing: " + music);
            array<Critter@> critters;

            uint            allcrit = player.GetMap().GetCritters(0, FIND_ALL | FIND_ONLY_PLAYERS, critters);
            for(uint c = 0; c < allcrit; c++)
            {
                critters[c].RunClientScript("_PlayMusic", 0, 0, 0, music, null);
            }
        }
        else
        {
            player.Say(SAY_NETMSG, "Invalid map.");
            return;
        }
    }
    return;
}

void ExecPlaySoundCommand(array<string@>@ command, Critter@ player, bool speech)
{
    string[] ssound = { "-s", "-sound" };
    string sound = GetParameterString(command, ssound);
    if(sound == "")
    {
        player.Say(SAY_NETMSG, "Missing sound filename.");
        return;
    }
    else
    {
        Map@ map = player.GetMap();
        if(valid(map))
        {
            if(GetIndexOfString(command, "-x") != -1 ||
               GetIndexOfString(command, "-y") != -1 ||
               GetIndexOfString(command, "-r") != -1)
            {
                string sx = GetParameterString(command, "-x");
                int    x = 0;
                string sy = GetParameterString(command, "-y");
                int    y = 0;
                string[] sradius = { "-r", "-radius" };
                string sr = GetParameterString(command, sradius);
                int    r = 0;
                StrToInt(sx, x);
                StrToInt(sy, y);
                StrToInt(sr, r);
                if(x == 0 && sx != "0")
                    x = player.HexX;
                if(y == 0 && sy != "0")
                    y = player.HexY;
                if(r == 0)
                    r = 10;
                map.PlaySound((speech ? "sound\\speech\\" : "") + sound, x, y, r);
                return;
            }
            else
            {
                map.PlaySound((speech ? "sound\\speech\\" : "") + sound);
                return;
            }
        }
        else
        {
            player.Say(SAY_NETMSG, "Invalid map.");
            return;
        }
    }
}

void ExecGetRequestsCommand(array<string@>@ command, Critter@ player)
{
    Broadcast_DumpRequestHelpBuffer(player);
}

/*
 * Client commands replacement - remember to disable original ones in client
 */

// TODO: finish tester params table and move command to tester access
void ExecParamCommand(array<string@>@ command, Critter@ player, Critter@ target)     // ~param
{
    if(command.length() >= 4)
    {
        int  control = 0;
        int  param = -1;
        bool ok = false;
        if(!StrToInt(command[2], control))
        {
            player.Say(SAY_NETMSG, "Wrong arguments.");
            return;
        }
        else
        {
            if(control > 0)
            {
                @target = GetCritter(control);
            }
			else
			{
				player.Say(SAY_NETMSG, "Invalid param group.");
                return;
			}
        }

        if(StrToInt(command[3], param))
        {
            if(param < 0 || param > 1200)
            {
                player.Say(SAY_NETMSG, "Invalid param number.");
                return;
            }
            if(target.Id == player.Id || (player.GetAccess() >= ACCESS_MODER && target.Id != player.Id) || (player.GetAccess() >= ACCESS_MODER && target.IsNpc()))
            {
                if(player.GetAccess() == ACCESS_TESTER && !Present(param, testerparamlist))
                {
                    player.Say(SAY_NETMSG, "You can't view or edit this param.");
                    return;
                }

                int  value = 0;
                bool haveValue = false;
                if(command.length >= 5)
                {
                    haveValue = true;
                    if(!StrToInt(command[4], value))
                    {
                        player.Say(SAY_NETMSG, "Invalid value argument <" + command[4] + ">");
                        return;
                    }
                }

                if(!haveValue)
                {
                    player.Say(SAY_NETMSG, "Param " + param + " of critter " + target.Name + "(" + target.Id + "): " + target.Param[param]);
                    return;
                }

                int oldValue = target.Param[param];

                // pre-process
                switch(param)
                {
                case ST_AGE:
                {
                    SetLvar(target, LVAR_birth_year, __Year - value);
                    SynchronizeAge(target);
                    if(oldValue != target.Param[ST_AGE])
                        player.Say(SAY_NETMSG, "SynchronizeAge " + target.Name + "(" + target.Id + "): " + oldValue + " -> " + target.Param[ST_AGE]);
                };
                    break;

                default:
                    target.ParamBase[param] = value;
                    break;
                }

                player.Say(SAY_NETMSG, "Changed param " + param + " of critter " + target.Name + "(" + target.Id + "): " + oldValue + " -> " + target.Param[param]);

                // post-process
                switch(param)
                {
                case ST_BASE_CRTYPE:
                    target.DisguisedBy = player.Id;
                    break;
                }
            }
            else
            {
                player.Say(SAY_NETMSG, "Wrong target: " + target.Name + "(" + target.Id + ")");
                return;
            }
        }
        else
        {
            player.Say(SAY_NETMSG, "Wrong arguments.");
            return;
        }
    }
    else
    {
        player.Say(SAY_NETMSG, "Missing arguments.");
    }
}

void ExecMassParamCommand(array<string@>@ command, Critter@ player, Critter@ target)     // ~param
{
	
	int type = 0;
    cheatGetOption(command, type, "-a");
	int typeB = 0;
    cheatGetOption(command, typeB, "-b");
	int typeC = 0;
    cheatGetOption(command, typeC, "-c");
	
	array<Critter@> crits;
	uint            n = 0;
	if(typeC==0)
    n = player.GetMap().GetCritters(0, FIND_ALL | FIND_ONLY_PLAYERS, crits);
	else  n = player.GetMap().GetCritters(0, FIND_ALL | FIND_ONLY_NPC, crits);
    for(uint i = 0; i < n; i++)
	{
        crits[i].ParamBase[type] = typeB;
	}
}
import void CallMobs(Critter& cr, int howmany, int whatkind, int whattype) from "mob_dynamic";
void CallMobsCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
	int type = 0;
    cheatGetOption(command, type, "-a");
	int typeB = 0;
    cheatGetOption(command, typeB, "-b");
	int typeC = 0;
    cheatGetOption(command, typeC, "-c");
	CallMobs(player, type, typeB, typeC);
}
//import void SpawnTeam(Critter& cr, int howmany, int whatkind, int team, bool withboss) from "mob_dynamic";
void SpawnTeamCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
	bool error = false;
	bool withboss = false;
	int type = 0;
    cheatGetOption(command, type, "-h");
	cheatGetOption(command, type, "-howmany");
	int typeB = 0;
    cheatGetOption(command, typeB, "-e");
	cheatGetOption(command, typeB, "-entire");
	int typeC = 0;
    cheatGetOption(command, typeC, "-t");
	cheatGetOption(command, typeC, "-team");
	int typeD = 3;
    cheatGetOption(command, typeD, "-b");
	cheatGetOption(command, typeD, "-boss");
	if(!valid(player.GetMap()))
		{
		player.Say(SAY_NETMSG, "Wrong map");
		error = true;
		}
	if(type == 0 || type < 1 || type > 10)
		{
		player.Say(SAY_NETMSG, "Missing arguments. -h or -howmany must be between 2-10");
		error = true;
		}
	if(typeB == 0)
		{
		player.Say(SAY_NETMSG, "Missing arguments. -e or -entire must be diffrent than 0, use 1 or 2 to spawn near you");
		error = true;
		}
	if(typeC == 0)
		{
		player.Say(SAY_NETMSG, "Missing arguments. -t or -team must be diffrent than 0, 1 or 5 enclave, 2 or 6 brotherhood, 3 or 7 ncr");
		player.Say(SAY_NETMSG, "4 or 8 vc, 9 or 10 defenders, 11 or 12 master army, 13 or 14 salvatories, 15 or 16 bishops");
		player.Say(SAY_NETMSG, "17 or 18 wrights, 19 or 20 Mordinos, 11 or 12 master army, 13 or 14 salvatories, 15 or 16 bishops");
		error = true;
		}
	if(typeD == 3)
		{
		player.Say(SAY_NETMSG, "Missing arguments. -b or -boss must be diffrent 0 or if you want spawn with boss 1");
		error = true;
		}
	if(typeD == 1)
		withboss = true;
	if(error)
		{
		player.Say(SAY_NETMSG, "Spawning event mobs failed!");
		return;
		}
	SpawnTeam(player, type, typeB, typeC, withboss);
}


void ExecGetColorCommand(array<string@>@ command, Critter@ player)
{
    if(command.length() < 5)
    {
        player.Say(SAY_NETMSG, "Missing arguments.");
        return;
    }

    int r = 0;
    int g = 0;
    int b = 0;
    if(StrToInt(command[2], r) &&
       StrToInt(command[3], g) &&
       StrToInt(command[4], b))
    {
        int   color = COLOR_RGB(r, g, b);

        bool  isAlpha = false;
        uint8 a = 0;
        if(command.length() >= 6 && StrToInt(command[5], a))
        {
            isAlpha = true;
            color = COLOR_CHANGE_ALPHA(color, a);
        }

        player.Say(SAY_NETMSG, "Color: " + r + "," + g + "," + b);
        if(isAlpha)
            player.Say(SAY_NETMSG, "Alpha: " + a);
        player.Say(SAY_NETMSG, "Number: " + color);
    }
    else
        player.Say(SAY_NETMSG, "Wrong arguments.");
}

void ExecLastSpawnedCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    player.Say(SAY_NETMSG, "Last spawned by " + target.Name + ":");
    if((GodOfTheRealm(target.Id) || target.GetAccess() > player.GetAccess()) &&
       target.Id != player.Id)
    {
        player.Say(SAY_NETMSG, "No idea.");
        return;
    }

    if(target.LastSpawnedCritter == 0 &&
       target.LastSpawnedItem == 0 &&
       target.LastSpawnedLocation == 0)
    {
        player.Say(SAY_NETMSG, "Nothing, " + GenderString(player, "he's", "she's", "it's") + " clean!");
        return;
    }

    if(target.LastSpawnedItem > 0)
        player.Say(SAY_NETMSG, "Item: " + target.LastSpawnedItem);
    if(target.LastSpawnedCritter > 0)
        player.Say(SAY_NETMSG, "Critter: " + target.LastSpawnedCritter);
    if(target.LastSpawnedLocation > 0)
        player.Say(SAY_NETMSG, "Location: " + target.LastSpawnedLocation);
}

string@ spaces(int num)   // helper
{
    if(num < 1)
        return " ";
    string result = "";
    result.rawResize(num);
    for(int s = 0; s < num; s++)
        result.rawSet( s, ' ');
    return result;
}

void ExecGameInfoCommand(array<string@>@ command, Critter@ player)
{
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Invalid arguments");
        return;
    }

    int gameinfo = 0;
    StrToInt(command[2], gameinfo);

    if(gameinfo == 1)
    {
        array<Critter@> players;
        uint            all = GetAllOnlinePlayers(players);
        uint            num = all;
        for(uint p = 0; p < all; p++)
        {
            if(!valid(players[p]))
                continue;

            if(WrathOfTheGod(players[p]))
                num--;
        }

        player.Say(SAY_NETMSG, "Players in game: " + num);
        player.Say(SAY_NETMSG, "Connections: " + all);         // TODO!

        player.Say(SAY_NETMSG, "Name                 Id        Ip              Online  Cond     X     Y     Location (Id, Pid)             Map (Id, Pid)                  Level");

        for(uint p = 0; p < all; p++)
        {
            if(!valid(players[p]))
                continue;

            if(WrathOfTheGod(players[p]))
                continue;

            string line = "";
            // collect info
            string ip = IpToString(players[p].GetIp());
            string online = (players[p].GetSocket() == -1 ? "Disconnect" : "Yes");
            string cond = "";
            switch(players[p].Cond)
            {
            case COND_LIFE:
                cond = "Life";
                break;
            case COND_KNOCKOUT:
                cond = "Knockout";
                break;
            case COND_DEAD:
                cond = "Dead";
                break;
            default:
                cond = "Unknown";
                break;
            }
            int    x = 0;
            int    y = 0;
            string locname = "";
            string mapname = "";
            if(players[p].GetMapId() == 0)
            {
                x = players[p].WorldX;
                y = players[p].WorldY;
                locname = "Global map";
            }
            else
            {
                x = players[p].HexX;
                y = players[p].HexY;

                Map@      map = players[p].GetMap();
                Location@ loc = map.GetLocation();

                map.ProtoName(mapname);
                loc.ProtoName(locname);

                mapname += " (" + map.Id + ", " + map.GetProtoId() + ")";
                locname += " (" + loc.Id + ", " + loc.GetProtoId() + ")";
            }
            // fix
            if(ip.length() == 0)
                ip = "0.0.0.0";                 // so ugly!

            // Name
            line += players[p].Name + spaces(21 - players[p].Name.length());
            // Id
            line += players[p].Id + spaces(10 - numDigits(players[p].Id));
            // Ip
            line += ip + spaces(16 - ip.length());
            // NetState
            line += online + spaces(11 - online.length());
            // Cond
            line += cond + spaces(9 - cond.length());
            // X, Y
            line += x + spaces(6 - numDigits(x));
            line += y + spaces(6 - numDigits(y));
            // Location (Id, Pid), Map (Id, Pid)
            line += locname + spaces(31 - locname.length());
            line += mapname + spaces(31 - mapname.length());
            // Level
            line += players[p].Param[ST_LEVEL] + spaces(4 - numDigits(players[p].Param[ST_LEVEL]));

            // finally - output
            player.Say(SAY_NETMSG, line);
        }
    }     // 1
    else
        player.Say(SAY_NETMSG, "Not implemented.");
}

void ExecLastRegisteredCommand(array<string@>@ command, Critter@ player)
{
    int id = GetGvar(GVAR_last_registered);

    if(id == 0)
    {
        player.Say(SAY_NETMSG, "GVAR missing");
        return;
    }

    string@ name = GetSafePlayerName(id);
    if(!valid(name))
        name = "???";

    player.Say(SAY_NETMSG, "Newest character: " + name + " (" + id + ")");
}

void ExecAccessListCommand(array<string@>@ command, Critter@ player)
{
    #ifndef __DEBUG__
    if(!WrathOfTheGod(player))
    {
        player.Say(SAY_NETMSG, "No.");
        return;
    }
    #endif

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Missing parameters");
        return;
    }

    {
        LoadConfig(GETACCESS_CFG);
        IConfigFile@ config = GetConfigFile(GETACCESS_CFG);
        if(!valid(config))
        {
          //  Log("ERROR Can't load config/GetAccess.cfg");
            player.Say(SAY_NETMSG, "INVALID GETACCESS CONFIG. PANIC.");
            return;
        }
        DPlayerLog(player, "Config OK");
    }

    string option = command[2];

    if(option == "help")
    {
        player.Say(SAY_NETMSG, "Available commands:");
        player.Say(SAY_NETMSG, " allowregistration [nick]");
        player.Say(SAY_NETMSG, " disallowregistration [nick]");
        player.Say(SAY_NETMSG, " list");
        // player.Say( SAY_NETMSG, " reload" );
    }
    else if(option == "allowregistration")
    {
        if(command.length() < 4)
        {
            player.Say(SAY_NETMSG, "Missing parameters (required: nickname)");
            return;
        }
        if(!valid(GetConfigSection(GETACCESS_CFG, command[3], true)))
        {
            player.Say(SAY_NETMSG, "No such user exists - " + command[3]);
            return;
        }
        SetConfigValue(GETACCESS_CFG, command[3], "Reserved", "false");
        SaveConfig(GETACCESS_CFG);

        string msg = "Allowed registration of " + command[3];
      //  Log(msg + " : " + player.Name + "(" + player.Id + ")");
        player.Say(SAY_NETMSG, msg);
    }
    else if(option == "disallowregistration")
    {
        if(command.length() < 4)
        {
            player.Say(SAY_NETMSG, "Missing parameters (required: nickname)");
            return;
        }
        if(!valid(GetConfigSection(GETACCESS_CFG, command[3], true)))
        {
            player.Say(SAY_NETMSG, "No such user exists: " + command[3]);
            return;
        }
        SetConfigValue(GETACCESS_CFG, command[3], "Reserved", "true");
        SaveConfig(GETACCESS_CFG);

        string msg = "Disallowed registration of " + command[3];
    //    Log(msg + " : " + player.Name + "(" + player.Id + ")");
        player.Say(SAY_NETMSG, msg);
    }
    else if(option == "list")
    {
        IConfigFile@  config = GetConfigFile(GETACCESS_CFG);
        array<string> sections;
        config.GetSections(sections);
        if(sections.length() > 0)
        {
            player.Say(SAY_NETMSG, "Hall of Fame");
            sections.sortAsc();
            for(uint s = 0; s < sections.length(); s++)
            {
                string@ res = GetConfigValue(GETACCESS_CFG, sections[s], "Reserved");
                player.Say(SAY_NETMSG, " " + sections[s] + (valid(res) ? " (reserved)" : ""));
            }
        }
        else
        {
            player.Say(SAY_NETMSG, "Nobody in access list. What are you doing here?");
            return;
        }
    }
    /* needs better config handling
       else if( option == "reload" )
       {
            SaveConfig( GETACCESS_CFG );
            UnloadConfig( GETACCESS_CFG );
            LoadConfig( GETACCESS_CFG );
            Log( "Access list reloaded : "+player.Name+"("+player.Id+")" );
       }
     */
}

void ExecReservedNicknameCommand(array<string@>@ command, Critter@ player)
{
    LoadConfig("config/ReservedNicknames.cfg");

    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Missing parameters");
        return;
    }

    IConfigSection@ section = GetConfigSection("config/ReservedNicknames.cfg", "Reserved");

    if(command[2] == "list")
    {
        if(!valid(section))
            player.Say(SAY_NETMSG, "No reserved nicknames found.");
        else
        {
            array<string> nicknames;
            section.GetVars(nicknames);
            if(nicknames.length() > 0)
            {
                nicknames.sortAsc();
                player.Say(SAY_NETMSG, "Reserved nickname" + (nicknames.length() > 1 ? "s" : "") + " (" + nicknames.length() + "):");
                for(uint n = 0, ncount = nicknames.length(); n < ncount; n++)
                {
                    player.Say(SAY_NETMSG, nicknames[n]);
                }
                player.Say(SAY_NETMSG, "Reserving " + nicknames.length() + " nickname" + (nicknames.length() > 1 ? "s" : "") + ".");
            }
            else
                player.Say(SAY_NETMSG, "No reserved nicknames found.");
        }
        return;
    }

    if(command.length() < 4 || command[3].length() == 0)
    {
        player.Say(SAY_NETMSG, "Missing parameters");
        return;
    }


    if(command[2] == "add")
    {
        IConfigVar@ var = GetConfigVar("config/ReservedNicknames.cfg", "Reserved", command[3], false);
        if(valid(var))
            section.DeleteVar(var.GetName());
        SetConfigValue("config/ReservedNicknames.cfg", "Reserved", command[3], "1");
        SaveConfig("config/ReservedNicknames.cfg");
        player.Say(SAY_NETMSG, "Nickname <" + command[3] + "> reserved.");
    }
    else if(command[2] == "delete")
    {
        if(!valid(section))
            player.Say(SAY_NETMSG, "No reserved nicknames found.");

        IConfigVar@ var = GetConfigVar("config/ReservedNicknames.cfg", "Reserved", command[3], false);
        if(valid(var))
        {
            section.DeleteVar(var.GetName());
            SaveConfig("config/ReservedNicknames.cfg");
            player.Say(SAY_NETMSG, "Nickname <" + var.GetName() + "> no longer reserved.");
        }
        else
            player.Say(SAY_NETMSG, "Nickname not reserved.");
    }
}

void ExecToGlobal(Critter@ player, Critter@ target)
{
    if(target.Id != player.Id &&
       ((player.GetAccess() < ACCESS_MODER) || GodOfTheRealm(target.Id)))
    {
        player.Say(SAY_NETMSG, "No.");
        return;
    }

    string who = target.Name + "(" + target.Id + ")";

    if(!valid(target.GetMap()))
    {
        player.Say(SAY_NETMSG, who + " already on worldmap.");
        return;
    }
    ;

    player.Say(SAY_NETMSG, "Moving " + who + " to worldmap.");
    target.TransitToGlobal(false);
}

void ExecCCD(array<string@>@ command, Critter@ player)
{
    #ifndef __DEBUG__
    if(!GodOfTheRealm(player.Id))
    {
        player.Say(SAY_NETMSG, "No.");
        return;
    }
    #endif

    string ccd = GetParameterString(command, "-m");
    if(ccd.length() == 0 || ccd == "NONE")
    {
        player.Say(SAY_NETMSG, "CCD removed");
        UnsetLexem(player, "$~");
    }
    else
    {
        player.Say(SAY_NETMSG, "CCD: " + ccd);
        SetLexem(player, "$~", ccd);
    }
}

void ExecFactionNews(array<string@>@ command, Critter@ player)
{
    int id = -1;
    if(!StrToInt(GetParameterString(command, "-f"), id))
    {
        player.Say(SAY_NETMSG, "You must specify faction id.");
        return;
    }
    if(id <= 0)
    {
        player.Say(SAY_NETMSG, "Invalid id.");
        return;
    }
    if(!FactionExists(id))
    {
        player.Say(SAY_NETMSG, "Faction does not exists");
        return;
    }

    IFaction@ faction = GetFaction(id);
    if(valid(faction))
    {
        uint count = GetFactionNewsCount(id);
        player.Say(SAY_NETMSG, "Found " + count + " news");
        for(uint index = 0; index < count; index++)
        {
            uint   type = 0;
            uint   master = 0, slave = 0;
            uint16 year;
            uint8  month, day, hour, minute;
            if(GetFactionNews(id, index, master, slave, type, year, month, day, hour, minute))
            {
                string timestamp = day + "." + month + "." + year + " " + hour + ":" + (minute < 10 ? "0" : "") + minute;
                string masterName = GetSafePlayerName(master, "(" + master + ")", "Player " + master);
                string slaveName  = GetSafePlayerName(slave,  "(" + slave + ")",  "Player " + slave);

                switch(type)
                {
                case NEWS_JOINED:
                    player.Say(SAY_NETMSG, timestamp + " " + masterName + " joined the faction");
                    break;
                case NEWS_RESIGNED:
                    player.Say(SAY_NETMSG, timestamp + " " + masterName + " resigned from being a member");
                    break;
                case NEWS_EXPELLED:
                    player.Say(SAY_NETMSG, timestamp + " " + slaveName + " was expelled by " + masterName);
                    break;
                case NEWS_PROMOTED:
                    player.Say(SAY_NETMSG, timestamp + " " + slaveName + " was promoted by " + masterName);
                    break;
                case NEWS_DEMOTED:
                    player.Say(SAY_NETMSG, timestamp + " " + slaveName + " was demoted by " + masterName);
                    break;
                case NEWS_CLAIMED:
                    player.Say(SAY_NETMSG, timestamp + " " + masterName + " claimed leadership");
                    break;
                case NEWS_LEADER:
                    player.Say(SAY_NETMSG, timestamp + " " + masterName + " became new leader");
                    break;
                case NEWS_OVERTHROWN:
                    player.Say(SAY_NETMSG, timestamp + " " + masterName + " was overthrown");
                    break;
                default:
                    player.Say(SAY_NETMSG, timestamp + " UNKNOWN NEWS TYPE <" + type + "> idx<" + index + ">");
                    break;
                }
            }
        }
    }
    else
        player.Say(SAY_NETMSG, "Invalid faction");
}

void ExecRunDialog(array<string@>@ command, Critter@ player, Critter@ target)
{
    if(player.Id == target.Id)
    {
        player.Say(SAY_NETMSG, "Talking to self not implemented.");
        return;
    }
    else if(!target.IsNpc())
    {
        player.Say(SAY_NETMSG, "Please use *chat* to talk with other players.");
        return;
    }

    uint dialog = 0;
    if(StrToInt(GetParameterString(command, "-d"), dialog))
    {
        player.Say(SAY_NETMSG, "Starting dialog " + dialog + " with " + target.Name);
        if(!RunDialog(player, target, dialog, true))
            player.Say(SAY_NETMSG, "Dialog error.");
    }
    else
    {
        player.Say(SAY_NETMSG, "Starting default dialog with " + target.Name);
        if(!RunDialog(player, target, true))
            player.Say(SAY_NETMSG, "Dialog error.");
    }
}

void ExecFOArt(array<string@>@ command, Critter@ player)
{
    string filename = GetParameterString(command, "-f");
    if(filename.length() == 0)
    {
        player.Say(SAY_NETMSG, "Missing filename.");
        return;
    }

    player.RunClientScript("client_messages@_foart", 0, 0, 0, filename, null);
}

void ExecTeamCommand(array<string@>@ command, Critter@ player, Critter@ target)
{
    // Default Settings
    int  minigameTeam    = 0;
    int  minigameId      = 15;
    int  minigameFlags   = 0;
    uint radius         = 0;
    bool all            = false;
    bool info           = false;
    bool persistent     = false;

    // Prepare array with targets
    cheatGetOption(command, all, "-all");
    cheatGetOption(command, radius, "-r");
    cheatGetOption(command, persistent, "-s");
    array<Critter@> targets;
    // Set team for all players in the same map as target
    if(all)
    {
        Map@ map = target.GetMap();
        if(!valid(map))
            targets.insertLast(target);
        else
            map.GetCritters(0, FIND_ONLY_PLAYERS | FIND_ALL, targets);
    }
    else
    {
        if(radius <= 0)
            targets.insertLast(target);
        // Set team for everyone around target in a given radius
        else
        {
            Map@ map = target.GetMap();
            if(!valid(map))
                targets.insertLast(target);
            else
                map.GetCrittersHex(target.HexX, target.HexY, radius, FIND_ONLY_PLAYERS | FIND_ALL, targets);
        }
    }

    // Prepare settings
    if(command.length() > 2)
    {
        if(command[2] == "none" || command[2] == "n")
            minigameId = 0;
        else if(command[2] == "spectator" || command[2] == "s")
            minigameTeam = 0;
        else
        {
            if(StrToInt(command[2], minigameTeam))
            {
                if(minigameTeam < 1 || minigameTeam > 15)
                {
                    player.Say(SAY_NETMSG, "Error: Invalid team number.");
                    return;
                }
            }
            else
                info = true;
        }
        if(persistent)
            SETFLAG(minigameFlags, MINIGAME_PERSISTENT);
    }
    else
        info = true;

    // Execute
    if(info)
    {
        player.Say(SAY_NETMSG, "Team Info:");
        for(int i = 0, j = targets.length(); i < j; i += 1)
        {
            int minigameData = targets[i].Param[ST_MINIGAME_DATA];
            int team = _getMinigameTeam(minigameData);
            if(minigameData == 0)
                player.Say(SAY_NETMSG, GetSafePlayerName(targets[i].Id) + " : none");
            else
            {
                if(team == 0)
                    player.Say(SAY_NETMSG, GetSafePlayerName(targets[i].Id) + " : spectator");
                else
                    player.Say(SAY_NETMSG, GetSafePlayerName(targets[i].Id) + " : " + team);
            }
        }
    }
    else
        for(int i = 0, j = targets.length(); i < j; i += 1)
        {
            // Radius and All doesn't change authenticated chars
            if((targets[i].GetAccess() != ACCESS_CLIENT) && (all || radius > 0))
                continue;
            SetMinigame(targets[i], minigameTeam, minigameId, minigameFlags, 0);
        }
}

#define AURA_FLAG_VISIBLE             (0x01)
#define AURA_FLAG_NEED_CRITTERS       (0x02)
#define AURA_FLAG_KNOCKBACK           (0x04)
#define AURA_FLAG_KNOCKBACK_SIMPLE    (0x08)
#define AURA_FLAG_IGNORE_ADMINS       (0x10)
#define AURA_FLAG_GRAVITY_PULL        (0x20)

enum auraNumber
{
    AURA_RESERVED = 0,
    AURA_KNOCKBACK_ALL,
    AURA_KNOCKBACK_NPC,
    AURA_KNOCKBACK_PLAYER,
    AURA_KILL_ALL,
    AURA_KILL_NPC,
    AURA_KILL_PLAYER,
    AURA_SKIN_RANDOM,     // disabled
    AURA_SKIN_RESET,
    AURA_GOLGOTHA,
    AURA_FOREST,
    AURA_SNOWQUEEN,
    AURA_GRAVITATION_WELL,
	AURA_SKIN_RANDOM_SAFE
};

string[] auraSwitch =
{
    "",
    "-knockback",
    "-knockbacknpc",
    "-knockbackplayer",
    "-kill",
    "-killnpc",
    "-killplayer",
    "-randomskin",
    "-resetskin",
    "-golgotha",
    "-forest",
    "-snowqueen",
    "-gravitationwell",
	"-randomskinsafe"
};

string[] auraName =
{
    "RESERVED",
    "Knockback aura, all critters",
    "Knockback aura, NPCs only",
    "Knockback aura, players only",
    "Death aura, all critters",
    "Death aura, NPCs only",
    "Death aura, players only",
    "Skin aura, apply random, players only",
    "Skin aura, reset, players only",
    "Golgotha aura, spawns stakes",
    "Forest aura, spawns trees",
    "Snow Queen aura, all critters",
    "Gravitation Well aura, all critters",
	"SAFE skin aura, no armor skins, players only"
};

void ExecAuraCommand(array<string@>@ command, Critter@ player)
{
    auraNumber aura;

    bool       on = Present("-on", command), off = Present("-off", command);

    if(on && off)
    {
        player.Say(SAY_NETMSG, "Cannot use -on and -off switches at same time");
        return;
    }
    else if(!on && !off)
    {
        player.Say(SAY_NETMSG, "Enabling: `aura -on [auraSwitch], see below");
        player.Say(SAY_NETMSG, "Disabling: `aura -off");
        player.Say(SAY_NETMSG, "Available:");
        for(uint a = 1, alen = auraSwitch.length(); a < alen; a++)
        {
            player.Say(SAY_NETMSG, auraSwitch[a]);
            player.Say(SAY_NETMSG, "  " + auraName[a]);
        }
        return;
    }

    if(on)
    {
        if(Present(auraSwitch[AURA_KNOCKBACK_ALL], command))
            aura = AURA_KNOCKBACK_ALL;
        else if(Present(auraSwitch[AURA_KNOCKBACK_NPC], command))
            aura = AURA_KNOCKBACK_NPC;
        else if(Present(auraSwitch[AURA_KNOCKBACK_PLAYER], command))
            aura = AURA_KNOCKBACK_PLAYER;
        else if(Present(auraSwitch[AURA_KILL_ALL], command))
            aura = AURA_KILL_ALL;
        else if(Present(auraSwitch[AURA_KILL_NPC], command))
            aura = AURA_KILL_NPC;
        else if(Present(auraSwitch[AURA_KILL_PLAYER], command))
            aura = AURA_KILL_PLAYER;
        else if(Present(auraSwitch[AURA_SKIN_RANDOM], command))
            aura = AURA_SKIN_RANDOM;
        else if(Present(auraSwitch[AURA_SKIN_RESET], command))
            aura = AURA_SKIN_RESET;
        else if(Present(auraSwitch[AURA_GOLGOTHA], command))
            aura = AURA_GOLGOTHA;
        else if(Present(auraSwitch[AURA_FOREST], command))
            aura = AURA_FOREST;
        else if(Present(auraSwitch[AURA_SNOWQUEEN], command))
            aura = AURA_SNOWQUEEN;
        else if(Present(auraSwitch[AURA_GRAVITATION_WELL], command))
            aura = AURA_GRAVITATION_WELL;
        else if(Present(auraSwitch[AURA_SKIN_RANDOM_SAFE], command))
            aura = AURA_SKIN_RANDOM_SAFE;			
        else
        {
            player.Say(SAY_NETMSG, "Missing/unknown aura switch");
            return;
        }

        player.Say(SAY_NETMSG, "Enabled: " + auraName[aura]);
        player.EraseTimeEvents(CTE_CHEAT_AURA);
        player.AddTimeEvent("cte_Aura", REAL_SECOND(1), CTE_CHEAT_AURA, aura);
    }
    else if(off)
    {
        player.Say(SAY_NETMSG, "Removing current aura");
        player.EraseTimeEvents(CTE_CHEAT_AURA);
        return;
    }
}

uint cte_Aura(Critter& cr, int identifier, uint& value)
{
    Map@ map = cr.GetMap();

    if(!valid(map))
        return(REAL_SECOND(5));

    int aura = value;     // yea
    if(!EnumContains("auraNumber", aura) || aura == AURA_RESERVED)
    {
        cr.Say(SAY_NETMSG, "Unknown aura<" + aura + ">, disabling");
        return(0);
    }

    int  flags = 0;
    uint radius = 5;
    uint findCritters = 0, foundCritters = 0;
    uint pulse = REAL_SECOND(1);

    switch(aura)
    {
    case AURA_KNOCKBACK_ALL:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK | AURA_FLAG_NEED_CRITTERS | AURA_FLAG_IGNORE_ADMINS);
        findCritters = FIND_LIFE;
        break;

    case AURA_KNOCKBACK_NPC:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK | AURA_FLAG_NEED_CRITTERS);
        findCritters = FIND_LIFE | FIND_ONLY_NPC;
        break;

    case AURA_KNOCKBACK_PLAYER:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK | AURA_FLAG_NEED_CRITTERS | AURA_FLAG_IGNORE_ADMINS);
        findCritters = FIND_LIFE | FIND_ONLY_PLAYERS;
        break;

    case AURA_KILL_ALL:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK_SIMPLE | AURA_FLAG_NEED_CRITTERS | AURA_FLAG_IGNORE_ADMINS);
        findCritters = FIND_LIFE;
        break;

    case AURA_KILL_NPC:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK_SIMPLE | AURA_FLAG_NEED_CRITTERS);
        findCritters = FIND_LIFE | FIND_ONLY_NPC;
        break;

    case AURA_KILL_PLAYER:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK_SIMPLE | AURA_FLAG_NEED_CRITTERS | AURA_FLAG_IGNORE_ADMINS);
        findCritters = FIND_LIFE | FIND_ONLY_PLAYERS;
        break;

    case AURA_SKIN_RANDOM:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK | AURA_FLAG_NEED_CRITTERS);
        #ifdef __DEBUG__
        findCritters = FIND_LIFE;
        #endif
        #ifndef __DEBUG__
        findCritters = FIND_LIFE | FIND_ONLY_PLAYERS;
        #endif
        break;

    case AURA_SKIN_RESET:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK_SIMPLE | AURA_FLAG_NEED_CRITTERS | AURA_FLAG_IGNORE_ADMINS);
        #ifdef __DEBUG__
        findCritters = FIND_LIFE;
        #endif
        #ifndef __DEBUG__
        findCritters = FIND_LIFE | FIND_ONLY_PLAYERS;
        #endif
        break;

    case AURA_GOLGOTHA:
    case AURA_FOREST:
        break;

    case AURA_SNOWQUEEN:
        SETFLAG(flags, AURA_FLAG_NEED_CRITTERS | AURA_FLAG_IGNORE_ADMINS);
        findCritters = FIND_LIFE;
        pulse = REAL_SECOND(5);
        break;

    case AURA_GRAVITATION_WELL:
        SETFLAG(flags, AURA_FLAG_KNOCKBACK | AURA_FLAG_NEED_CRITTERS | AURA_FLAG_IGNORE_ADMINS | AURA_FLAG_GRAVITY_PULL);
        findCritters = FIND_LIFE;
        radius = 20;
        break;

    case AURA_SKIN_RANDOM_SAFE:
        SETFLAG(flags, AURA_FLAG_VISIBLE | AURA_FLAG_KNOCKBACK | AURA_FLAG_NEED_CRITTERS);
        #ifdef __DEBUG__
        findCritters = FIND_LIFE;
        #endif
        #ifndef __DEBUG__
        findCritters = FIND_LIFE | FIND_ONLY_PLAYERS;
        #endif
        break;
		
    default:
        SETFLAG(flags, AURA_FLAG_VISIBLE);
        break;
    }

    array<Critter@> crits;
    if(FLAG(flags, AURA_FLAG_NEED_CRITTERS))
    {
        foundCritters = map.GetCrittersHex(cr.HexX, cr.HexY, radius, findCritters, crits);
        for(uint c = 0; c < foundCritters; c++)
        {
            if(crits[c].Id == cr.Id)
            {
                crits.removeAt(c);
                foundCritters--;
                break;
            }
        }
    }

    if(FLAG(flags, AURA_FLAG_VISIBLE))
    {
        uint16 stepX = cr.HexX;
        uint16 stepY = cr.HexY;

        map.MoveHexByDir(stepX, stepY, 4, radius);
        for(uint8 stepDir = 0; stepDir < 6; stepDir++)
        {
            for(uint step = 0; step < radius; step++)
            {
                map.MoveHexByDir(stepX, stepY, stepDir, 1);
                map.RunEffect(PID_EXPLODE_EMP, stepX, stepY, 0);
            }
        }

        if(foundCritters > 0)
            map.RunEffect(PID_EXPLODE_EMP, cr.HexX, cr.HexY, CLAMP(foundCritters / radius, 0, radius - 1));
    }

    if(FLAG(flags, AURA_FLAG_NEED_CRITTERS))
    {
        int[] knock = { ANIM2_DEAD_BURN, ANIM2_DEAD_PULSE };
        int[] death = { ANIM2_DEAD_PULSE, ANIM2_DEAD_PULSE_DUST, ANIM2_DEAD_BURN, ANIM2_DEAD_BURN_RUN  };

        for(uint c = 0; c < foundCritters; c++)
        {
            if(!valid(crits[c]))
                continue;

            if(crits[c].IsPlayer() && FLAG(flags, AURA_FLAG_IGNORE_ADMINS) && crits[c].GetAccess() == ACCESS_ADMIN)
                continue;

            if(!GodOfTheRealm(crits[c].Id))
            {
                if(FLAG(flags, AURA_FLAG_KNOCKBACK) || FLAG(flags, AURA_FLAG_KNOCKBACK_SIMPLE) || FLAG(flags, AURA_FLAG_GRAVITY_PULL))
                {
                    uint16 knockbackX = cr.HexX, knockbackY = cr.HexY;
                    if(FLAG(flags, AURA_FLAG_GRAVITY_PULL))
                        map.GetHexCoordWall(crits[c].HexX, crits[c].HexY, knockbackX, knockbackY, 0.0f, Random(radius, radius * 2) - (crits[c].Param[ST_STRENGTH] / 4));
                    else
                        map.GetHexCoordWall(crits[c].HexX, crits[c].HexY, knockbackX, knockbackY, (Random(180 - Random(0, 25), 180 + Random(0, 25))), Random(radius, radius * 2) - (crits[c].Param[ST_STRENGTH] / 4));

                    map.PlaySound("was1xxx" + Random(1, 2), crits[c].HexX, crits[c].HexY, 5);
                    map.RunEffect(PID_EXPLODE_EMP, crits[c].HexX, crits[c].HexY, 0);

                    if(FLAG(flags, AURA_FLAG_KNOCKBACK_SIMPLE))
                        crits[c].ToKnockout(0, 0, 0, 0, knockbackX, knockbackY);
                    else
                        crits[c].ToKnockout(knock[Random(0, knock.length() - 1)], ANIM2_DEAD_PRONE_FRONT, ANIM2_STANDUP_FRONT, crits[c].Param[ST_ACTION_POINTS] - Random(0, crits[c].Param[ST_LUCK] / 2), knockbackX, knockbackY);
                }


                if(aura == AURA_KILL_ALL || aura == AURA_KILL_NPC || aura == AURA_KILL_PLAYER)
                {
                    crits[c].ToDead(death[Random(0, death.length() - 1)], null);
                }
                else if(aura == AURA_SKIN_RANDOM)
                {
                    // ??? how to get enabled crtypes list without warnings flood ???
                    // no idea, enabled for pre-wipe anyway

                    uint skin = Random(1, 134);
                    if(crits[c].ChangeCrType(skin))
                    {
                        crits[c].ParamBase[ST_BASE_CRTYPE] = skin;
                        crits[c].DisguisedBy = cr.Id;
                    }
                }
                else if(aura == AURA_SKIN_RESET)
                {
                    bool  isMale = (crits[c].ParamBase[ST_GENDER] == GENDER_MALE);
                    uint  baseType = (isMale ? CRTYPE_MALE_DEFAULT : CRTYPE_FEMALE_DEFAULT);
                    uint  crType = baseType;

                    Item@ armor = crits[c].GetItem(0, SLOT_ARMOR);
                    if(valid(armor))
                    {
                        switch(GetCritterAnimType(crType))
                        {
                        case ANIM_TYPE_FALLOUT:
                            crType = (isMale ? armor.Proto.Armor_CrTypeMale : armor.Proto.Armor_CrTypeFemale);
                            break;
                        }
                    }

                    crits[c].ChangeCrType(crType);
                    crits[c].ParamBase[ST_BASE_CRTYPE] = baseType;
                    crits[c].DisguisedBy = 0;
                }
                else if(aura == AURA_SNOWQUEEN)
                {
                    if(crits[c].IsPlayer())
                        crits[c].RunClientScript("client_timeouts@_add_unsafe", 30, 0, 0, "Frozen", null);

                    MapMessageEx(FLOAT_ENFORCED, FLOAT_MODE_ALL, crits[c], "frozen", crits[c].HexX, crits[c].HexY, 255, COLOR_RGB(255, 255, 255), true, -50, 50, -20, -50);
                    crits[c].Wait(30000);
                }
            }
        }
    }
    else     // !FLAG( flags, AURA_FLAG_NEED_CRITTERS ))
    {
        array<Item@> items;
        {
            array<Item@> tempItems;
            int          foundItems = map.GetItems(cr.HexX, cr.HexY, radius, PID_UNVISIBLE_BLOCK, tempItems);
            for(int i = 0; i < foundItems; i++)
            {
                if(tempItems[i].Val8 == SPECIAL_ITEM_AURA)
                    items.insertLast(tempItems[i]);
            }
        }

        if(items.length() >= radius * 2)
            return(REAL_SECOND(1));

        if(aura == AURA_GOLGOTHA)
        {
            Item@ stake = map.AddItem(cr.HexX + Random(-radius, radius), cr.HexY + Random(-radius, radius), PID_UNVISIBLE_BLOCK, 1);
            if(valid(stake))
            {
                int num = Random(1, 12);
                stake.PicMap = GetStrHash("art\\scenery\\stake" + (num < 10 ? "0" : "") + num + ".frm");
                stake.PicInv = GetStrHash("art\\scenery\\stake" + (num < 10 ? "0" : "") + num + ".frm");
                stake.Val8 = SPECIAL_ITEM_AURA;
                _SetSpawner(stake, cr);                // it's never legit ;)
                stake.Update();
            }
        }
        else if(aura == AURA_FOREST)
        {
            Item@ tree = map.AddItem(cr.HexX + Random(-radius, radius), cr.HexY + Random(-radius, radius), PID_UNVISIBLE_BLOCK, 1);
            if(valid(tree))
            {
                int num = Random(1, 11);
                tree.PicMap = GetStrHash("art\\scenery\\tree" + num + ".frm");
                tree.PicInv = GetStrHash("art\\scenery\\tree" + num + ".frm");
                tree.Val8 = SPECIAL_ITEM_AURA;
                _SetSpawner(tree, cr);                // it's never legit ;)
                tree.Update();
            }
        }
    }

    cr.RefreshVisible();
    return(pulse);
}

void ExecAuraCleanupCommand(array<string@>@ command, Critter@ player)
{
    Map@ map = player.GetMap();
    if(!valid(map))
    {
        player.Say(SAY_NETMSG, "Not on worldmap.");
        return;
    }

    array<Item@> items;
    uint         count = map.GetItems(PID_UNVISIBLE_BLOCK, items);
    uint         deleted = 0;
    for(uint i = 0; i < count; i++)
    {
        if(items[i].Val8 == SPECIAL_ITEM_AURA)
        {
            DeleteItem(items[i]);
            deleted++;
        }
    }

    player.Say(SAY_NETMSG, "Removed " + deleted + " item" + (deleted > 1 ? "s" : ""));
}

// GM Events

void ExecSetGMEvent(array<string@>@ command, Critter& player)
{
	if(command.length() < 4 || command.length() > 5)
    {
        player.Say(SAY_NETMSG, "USAGE: `setgmevent <event_type> <time_in_minutes> <multipler>.");
		player.Say(SAY_NETMSG, "Event type: multiexp - setting up global multipler to experience points (2-10)");
		player.Say(SAY_NETMSG, "Event type: multiexpkill - setting up multipler to experience points, for killing only (2-10)");
		player.Say(SAY_NETMSG, "Event type: multiexpcaravans - setting up multipler to experience points, for finishing caravans only (2-10)");
		player.Say(SAY_NETMSG, "Time: How long event will be (in minutes)");
		player.Say(SAY_NETMSG, "Multipler: Multipler vaule for earned experience points");
        return;
    }
	
	uint8 multipler = 1;
	uint eventtype;
	uint eventtime = 1;
	string eventname;
	
	if(StrToInt(command[3], eventtime))
		{
			if(eventtime < 1)
			{
				player.Say(SAY_NETMSG, "Event can't take less than 1 minute!");
				return;	
			}
		}
	
	if(StrToInt(command[4], multipler))
		{
			if(multipler < 2 || multipler > 10)
			{
				player.Say(SAY_NETMSG, "Multipler can't be less than 2 and greater than 10!");
				return;	
			}
		}
	
	if(command[2] == "multiexp")
		{
			eventtype = GM_EVENT_MULTIEXP_GLOBAL;
			eventname = "Multi experience (x" + multipler + ") event for %COUNTDOWN_HUMAN%.";
			if(GetGvar(GVAR_experience_multipler) == 1)
			{
				SetGvar(GVAR_experience_multipler, multipler);
			}
			else
			{
				player.Say(SAY_NETMSG, "There's allready this event.");
				return;
			}
		}
	
	if(command[2] == "multiexpkill")
		{
			eventtype = GM_EVENT_MULTIEXP_KILL;
			eventname = "Multi experience (x" + multipler + ") for killing event for %COUNTDOWN_HUMAN%.";
			if(GetGvar(GVAR_experience_multipler_kill) == 1)
			{
				SetGvar(GVAR_experience_multipler_kill, multipler);
			}
			else
			{
				player.Say(SAY_NETMSG, "There's allready this event.");
				return;
			}
		}
	
	if(command[2] == "multiexpcaravans")
			{
			eventtype = GM_EVENT_MULTIEXP_CARAVANS;
			eventname = "Multi experience (x" + multipler + ") for finishing caravans event for %COUNTDOWN_HUMAN%.";
			if(GetGvar(GVAR_experience_multipler_caravans) == 1)
			{
				SetGvar(GVAR_experience_multipler_caravans, multipler);
			}
			else
			{
				player.Say(SAY_NETMSG, "There's allready this event.");
				return;
			}
		}
	CreateTimeEvent(AFTER(REAL_MINUTE(eventtime)), "_erasegmevent", eventtype, false);
	ServerEventCNTSet(eventname, 0, eventtype, REAL_MINUTE(eventtime));
}

// adds to ExecSetGMEvent

uint _erasegmevent(array<uint>@ eventtype)
{
	switch(eventtype[0])
	{
		case GM_EVENT_MULTIEXP_GLOBAL: SetGvar(GVAR_experience_multipler, 1); break;
		case GM_EVENT_MULTIEXP_KILL: SetGvar(GVAR_experience_multipler_kill, 1); break;
		case GM_EVENT_MULTIEXP_CARAVANS: SetGvar(GVAR_experience_multipler_caravans, 1); break;
	}
	
	return 0;
}

void ExecEvPonyAttack(array<string@>@ command, Critter& player)
{
	//What commands?
	//Where to spawn hexX, hexY
	//attack players, npcs, all
	//how many attacks, if 0 then infinite
	if(command.length() < 5 || command.length() > 6)
	{
        player.Say(SAY_NETMSG, "USAGE: `ev-ponyattack <hexX> <hexY> <targets> <howmanyattacks>.");
		player.Say(SAY_NETMSG, "<hexX> <hexY>: Coordinates to spawn.");
		player.Say(SAY_NETMSG, "Targets: players, npcs, all");
		player.Say(SAY_NETMSG, "How many attacks: Before go out. If 0 then infinite.");
        return;
    }
	
	uint16 hexX = 0, hexY = 0, howmanyattacks = 0;
	
	if(!StrToInt(command[2], hexX) || !StrToInt(command[3], hexY))
	{
		player.Say(SAY_NETMSG, "Incorrect coordinates.");
		return;
	}
	
	uint8 findtypes;
	if(command[4] != "players" && command[4] != "npcs" && command[4] != "all")
	{
		player.Say(SAY_NETMSG, "Incorrect targets.");
		return;
	}
	else if(command[4] == "players")
	{
		findtypes = 1;
	}
	else if(command[4] == "npcs")
	{
		findtypes = 2;
	}
	else if(command[4] == "all")
	{
		findtypes = 0;
	}
	
	if(!StrToInt(command[5], howmanyattacks))
	{
		player.Say(SAY_NETMSG, "Incorrect number of attacks.");
		return;
	}
	else
	{
		howmanyattacks = CLAMP(howmanyattacks, 0, 1000);
	}
	
	if(howmanyattacks > 0)
	{
		player.Say(SAY_NETMSG, "Now spawning attack of the ponies for " + howmanyattacks + " attacks. They will look for " + command[4] + "...");
	}
	else
	{
		player.Say(SAY_NETMSG, "Now spawning attack of the ponies for infinite attacks. They will look for " + command[5] + "...");
	}
	
	//What we are need?
	//Pony commander (new proto) pid 902
	//Pony soldier (same proto) pid 902
	//Howitzer (an item, not scenery, add new proto) pid 25468
	
	//Scenario:
	//Spawn howitzer with two ponies
	//{Commander: Load a bullet for a howitzer...
	//AFTER 1 second Run anim for pony-slodier
	//After 3-10 seconds: Commander: Fire!
	//AFTER 1 second Run anim for pony-slodier
	//ExplodeEx(map, 100, 41, PID_EXPLODE_ROCKET, radius, Random(1000, 2000), DAMAGE_EXPLODE, 3, 0, 0);
	//}repeat few times
	
	Map@ map = player.GetMap();
	if(!valid(map))
	{
		player.Say(SAY_NETMSG, "You're not on valid map.");
		return;
	}
	
	Item@ Howitzer = map.AddItem(hexX, hexY, PID_HOWITZER_ITEM, 1);
	
	Critter@ Commander = map.AddNpc(902, hexX - 4, hexY + 1, 4, null, null, null);
	Critter@ Soldier = map.AddNpc(902, hexX, hexY + 1, 5, null, null, null);
	
	array<uint> ponyattack = { map.Id , Commander.Id, Soldier.Id , Howitzer.Id , findtypes , howmanyattacks, 0 , 0 , 0};
	CreateTimeEvent(AFTER(REAL_SECOND(5)), "e_PonyPrepareAttack", ponyattack, false);
	
	//When one pony is dead or ko
	//Delete ponies
	//Delete Howitzer
}

uint e_PonyPrepareAttack(array<uint>@ ponyattack) //reload
{
	Critter@ Commander = GetCritter(ponyattack[1]);
	if(!valid(Commander))
		return 0;
	
	Critter@ Soldier = GetCritter(ponyattack[2]);
	if(!valid(Soldier))
		return 0;
		
	Item@ Howitzer = GetItem(ponyattack[3]);
	if(!valid(Howitzer))
		return 0;
	
	if(Commander.IsDead() && Soldier.IsDead())
		return REAL_SECOND(Random(15 , 60));
		
	if(Commander.IsDead())
	{
		Soldier.Say(SAY_NORM_ON_HEAD, "Waiting for commands...");
		return REAL_SECOND(Random(15 , 60));
	}
	
	if(Soldier.IsDead())
	{
		Commander.Say(SAY_NORM_ON_HEAD, "Wake up pony-soldier! Don't pretend you are dead...");
		return REAL_SECOND(Random(15 , 60));
	}
	
	Commander.Say(SAY_NORM_ON_HEAD, "Load a bullet for a howitzer!");
		
	Soldier.Animate(ANIM1_UNARMED, ANIM2_USE, Howitzer, true, true);
	
	CreateTimeEvent(AFTER(REAL_SECOND(Random(2,5))), "e_PonyFire", ponyattack, false);
	
	return 0;
}

uint e_PonyFire(array<uint>@ ponyattack) //fire command
{
	Map@ map = GetMap(ponyattack[0]);
	if(!valid(map))
		return 0;
		
	Critter@ Commander = GetCritter(ponyattack[1]);
	if(!valid(Commander))
		return 0;
		
	Critter@ Soldier = GetCritter(ponyattack[2]);
	if(!valid(Soldier))
		return 0;
		
	array<Critter@> crits;
	switch(ponyattack[4])
	{
		case 0: map.GetCritters(0, FIND_LIFE_AND_KO, crits); break;
		case 1: map.GetCritters(0, FIND_LIFE_AND_KO | FIND_ONLY_PLAYERS, crits); break;
		case 2: map.GetCritters(0, FIND_LIFE_AND_KO | FIND_ONLY_NPC, crits); break;
	}
	
	if((crits.length() == 0 && ponyattack[4] == 1) || //No players found
	(crits.length() == 2 && (ponyattack[4] == 0 || ponyattack[4] == 2))) //No npcs found (only ponys)
	{	
		Commander.Say(SAY_NORM_ON_HEAD, "Damn... No targets...");
		Soldier.Say(SAY_NORM_ON_HEAD, ":(");
		return REAL_SECOND(Random(15 , 60));
	}
	else
	{
		uint16 randomindex;
		
		do
		{
			randomindex = Random(0, crits.length() -1);
		}while(crits[randomindex].GetProtoId() == 902);
		
		if(!valid(crits[randomindex]))
			return 0;
		ponyattack[7] = crits[randomindex].HexX;
		ponyattack[8] = crits[randomindex].HexY;
	}
		
	Commander.Say(SAY_SHOUT_ON_HEAD, "FIRE!");
		
	Item@ Howitzer = GetItem(ponyattack[3]);
	if(!valid(Howitzer))
		return 0;
	
	Soldier.Animate(ANIM1_UNARMED, ANIM2_USE, Howitzer, true, true);
	
	CreateTimeEvent(AFTER(REAL_SECOND(1)), "e_PonyExplode", ponyattack, false);
	
	
	return 0;
}

uint e_PonyExplode(array<uint>@ ponyattack) //explode
{
	
	Map@ map = GetMap(ponyattack[0]);
	if(!valid(map))
		return 0;
	
	ExplodeEx(map, ponyattack[7], ponyattack[8], PID_EXPLODE_ROCKET, Random(3,4) , Random(100, 200), DAMAGE_EXPLODE, 3, ponyattack[1], 0);
	
	ponyattack[6]++;
	
	if(ponyattack[5] == ponyattack[6])
		CreateTimeEvent(AFTER(REAL_SECOND(5)), "e_PonyDelete", ponyattack, false);
	else
		CreateTimeEvent(AFTER(REAL_SECOND(5)), "e_PonyPrepareAttack", ponyattack, false);
	
	return 0;
}

uint e_PonyDelete(array<uint>@ ponyattack) //removing
{
	Critter@ Commander = GetCritter(ponyattack[1]);
	if(valid(Commander)) 
		DeleteNpc(Commander);
	
	Critter@ Soldier = GetCritter(ponyattack[2]);
	if(valid(Soldier))
		DeleteNpc(Soldier);
		
	Item@ Howitzer = GetItem(ponyattack[3]);
	if(valid(Howitzer))
		DeleteItem(Howitzer);
		
	return 0;
}

void ExecEraseTimeEventCommand(array<string@>@ command, Critter& player)
{
	int indx = 0;
	
	if(command.length < 3)
	{
		player.Say(SAY_NETMSG, "Missing TimeEvent's ID argument!");
		return;
	}
	if(command.length > 3)
	{
		player.Say(SAY_NETMSG, "Too many arguments!");
		return;
	}
	if(!StrToInt(command[2], indx))
	{
		player.Say(SAY_NETMSG, "Bad argument! Give TimeEvent's ID!");
		return;
	}
	if(indx <= 0)
	{
		player.Say(SAY_NETMSG, "Bad argument! TimeEvent's ID must be greater than 0!");
		return;
	}
	
	uint duration = 0;
	array<uint> UINTvalues;
	array<int> INTvalues;
	
	if(GetTimeEvent(uint(indx), duration, UINTvalues) || GetTimeEvent(uint(indx), duration, INTvalues))
	{
		string resultstring = "Found TimeEvent's values: ";
		
		if(UINTvalues.length > 0)
		{
			for(uint i = 0; i < UINTvalues.length(); i++)
			{
				if(i == 0)
					resultstring = resultstring + UINTvalues[i];
				else
					resultstring = resultstring + ", " + UINTvalues[i];
			}
			resultstring += "...";
		}
		
		if(INTvalues.length > 0)
		{
			for(uint i = 0; i < INTvalues.length(); i++)
			{
				if(i == 0)
					resultstring = resultstring + INTvalues[i];
				else
					resultstring = resultstring + ", " + INTvalues[i];
			}
			resultstring += "...";
		}
		
		if(UINTvalues.length == 0 && INTvalues.length == 0)
			resultstring = "No TimeEvent's values found...";
		
		player.Say(SAY_NETMSG, resultstring);
		player.Say(SAY_NETMSG, "Erasing TimeEvent: " + indx + "...");
		EraseTimeEvent(uint(indx));
	}
	else
	{
		player.Say(SAY_NETMSG, "Can't found TimeEvent with index " + indx + "...");
	}
}
void ExecEraseAllEventCommand(array<string@>@ command, Critter& player)
{
	for(uint i = 0; i < 100000000; i++)
			{
			EraseTimeEvent(i);
			}
}
void ExecGiveLevelBookCommand(array<string@>@ command, Critter& player)
{
	int level = 0;
	
	if(command.length < 3)
	{
		player.Say(SAY_NETMSG, "Missing number of levels argument!");
		return;
	}
	if(command.length > 3)
	{
		player.Say(SAY_NETMSG, "Too many arguments!");
		return;
	}
	if(!StrToInt(command[2], level))
	{
		player.Say(SAY_NETMSG, "Bad argument! Give number of levels!");
		return;
	}
	if(level <= 1)
	{
		player.Say(SAY_NETMSG, "Bad argument! Number of levels must be greater than 1!");
		return;
	}
	
	player.Say(SAY_NETMSG, "Preapring the long story...");
	
	Item@ hintbook = player.AddItem(PID_BOOK_OF_ACHIEVEMENT, 1);
	hintbook.Val0 = level-1;
	hintbook.Val2 = level;
	uint16 chapters = level - 1;
	
	SetLexem(hintbook, "$writtenby", player.Name + ", the one and only...");
	
	player.Say(SAY_NETMSG, "Story with " + chapters + " " + (chapters > 1 ? "chapters" : "chapter") + " is ready to read... It's very unique and has " + player.Name + "'s autograph...");
}

void ExecAddBanCommand(array<string@>@ command, Critter& player)
{
	int critId = 0, hours = 0, withip = 0;
	
	if(command.length < 6)
	{
		player.Say(SAY_NETMSG, "Missing arguments!");
		player.Say(SAY_NETMSG, "USAGE: `addban <player.Id> <withip/withoutip> <hours (0 for permban)> <reasonwhy>");
		return;
	}
	/*if(command.length > 6)
	{
		player.Say(SAY_NETMSG, "Too many arguments!");
		return;
	}*/
	if(!StrToInt(command[2], critId))
	{
		player.Say(SAY_NETMSG, "Bad argument! Give Player's ID!");
		return;
	}
	
	if(critId <= 0)
	{
		player.Say(SAY_NETMSG, "Bad argument! Player's ID must be greater than 0!");
		return;
	}
	
	if(command[3] != "withip" && command[3] != "withoutip")
	{
		player.Say(SAY_NETMSG, "Bad argument! Use withip or withoutip suffix.");
		return;
	}
	
	if(command[3] == "withip") withip = 1;
	else if(command[3] == "withoutip") withip = 0;
	
	if(!StrToInt(command[4], hours))
	{
		player.Say(SAY_NETMSG, "Bad argument! Give number of levels!");
		return;
	}
	
	if(hours <= -1)
	{
		player.Say(SAY_NETMSG, "Bad argument! Hours must be greater than 0!");
		return;
	}
	
	string reason = command[5];
	
	for(uint8 i = 6; i < command.length(); i++)
	{
		reason = reason + " " + command[i];
	}
	
	AddBan(player, critId, withip, hours, reason);
}

void ExecBanListCommand(array<string@>@ command, Critter& player)
{
	ShowBanList(player);
}

void ExecRemoveBanCommand(array<string@>@ command, Critter& player)
{
	int critId = 0;
	
	if(command.length < 3)
	{
		player.Say(SAY_NETMSG, "Missing arguments!");
		player.Say(SAY_NETMSG, "USAGE: `removeban <player.Id>");
		return;
	}
	if(command.length > 3)
	{
		player.Say(SAY_NETMSG, "Too many arguments!");
		return;
	}
	if(!StrToInt(command[2], critId))
	{
		player.Say(SAY_NETMSG, "Bad argument! Give Player's ID!");
		return;
	}
	
	RemoveBan(player, critId);
}

void ExecSetEventWithSmthngCommand(Critter& player, uint8 kindofevent)
{
	Map@ map = player.GetMap();
	
	if(!valid(map))
	{
		player.Say(SAY_NETMSG, "You can't run this event here!");
		return;
	}
	
	if(!_MapHasMode(map, MAP_MODE_NO_GRIDS) && kindofevent != 0)
	{
		ExecMapGrids(player, false);
		/*player.Say(SAY_NETMSG, "Setting loop time to 5 seconds!");
		map.SetLoopTime(3, 5000);*/
	}
	else if(_MapHasMode(map, MAP_MODE_NO_GRIDS))
	{
		player.Say(SAY_NETMSG, "Grids are already disabled.");
		/*player.Say(SAY_NETMSG, "Setting loop time to 5 seconds!");
		map.SetLoopTime(3, 5000);*/
	}
	
	if(kindofevent == 0)
	{
		
		if(_MapHasMode(map, MAP_MODE_NO_GRIDS))
		{
			player.Say(SAY_NETMSG, "Grids are still disabled - enable it manually if needed!");
			/*player.Say(SAY_NETMSG, "Setting default loop time!");
			map.SetLoopTime(3, uint(-1));*/
		}
		else if(!_MapHasMode(map, MAP_MODE_NO_GRIDS))
		{
			player.Say(SAY_NETMSG, "Grids are already enabled.");
			/*player.Say(SAY_NETMSG, "Setting default loop time!");
			map.SetLoopTime(3, uint(-1));*/
		}
		
		if(_MapHasMode(map, MAP_MODE_EVENT_WITH_CAR))
		{
			_MapUnsetMode(map, MAP_MODE_EVENT_WITH_CAR);
			player.Say(SAY_NETMSG, "Event with car is disabled!");
		}
		
		if(_MapHasMode(map, MAP_MODE_EVENT_WITH_ITEM))
		{
			_MapUnsetMode(map, MAP_MODE_EVENT_WITH_ITEM);
			player.Say(SAY_NETMSG, "Event with item is disabled!");
		}
		
		if(_MapHasMode(map, MAP_MODE_EVENT_WITH_MOBS))
		{
			_MapUnsetMode(map, MAP_MODE_EVENT_WITH_MOBS);
			player.Say(SAY_NETMSG, "Event with mobs is disabled!");
		}
	}
	
	if(_MapHasMode(map, MAP_MODE_EVENT_WITH_CAR))
	{
		player.Say(SAY_NETMSG, "Event with car is already setted up!");
	}
	else if(kindofevent == 1)
	{
		_MapSetMode(map, MAP_MODE_EVENT_WITH_CAR);
		player.Say(SAY_NETMSG, "Event with car is enabled!");
	}
	
	if(_MapHasMode(map, MAP_MODE_EVENT_WITH_ITEM))
	{
		player.Say(SAY_NETMSG, "Event with item is already setted up!");
	}
	else if(kindofevent == 2)
	{
		_MapSetMode(map, MAP_MODE_EVENT_WITH_ITEM);
		player.Say(SAY_NETMSG, "Event with item is enabled!");
	}
	
	if(_MapHasMode(map, MAP_MODE_EVENT_WITH_MOBS))
	{
		player.Say(SAY_NETMSG, "Event with mobs is already setted up!");
	}
	else if(kindofevent == 3)
	{
		_MapSetMode(map, MAP_MODE_EVENT_WITH_MOBS);
		player.Say(SAY_NETMSG, "Event with mobs is enabled!");
	}
}

void ExecEvTrader(array<string@>@ command, Critter& player)
{
	int npcId = 0, itemPID = 0;
	
	if(command.length < 4)
	{
		player.Say(SAY_NETMSG, "Missing arguments!");
		player.Say(SAY_NETMSG, "USAGE: `ev-trader <npc.Id> <itemPID>");
		return;
	}
	
	if(command.length > 4)
	{
		player.Say(SAY_NETMSG, "Too many arguments!");
		player.Say(SAY_NETMSG, "USAGE: `ev-trader <npc.Id> <itemPID>");
		return;
	}
	
	if(!StrToInt(command[2], npcId))
	{
		player.Say(SAY_NETMSG, "Bad argument! Give NPC's ID!");
		return;
	}
	
	if(npcId <= 0)
	{
		player.Say(SAY_NETMSG, "Bad argument! NPC's ID must be greater than 0!");
		return;
	}
	
	Critter@ trader = GetCritter(npcId);
	if(!valid(trader))
	{
		player.Say(SAY_NETMSG, "Couldn't find this trader!");
		return;
	}
	
	if(_CritHasMode(trader, MODE_NO_BARTER))
	{
		player.Say(SAY_NETMSG, "Players can't make any deal with this NPC!");
		return;
	}
	
	if(!_CritHasMode(trader, MODE_NO_STEAL))
	{
		player.Say(SAY_NETMSG, "Players will be able to steal this item from NPC!");
		//return;
	}
	
	if(!_CritHasMode(trader, MODE_NO_LOOT))
	{
		player.Say(SAY_NETMSG, "Players will be able to loot this item from NPC!");
		//return;
	}
	
	if(_CritHasMode(trader, MODE_NO_TALK))
	{
		player.Say(SAY_NETMSG, "Players can't talk with this NPC!");
		return;
	}
	
	if(!StrToInt(command[3], itemPID))
	{
		player.Say(SAY_NETMSG, "Bad argument! Give item's PID!");
		return;
	}
	
	if(itemPID <= 0)
	{
		player.Say(SAY_NETMSG, "Bad argument! Item's PID must be greater than 0!");
		return;
	}
	
	array<uint> traderdata = { npcId , 1 , itemPID };
	CreateTimeEvent(AFTER(0), "trader@e_SpecialItemEvent", traderdata, false);
}

void ExecSetMapEventCommand(uint8 eventtype, uint8 eventindx, Critter& player)
{
	Map@ map = player.GetMap();
	if(!valid(map))
	{
		player.Say(SAY_NETMSG,"You can't set this event to global map.");
		return;
	}
	switch(eventtype)
	{
		case MAP_EVENT_OUT_CRITTER:
			switch(eventindx)
			{
				case 0: 
					map.SetEvent(MAP_EVENT_OUT_CRITTER, null);
					player.Say(SAY_NETMSG, "Removed critter out event on this map.");
					break;
				case 1:
					map.SetEvent(MAP_EVENT_OUT_CRITTER, "_RemoveItems");
					player.Say(SAY_NETMSG, "All items from players who will leave this map will be removed!");
					break;
				default: player.Say(SAY_NETMSG, "Unknown map event function.");
			}
		break;
		default: player.Say(SAY_NETMSG, "Unknown map event.");
	}
}

void ExecSetColorCommand(array<string@>@ command, Critter& player)
{
	//117440512 + (r * 64) + (g * 32) + b
	//Set default values:
	int r = 0, g = 0, b = 0, /*lightDay = 2,*/ intens =  30, radius = 0, itemId = 0;
	bool MakeLight = false;
    string[] sitem = { "-i", "-item" };

    if(StrToInt(GetParameterString(command, sitem), itemId))
    {
        Item@ item = FindItem(player, itemId);
        if(valid(item))
        {
            int arg = 0;
            string[] red = { "-r", "-red" };
			string[] green = { "-g", "-green" };
			string[] blue = { "-b", "-blue" };
            //string[] lday = { "-ld", "-lightday" };
            string[] intensity = { "-int", "-intens" };
            string[] rad = { "-rad", "-radius" };
			//string[] light = { "-l", "-light" };
			
			cheatGetOption(command, MakeLight, "-light");
						
			if(StrToInt(GetParameterString(command, red), arg))
				if(arg < 0 || arg > 255) player.Say(SAY_NETMSG, "Range of red color: 0 - 255");
				else r = arg;
			
			if(StrToInt(GetParameterString(command, green), arg))
				if(arg < 0 || arg > 255) player.Say(SAY_NETMSG, "Range of green color: 0 - 255");
				else g = arg;
				
			if(StrToInt(GetParameterString(command, blue), arg))
				if(arg < 0 || arg > 255) player.Say(SAY_NETMSG, "Range of red color: 0 - 255");
				else b = arg;
				
			item.LightColor = /*117440512*/ COLOR_RGB(r, g, b);
			player.Say(SAY_NETMSG, "New color red <" + r + ">, green <" + g + "> and blue <" + b + "> is applied to item <" + item.Id +">.");
			
            /*if(StrToInt(GetParameterString(command, lday), arg))
                lightDay = arg;*/
            if(StrToInt(GetParameterString(command, intensity), arg))
                intens = arg;
            if(StrToInt(GetParameterString(command, rad), arg))
                radius = arg;
			
			item.LightIntensity = intens;
			item.LightDistance = radius;
			//( mobj->LightDirOff | ( ( mobj->LightDay & 3 ) << 6 ) )
			
			if(!FLAG(item.Flags, ITEM_LIGHT))
				SETFLAG(item.Flags, ITEM_LIGHT);
			//if(!FLAG(item.LightFlags,(1 | ((lightDay & 3) << 6 ))))
				//SETFLAG(item.LightFlags,(1 | ((lightDay & 3) << 6 )));
			if(!_LightIsInverse(item) && !MakeLight)
				_LightSetInverse(item);
			
			if(_LightIsInverse(item) && MakeLight)
				_LightUnsetInverse(item);

            item.Update();
        }
        else
        {
            player.Say(SAY_NETMSG, "Item not found. ");
            return;
        }
    }
    else
	{
        player.Say(SAY_NETMSG, "Missing -i argument.");
		return;
	}
}

void ExecSpawnGMSpawnerCommand(array<string@>@ command, Critter& player)
{
	Map@ map = player.GetMap();
	if(!valid(map))
	{
		player.Say(SAY_NETMSG, "You can't spawn it at global map.");
		return;
	}
	
	array<uint16> defaultLockers = { 42 , 43 , 128 , 139 , 188 , 189 , 197 , 204 , 245 , 367 , 370 , 501 , 502 , 22139 , 22140 , 22442 , 22447 , 22567 , 22568 , 22990 , 22399 , 22400 };
	int kind = Random(69, 84), x = player.HexX, y = player.HexY, pid = defaultLockers[Random(0, defaultLockers.length() - 1)];
	bool smallGuns = false, bigGuns = false, energyWeapons = false, closeCombat = false, armors = false, bonusLow = false, bonusHigh = false, ammunition = false;
	string whatspawner = "random", whatbonus = "no";
	
	
	
	StrToInt(GetParameterString(command, "-x"), x);
    StrToInt(GetParameterString(command, "-y"), y);
	
	StrToInt(GetParameterString(command, "-pid"), pid);
	ProtoItem@ protoId = GetProtoItem(pid);
	if(protoId.Type != ITEM_TYPE_CONTAINER)
	{
		player.Say(SAY_NETMSG, "This is not container.");
		return;
	}
	
	StrToInt(GetParameterString(command, "-v"), kind);
	if(kind < 0) //Min val4
	{
		player.Say(SAY_NETMSG, "Value4 can't be lower than 0.");
		return;
	}
	
	if(kind > 94) //Max val4
	{
		player.Say(SAY_NETMSG, "Value4 can't be higher than 94.");
		return;
	}
	
	cheatGetOption(command, smallGuns, "-sg");
	cheatGetOption(command, bigGuns, "-bg");
	cheatGetOption(command, energyWeapons, "-ew");
	cheatGetOption(command, closeCombat, "-cc");
	cheatGetOption(command, armors, "-arm");
	cheatGetOption(command, bonusLow, "-low");
	cheatGetOption(command, bonusHigh, "-high");
	cheatGetOption(command, ammunition, "-ammo");
	
	if(smallGuns)
	{
		whatspawner = "small guns";
		if(bonusLow) kind = 75;
		else if(bonusHigh) kind = 80;
		else kind = 69;
	}
	else if(bigGuns)
	{
		whatspawner = "big guns";
		if(bonusLow) kind = 76;
		else if(bonusHigh) kind = 81;
		else kind = 70;
	}
	else if(energyWeapons)
	{
		whatspawner = "energy weapons";
		if(bonusLow) kind = 77;
		else if(bonusHigh) kind = 82;
		else kind = 71;
	}
	else if(closeCombat)
	{
		whatspawner = "melee weapons";
		if(bonusLow) kind = 78;
		else if(bonusHigh) kind = 83;
		else kind = 73;
	}
	else if(armors)
	{
		whatspawner = "armors";
		if(bonusLow) kind = 79;
		else if(bonusHigh) kind = 84;
		else kind = 74;
	}
	else if(ammunition)
	{
		whatspawner = "amunition";
		kind = 72;
	}
	else if(bonusLow)
	{
		kind = Random(75, 79);
	}
	else if(bonusHigh)
	{
		kind = Random(80, 84);
	}
	
	if(bonusLow)
	{
		whatbonus = "low";
		
	}
	else if(bonusHigh)
	{
		whatbonus = "high";
	}
	
	player.Say(SAY_NETMSG, "Creating " + whatspawner + " spawner, which will spawn items with " + whatbonus + " bonuses...");
	Item@ spawner = map.AddItem(x, y, pid, 1);
	spawner.Val4 = kind;
	
	spawner.SetScript("item_spawner_container@for_event_init");
	
	player.Say(SAY_NETMSG, "Done. Only Admins and Game Masters can look to it.");
	
}

void ExecSetDeteriorationCommand(array<string@>@ command, Critter& player)
{
	int minTier = 4, maxTier = 4, percent = 1, hours = 12, multipler = 1;
	bool runtime = false;
	
	array<string> min = { "-min" };
	array<string> max = { "-max" };
	array<string> prc = { "-percent" };
	array<string> hrs = { "-hours" };
	array<string> mul = { "-multipler" };
	
	StrToInt(GetParameterString(command, min), minTier);
	StrToInt(GetParameterString(command, max), maxTier);
	StrToInt(GetParameterString(command, prc), percent);
	StrToInt(GetParameterString(command, hrs), hours);
	StrToInt(GetParameterString(command, mul), multipler);
	
	cheatGetOption(command, runtime, "-runtime");
	CLAMP(minTier, 1, 4);
	CLAMP(maxTier, 1, 4);
	CLAMP(percent, 1, 100);
	CLAMP(hours, 1, 48);
	CLAMP(multipler, 1, 10);
	
	if(minTier == 4 || maxTier == 4)
	{
		SetGvar(GVAR_deterioration_T4, multipler);
		player.Say(SAY_NETMSG, "Deterioration's multipler of tier 4: " + multipler + ".");
	}
	else
	{
		player.Say(SAY_NETMSG, "The other tiers than 4 are not implemented here yet.");
		return;
	}
	
	if(runtime)
	{
		array<uint> settings = { minTier, maxTier, percent, hours };
		uint timeEvent = CreateTimeEvent(AFTER(0), "e_ApplyDeterioration", settings, true);
		player.Say(SAY_NETMSG, "Created loop number " + timeEvent +" for every " + hours + " hour" + (hours == 1 ? "" : "s") + ", for tier " + (minTier == maxTier ? "" + minTier : ("range " + minTier + " - " + maxTier)) + " with -" + percent + "%.");
		player.Say(SAY_NETMSG, "To remove loop use following command: `erasetimeevent " + timeEvent);
	}
}

uint e_ApplyDeterioration(array<uint>@ settings)
{
	array<Item@> items;
	
	uint8 percent = settings[2];
	
	// GetAllItems(0, items);
	
	if(settings[0] == 4 || settings[1] == 4)
	{
		GetAllItems(PID_POWER_HELMET, items);
		GetAllItems(PID_APA_HELMET, items);
		GetAllItems(PID_APA_HELMET_MK2, items);
		GetAllItems(PID_HARDENED_POWER_HELMET, items);
		GetAllItems(PID_POWERED_ARMOR, items);
		GetAllItems(PID_HARDENED_POWER_ARMOR, items);
		GetAllItems(PID_ADVANCED_POWER_ARMOR, items);
		GetAllItems(PID_ADVANCED_POWER_ARMOR_MK2, items);
		GetAllItems(PID_PK12_GAUSS_PISTOL, items);
		GetAllItems(PID_M72_GAUSS_RIFLE, items);
		GetAllItems(PID_VINDICATOR_MINIGUN, items);
		GetAllItems(PID_BOZAR, items);
		GetAllItems(PID_HK_G11, items);
		GetAllItems(PID_TURBO_PLASMA_RIFLE, items);
		GetAllItems(PID_HK_G11E, items);
		GetAllItems(PID_YK42B_PULSE_RIFLE, items);
		GetAllItems(PID_PLASMA_GATLING, items);
		GetAllItems(PID_SAIGA12, items);
		GetAllItems(PID_NAPALM, items);
		GetAllItems(PID_M203, items);
	//	Log("Degradation of " + items.length() + " T4 items...");
	}
	
	uint counter = items.length();
	
	for(uint i = 0; i < items.length(); i++)
	{
		if(!valid(items[i]))
		{
			counter--;
			continue;
		}
		if(!items[i].IsDeteriorable())
		{
			counter--;
			continue;
		}
		
		if(FLAG(items[i].BrokenFlags, BI_ETERNAL) || FLAG(items[i].BrokenFlags, BI_NOTRESC))
		{
			counter--;
			continue;
		}
		int maxbroken = items[i].BrokenCount;
		maxbroken = maxbroken + percent;
		CLAMP(maxbroken, 0, 100);
		
		SetMinWear(items[i], maxbroken);
		
		items[i].Update();

	}
	
	//Log(counter + " of items were damaged by " + percent + "%.");
	
	return REAL_HOUR(settings[3]);
}

// admin access
bool IsAdmin(Critter& player)
{
    return player.GetAccess() >= ACCESS_ADMIN;
}

bool IsGM(Critter& player)
{
    return player.GetAccess() >= ACCESS_MODER;
}

int AllowParameterIfAccess(int access, uint parameter, Critter& fromCr, Critter& toCr)
{
    if(access <= ACCESS_CLIENT || toCr.GetAccess() < access)
        return(0);

    return(fromCr.Param[parameter]);
}

int AllowParameterIfTester(uint parameter, Critter& fromCr, Critter& toCr)
{
    return(AllowParameterIfAccess(ACCESS_TESTER, parameter, fromCr, toCr));
}

int AllowParameterIfModer(uint parameter, Critter& fromCr, Critter& toCr)
{
    return(AllowParameterIfAccess(ACCESS_MODER, parameter, fromCr, toCr));
}

int AllowParameterIfAdmin(uint parameter, Critter& fromCr, Critter& toCr)
{
    return(AllowParameterIfAccess(ACCESS_ADMIN, parameter, fromCr, toCr));
}

int AllowParameterIfHidden(uint parameter, Critter& fromCr, Critter& toCr)
{
    Map@ mapa = fromCr.GetMap();
	Map@ mapb = toCr.GetMap();
	
	//When(both critters are on Worldmap) or (both critters are in the same team and both aren't the same character)
	if((!valid(mapa) && !valid(mapb)) || (fromCr.Param[ST_TEAM_ID] == toCr.Param[ST_TEAM_ID] && fromCr.Id != toCr.Id))
		return(fromCr.Param[parameter]);
	else
		return(AllowParameterIfAccess(ACCESS_MODER, parameter, fromCr, toCr));
}

int AllowParameterIfGod(uint parameter, Critter& fromCr, Critter& toCr)
{
    if(!GodOfTheRealm(toCr.Id))
        return(0);

    return(fromCr.Param[parameter]);
}

//
// Executes command
//
void unsafe_ExecCommand(Critter& player, int p0, int p1, int p2, string@ commandString, array<int>@ data)
{
    if(player.GetAccess() < ACCESS_TESTER)
        return;
    if(GetLvar(player, LVAR_authed_char) == 0)       // Move all this to GetAccess handler when we have one.
    {
        SetLvar(player, LVAR_authed_char, 1);
        SetCritterEvents(player);
    }

    ExecCommand(player, p0, p1, p2, commandString, data);
}

void ExecCommand(Critter& player, int p0, int p1, int p2, string@ commandString, array<int>@ data)
{
    if(player.GetAccess() < ACCESS_TESTER)
        return;                                         // it's here, not only inside the unsafe_ wrapper, because it's called in replays etc.
    if(!valid(commandString))
        return;

    ExecCommand(player, commandString);
}

// bool, for broken macros
bool ExecCommand(Critter& player, string@ commandString)
{
    if(player.GetAccess() < ACCESS_TESTER)
        return(false);                                           // it's here, not only inside the unsafe_ wrapper, because it's called in replays etc.
    if(!valid(commandString))
        return(false);

   /* if(stringReplaceText(commandString, "|", "") > 0)
    {
        player.Say(SAY_NETMSG, "" + COLOR_RGB(255, 0, 0) + " Illegal character found, command ignored.");     // yea
        return(false);
    }*/

    Preprocess(player, commandString);

    array<string@>@ command = split(commandString, " ");
    string name = GetSafePlayerName(player.Id);
    uint   id = 0;
    // two global target specifying methods -p for players -n for npcs
    string targetName = GetParameterString(command, "-p");
    string npcId = GetParameterString(command, "-n");

    StrToInt(targetName, id);
    // DLog("name: " + targetName + ", id: " + id);
    Critter@ target;
    uint     targetId = 0;

    // have to be player name
    if(targetName != "")
    {
        if(id == 0)
        {
            @target = GetPlayer(targetName);
            targetId = GetPlayerId(targetName);
        }
        else
        {
            // id
            @target = GetCritter(id);
            targetId = id;
        }
    }
    if(npcId != "")
    {
        StrToInt(npcId, id);
        if(id != 0)
            @target = GetCritter(NPC_BASE_ID + id);
    }

    if(!valid(target))
    {
        DLog("Target not valid, defaulting to player");
        @target = @player;
        targetId = player.Id;
    }

    if((command[1] == "init") && (!CheatsInitialized))
    {
        player.Say(SAY_NETMSG, "Running Init");
        InitCheats(false);
        return(true);
    }

    if(!GodOfTheRealm(player.Id) && GodOfTheRealm(target.Id) && _CritHasExtMode(target, MODE_EXT_GOD))
    {
        @target = @player;
        targetId = player.Id;
    }

    #ifndef __DEBUG__
    // check if player is authorized
    if(!IsAllowed(player.Id, command[1]))
    {
        player.Say(SAY_NETMSG, "Unknown command or insufficient privileges.");
        return(false);
    }
    #endif

    /*
       // all checks should be done at this moment, let's help our noob-GMs/devs!
       if( command.length() >= 3 && command[2].length() == 5 && command[2] == "-help" )
       {
            CheatHelpShow( player, "`"+command[1] );
            return;
       }
     */

    // [1] cause zero is command to invoke the listener
    if(command[1] == "accesslist")
    {
        ExecAccessListCommand(command, player);
    }
	else if(command[1] == "addban")
	{
		ExecAddBanCommand(command,player);
	}
    else if(command[1] == "addbankmoney")
    {
        ExecBankMoney(command, player, true);
    }
    else if(command[1] == "addfollower")
    {
        ExecAddNpcCommand(command, player, target, false, true);
    }
    else if(command[1] == "addmob")
    {
        ExecAddNpcCommand(command, player, target, true, false);
    }
    else if(command[1] == "addnpc")
    {
        ExecAddNpcCommand(command, player, target, false, false);
    }
    else if(command[1] == "airstrike")
    {
        ExecAirstrikeCommand(command, player, target);
    }
    else if(command[1] == "alts")
    {
        ExecAltsCommand(command, player);
    }
// else if(command[1] == "animate") { ExecAnimateCommand(command, player, target); }
    else if(command[1] == "antiblock")
    {
        ExecAntiblockCommand(command, player);
    }
    else if(command[1] == "aura")
    {
        ExecAuraCommand(command, player);
    }
    else if(command[1] == "auracleanup")
    {
        ExecAuraCleanupCommand(command, player);
    }
    else if(command[1] == "spawnpoint")
    {
        ExecSpawnPointCommand(command, player);
    }
    else if(command[1] == "append")
    {
        ExecSayCommand(command, player, target, SAY_APPEND);
    }
	else if(command[1] == "banlist")
	{
		ExecBanListCommand(command, player);
	}
    else if(command[1] == "bc")
    {
        ExecBroadcastCommand(command, player);
    }
    else if(command[1] == "blockers")
    {
        ExecBlockersCommand(command, player, target);
    }
    else if(command[1] == "broadcast")
    {
        ExecBroadcastCommand(command, player);
    }
    else if(command[1] == "changefaction")
    {
        ExecChangeFactionCommand(command, player, target);
    }
    else if(command[1] == "changerank")
    {
        ExecChangeRankCommand(command, player, target);
    }
    else if(command[1] == "checkbank")
    {
        ExecCheckBankCommand(command, player);
    }
    else if(command[1] == "checkbanks")
    {
        ExecCheckBanksCommand(command, player);
    }
    else if(command[1] == "checkbankaccount")
    {
        ExecCheckBankAccount(command, player, false);
    }
    else if(command[1] == "checkbankaccounts")
    {
        ExecCheckBankAccount(command, player, true);
    }
    else if(command[1] == "checktown")
    {
        ExecCheckTownCommand(command, player);
    }
    else if(command[1] == "cleanup")
    {
        ExecCleanupCommand(command, player);
    }
    else if(command[1] == "clearallillegalflags")
    {
        ExecClearAllIllegalFlagsCommand(command, player);
    }
    else if(command[1] == "clearenemystack")
    {
        ExecClearEnemyStackCommand(command, player, target, false);
    }
    else if(command[1] == "clearenemystacks" || command[1] == "ces")
    {
        ExecClearEnemyStackCommand(command, player, target, true);
    }
    else if(command[1] == "clearinventory")
    {
        ExecClearInventoryCommand(command, player, target);
    }
    else if(command[1] == "clearillegalflags")
    {
        ClearIllegalFlags(target);
    }
    else if(command[1] == "cleartimeouts" || command[1] == "cto")
    {
        ExecClearTimeoutsCommand(command, player, target);
    }
    else if(command[1] == "clone")
        ExecCloneCommand(command, player, target);
	else if(command[1] == "tee")
        ExecteeCommand(command, player, target);
    else if(command[1] == "condition")
    {
        ExecConditionCommand(command, player, target);
    }
    else if(command[1] == "controlmobs")
    {
        ExecControlMobsCommand(command, player, target);
    }
    else if(command[1] == "controlnpc")
    {
        ExecControlNpcCommand(command, player, target);
    }
    else if(command[1] == "corecheats")
    {
        ExecCoreCheats(command, player);
    }
    else if(command[1] == "countitems")
    {
        ExecCountItemsCommand(command, player);
    }
    else if(command[1] == "createlocation")
    {
        ExecCreateLocationCommand(command, player);
    }
    else if(command[1] == "criticalchance")
    {
        ExecCriticalChance(command, player, target);
    }
    else if(command[1] == "critterinfo" || command[1] == "crinfo")
    {
        ExecCritterInfoCommand(command, player, target);
    }
    else if(command[1] == "damage")
    {
        ExecDamageCommand(command, player, target);
    }
    else if(command[1] == "deathincarnate")
    {
        ExecDeathIncarnateCommand(command, player, target);
    }
    else if(command[1] == "deathmatch")
    {
        ExecDeathmatchCommand(command, player);
    }
    else if(command[1] == "deletelocation")
    {
        ExecDeleteLocationCommand(command, player);
    }
    else if(command[1] == "devenable")
    {
        ExecDevEnableCommand(command, player);
    }
    else if(command[1] == "dialog")
    {
        ExecSayCommand(command, player, target, SAY_DIALOG);
    }
    else if(command[1] == "disabledismantling")
    {
        ExecMapDismantling(player, false);
    }
    else if(command[1] == "disablegrids")
    {
        ExecMapGrids(player, false);
    }
    else if(command[1] == "disablepvp")
    {
        ExecMapPvp(player, false);
    }
	else if(command[1] == "disablepve")
    {
        ExecMapPve(player, false);
    }
    else if(command[1] == "disabletb")
    {
        ExecSetTurnbasedCombat(player, false);
    }
    else if(command[1] == "disguise")
    {
        ExecDisguiseCommand(command, player, target);
    }
	else if(command[1] == "massdisguise")
    {
        ExecMassDisguiseCommand(command, player);
    }
    else if(command[1] == "disguiseinfo")
    {
        ExecDisguiseInfoCommand(command, player);
    }
    else if(command[1] == "dismiss")
    {
        ExecDismissCommand(command, player, target, false);
    }
    else if(command[1] == "dismissteam")
    {
        ExecDismissCommand(command, player, target, true);
    }
    else if(command[1] == "dropalltimeouts")
    {
        ExecClearAllTimeoutsCommand(command, player);
    }
    else if(command[1] == "dropitems")
    {
        ExecDropItemsCommand(command, player, target);
    }
    else if(command[1] == "dropdrugs")
    {
        ExecDropDrugsCommand(command, player, target);
    }
    else if(command[1] == "emote")
    {
        ExecSayCommand(command, player, target, SAY_EMOTE);
    }
    else if(command[1] == "emoteh")
    {
        ExecSayCommand(command, player, target, SAY_EMOTE_ON_HEAD);
    }
    else if(command[1] == "erasetimeevent")
    {
        ExecEraseTimeEventCommand(command, player);
    }
	else if(command[1] == "eraseallevent")
    {
	ExecEraseAllEventCommand(command, player);
    }
	else if(command[1] == "explode")
    {
        ExecExplodeCommand(command, player, target);
    }
    else if(command[1] == "enabledismantling")
    {
        ExecMapDismantling(player, true);
    }
    else if(command[1] == "enablegrids")
    {
        ExecMapGrids(player, true);
    }
    else if(command[1] == "enablepvp")
    {
        ExecMapPvp(player, true);
    }
	else if(command[1] == "enablepve")
    {
        ExecMapPve(player, true);
    }
    else if(command[1] == "enabletb")
    {
        ExecSetTurnbasedCombat(player, true);
    }
	else if(command[1] == "ev-ponyattack")
    {
        ExecEvPonyAttack(command, player);
    }
	else if(command[1] == "ev-trader")
    {
        ExecEvTrader(command, player);
    }
    else if(command[1] == "factionnews")
    {
        ExecFactionNews(command, player);
    }
    else if(command[1] == "factioninfo")
    {
        ExecFactionInfoCommand(command, player, target, false);
    }
    else if(command[1] == "factiononline")
    {
        ExecFactionOnlineCommand(command, player);
    }
    else if(command[1] == "findchars")
        ExecFindCharsCommand(command, player);
    else if(command[1] == "finditems")
    {
        ExecFindItemsCommand(command, player);
    }
    else if(command[1] == "findnpc")
    {
        ExecFindNpcCommand(command, player);
    }
    else if(command[1] == "flash")
    {
        ExecSayCommand(command, player, target, SAY_FLASH_WINDOW);
    }
    else if(command[1] == "foart")
    {
        ExecFOArt(command, player);
    }
    else if(command[1] == "gaintowncontrol")
    {
        ExecGainTownControlCommand(command, player);
    }
    else if(command[1] == "gameinfo")
    {
        ExecGameInfoCommand(command, player);
    }
    else if(command[1] == "getcolor")
    {
        ExecGetColorCommand(command, player);
    }
    else if(command[1] == "getclaim")
    {
        ExecGetClaimCommand(command, player);
    }
    else if(command[1] == "getclaimtime")
    {
        ExecGetClaimTimeCommand(command, player);
    }
    else if(command[1] == "getleader")
    {
        ExecGetLeaderCommand(command, player);
    }
    else if(command[1] == "getitems")
    {
        ExecGetItemsCommand(command, player, target);
    }
    else if(command[1] == "getleadertime")
    {
        ExecGetLeaderTimeCommand(command, player);
    }
    else if(command[1] == "getrequests")
    {
        ExecGetRequestsCommand(command, player);
    }
    else if(command[1] == "getuvar")
    {
        ExecGetUVarCommand(command, player, target);
    }
    else if(command[1] == "getvar")
    {
        ExecGetVarCommand(command, player, targetId);
    }
    else if(command[1] == "give")
    {
        ExecGiveCommand(command, player, target);
    }
	else if(command[1] == "massgive")
    {
        ExecMassGiveCommand(command, player, target);
    }
	else if(command[1] == "givelevelbook")
    {
        ExecGiveLevelBookCommand(command, player);
    }
    else if(command[1] == "givekey")
    {
        ExecGiveKeyCommand(command, player, target);
    }
    else if(command[1] == "goto")
        ExecGoToCommand(command, player, target, false);
    else if(command[1] == "gototeam")
        ExecGoToCommand(command, player, target, true);
    else if(command[1] == "heal")
    {
        ExecHealCommand(command, player, target);
    }
    else if(command[1] == "healall")
    {
        ExecHealAllCommand(command, player);
    }
// else if(command[1] == "help") { ExecHelpCommand(command, player); } // -> cheats_help.fos
    else if(command[1] == "hideloc")
        ExecLocVisCommand(command, player, target, false);
    else if(command[1] == "hidemap")
    {
        ExecHideMapCommand(command, player);
    }
    else if(command[1] == "iddqd")
    {
        ExecGodCommand(command, player);
    }
    else if(command[1] == "idkfa")
    {
        ExecIDKFACommand(command, player, target);
    }
    else if(command[1] == "id2name")
    {
        ExecIdToNameCommand(command, player);
    }
    else if(command[1] == "inspect")
    {
        ExecInspectCommand(command, player);
    }
    else if(command[1] == "irradiate")
    {
        ExecIrradiateCommand(command, player, target);
    }
    else if(command[1] == "itemflags")
    {
        ExecItemFlagsCommand(command, player);
    }
    else if(command[1] == "itemlight")
    {
        ExecItemLightCommand(command, player);
    }
    else if(command[1] == "itemproto")
    {
        ExecItemProtoCommand(command, player);
    }
    else if(command[1] == "karma")
    {
        ExecKarmaCommand(command, player, target, false);
    }
    else if(command[1] == "karmateam")
    {
        ExecKarmaCommand(command, player, target, true);
    }
    else if(command[1] == "kill")
    {
        ExecKillCommand(command, player, target);
    }
    else if(command[1] == "killeradmin")
    {
        ExecKillerAdminCommand(command, player);
    }
    else if(command[1] == "killmobs")
    {
        ExecKillMobsCommand(command, player);
    }
    else if(command[1] == "lastregistered")
    {
        ExecLastRegisteredCommand(command, player);
    }
    else if(command[1] == "lastspawned")
    {
        ExecLastSpawnedCommand(command, player, target);
    }
    else if(command[1] == "log")
    {
        ExecLogCommand(command, player);
    }
    else if(command[1] == "listauthenticated" || command[1] == "la")
    {
        ExecListAuthenticatedCommand(command, player);
    }
    else if(command[1] == "listcommands")
    {
        ExecListCommandsCommand(command, player);
    }
    else if(command[1] == "listfactions")
    {
        ExecFactionInfoCommand(command, player, null, true);
    }
    else if(command[1] == "listfollowers")
    {
        ExecListFollowersCommand(command, player, target);
    }
    else if(command[1] == "listmaps")
    {
        ExecListMapsCommand(command, player);
    }
    else if(command[1] == "listplayers" || command[1] == "lp")
    {
        ExecListPlayersCommand(command, player);
    }
    else if(command[1] == "listtents")
    {
        ExecTentListCommand(command, player);
    }
	else if(command[1] == "dl")
    {
        ExecDLCommand(command, player, target);
    }
    else if(command[1] == "listtracked" || command[1] == "lt")
    {
        ExecListTrackedPlayersCommand(command, player);
    }
    else if(command[1] == "lock")
        ExecLockCommand(command, player, target);
    else if(command[1] == "lockcar")
        ExecLockCarCommand(command, player, true);
    else if(command[1] == "makeencounter")
    {
        ExecMakeEncounterCommand(command, player);
    }
    else if(command[1] == "mapinfo")
    {
        ExecMapInfoCommand(command, player);
    }
    else if(command[1] == "modchar")
    {
        ExecModCharCommand(command, player, target);
    }
    else if(command[1] == "move")
    {
        ExecMoveCommand(command, player, target);
    }
    else if(command[1] == "name2id")
    {
        ExecNameToIdCommand(command, player, target);
    }
    else if(command[1] == "netmsg")
    {
        ExecSayCommand(command, player, target, SAY_NETMSG);
    }
    else if(command[1] == "normaldeadly")
    {
        ExecNormalDeadlyCommand(command, player, target);
    }
    else if(command[1] == "numplayers")
    {
        player.Say(SAY_NETMSG, "There are " + GetNumberOfPlayersOnline() + " players online right now");
    }
    else if(command[1] == "param")
    {
        ExecParamCommand(command, player, target);
    }
	else if(command[1] == "massparam")
    {
        ExecMassParamCommand(command, player, target);
    }
	else if(command[1] == "callmobs")
    {
        CallMobsCommand(command, player, target);
    }
	else if(command[1] == "spawnteam")
    {
        SpawnTeamCommand(command, player, target);
    }
	else if(command[1] == "st")
    {
        SpawnTeamCommand(command, player, target);
    }
	else if(command[1] == "autobalance")
    {
        ExecAutoBalanceCommand(command, player, target);
    }
    else if(command[1] == "perkadjust")
    {
        ExecPerkAdjust(command, player, target);
    }
    else if(command[1] == "pickitems")
    {
        ExecPickItemsCommand(command, player, target);
    }
    else if(command[1] == "phase")
    {
        ExecShiftCommand(command, player, target, false, true);
    }
    else if(command[1] == "phaseteam")
    {
        ExecShiftCommand(command, player, target, true, true);
    }
    else if(command[1] == "playerkarma")
    {
        ExecPlayerKarmaCommand(command, player, target, false);
    }
    else if(command[1] == "playmusic")
    {
        ExecPlayMusicCommand(command, player);
    }
    else if(command[1] == "playsound")
    {
        ExecPlaySoundCommand(command, player, false);
    }
    else if(command[1] == "playspeech")
    {
        ExecPlaySoundCommand(command, player, true);
    }
    else if(command[1] == "profadjust")
    {
        ExecProfAdjust(command, player, target);
    }
    else if(command[1] == "registerfaction")
    {
        ExecRegisterFactionCommand(command, player);
    }
	else if(command[1] == "removeban")
    {
        ExecRemoveBanCommand(command, player);
    }
    else if(command[1] == "removebankmoney")
    {
        ExecBankMoney(command, player, false);
    }
    else if(command[1] == "removefaction")
        ExecRemoveFactionCommand(command, player);
    else if(command[1] == "removeitems")
    {
        ExecRemoveItemsCommand(command, player);
    }
    else if(command[1] == "reservednickname")
    {
        ExecReservedNicknameCommand(command, player);
    }
    else if(command[1] == "resetalldisguises")
    {
        ExecResetAllDisguisesCommand(command, player);
    }
    else if(command[1] == "resetprices")
    {
        InitPrices();
    }
    else if(command[1] == "resetreputations")
        ExecResetReputationsCommand(command, player, target);
    else if(command[1] == "resettown")
    {
        ExecResetTownCommand(command, player, false);
    }
    else if(command[1] == "resettowns")
    {
        ExecResetTownCommand(command, player, true);
    }
    else if(command[1] == "resetworldmap")
    {
        ExecResetWorldMapCommand(command, player);
    }
    else if(command[1] == "respawn" || command[1] == "revive")
    {
        ExecRespawnCommand(command, player, target);
    }
    else if(command[1] == "respawnall" || command[1] == "reviveall")
    {
        ExecRespawnAllCommand(command, player);
    }
    else if(command[1] == "respawnallplayers" || command[1] == "reviveallplayers")
    {
        ExecRespawnAllCommand(command, player);
    }
// else if(command[1] == "riddle") { ExecRiddleCommand(command, player); }
    else if(command[1] == "rotate")
    {
        ExecRotateCommand(command, player, target);
    }
    else if(command[1] == "rundialog")
    {
        ExecRunDialog(command, player, target);
    }
    else if(command[1] == "saferegen")
    {
        ExecSafeRegenCommand(command, player);
    }
    else if(command[1] == "say")
    {
        ExecSayCommand(command, player, target, SAY_NORM);
    }
    else if(command[1] == "sayh")
    {
        ExecSayCommand(command, player, target, SAY_NORM_ON_HEAD);
    }
	else if(command[1] == "setcolor")
	{
		ExecSetColorCommand(command, player);
	}
	else if(command[1] == "setdeterioration")
	{
		ExecSetDeteriorationCommand(command, player);
	}
	else if(command[1] == "seteventwithcar")
	{
		ExecSetEventWithSmthngCommand(player, 1);
	}
	else if(command[1] == "seteventwithitem")
	{
		ExecSetEventWithSmthngCommand(player, 2);
	}
	else if(command[1] == "seteventwithmobs")
	{
		ExecSetEventWithSmthngCommand(player, 3);
	}
	    else if(command[1] == "setanim")
    {
        ExecSetAnimCommand(command, player, target, false);
    }
    else if(command[1] == "masssetanim")
    {
        ExecSetAnimCommand(command, player, target, true);
    }
    else if(command[1] == "setfaction")
    {
        ExecSetFactionCommand(command, player, target);
    }
	else if(command[1] == "setgmevent")
	{
		ExecSetGMEvent(command, player);
	}
    else if(command[1] == "sethp")
    {
        ExecSetHPCommand(command, player, target);
    }
    else if(command[1] == "setlexem")
    {
        ExecSetLexemCommand(command, player, target);
    }
	else if(command[1] == "setremoveitemsonmap")
    {
        ExecSetMapEventCommand(MAP_EVENT_OUT_CRITTER, 1, player);
    }
    else if(command[1] == "setperk")
    {
        ExecSetPerkCommand(command, player, target);
    }
    else if(command[1] == "setmapdata")
    {
        ExecSetMapDataCommand(command, player);
    }
    else if(command[1] == "setlocvisibility")
    {
        ExecSetLocVisibility(command, player);
    }
	else if(command[1] == "eventtimer")
    {
        ExecEventTimer(command, player);
    }
	else if(command[1] == "et")
    {
        ExecEventTimer(command, player);
    }
	else if(command[1] == "createofficer")
    {
	ExeccreateofficerCommand(command, player);
	}
    else if(command[1] == "setrain")
    {
        ExecSetRain(command, player);
    }	
    else if(command[1] == "setreputation" || command[1] == "setrep")
    {
        ExecSetReputationCommand(command, player, target);
    }
    else if(command[1] == "settimeout" || command[1] == "sto")
    {
        ExecSetTimeoutCommand(command, player, target);
    }
    else if(command[1] == "setuvar")
    {
        ExecSetUVarCommand(command, player, target);
    }
    else if(command[1] == "setvar")
    {
        ExecSetVarCommand(command, player, targetId);
    }
    else if(command[1] == "shift")
    {
        ExecShiftCommand(command, player, target, false, false);
    }
    else if(command[1] == "shiftteam")
    {
        ExecShiftCommand(command, player, target, true, false);
    }
    else if(command[1] == "shout")
    {
        ExecSayCommand(command, player, target, SAY_SHOUT);
    }
    else if(command[1] == "shouth")
    {
        ExecSayCommand(command, player, target, SAY_SHOUT_ON_HEAD);
    }
    else if(command[1] == "showhands")
    {
        ExecShowHandsCommand(command, player, target);
    }
    else if(command[1] == "showloc")
        ExecLocVisCommand(command, player, target, true);
    else if(command[1] == "showvars")
    {
        ExecShowVarsCommand(command, player, target);
    }
    else if(command[1] == "slap")
    {
        ExecSlapCommand(command, player, target);
    }
    else if(command[1] == "massslap")
    {
        ExecMassSlapCommand(command, player, target);
    }
    else if(command[1] == "startevent")
    {
        ExecStartEventCommand(command, player);
    }
    else if(command[1] == "stopevent")
    {
        ExecStopEventCommand(command, player);
    }
    else if(command[1] == "stoptrackplayer")
    {
        ExecStopTrackPlayerCommand(command, player, target);
    }
    else if(command[1] == "spawncar")
        ExecSpawnCarCommand(command, player, target);
	else if(command[1] == "spawngmspawner")
        ExecSpawnGMSpawnerCommand(command, player);
    else if(command[1] == "spawnitem")
        ExecSpawnItemCommand(command, player, target);
    else if(command[1] == "suicide")
    {
        ExecSuicideCommand(command, player);
    }
    else if(command[1] == "summon")
    {
        ExecSummonCommand(command, player, target, false);
    }
    else if(command[1] == "summonteam")
    {
        ExecSummonCommand(command, player, target, true);
    }
    else if(command[1] == "team")
    {
        ExecTeamCommand(command, player, target);
    }
    else if(command[1] == "teleport" || command[1] == "tp")
    {
        ExecTeleportCommand(command, player, target, false);
    }
    else if(command[1] == "teleporter")
    {
        ExecTeleporterCommand(command, player);
    }
    else if(command[1] == "teleportteam")
    {
        ExecTeleportCommand(command, player, target, true);
    }
    else if(command[1] == "tentinfo")
    {
        ExecTentInfoCommand(command, player, target);
    }
    else if(command[1] == "toglobal")
    {
        ExecToGlobal(player, target);
    }
    else if(command[1] == "trackplayer")
    {
        ExecTrackPlayerCommand(command, player, target);
    }
// else if(command[1] == "usedammo") { ExecUsedAmmo(player); }
    else if(command[1] == "unlockcar")
        ExecLockCarCommand(command, player, false);
		
	else if(command[1] == "unsetevent")
	{
		ExecSetEventWithSmthngCommand(player, 0);
	}
	else if(command[1] == "unsetmapoutevent")
    {
        ExecSetMapEventCommand(MAP_EVENT_OUT_CRITTER, 0, player);
    }	
    else if(command[1] == "whisper")
    {
        ExecSayCommand(command, player, target, SAY_WHISP);
    }
    else if(command[1] == "whisperh")
    {
        ExecSayCommand(command, player, target, SAY_WHISP_ON_HEAD);
    }
    else if(command[1] == "virtualmoney")
    {
        ExecVirtualMoneyCommand(command, player);
    }
    else if(command[1] == "xp")
    {
        ExecXpCommand(command, player, target, false);
    }
    else if(command[1] == "xpteam")
    {
        ExecXpCommand(command, player, target, true);
    }
    else if(command[1] == "zeroext")
    {
        ExecZeroExtCommand(command, player, target);
    }
    else if(command[1] == "zone")
    {
        ExecZoneCommand(command, player);
    }
    else if(command[1] == "zoneplayers")
    {
        ExecZonePlayersCommand(command, player);
    }
	else if(command[1] == "event")
    {
        ExecEventCommand(command, player);
    }
	else if(command[1] == "gm")
    {
        ExecgmCommand(command, player);
    }
    else
    {
        player.Say(SAY_NETMSG, "Unknown command or insufficient privileges.");
        return(false);
    }
    #ifdef __DEBUG__
    // AddAchievement( player, ACHIEVEMENT_GM_ABUSE );
    #endif

    return(true);
}

Serializator serializer;
void LoadEventSpawns()
{
    serializer.Clear();
    if(!serializer.Load("event_spawns"))
        return;

    serializer.Get(eventItems).Get(eventCritters);
}

void SaveEventSpawns()
{
    serializer.Clear();
    serializer.Set(eventItems).Set(eventCritters).Save("event_spawns");
}

void answer_Test(Critter& player, uint answerI, string& answerS)
{
    player.Say(SAY_NETMSG, "" + answerI + ", " + answerS);
}

bool _UseSkill(Item& item, Critter& crit, int skill)
{
    crit.Say(SAY_NETMSG, "Use: " + skill);
    if(skill == SK_LOCKPICK)
    {
        if(Random(0, 9) == 0)
        {
            crit.Say(SAY_NETMSG, "Picked");
            item.LockerCondition = LOCKER_ISOPEN;
            item.Update();
        }
        return true;
    }
    return false;
}

void checkbot(Critter& cr, int playerId, int, int)
{
    int      id = cr.Id;
    id ^= 0x1B7D5C7E;
    Critter@ tocheck = GetCritter(playerId);
    if(!valid(tocheck) || tocheck.IsNpc())
    {
        cr.Say(SAY_NETMSG, "Invalid player.");
        return;
    }
    tocheck.RunClientScript("client_main@_ResetTimer", id, Random(0, 0xFF), Random(0, 0xFFFF), null, null);
}

#pragma bindfunc "uint Critter::GetIp() -> Utils.dll Critter_GetIp"

void ip(Critter& cr, int, int, int)
{
    uint ip = cr.GetIp();
    cr.Say(SAY_NETMSG, "ip=" + ip);
    if(ip > 0)
    {
        string result = "";
        for(uint i = 0; i < 4; i++)
        {
            result += (i == 0 ? "" : ".") + ((ip >> (i * 8)) & 0xFF);
        }
        cr.Say(SAY_NETMSG, "ip=" + result);
    }
}

///////////////////////////////////////////////////////////////////////////////////

class FakeCombat
{
    private uint        target;
    private array<uint> result;

    FakeCombat()
    {
        this.Clear();
    }

    FakeCombat(Critter & cr)
    {
        this.Clear();
        this.Target(cr);
    }

    private void New(uint what) final
    {
        this.result.insertLast(what);
        this.result.insertLast(this.target);
    }

    FakeCombat@ Clear()
    {
        this.target = 0;
        this.result.resize(0);

        return(this);
    }

    FakeCombat@ Target(Critter& cr)
    {
        this.target = cr.Id;

        return(this);
    }

    FakeCombat@ Miss()
    {
        this.New(CMSG_MISS);

        return(this);
    }

    FakeCombat@ CritMiss(uint effects)
    {
        this.New(CMSG_CRIT_MISS);
        this.result.insertLast(effects);

        return(this);
    }

    FakeCombat@ CritMissDamage(uint effects, uint damage)
    {
        this.New(CMSG_CRIT_MISS_DAMAGE);
        this.result.insertLast(effects);
        this.result.insertLast(damage);

        return(this);
    }

    FakeCombat@ Oops(uint who2)
    {
        this.New(CMSG_OOPS);
        this.result.insertLast(who2);

        return(this);
    }

    FakeCombat@ Hit(uint damage)
    {
        this.New(CMSG_HIT);
        this.result.insertLast(damage);

        return(this);
    }

    FakeCombat@ HitRandomly()
    {
        this.New(CMSG_HIT_RANDOMLY);

        return(this);
    }

    FakeCombat@ HitDead(uint damage)
    {
        this.New(CMSG_HIT_DEAD);
        this.result.insertLast(damage);

        return(this);
    }

    FakeCombat@ AimedHit(uint location, uint damage)
    {
        this.New(CMSG_AIMED_HIT);
        this.result.insertLast(location);
        this.result.insertLast(damage);

        return(this);
    }

    FakeCombat@ AimedHitDead(uint location, uint damage)
    {
        this.New(CMSG_AIMED_HIT_DEAD);
        this.result.insertLast(location);
        this.result.insertLast(damage);

        return(this);
    }

    FakeCombat@ CritHit(uint damage, uint effect, uint message)
    {
        this.New(CMSG_CRIT_HIT);
        this.result.insertLast(damage);
        this.result.insertLast(effect);
        this.result.insertLast(message);

        return(this);
    }

    FakeCombat@ CritHitDead(uint damage, uint effect, uint message)
    {
        this.New(CMSG_CRIT_HIT_DEAD);
        this.result.insertLast(damage);
        this.result.insertLast(effect);
        this.result.insertLast(message);

        return(this);
    }

    FakeCombat@ CritAimedHit(uint location, uint damage, uint effect, uint message)
    {
        this.New(CMSG_CRIT_AIMED_HIT);
        this.result.insertLast(location);
        this.result.insertLast(damage);
        this.result.insertLast(effect);
        this.result.insertLast(message);

        return(this);
    }

    FakeCombat@ CritAimedHitDead(uint location, uint damage, uint effect, uint message)
    {
        this.New(CMSG_CRIT_AIMED_HIT_DEAD);
        this.result.insertLast(location);
        this.result.insertLast(damage);
        this.result.insertLast(effect);
        this.result.insertLast(message);

        return(this);
    }

    bool Send()
    {
        Critter@ _target = GetCritter(this.target);
        if(valid(_target))
        {
            Critter@[] realTarget = { _target };
            array<Critter@> crits;
            uint            count = _target.GetMap().GetCrittersSeeing(realTarget, true, FIND_ALL | FIND_ONLY_PLAYERS, crits);
            for(uint c = 0; c < count; c++)
            {
                this.Send(crits[c]);
                // if( !this.Send( crits[c] ))
                //	return( false );
            }

            return(true);
        }

        return(false);
    }

    bool Send(Critter& cr)
    {
        if(cr.IsNotValid || cr.IsNpc())
            return(false);

        uint len = this.result.length();

        if(len > 0)
        {
            this.result.insertAt(0, ++len);
            cr.SendCombatResult(result);
            this.result.removeAt(0);
        }

        return(true);
    }

    /*
       bool SendText( Critter& cr, string& msg )
       {
            if( cr.IsNotValid || cr.IsNpc() )
                    return( false );

            if( msg.length() > 0 )
            {
                    cr.RunClientScript( "client_messages@combat", 0, 0, 0, msg, null );
                    return( true );
            }

            return( false );
       }

       bool SendText( Critter& cr, uint16 hx, uint16 hy, string& hex, int damage = 0 )
       {
            if( cr.IsNotValid || cr.IsNpc() )
                    return( false );

            if( valid(cr.GetMap()) && hx > 0 && hy > 0 && hex.length() > 0 )
            {
                    cr.RunClientScript( "client_messages@combat", damage, hx, hy, "|"+hex, null );
                    return( true );
            }

            return( false );
       }

       bool SendText( Critter& cr, string& msg, uint16 hx, uint16 hy, string& hex, int damage = 0 )
       {
            if( cr.IsNotValid || cr.IsNpc() || msg.length() == 0 )
                    return( false );

            if( msg.length() > 0 && valid(cr.GetMap()) && hx > 0 && hy > 0 && hex.length() > 0 )
            {
                    cr.RunClientScript( "client_messages@combat", damage, hx, hy, msg+"|"+hex, null );
                    return( true );
            }

            return( false );
       }
     */
};

void ItemEvent(Item& item, int event, string& function)
{
    Critter@ spawner = GetCritter(_GetSpawner(item));
    if(!item.SetEvent(event, function))
    {
        if(valid(spawner))
            spawner.Say(SAY_NETMSG, "Can't set script to \"" + function + "\", removing item.");
        DeleteItem(item);
    }
    else
    {
        if(valid(spawner))
            spawner.Say(SAY_NETMSG, "ItemEvent " + event + " for " + item.Id + " set to " + function);
    }
}

void ItemTypeEvent(Item& item, int type, int event, string& function)
{
    Critter@ spawner = GetCritter(_GetSpawner(item));
    if(item.GetType() != uint(type))
    {
        if(valid(spawner))
            spawner.Say(SAY_NETMSG, "Invalid item type, removing item.");
        DeleteItem(item);
    }
    else
    {
        ItemEvent(item, event, function);
    }
}

///// functions for `give/`spawnitem -script

// weapons
void weapon_disconnect(Item& item, bool firstTime)
{
    ItemTypeEvent(item, ITEM_TYPE_WEAPON, ITEM_EVENT_ATTACK, "weapon_function_disconnect");
}

void weapon_explode(Item& item, bool firstTime)
{
    ItemTypeEvent(item, ITEM_TYPE_WEAPON, ITEM_EVENT_ATTACK, "weapon_function_explode");
}

void weapon_kill(Item& item, bool firstTime)
{
    ItemTypeEvent(item, ITEM_TYPE_WEAPON, ITEM_EVENT_ATTACK, "weapon_function_kill");
}

void weapon_heal(Item& item, bool firstTime)
{
    ItemTypeEvent(item, ITEM_TYPE_WEAPON, ITEM_EVENT_ATTACK, "weapon_function_heal");
}

/*
   void weapon_revive( Item& item, bool firstTime )
   {
        if( firstTime )
                ItemTypeEvent( item, ITEM_TYPE_WEAPON, ITEM_EVENT_ATTACK, "weapon_function_revive" );
   }
 */

void item_sound(Item& item, bool firstTime)
{
    ItemEvent(item, ITEM_EVENT_WALK, "item_function_sound");
}

///// cheated items events

bool weapon_function_disconnect(Item& item, Critter& sadist, Critter& victim)   // ITEM_EVENT_ATTACK
{
    if(sadist.GetAccess() < ACCESS_MODER)
    {
        sadist.Say(SAY_NETMSG, "No.");
        return(true);
    }

    if(victim.IsNpc())
    {
        sadist.Say(SAY_NETMSG, "You can't disconnect NPCs.");
        return(true);
    }

    if(sadist.GetAccess() < victim.GetAccess() || GodOfTheRealm(victim.Id))
    {
        sadist.Say(SAY_NETMSG, "No, you don't.");
        return(true);
    }

    LogCommandUsage(sadist, "ItemEventCheat: disconnected " + victim.Name + "<" + victim.Id + ">");

    sadist.Animate(0, ANIM2_BURST, item, true, false);
    victim.Disconnect();

    return(true);
}

// AS bug : import void MapMessageEx( uint8 type, uint8 mode, Critter& target, string& text, uint16 hexX, uint16 hexY, uint8 delay = 150, uint color = 0, bool fade = true, int8 fromX = 0, int8 toX = 0, int8 fromY = 0, int8 toY = 0 ) from "utils";
import void MapMessageEx(uint8 type, uint8 mode, Critter& target, string& text, uint16 hexX, uint16 hexY, uint8 delay, uint color, bool fade, int8 fromX, int8 toX, int8 fromY, int8 toY) from "utils";

bool weapon_function_explode(Item& item, Critter& sadist, Critter& victim)   // ITEM_EVENT_ATTACK
{
    if(sadist.GetAccess() < ACCESS_MODER)
    {
        sadist.Say(SAY_NETMSG, "No.");
        return(true);
    }

    if(victim.IsDead())
    {
        sadist.Say(SAY_NETMSG, GenderString(victim, "He", "She", "It") + "'s already as dead as possible.");
        return(true);
    }

    LogCommandUsage(sadist, "ItemEventCheat: exploded " + victim.Name + "<" + victim.Id + ">");

    sadist.Animate(0, ANIM2_BURST, item, true, false);
    AI_TrySayCombatText(victim, Random(COMBAT_TEXT_HIT_HEAD, COMBAT_TEXT_HIT_GROIN), true);
    victim.ToDead(ANIM2_DEAD_EXPLODE, null);

    return(true);
}

bool weapon_function_kill(Item& item, Critter& sadist, Critter& victim)   // ITEM_EVENT_ATTACK
{
    if(sadist.GetAccess() < ACCESS_MODER)
    {
        sadist.Say(SAY_NETMSG, "No.");
        return(true);
    }

    if(victim.IsDead())
    {
        sadist.Say(SAY_NETMSG, GenderString(victim, "He", "She", "It") + "'s already as dead as possible.");
        return(true);
    }

    LogCommandUsage(sadist, "ItemEventCheat: killed " + victim.Name + "<" + victim.Id + ">");

    Map@      map = victim.GetMap();
    const int mode_invulnerable = victim.Param[MODE_INVULNERABLE];

    if(valid(map))
    {
        uint anim2 = ANIM2_BURST;
        if(IsGrenade(item))
        {
            anim2 = ANIM2_THROW;
            map.RunFlyEffect(item.GetProtoId(), sadist, victim, sadist.HexX, sadist.HexY, victim.HexX, victim.HexY);
            map.RunEffect(PID_EXPLODE_FIRE_BIG, victim.HexX, victim.HexY, 1);
            map.RunEffect(PID_EXPLODE_ROCKET, victim.HexX, victim.HexY, 1);
        }
        else if(item.Proto.ProtoId == PID_ROCKET_LAUNCHER)
        {
            map.RunFlyEffect(PID_FLYING_ROCKET, sadist, victim, sadist.HexX, sadist.HexY, victim.HexX, victim.HexY);
            map.RunEffect(PID_EXPLODE_FIRE_BIG, victim.HexX, victim.HexY, 1);
            map.RunEffect(PID_EXPLODE_ROCKET, victim.HexX, victim.HexY, 1);
        }

        if(anim2 > 0)
            sadist.Animate(0, anim2, item, true, false);

        uint location = Random(HIT_LOCATION_HEAD, HIT_LOCATION_GROIN);
        uint hp = Random(victim.Param[ST_CURRENT_HP] + ABS(__DeadHitPoints),
                         (victim.Param[ST_CURRENT_HP] + ABS(__DeadHitPoints)) * 2);
        uint effect = 0;

        if(location == HIT_LOCATION_HEAD || location == HIT_LOCATION_EYES)
        {
            if(Random(0, 1) == 0)
                SETFLAG(effect, HF_BLINDED);
        }
        else if(location == HIT_LOCATION_LEFT_ARM)
        {
            if(Random(0, 1) == 0)
                SETFLAG(effect, HF_CRIPPLED_LEFT_ARM);
        }
        else if(location == HIT_LOCATION_RIGHT_ARM)
        {
            if(Random(0, 1) == 0)
                SETFLAG(effect, HF_CRIPPLED_RIGHT_ARM);
        }
        else if(location == HIT_LOCATION_LEFT_LEG)
        {
            if(Random(0, 1) == 0)
                SETFLAG(effect, HF_CRIPPLED_LEFT_LEG);
        }
        else if(location == HIT_LOCATION_RIGHT_LEG)
        {
            if(Random(0, 1) == 0)
                SETFLAG(effect, HF_CRIPPLED_RIGHT_LEG);
        }

        if(Random(0, (location == HIT_LOCATION_TORSO ? 1 : 2)) == 0)
            SETFLAG(effect, HF_BYPASS_ARMOR);

        FakeCombat@ result = FakeCombat(victim);

        bool        dead = (mode_invulnerable <= 0);
        if(mode_invulnerable > 0 && GodOfTheRealm(sadist.Id) && sadist.GetAccess() == ACCESS_ADMIN)
            dead = true;

        if(location >= HIT_LOCATION_HEAD && location <= HIT_LOCATION_GROIN)
            AI_TrySayCombatText(victim, location + 9, true);

        if(dead)
            result.CritAimedHitDead(location, hp, effect, 0);
        else
            result.CritAimedHit(location, hp, effect, 0);

        result.Send();

//		if( GodOfTheRealm( sadist.Id ) && sadist.GetAccess() == ACCESS_ADMIN )
//			MapMessageEx( FLOAT_ENFORCED, FLOAT_MODE_ALL, victim, "annihilated", victim.HexX, victim.HexY, 255, COLOR_RGB(0xFF,0,0), true, -20, 20, -10, -20 );
    }

    if(GodOfTheRealm(sadist.Id) && sadist.GetAccess() == ACCESS_ADMIN)
    {
        victim.ParamBase[MODE_INVULNERABLE] = 0;
        victim.ToDead(GetRandomDeathAnimation(), null);
        victim.ParamBase[MODE_INVULNERABLE] = mode_invulnerable;
    }
    else
        victim.ToDead(GetRandomDeathAnimation(), null);

    return(true);
}

bool weapon_function_heal(Item& item, Critter& sadist, Critter& victim)   // ITEM_EVENT_ATTACK
{
    if(sadist.GetAccess() < ACCESS_MODER)
    {
        sadist.Say(SAY_NETMSG, "No.");
        return(true);
    }

    LogCommandUsage(sadist, "ItemEventCheat: healed " + victim.Name + "<" + victim.Id + ">");

    sadist.Animate(0, ANIM2_BURST, item, true, false);
    Heal(victim);

    return(true);
}

/*
   bool weapon_function_revive( Item& item, Critter& sadist, Critter& victim ) // ITEM_EVENT_ATTACK
   {
        if( !victim.IsDead() )
        {
                sadist.Say( SAY_NETMSG, victim.Name+"("+victim.Id+") is not dead." );
                return( true );
        }

        victim.ToLife();

        return( true );
   }
 */

void item_function_sound(Item& item, Critter& victim, bool entered, uint8 dir)
{
    string self = "item " + item.Id + ": ";
    uint16 hX = 0, hY = 0;
    Map@   map = item.GetMapPosition(hX, hY);

    #ifdef __DEBUG__
    if(valid(map))
        map.SetText(hX, hY, 0, self + victim.Name + "(" + victim.Id + ") entered:" + entered + " dir" + dir);
    else
        victim.Say(SAY_NETMSG, self + "entered:" + entered + " dir" + dir);
    #endif

    string lexem = (entered ? "$+" : "$-"); // TODO: confict with item description
    if(IsLexem(item, lexem))
    {
        int radius = 5;
        if(IsLexem(item, "$!"))
        {
            StrToInt(GetLexem(item, "$!"), radius);
        }
        map.PlaySound(GetLexem(item, lexem), hX, hY, radius);
    }
}

void _ForceEncounter(Map& map)
{
    Location@       loc = map.GetLocation();
    array<Critter@> crits;
    uint            n = GetGlobalMapCritters(loc.WorldX, loc.WorldY, 25, FIND_LIFE | FIND_ONLY_PLAYERS, crits);
    shuffle_ptrarray(crits, Critter@);
    for(uint i = 0; i < n; i++)
    {
        Critter@ cr = crits[i];
        if(!valid(cr.GetFollowLeader()) /* possible? */ || cr.GetFollowLeader().Id != cr.Id)
            continue;
        cr.TransitToMap(map.Id, 0, true);
        map.SetLoopTime(4, uint(-1));
        map.SetEvent(MAP_EVENT_LOOP_4, "_DoNothing");
    }
}

void SetTimeoutForAll(Map& map, int timeout, int time)
{
    array<Critter@> crits;
    uint            count = map.GetCritters(0, FIND_ALL, crits);
	
	
	// Event with cars
	/*array<Item@> cars;
	if(_MapHasMode(map, MAP_MODE_EVENT_WITH_CAR)
	{
		map.GetItemsByType(ITEM_TYPE_CAR, cars); 

		for(uint c = 0; c < count; c++)
		{
			for(uint16 i = 0; i < cars.length(); i++)
				if(IsKeyAviable(crits[c], cars[i].LockerId))
				{
					if(cr.Timeout[TO_TRANSFER] > 0)
						_SetTimeout(crits[c], TO_TRANSFER, time);
				
					crits.removeAt(c);
					count--;
					break;
				}
		}
	}*/

    for(uint c = 0; c < count; c++)
    {
        _SetTimeout(crits[c], timeout, time);
    }
}

void _LockMap(Map& map)
{
    SetTimeoutForAll(map, TO_TRANSFER, REAL_SECOND(2238) + REAL_MS(800));
}

void _RemoveItems(Map& map, Critter& cr)
{
    if(cr.IsDead()) return;
	
	array<Item@> items;
	cr.GetItems(-1, items);
	
	for(uint i = 0; i < items.length(); i++)
	{
		if(!valid(items[i])) continue;
		
		if(_MapHasMode(map, MAP_MODE_EVENT_WITH_CAR) && items[i].GetProtoId() == PID_KEY) continue;
		
		DeleteItem(items[i]);
	}
}

void _DoNothing(Map& map)   // why am i needed, why?
{}

#ifdef __DEBUG__

# include "buffer_h.fos"
# include "buffer_lazy_h.fos"

void unsafe_deflect(Critter& cr, int target, int, int, string@ func, array<int32>@ data)
{
    cr.Say(SAY_NETMSG, "deflect start");

    if(!valid(func) || func.length() == 0)
    {
        cr.Say(SAY_NETMSG, "No function name");
        return;
    }

    Critter@ victim = GetCritter(target);
    if(!valid(victim))
    {
        cr.Say(SAY_NETMSG, "Invalid target<" + target + ">");
        return;
    }

    if(victim.IsNpc())
    {
        cr.Say(SAY_NETMSG, "Not on npcs");
        return;
    }

    if(!valid(data) || data.length() == 0)
    {
        cr.Say(SAY_NETMSG, "No data");
        return;
    }

    cr.Say(SAY_NETMSG, "deflect read");
    Buffer@ buffer = NewBuffer(data);
    cr.Say(SAY_NETMSG, "deflect send");
    RunLazyScript(victim, func, 0, 0, 0, null, buffer.AsInt32());
    cr.Say(SAY_NETMSG, "deflect end");
}
#endif

////

#ifdef SOME_SUNNY_DAY

# define RIDDLE_TYPE_NOT_SET     (0)
# define RIDDLE_TYPE_DIALOG      (1)

# define RIDDLE_STATE_WIP        (-1)
# define RIDDLE_STATE_STOPPED    (0)
# define RIDDLE_STATE_RUNNING    (1)

class CRiddle
{
    uint          id;
    string        name;
    string        author;

    int           type;
    int           state;

    array<string> question;
    array<string> answer;
    array<uint>   reward;               // PID, count_from, count_to
    int           reward_flags;

    CRiddle(uint id)
    {
        this.id = id;
        this.name = "noname";
        this.name = "nobody";

        this.type  = RIDDLE_TYPE_NOT_SET;
        this.state = RIDDLE_STATE_WIP;
    }

    # define _LoadSaveRiddle           \
        # (serializator, op)           \
        serializator op this.id;       \
        serializator op this.name;     \
        serializator op this.author;   \
        serializator op this.type;     \
        serializator op this.state;    \
        serializator op this.question; \
        serializator op this.answer;   \
        serializator op this.reward;   \
        serializator op this.reward_flags

    void Load(Serializator@ riddle)
    {
        _LoadSaveRiddle(riddle, >>);

   //     Log("Loaded riddle: " + this.name);
    }

    void Save(string prefix)
    {
        Serializator@ riddle;
        _LoadSaveRiddle(riddle, <<);
        riddle.Save(prefix + ("" + id));

     //   Log("Saved riddle: " + this.name);
    }
};
array<CRiddle@> Riddles;

void LoadRiddles()
{
    return;
    Serializator@ riddles;

    if(riddles.Load("Cheats:RiddleList"))
    {
    //    Log("Loading riddles...");
        array<uint> riddlesIDs;
        riddles >> riddlesIDs;


        for(uint r = 0, rlen = riddlesIDs.length(); r < rlen; r++)
        {
            Serializator@ sRiddle;
            if(sRiddle.Load("Cheats:Riddle:" + riddlesIDs[r]))
            {
                CRiddle@ riddle = CRiddle(riddlesIDs[r]);
                riddle.Load(sRiddle);
            }
        }
     //   Log("Loaded riddles.");
    }
}

void SaveRiddles()
{
    uint rlen = Riddles.length();
    if(rlen > 0)
    {
     //   Log("Saving riddles...");
        array<uint> riddleIDs;
        for(uint r = 0; r < rlen; r++)
        {
            Riddles[r].Save("Cheats:Riddle:");
            riddleIDs.insertLast(Riddles[r].id);
        }
        if(riddleIDs.length() > 0)
        {
            Serializator@ riddles;
            riddles << riddleIDs;
            riddles.Save("Cheats:RiddleList");
        }
    //    Log("Saved riddles.");
    }
}

string riddleInfo(uint idx, bool shortInfo)
{
    string result = "";
    if(idx > Riddles.length() - 1)
    {
        result = "IDX " + idx + " out of bounds!";
        return(result);
    }

    string state = "UnknownState";
    switch(Riddles[idx].state)
    {
    case RIDDLE_STATE_WIP:
        state = "WIP";
    case RIDDLE_STATE_STOPPED:
        state = "STOPPED";
    case RIDDLE_STATE_RUNNING:
        state = "RUNNING";
    }
    result += "[" + Riddles[idx].id + "] '" + Riddles[idx].name + "' " + Riddles[idx].author;

    if(!shortInfo)
    {}

    return(result);
}
void ExecRiddleCommand(array<string@>@ command, Critter@ player)
{
    if(command.length() < 3)
    {
        player.Say(SAY_NETMSG, "Missing parameters.");
        return;
    }
    else if(command[2] == "list")
    {
        if(Riddles.length() == 0)
        {
            player.Say(SAY_NETMSG, "There is no riddles.");
        }
        for(uint r = 0, rlen = Riddles.length(); r < rlen; r++)
        {
            player.Say(SAY_NETMSG, riddleInfo(r, true));
        }
    }
}




#endif
/*@}*/

void highlight_info(Critter& player, Critter@ npc, string@ text)
{
	text += ("$r" + "" + player.ParamBase[CONFIG_1]);
	
	text += ("$g" + "" + player.ParamBase[CONFIG_2]);
	
	text += ("$b" + "" + player.ParamBase[CONFIG_3]);
	
	text += ("$a" + "" + player.ParamBase[CONFIG_4]);
	
	text += ("$c" + "|" + COLOR_RGB(player.Param[CONFIG_1],player.Param[CONFIG_2],player.Param[CONFIG_3]) + " ");
}

void highlight_change(Critter& player, Critter@npc, int color, int value, int sub)
{
	switch(color)
	{
	case 1: 
	if(sub>0) player.ParamBase[CONFIG_1] -= value; else player.ParamBase[CONFIG_1] += value; break;
	case 2:
	if(sub>0) player.ParamBase[CONFIG_2] -= value; else player.ParamBase[CONFIG_2] += value; break;
	case 3:
	if(sub>0) player.ParamBase[CONFIG_3] -= value; else player.ParamBase[CONFIG_3] += value; break;
	case 4:
	if(sub>0) player.ParamBase[CONFIG_4] -= value; else player.ParamBase[CONFIG_4] += value; break;
	}
	
	if(player.ParamBase[CONFIG_1] < 0)
		player.ParamBase[CONFIG_1] = 0;
	if(player.ParamBase[CONFIG_2] < 0)
		player.ParamBase[CONFIG_2] = 0;
	if(player.ParamBase[CONFIG_3] < 0)
		player.ParamBase[CONFIG_3] = 0;
	if(player.ParamBase[CONFIG_4] < 0)
		player.ParamBase[CONFIG_4] = 0;
		
	if(player.ParamBase[CONFIG_1] > 255)
		player.ParamBase[CONFIG_1] = 255;
	if(player.ParamBase[CONFIG_2] > 255)
		player.ParamBase[CONFIG_2] = 255;
	if(player.ParamBase[CONFIG_3] > 255)
		player.ParamBase[CONFIG_3] = 255;
	if(player.ParamBase[CONFIG_4] > 255)
		player.ParamBase[CONFIG_4] = 255;

	
}

void position_change(Critter& player, Critter@npc, int color, int value, int sub)
{
	switch(color)
	{
	case 1: 
	if(sub>0) player.ParamBase[CONFIG_1] -= value; else player.ParamBase[CONFIG_1] += value; break;
	case 2:
	if(sub>0) player.ParamBase[CONFIG_2] -= value; else player.ParamBase[CONFIG_2] += value; break;
	case 3:
	if(sub>0) player.ParamBase[CONFIG_3] -= value; else player.ParamBase[CONFIG_3] += value; break;
	
	}
	

	
}

void timeout_font(Critter& player, Critter@npc, int color)
{
	player.ParamBase[CONFIG_1] = color;
	player.RunClientScript("client_container_addons@_update_config", player.Id, 9, color, "", null);
}

void highlight_save(Critter& player, Critter@npc, int config)
{	
	player.RunClientScript("client_container_addons@_update_config", player.Id, config, 0, "", null);
}

void bind_key(Critter& player, Critter@npc, int key, int special)
{
	if(special>0)
	{
		if(special != 2)
		switch(key)
		{
		case 1: player.ParamBase[CONFIG_2] = 1; break;
		case 2: player.ParamBase[CONFIG_3] = 1; break;
		case 3: player.ParamBase[CONFIG_4] = 1; break;
		}
		else
		switch(key)
		{
		case 1: player.ParamBase[CONFIG_2] = 0; break;
		case 2: player.ParamBase[CONFIG_3] = 0; break;
		case 3: player.ParamBase[CONFIG_4] = 0; break;
		}
	}
	else player.ParamBase[CONFIG_1] = key;
}

void select_action(Critter& player, Critter@npc, int action)
{
	player.ParamBase[CONFIG_5] = action;
}

void select_item(Critter& player, Critter@npc, int item)
{
	if(player.Param[CONFIG_6] == 0)
		{
		player.ParamBase[CONFIG_6] = item;
		return;
		}
	if(player.Param[CONFIG_7] == 0)
		{
		player.ParamBase[CONFIG_7] = item;
		return;
		}
	if(player.Param[CONFIG_8] == 0)
		{
		player.ParamBase[CONFIG_8] = item;
		return;
		}
	if(player.Param[CONFIG_9] == 0)
		{
		player.ParamBase[CONFIG_9] = item;
		return;
		}
	if(player.Param[CONFIG_10] == 0)
		{
		player.ParamBase[CONFIG_10] = item;
		return;
		}
	player.Say(SAY_NETMSG, "|"+COLOR_RGB(255,0,0)+" Reached maximum amount of items for one hotkey");
}

void reset_item(Critter& player, Critter@npc)
{
	player.ParamBase[CONFIG_6] = 0;
	player.ParamBase[CONFIG_7] = 0;
	player.ParamBase[CONFIG_8] = 0;
	player.ParamBase[CONFIG_9] = 0;
	player.ParamBase[CONFIG_10] = 0;
}

bool is_select_item(Critter& player, Critter@npc, int item)
{
	if(player.Param[CONFIG_6] == item)
		return false;
	if(player.Param[CONFIG_7] == item)
		return false;
	if(player.Param[CONFIG_8] == item)
		return false;
	if(player.Param[CONFIG_9] == item)
		return false;
	if(player.Param[CONFIG_10] == item)
		return false;
		
	return true;
}
bool is_bind_key(Critter& player, Critter@npc, int key)
{
	switch(key)
		{
		case 1: if(player.ParamBase[CONFIG_2] > 0) return false; else return true;
		case 2: if(player.ParamBase[CONFIG_3] > 0) return false; else return true;
		case 3: if(player.ParamBase[CONFIG_4] > 0) return false; else return true;
		}
	return false;
}

bool is_bind_key_not(Critter& player, Critter@npc, int key)
{
	switch(key)
		{
		case 1: if(player.ParamBase[CONFIG_2] > 0) return true; else return false;
		case 2: if(player.ParamBase[CONFIG_3] > 0) return true; else return false;
		case 3: if(player.ParamBase[CONFIG_4] > 0) return true; else return false;
		}
	return false;
}

void bind_save(Critter& player, Critter@npc)
{	
	player.RunClientScript("client_container_addons@_update_config", player.Id, player.Param[CONFIG_5], 0, "", null);
}
