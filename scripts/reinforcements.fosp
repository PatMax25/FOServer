                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             

int week_patch=1;
int doubleloot=1;
bool dropchance(float chance)
{
	if(chance==0)
	return false;
	if(Random(0,100)<chance)
	return true;
	
	return false;
	
}

bool can_tc_modoc=false;
bool can_tc_klamath=false;
bool can_tc_gecko=false;
bool can_tc_bh=false;
bool can_tc_redding=false;
bool can_tc_den=false;
bool can_tc_necro=false;
bool can_tc_reno=false;

uint when_tc_modoc=0;
uint when_tc_klamath=0;
uint when_tc_gecko=0;
uint when_tc_bh=0;
uint when_tc_redding=0;
uint when_tc_den=0;
uint when_tc_necro=0;
uint when_tc_reno=0;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   

import bool AddMiscPlane(Critter&npc,uint priority,uint waitMinute,string@funcName)from"npc_planes";
import bool AddMiscPlane(Critter&npc,uint priority,int identifier,uint identifierExt,uint waitSecond,string@funcName)from"npc_planes";
import bool AddWalkPlane(Critter&npc,uint priority,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)from"npc_planes";
import bool AddWalkPlane(Critter&npc,uint priority,int identifier,uint identifierExt,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)from"npc_planes";
import bool AddAttackPlane(Critter&npc,uint priority,Critter&target)from"npc_planes";
import bool AddAttackPlane(Critter&npc,uint priority,uint critId)from"npc_planes";
import bool AddAttackPlane(Critter&npc,uint priority,Critter&target,int minHp)from"npc_planes";
import bool AddAttackPlane(Critter&npc,uint priority,uint critId,int minHp)from"npc_planes";
import bool AddAttackPlane(Critter&npc,uint priority,Critter&target,bool run)from"npc_planes";
import bool AddPickPlane(Critter&npc,uint priority,uint16 hexX,uint16 hexY,uint16 protoId,uint useItemId,bool toOpen)from"npc_planes";
import bool AddPickPlane(Critter&npc,uint priority,Item@item,uint useItemId,bool toOpen)from"npc_planes";
import bool AddPickPlane(Critter&npc,uint priority,Item@item,uint useItemId,bool toOpen,bool run)from"npc_planes";
import bool AddHealCritterPlane(Critter&npc,uint priority,Critter@target,bool run)from"npc_planes";
import bool AddDoctorCritterPlane(Critter&npc,uint priority,Critter@target,bool run)from"npc_planes";

import uint EraseAttackPlane(Critter&npc,uint priority,Critter&target)from"npc_planes";
import uint EraseAttackPlane(Critter&npc,uint priority,uint critId)from"npc_planes";                                                                                                                                                        

int GetRootMapData(Map&map,uint index)
{
	return map.GetLocation().GetMapByIndex(0).GetData(index);
}  

void SetRootMapData(Map&map,uint index,int val)
{
	map.GetLocation().GetMapByIndex(0).SetData(index,val);
}   

int GetRootMapData(Location&loc,uint index)
{
	return loc.GetMapByIndex(0).GetData(index);
}  

void SetRootMapData(Location&loc,uint index,int val)
{
	loc.GetMapByIndex(0).SetData(index,val);
}                                                                                                                                                                       

import void AddReputation(Critter@cr,uint index,int val)from"reputations";
import void SubReputation(Critter@cr,uint index,int val)from"reputations";
import void AddReputation(Critter@cr,uint index,int val,int cap)from"reputations";
import void SubReputation(Critter@cr,uint index,int val,int cap)from"reputations";
import uint ReputationIndex(uint locid)from"reputations";
import void ProcessProfitReputation(Critter@cr,uint index,int profit)from"reputations";

import void InitGroups()from"reputations_modifiers";
import void ApplyReputationModifiers(Critter&cr,uint index)from"reputations_modifiers";
import void ApplyReputationModifiers(Critter&cr,uint index,float fraction)from"reputations_modifiers";
import void ApplyReputationModifiers(Critter&cr,uint index,int num,int den)from"reputations_modifiers";
import int GetReputationModifier(uint fac1,uint fac2)from"reputations_modifiers";
import int GetGroupsStatus(uint fac1,uint fac2)from"reputations_modifiers";
import int GetGroupsStatus(Critter&c1,Critter&c2)from"reputations_modifiers";
import void ReputationsInit(Critter&cr)from"reputations_modifiers";
import void FeedReputations(Critter@cr,uint index,int cap)from"reputations_modifiers";                                                                                                                                                                                                                                                                                                                                                                                                                       

import Location@GetLocationOf(Critter&critter)from"utils";
import string GetLocationName(uint locId)from"utils";
import string GetLocationName(Location@loc)from"utils";
import bool ReadPids(array<int>&out pids,bool removeinvalid)from"utils";
import void ReadDefines(string@fileName,dictionary&items,array<string>@defines)from"utils";
import bool ParseDefine(const string&in line,string&out spid,int&out id)from"utils";
import int SkipWhitespaces(const string&in str,int start)from"utils";
import int SkipNonWhitespaces(const string&in str,int start)from"utils";
import bool IsParameterTag(string&str)from"utils";
import string GetParameterString(array<string@>@arr,string&parameter)from"utils";
import int GetIndexOfString(array<string@>@arr,string&str)from"utils";
import string GetConcatenatedString(array<string@>@arr,uint startindex,int stopindex)from"utils";
import string GetConditionOfCritter(Critter@cr)from"utils";
import string GetExtConditionOfCritter(Critter@cr)from"utils";
import uint GetAllOnlinePlayers(array<Critter@>&out players)from"utils";
import uint GetAuthenticatedPlayers(array<Critter@>&out players)from"utils";
import uint GetAuthenticatedPlayers(array<Critter@>&out players,bool ignorePriviledges)from"utils";
import uint GetNumberOfPlayersOnline()from"utils";
import void SetTurnBasedAvailability(Location@loc)from"utils";
import bool IsGuarded(Map@map)from"utils";
import bool IsPublic(Map@map)from"utils";
import bool IsEncounterMap(Map@map)from"utils";
import bool IsTown(Map@map)from"utils";
import bool IsDungeon(Map@map)from"utils";
import bool IsBaseControl(Map@map)from"utils";

import uint GetMapType(Map@map)from"utils";
import void LockDoor(uint x,uint y,Map@map,uint complexity,uint lockid)from"utils";
import void UnlockDoor(uint x,uint y,Map@map)from"utils";
import void ClearContainer(Item@container)from"utils";
import void MoveItemsCritterToCont(Critter&crFrom,Item&contTo,uint specid)from"utils";
import string GetCritterInfo(Critter&cr)from"utils";
import bool AddExpTeam(Critter&critter,int xp)from"utils";
import void ClearEnemyStack(Critter&critter)from"utils";
import void ClearEnemyStacksOnMap(Map@map)from"utils";
import bool IsCurrentEnemy(Critter&cr,uint targetId)from"utils";
import string@GetSafePlayerName(uint id)from"utils";
import string GetSafePlayerName(uint id,string&onSuccess,string&onError)from"utils";
import IDateTime@GetCurrentDateTime()from"utils";
import string GetCurrentDateTimeString()from"utils";
import string GetCurrentDateTimeString(bool date,bool time)from"utils";
import Critter@GetMostSkilled(array<Critter@>@group,int skill)from"utils";
import string GetAuthString(Critter&player)from"utils";
import string GetAuthString(int accesslevel)from"utils";
import bool CanRequestHelp(Critter&player)from"utils";
import void SetRequestedHelp(Critter&player)from"utils";
import void SetRequestedHelp(Critter&player,int minutes)from"utils";
import Critter@GetOnlineGM()from"utils";
import void Preprocess(Critter&player,string&commandString)from"utils";
import bool IsHumanoid(Critter@cr)from"utils";
import uint GetGroupIndex(Critter&cr)from"utils";
import uint GetGroupIndex(int st)from"utils";
import void SetGroupIndex(Critter&cr,uint val)from"utils";
import uint GetGroupRank(Critter&cr)from"utils";
import void SetGroupRank(Critter&cr,uint val)from"utils";
import uint GetGroupMode(Critter&cr)from"utils";
import void SetGroupMode(Critter&cr,uint val)from"utils";
import void SetGroupInfo(Critter&cr,uint faction,uint rank,uint mode)from"utils";
import void SetGroupInfoPack(Critter&cr,uint packInfo)from"utils";
import void ClearEvents(Critter&cr)from"utils";

import int GetGvar(uint gvar)from"utils";
import void SetGvar(uint gvar,uint value)from"utils";
import int GetLLvar(Location&location,uint llvar)from"utils";
import int GetLLvar(uint locationId,uint llvar)from"utils";
import void SetLLvar(Location&location,uint llvar,uint value)from"utils";
import int GetLMvar(Map&map,uint llvar)from"utils";
import int GetLMvar(uint mapId,uint llvar)from"utils";
import void SetLMvar(Map&map,uint llvar,uint value)from"utils";
import int GetLIvar(Item&item,uint llvar)from"utils";
import int GetLIvar(uint itemId,uint llvar)from"utils";
import void SetLIvar(Item&item,uint llvar,uint value)from"utils";
import int GetLvar(Critter&critter,uint lvar)from"utils";
import int GetLvar(uint id,uint lvar)from"utils";
import void SetLvar(Critter&critter,uint lvar,uint value)from"utils";
import void SetLvar(uint id,uint lvar,uint value)from"utils";
import int GetUvar(uint uvar,uint key,uint index)from"utils";
import void SetUvar(uint uvar,uint key,uint index,uint value)from"utils";

import uint GetContainerValue(Item@container)from"utils";
import uint BaseItemValue(uint pid,bool ammo)from"utils";
import uint BaseItemValue(uint pid,uint broken,uint det,bool ammo)from"utils";
import uint BaseItemValue(Item@item)from"utils";
import uint BaseItemValue(Item@item,uint proc)from"utils";
import uint BaseSingleItemValue(Item@item)from"utils";
import uint BaseSingleItemValue(Item@item,uint proc)from"utils";

import void SetBloodType(Critter@cr)from"utils";
import string GetBloodType(Critter@cr)from"utils";
import string GetBloodRandom()from"utils";

import void LogCommandUsage(Critter&player,string&commandString)from"utils";
import void DropTimeouts(Critter&cr)from"utils";

import bool HasItem(Critter@cr,uint pid)from"utils";
import bool HasSomeWeapon(Critter@cr)from"utils";
import uint GetBestWeaponSkill(Critter@cr)from"utils";
import void GiveBag(uint bag,Critter@cr)from"utils";
import void SetQuestGarbager(uint time,uint playerid,uint locid,uint var,uint val)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,uint factionRank,uint factionMode,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,array<int>params,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,array<int>params,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,uint factionRank,uint factionMode,bool isMob,uint level)from"utils";
import void AddScore(Critter@cr,uint score,uint points)from"utils";

import bool ReloadWeapon(Critter&cr)from"utils";
import Item@GetRadio(Critter&cr)from"utils";
import Item@GetRepairTool(Critter&cr)from"utils";
import Item@GetEquippedItem(Critter&cr,uint Pid)from"utils";
import Item@GetEquippedItem(Critter&cr,array<uint>&Pids)from"utils";
import Item@GetEquippedItemByType(Critter&cr,uint ItemType)from"utils"; 

import bool SkillRoll(Critter@cr,int skill,int bonus)from"utils";
import int SkillCheck(Critter&cr,int skill,int skillused,Item@item,int bonus)from"utils";
import string SkillName(uint8 skill)from"utils";
import void ChangeCrTypeSafe(Critter&cr,uint8 crType)from"utils";

import bool Pickable(Item@item)from"utils";

import void TransferItemsToContOnMap(Critter&cr,Map@map,int entid,int contpid,int itemtypes)from"utils";
import void TransferItemsFromContOnMap(Critter&cr,Map@map,int entid,int contpid)from"utils";

import string IpToString(uint ip)from"utils";

import void VerboseAction(Critter&cr,string&text)from"utils";
import void VerboseAction(Critter&cr,Critter&target,string&text)from"utils";
import void VerboseExperience(Critter&cr,int xpDiff,int levelDiff)from"utils";

import void SetChosenActions(Critter&cr,array<int>&actions)from"utils";

import void HexLine(uint16 x0,uint16 y0,uint16 x1,uint16 y1,array<uint16>@xList,array<uint16>@yList)from"utils";
import void HexCircle(uint16 x0,uint16 y0,uint16 radius,array<uint16>@xList,array<uint16>@yList)from"utils";

import void StartPersonalDataCleanup()from"utils";

import bool IsPersonalData(Location&location,string&name)from"utils";
import bool GetPersonalData(Location&location,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Location&location,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Location&location,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Location&location,string&name)from"utils";

import bool IsPersonalData(Map&map,string&name)from"utils";
import bool GetPersonalData(Map&map,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Map&map,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Map&map,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Map&map,string&name)from"utils";

import bool IsPersonalData(Critter&critter,string&name)from"utils";
import bool GetPersonalData(Critter&critter,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Critter&critter,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Critter&critter,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Critter&critter,string&name)from"utils";

import bool IsPersonalData(Item&item,string&name)from"utils";
import bool GetPersonalData(Item&item,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Item&item,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Item&item,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Item&item,string&name)from"utils";

import bool FindPreferredGridApprox(Map&map,uint16&hx,uint16&hy)from"utils";           

import bool StrToInt(string@s,uint64&inout val)from"strtoint";
import bool StrToInt(string@s,uint&inout val)from"strtoint";
import bool StrToInt(string@s,uint16&inout val)from"strtoint";
import bool StrToInt(string@s,uint8&inout val)from"strtoint";
import bool StrToInt(string@s,int64&inout val)from"strtoint";
import bool StrToInt(string@s,int16&inout val)from"strtoint";
import bool StrToInt(string@s,int8&inout val)from"strtoint";    

import int FindInArray(array<int>&arr,int value)from"utils";
import int FindInArray(array<uint>&arr,uint value)from"utils";
import int FindInArray(array<uint16>&arr,uint16 value)from"utils";
import int FindInArray(array<uint8>&arr,uint8 value)from"utils";
import bool FindInArray(array<int>&arr,int id,int&index)from"utils";
import bool FindInArray(array<uint>&arr,uint id,int&index)from"utils";
import bool FindInArray(array<uint8>&arr,uint8 id,int&index)from"utils";
import int FindInArray(array<string>&arr,string&value)from"utils";
import int FindInArray(array<string@>@arr,string&value)from"utils";
import bool Present(int what,array<int>&where)from"utils";
import bool Present(uint what,array<uint>&where)from"utils";
import bool Present(uint16 what,array<uint16>&where)from"utils";
import bool Present(string&what,array<string>&where)from"utils";
import bool Present(string&what,array<string@>@where)from"utils";

import uint CreateLocationForGroup(Critter&player,uint16 pid,uint16 worldX,uint16 worldY,array<Critter@>&)from"utils";
import bool FindFirstFreeHex(Map@map,uint16&x,uint16&y,uint8 dir,uint16 maxSteps)from"utils";
import bool FindNearestFreeHex(Map&map,uint16&x,uint16&y,uint radius)from"utils";

import bool GetItemCoordinates(Item&item,uint&mapID,uint16&x,uint16&y)from"utils";
import bool ItemOnHex(uint16 pid,Map@map,uint16 x,uint16 y)from"utils";

import void PrintCallstack()from"utils";
import void PrintCallstack(int level)from"utils";

import bool LocationHasCritters(Location&loc,uint findType)from"utils";
import uint LocationGetCritters(Location&loc,uint findType,array<Critter@>@critters)from"utils";
import uint LocationGetPlayersAndFollowers(Location&loc,uint findType,array<Critter@>@critters)from"utils";
import uint MapGetPlayersAndFollowers(Map&map,uint findType,array<Critter@>@critters)from"utils";
import uint CritterGetPlayersAndFollowers(Critter&critter,bool lookOnMe,uint findType,array<Critter@>@critters)from"utils";
import bool LocationHasItems(Location&loc,uint16 protoId)from"utils";
import uint LocationGetItems(Location&loc,uint16 protoId,array<Item@>@items)from"utils";
import void LocationDeleteItems(Location&loc,uint16 protoId)from"utils";

import bool IsDisposableEncounter(Location@loc)from"utils";

import bool IsT4Item(Item&item)from"utils";
import bool IsT3Item(Item&item)from"utils";
import uint16 AddT3Item()from"utils";
import uint16 AddT4Item()from"utils";
import uint16 AddImplant()from"utils";
import uint16 AddT4BP()from"utils";
import uint16 AddRareAmmo()from"utils";
import uint16 AddTypicalAmmo()from"utils";

import void SetDeterioration(Item&item)from"utils";  

shared class CPosition
{
	uint x;
	uint y;
	uint dir;
};

shared interface IRect
{
	bool IsWithin(Critter&cr);
};

shared class Rect:IRect
{
	uint x1;
	uint y1;
	uint x2;
	uint y2;
	
	Rect(uint x1,uint y1,uint x2,uint y2)
	{
		this.x1=x1;
		this.y1=y1;
		this.x2=x2;
		this.y2=y2;
	}
	
	bool IsWithin(Critter&cr)
	{
		return((cr.HexX>=this.x1&&cr.HexX<=this.x2)&&(cr.HexY>=this.y1&&cr.HexY<=this.y2));
	}
};

shared interface IDateTime
{
	uint16 get_Year();
	uint16 get_Month();
	uint16 get_DayOfWeek();
	uint16 get_Day();
	uint16 get_Hour();
	uint16 get_Minute();
	uint16 get_Second();
	uint16 get_Milliseconds();
	string@ToString();
};                                                                                                                                                                                                                                

import void GuardInit(Critter&guard)from"guard";
import void GuardOnIdle(Critter&guard)from"guard";
import void GuardOnSomeoneSteal(Critter&guard,Critter&fromCrit,Critter&target,bool success,Item&item,uint count)from"guard";
import void GuardOnShowCritter(Critter&cr,Critter&target)from"guard";
import void GuardOnMessage(Critter&guard,Critter&sender,int num,int val)from"guard";
import void CheckHealing(Critter&cr)from"guard";
import void GuardPerks(Critter&cr)from"guard";
import bool DetectStealing(Critter&cr,Critter&target,Critter&thief)from"guard";
import void CheckForWeapons(Critter&guard,Critter&crit)from"guard";

import bool InWeaponAllowedZone(Critter@cr)from"guard";                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

shared class Entire
{
	int Number;
	uint16 HexX;
	uint16 HexY;
	uint8 Direction;
};

uint ParseEntires(Map&map,array<Entire>&entires,int number)
{
	uint oldCount=entires.length();
	uint count=map.CountEntire(number);
	entires.resize(oldCount+count);
	
	for(uint i=0;i<count;i++)
	{
		Entire@ent=entires[oldCount+i];
		if(map.GetEntireCoords(number,i,ent.HexX,ent.HexY,ent.Direction)==false)
		return 0;
		ent.Number=number;
	}
	
	return count;
}

bool IsEntireFree(uint mappid,int number)
{
	Map@map=GetMapByPid(mappid,0);
	return IsEntireFree(map,number);
}

bool IsEntireFree(Map&map,int number)
{
	uint16 x,y;
	x=0;
	y=0;
	return GetEntireFreeHex(map,number,x,y);
}

bool GetEntireFreeHex(Map&map,int number,uint16&hx,uint16&hy,uint skip=0)
{
	uint count=map.CountEntire(number); 
	
	for(uint i=skip;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy)&&map.IsHexPassed(hx,hy))
		return true;
	}
	
	if(hx==0||hy==0||hx>=map.GetWidth()-1||hy>=map.GetHeight()-1)
	return false; 
	
	for(uint i=0;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy))
		{
			for(int x=-1;x<=1;x++)
			{
				for(int y=-1;y<=1;y++)
				{
					if(x==0&&y==0)
					continue;
					if(__MapHexagonal)
					{
						if((hx%2)==1&&((x==-1&&y==1)||(x==1&&y==1)))
						continue;
						if((hx%2)==0&&((x==-1&&y==-1)||(x==1&&y==-1)))
						continue;
					}
					
					if(map.IsHexPassed(hx+x,hy+y))
					{
						hx+=x;
						hy+=y;
						return true;
					}
				}
			}
		}
	}
	return false;
}

bool GetNearEntire(Map&map,int number,uint16&hx,uint16&hy)
{
	uint16 hxBase=hx;
	uint16 hyBase=hy;
	
	array<Entire>entires;
	uint count=ParseEntires(map,entires,number);
	if(count==0)
	return false;
	
	hx=entires[0].HexX;
	hy=entires[0].HexY;
	for(uint i=1;i<count;i++)
	{
		Entire@ent=entires[i];
		if(GetDistantion(hxBase,hyBase,ent.HexX,ent.HexY)<GetDistantion(hxBase,hyBase,hx,hy))
		{
			hx=ent.HexX;
			hy=ent.HexY;
		}
	}
	
	return true;
}                                                                                    

shared class Serializator
{
	Serializator()
	{
		CurPos=0;
		BufSize=0;
		DataSize=0;
	}
	
	Serializator(uint approxSize)
	{
		CurPos=0;
		BufSize=0;
		DataSize=0;
		GrowBuffer(approxSize);
	}
	
	void GrowBuffer()
	{
		BufSize+=(128);
		Array.resize(BufSize);
	}
	
	void GrowBuffer(uint length)
	{
		BufSize+=length;
		Array.resize(BufSize);
	}
	
	bool Save(string&name)
	{
		if(DataSize==0)
		return false;
		bool result=SetAnyData(name,Array,DataSize);
		Clear();
		return result;
	}
	
	bool Load(string&name)
	{
		Clear();
		if(!IsAnyData(name))
		return false;
		if(!GetAnyData(name,Array))
		return false;
		BufSize=Array.length();
		DataSize=BufSize;
		return true;
	}
	
	void Clear()
	{
		CurPos=0;
		BufSize=0;
		DataSize=0;
	}
	
	Serializator@SetCurPos(uint pos)
	{
		if(pos>BufSize)
		GrowBuffer(pos-BufSize+(128));
		CurPos=pos;
		return this;
	}
	
	Serializator@Fill(uint8 value,uint length)
	{
		if(CurPos+length>BufSize)
		GrowBuffer(CurPos+length-BufSize+(128));
		for(uint i=0;i<length;i++)
		Array[CurPos++]=value;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@Set(const int64&value)
	{
		if(CurPos+8>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>56)&0xFF;
		Array[CurPos++]=(value>>48)&0xFF;
		Array[CurPos++]=(value>>40)&0xFF;
		Array[CurPos++]=(value>>32)&0xFF;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const int64&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const int32&value)
	{
		if(CurPos+4>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const int32&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const int16&value)
	{
		if(CurPos+2>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const int16&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const int8&value)
	{
		if(CurPos+1>BufSize)
		GrowBuffer();
		Array[CurPos++]=value;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const int8&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const uint64&value)
	{
		if(CurPos+8>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>56)&0xFF;
		Array[CurPos++]=(value>>48)&0xFF;
		Array[CurPos++]=(value>>40)&0xFF;
		Array[CurPos++]=(value>>32)&0xFF;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const uint64&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const uint32&value)
	{
		if(CurPos+4>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const uint32&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const uint16&value)
	{
		if(CurPos+2>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const uint16&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const uint8&value)
	{
		if(CurPos+1>BufSize)
		GrowBuffer();
		Array[CurPos++]=value;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const uint8&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const bool&value)
	{
		if(CurPos+1>BufSize)
		GrowBuffer();
		Array[CurPos++]=value?1:0;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const bool&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const string&value)
	{
		uint len=value.rawLength();
		if(CurPos+len+1>BufSize)
		GrowBuffer(CurPos+len+1-BufSize+(128));
		for(uint i=0;i<len;i++)
		Array[CurPos++]=value.rawGet(i);
		Array[CurPos++]=0;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const string&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const float&value)
	{
		int dummy=FloatToInt(value);
		return Set(dummy);
	}
	
	Serializator@opShl(const float&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const array<int64>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*8;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<int64>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<int32>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*4;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<int32>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<int16>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*2;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<int16>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<int8>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<int8>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<uint64>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*8;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<uint64>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<uint32>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*4;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<uint32>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<uint16>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*2;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<uint16>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<uint8>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<uint8>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<bool>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<bool>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<string>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		for(uint i=0,j=valuesLen;i<j;i++)
		len+=values[i].length();
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<string>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<float>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*4;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(FloatToInt(values[i]));
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<float>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const Critter&cr)
	{
		if(CurPos+4>BufSize)
		GrowBuffer();
		uint value=cr.Id;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const Critter&cr)
	{
		return Set(cr);
	}
	
	Serializator@Set(const Item&item)
	{
		if(CurPos+4>BufSize)
		GrowBuffer();
		uint value=item.Id;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const Item&item)
	{
		return Set(item);
	}
	
	Serializator@Get(int64&value)
	{
		value=0;
		if(CurPos+8>DataSize)
		return this;
		value|=Array[CurPos++]<<56;
		value|=Array[CurPos++]<<48;
		value|=Array[CurPos++]<<40;
		value|=Array[CurPos++]<<32;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(int64&value)
	{
		return Get(value);
	}
	
	Serializator@Get(int32&value)
	{
		value=0;
		if(CurPos+4>DataSize)
		return this;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(int32&value)
	{
		return Get(value);
	}
	
	Serializator@Get(int16&value)
	{
		value=0;
		if(CurPos+2>DataSize)
		return this;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(int16&value)
	{
		return Get(value);
	}
	
	Serializator@Get(int8&value)
	{
		value=0;
		if(CurPos+1>DataSize)
		return this;
		value=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(int8&value)
	{
		return Get(value);
	}
	
	Serializator@Get(uint64&value)
	{
		value=0;
		if(CurPos+8>DataSize)
		return this;
		value|=Array[CurPos++]<<56;
		value|=Array[CurPos++]<<48;
		value|=Array[CurPos++]<<40;
		value|=Array[CurPos++]<<32;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(uint64&value)
	{
		return Get(value);
	}
	
	Serializator@Get(uint32&value)
	{
		value=0;
		if(CurPos+4>DataSize)
		return this;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(uint32&value)
	{
		return Get(value);
	}
	
	Serializator@Get(uint16&value)
	{
		value=0;
		if(CurPos+2>DataSize)
		return this;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(uint16&value)
	{
		return Get(value);
	}
	
	Serializator@Get(uint8&value)
	{
		value=0;
		if(CurPos+1>DataSize)
		return this;
		value=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(uint8&value)
	{
		return Get(value);
	}
	
	Serializator@Get(bool&value)
	{
		value=false;
		if(CurPos+1>DataSize)
		return this;
		value=Array[CurPos++]==1?true:false;
		return this;
	}
	
	Serializator@opShr(bool&value)
	{
		return Get(value);
	}
	
	Serializator@Get(string&str)
	{
		uint len=0;
		for(uint i=CurPos;;i++)
		{
			if(i==DataSize)
			{
				str="";
				return this;
			}
			if(Array[i]==0)
			{
				len=i-CurPos;
				break;
			}
		}
		str.rawResize(len);
		for(uint i=0;i<len;i++)
		str.rawSet(i,Array[CurPos++]);
		CurPos++;
		return this;
	}
	
	Serializator@opShr(string&str)
	{
		return Get(str);
	}
	
	Serializator@Get(float&value)
	{
		int dummy=0;
		Get(dummy);
		value=IntToFloat(dummy);
		return this;
	}
	
	Serializator@opShr(float&value)
	{
		return Get(value);
	}
	
	Serializator@Get(array<int64>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<int64>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<int32>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<int32>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<float>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		{
			int dummy=0;
			Get(dummy);
			values[i]=IntToFloat(dummy);
		}
		return this;
	}
	
	Serializator@opShr(array<float>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<int16>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<int16>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<int8>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<int8>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<uint64>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<uint64>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<uint32>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<uint32>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<uint16>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<uint16>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<uint8>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<uint8>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<bool>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<bool>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<string>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<string>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(Critter@&cr)
	{
		@cr=null;
		if(CurPos+4>DataSize)
		return this;
		uint id=0;
		id|=Array[CurPos++]<<24;
		id|=Array[CurPos++]<<16;
		id|=Array[CurPos++]<<8;
		id|=Array[CurPos++];
		@cr=::GetCritter(id);
		return this;
	}
	
	Serializator@opShr(Critter@&cr)
	{
		return Get(cr);
	}
	
	Serializator@Get(Item@&item)
	{
		@item=null;
		if(CurPos+4>DataSize)
		return this;
		uint id=0;
		id|=Array[CurPos++]<<24;
		id|=Array[CurPos++]<<16;
		id|=Array[CurPos++]<<8;
		id|=Array[CurPos++];
		@item=::GetItem(id);
		return this;
	}
	
	Serializator@opShr(Item@&item)
	{
		return Get(item);
	}
	
	array<uint8>Array;
	uint CurPos;
	uint BufSize;
	uint DataSize;
};                                                                                             

shared interface IBroadcastBuffer
{
	string GetString();
	
	void SetType(int type);
	int GetType();
	void SetTime(int time);
	int GetTime();
	void SetSetup(int setup);
	int GetSetup();
	void SetMessage(string message);
	void AppendMessage(string message);
	string GetMessage();
	void SetData(array<int>data);
	
	void SetStart(int time);
	void ResetStart();
	
	void SetLifetime(int lifetime);
	
	void SetFilters(int filters);
	void SetFilter(int filter);
	void SetFilter(int filter,int data);
	void UnsetFilter(int filter);
	bool Filter(int filter);
	bool CheckFilters(Critter@player);
	
	bool Send(Critter@player);
	uint SendToAll();
	
	void SetGM(int id);
	void UnsetGM();
	
	void ToDelete();
};  

import void UpdateBroadcast()from"broadcast";

import IBroadcastBuffer@AddBroadcastBuffer(int type,int time,int setup,string&message,array<int>&data,int lifetime,int flags)from"broadcast";
import void DumpBroadcastBuffer(Critter@player)from"broadcast";
import uint FindBroadcastBufferByType(int type,array<IBroadcastBuffer@>&buf)from"broadcast";
import uint FindBroadcastBufferByGM(int id,array<IBroadcastBuffer@>&buf)from"broadcast"; 

import IBroadcastBuffer@Broadcast_Message(string&message,int time,int filters,bool send)from"broadcast";
import IBroadcastBuffer@Broadcast_Message(string&message,int time,int filters)from"broadcast";
import IBroadcastBuffer@Broadcast_Message(string&message,int&time)from"broadcast";
import IBroadcastBuffer@Broadcast_Message(string&message,bool send)from"broadcast";
import IBroadcastBuffer@Broadcast_Message(string&message)from"broadcast"; 

import void Broadcast_TownControl_Set(string&message,int location,int time,int faction)from"broadcast";
import void Broadcast_TownControl_Set(int location,int time,int faction,Critter&player)from"broadcast";
import void Broadcast_TownControl_Stop(int location)from"broadcast"; 

import IBroadcastBuffer@Broadcast_Influence(int location,int time,string&message)from"broadcast"; 

import uint Broadcast_RequestHelp(Critter@player,string&message)from"broadcast";
import void Broadcast_CheckRequestHelpBuffer(Critter@gm)from"broadcast";
import void Broadcast_DumpRequestHelpBuffer(Critter@gm)from"broadcast"; 

import void baseControl(string msg,int mapId,uint time)from"broadcast";
import void baseControlRadio(string msg,uint time,int mapId,uint factionId)from"broadcast"; 

import void ServerEventMSG(uint time,string msg)from"broadcast"; 

import IBroadcastBuffer@GetEventCountDownBuffer(int location,int type)from"broadcast";
import void ServerEventCNTSet(string message,uint location,uint type,uint time)from"broadcast";
import void ServerEventCNTSet(uint location,uint type,uint time)from"broadcast";
import void ServerEventCNTStop(uint location,uint type)from"broadcast";                  

uint[]Thresholds={(24),(60)};
bool Initialized=false;             

string BTypeLocation,BShowWave="1st";
uint16 BShowLocation;
uint BShowType=(1);
uint BShowTime; 

class CAlertSettings
{
	uint AlertLevelNone;
	uint AlertLevelLight;
	uint AlertLevelHeavy;
	
	uint AlertCountGuard;
	uint AlertCountNpc;
	uint AlertCountDrop;
	uint AlertCountPDrop;
	
	uint ReinforcementsDelayLow;
	uint ReinforcementsDelayHigh;
	uint ReinforcementsDelayRet;
	uint ReinforcementsCountLow;
	uint ReinforcementsCountHigh;
	
	uint CycleLength;
	
	CAlertSettings()
	{
		AlertLevelNone=(0);
		AlertLevelLight=(24);
		AlertLevelHeavy=(60);
		
		AlertCountGuard=(2);
		AlertCountNpc=(1);
		AlertCountDrop=(4);
		AlertCountPDrop=(20);
		
		ReinforcementsDelayLow=(((15)*60));
		ReinforcementsDelayHigh=(((60)*60));
		ReinforcementsDelayRet=(((1200)*60));
		ReinforcementsCountLow=(4);
		ReinforcementsCountHigh=(8);
		
		CycleLength=(((30)*60));
	}
	
	void Init()
	{
		__AlertLevelReact=(50);
		Load();
		Update();
	}
	
	void Load()
	{
		if(!IsAnyData("AlertSettings"))
		return;
		Serializator serializer;
		serializer.Load("AlertSettings");
		serializer.Get(this.AlertLevelNone)
		.Get(this.AlertLevelLight)
		.Get(this.AlertLevelHeavy)
		.Get(this.AlertCountGuard)
		.Get(this.AlertCountNpc)
		.Get(this.AlertCountDrop)
		.Get(this.AlertCountPDrop)
		.Get(this.ReinforcementsDelayLow)
		.Get(this.ReinforcementsDelayHigh)
		.Get(this.ReinforcementsDelayRet)
		.Get(this.ReinforcementsCountLow)
		.Get(this.ReinforcementsCountHigh)
		.Get(this.CycleLength)
		.Get(__AlertLevelReact);
	}
	
	void Save()
	{
		Serializator serializer;
		serializer.Set(this.AlertLevelNone)
		.Set(this.AlertLevelLight)
		.Set(this.AlertLevelHeavy)
		.Set(this.AlertCountGuard)
		.Set(this.AlertCountNpc)
		.Set(this.AlertCountDrop)
		.Set(this.AlertCountPDrop)
		.Set(this.ReinforcementsDelayLow)
		.Set(this.ReinforcementsDelayHigh)
		.Set(this.ReinforcementsDelayRet)
		.Set(this.ReinforcementsCountLow)
		.Set(this.ReinforcementsCountHigh)
		.Set(this.CycleLength)
		.Set(__AlertLevelReact);
		serializer.Save("AlertSettings");
	}
	
	void Update()
	{
		Thresholds[0]=this.AlertLevelLight;
		Thresholds[1]=this.AlertLevelHeavy;
	}
};             

class CAlertMap
{
	uint Index;
	uint MapId;
	
	uint AlertLevel;
	bool NoReinforcements;
	bool Dead;
	
	array<uint>Reinforcements;
	array<uint>ReinforcementsMax;
	array<bool>Calling;
	array<uint>EventId;
	array<uint>Attackers;
	
	CAlertMap()
	{
		Index=0;
		MapId=0;
		
		AlertLevel=0;
		NoReinforcements=true;
		Dead=false;
		
		Reinforcements.resize((2));
		for(uint __i=0,__j=Reinforcements.length();__i<__j;__i++) Reinforcements[__i]=0;
		ReinforcementsMax.resize((2));
		for(uint __i=0,__j=ReinforcementsMax.length();__i<__j;__i++) ReinforcementsMax[__i]=0;
		Calling.resize((2));
		for(uint __i=0,__j=Calling.length();__i<__j;__i++) Calling[__i]=false;
		EventId.resize((2));
		for(uint __i=0,__j=EventId.length();__i<__j;__i++) EventId[__i]=0;
	}
	
	CAlertMap(uint index,uint mapid,array<uint>@maxes)
	{
		Index=index;
		MapId=mapid;
		
		AlertLevel=0;
		
		if(!(@maxes!=null)||maxes.length()==0)
		NoReinforcements=true;
		else
		{
			NoReinforcements=false;
			Dead=false;
			Reinforcements.resize((2));
			ReinforcementsMax.resize((2));
			for(uint i=0,j=(((maxes.length())<((2)))?(maxes.length()):((2)));i<j;i++)
			ReinforcementsMax[i]=maxes[i];
			for(uint i=0,j=(((maxes.length())<((2)))?(maxes.length()):((2)));i<j;i++)
			Reinforcements[i]=maxes[i];
			Calling.resize((2));
			for(uint __i=0,__j=Calling.length();__i<__j;__i++) Calling[__i]=false;
			EventId.resize((2));
			for(uint __i=0,__j=EventId.length();__i<__j;__i++) EventId[__i]=0;
		}
	}
	
	void StartCalling(uint type,Map&map)
	{
		if(type>=(2))
		type=(2)-1;
		type++;
		do
		{
			type--;
			if(this.Calling[type])
			continue;
			;
			uint[]values={this.Index,type};
			
			BShowTime=Random(settings.ReinforcementsDelayLow,settings.ReinforcementsDelayHigh);
			BShowLocation=map.GetLocation().GetProtoId();
			
			this.EventId[type]=CreateTimeEvent(((__FullSecond)+(BShowTime)),"e_CallReinforcements",values,true);
			ShowBroadcast(BShowLocation);
			this.Calling[type]=(this.EventId[type]>0);
		}
		while(type>0);
	}
	
	void Spawn(uint type)
	{
		if(IsDead())
		return;
		;
		if(type>=(2))
		return;
		if(this.Reinforcements[type]==0)
		return;
		uint n=Random(settings.ReinforcementsCountLow,settings.ReinforcementsCountHigh);
		n=(((n)<(this.Reinforcements[type]))?(n):(this.Reinforcements[type]));
		n=CallReinforcements(this.Attackers,this,n,type);
		this.Reinforcements[type]-=n;
		;
	}
	
	void Cycle()
	{
		if(IsDead())
		return;
		;
		uint drop=(settings.AlertCountPDrop*this.AlertLevel)/100;
		drop=(((drop)>(settings.AlertCountDrop))?(drop):(settings.AlertCountDrop));
		if(this.AlertLevel<drop)
		this.AlertLevel=0;
		else
		this.AlertLevel-=drop;
		if(NoReinforcements)
		{
			;
			return;
		}
		if(this.AlertLevel==0)
		this.Attackers.resize(0);
		for(uint i=0;i<(2);i++)
		if(this.Calling[i]&&this.AlertLevel<Thresholds[i])
		{
			this.Calling[i]=false;
			EraseTimeEvent(this.EventId[i]);
			this.EventId[i]=0;
			;
		}
		;
	}
	
	void ProcessDeath(Critter&cr,Critter@killer)
	{
		if(IsDead())
		return;
		;
		
		if(((cr.Param[(534)]&((0x00000008)))!=0))
		this.AlertLevel+=settings.AlertCountGuard;
		else if((cr.IsNpc()&&!(((cr.Param[(534)]&((0x00000020)))!=0)))&&!(cr.Param[(89)]==200||cr.Param[(89)]==201||cr.Param[(89)]==202||cr.Param[(89)]==203))
		this.AlertLevel+=settings.AlertCountNpc;
		
		if(NoReinforcements)
		{
			;
			return;
		}
		
		if(this.AlertLevel>=(8)&&(@killer!=null)&&!(cr.Param[(89)]==200||cr.Param[(89)]==201||cr.Param[(89)]==202||cr.Param[(89)]==203))
		if(!Present(killer.Id,this.Attackers))
		this.Attackers.insertLast(killer.Id);
		
		uint i=(2);
		do
		{
			i--;
			if(this.AlertLevel>=Thresholds[i])
			{
				if(!this.Calling[i])
				{
					Map@map=cr.GetMap();
					StartCalling(i,map);
				}
				break;
			}
		}
		while(i>0);
		;
	}
	
	void ReinforcementReturn(uint type)
	{
		if(IsDead())
		return;
		if(type>=(2))
		return;
		this.Reinforcements[type]++;
		if(this.Reinforcements[type]>this.ReinforcementsMax[type])
		this.Reinforcements[type]=this.ReinforcementsMax[type];
		;
	}
	
	bool IsDead()
	{
		return this.Dead;
	}
	
	void Validate()
	{
		Map@map=GetMap(MapId);
		if(!(@map!=null)||map.GetData((7))!=int(this.Index))
		this.Dead=true;
	}
	
}; 

CAlertSettings settings;
array<CAlertMap@>alerts;

void SaveAlertMaps()
{
	
	settings.Save();
	Serializator serializer;
	uint len=alerts.length();
	if(len==0)
	{
		Log("ERR: no dummy alert");
		return;
	}
	serializer.Set(len-1);
	for(uint i=1;i<len;i++)
	{
		serializer.Set(alerts[i].Index)
		.Set(alerts[i].MapId)
		.Set(alerts[i].AlertLevel)
		.Set(alerts[i].NoReinforcements)
		.Set(alerts[i].Dead)
		.Set(alerts[i].Reinforcements)
		.Set(alerts[i].ReinforcementsMax)
		.Set(alerts[i].Calling)
		.Set(alerts[i].EventId);
	}
	serializer.Save("AlertMaps");
}

void SetAlertMap(Map&map,array<uint>@maxes)
{
	if(!Initialized)
	InitAlertMaps();
	uint n=alerts.length();
	for(uint i=1;i<n;i++)
	alerts[i].Validate();
	
	CAlertMap@alert=CAlertMap(n,map.Id,maxes);
	alerts.insertLast(alert);
	map.SetData((7),n);
	
}

bool InitAlertMaps()
{
	if(Initialized)
	return true;
	if(Thresholds.length()!=(2))
	{
		Log("ERR: Failed to initialize: Thresholds length != REINFORCEMENT_COUNT");
		return false;
	}
	settings.Init();
	CreateTimeEvent(((__FullSecond)+(settings.CycleLength)),"e_AlertMapsCycle",false);
	Initialized=true;
	CAlertMap@dummy=CAlertMap();
	alerts.insertLast(dummy);
	Serializator serializer;
	if(!IsAnyData("AlertMaps"))
	return true;
	if(!serializer.Load("AlertMaps"))
	return true;
	uint n=0;
	serializer.Get(n);
	for(uint i=0;i<n;i++)
	{
		CAlertMap@alert=CAlertMap();
		serializer.Get(alert.Index)
		.Get(alert.MapId)
		.Get(alert.AlertLevel)
		.Get(alert.NoReinforcements)
		.Get(alert.Dead)
		.Get(alert.Reinforcements)
		.Get(alert.ReinforcementsMax)
		.Get(alert.Calling)
		.Get(alert.EventId);
		alerts.insertLast(alert);
	}
	
	return true;
}

bool IsAlertMap(Map&map)
{
	return map.GetData((7))>0;
}

uint GetAlertLevel(Map&map)
{
	if(map.GetData((7))==0)
	return 0;
	return alerts[map.GetData((7))].AlertLevel;
}

void ProcessDeath(Map&map,Critter&cr,Critter@killer)
{
	if(map.GetData((7))==0)
	return;
	alerts[map.GetData((7))].ProcessDeath(cr,killer);
}

void ReinforcementReturn(Critter&npc)
{
	alerts[npc.Param[(92)]].ReinforcementReturn(npc.Param[(91)]);
}

uint e_ReinforcementReturn(array<uint>@values)
{
	alerts[values[0]].ReinforcementReturn(values[1]);
	return 0;
}

uint e_CallReinforcements(array<uint>@values)
{
	if(alerts[values[0]].Dead)
	return 0;
	alerts[values[0]].Spawn(values[1]);  
	
	return Random(settings.ReinforcementsDelayLow,settings.ReinforcementsDelayHigh);
}

uint e_AlertMapsCycle(array<uint>@values)
{
	for(uint i=1,j=alerts.length();i<j;i++)
	alerts[i].Cycle();
	return settings.CycleLength;
}         

uint GetPid(uint locpid,uint mappid,uint type)
{
	if(type==0)
	{
		switch(locpid)
		{
			case(355):
			case(4):
			return Random(0,1)==0?134:135;
			case(6):
			return 119;
			case(33):
			case(14):
			return 386;
			case(10):
			case(30):
			case(54):
			case(94):
			return Random(0,1)==0?518:519;
			case(352):
			case(354):
			case(25):
			case(17):
			case(365):
			case(32):
			return Random(0,1)==0?71:72;
			case(353): 
			
			case(26):
			return Random(0,1)==0?46:47; 
			
			default:
			return 71;
		}
	}
	else
	{
		switch(locpid)
		{
			case(355):
			case(4):
			return Random(0,1)==0?222:223;
			case(6):
			return 119;
			case(354):
			case(30):
			case(10):
			case(54):
			case(94):
			return Random(0,1)==0?475:476;
			case(352):
			case(33):
			case(14):
			return 386;
			case(25):
			case(17):
			case(365):
			case(32):
			return Random(0,1)==0?71:72;
			case(353): 
			
			case(26):
			return Random(0,1)==0?46:47; 
			
			default:
			return 71;
		}
	}
	return 0;
}        

uint GetBag(uint locpid,uint mappid,uint type)
{
	if(type==0)
	{
		switch(locpid)
		{
			case(352):
			return Random(0,1)==0?212:15;
			case(353):
			return Random(0,1)==0?394:167;
			case(354):
			return Random(0,1)==0?332:327;
			case(355):
			return Random(0,1)==0?12:11;
			
			case(30):
			return Random(0,1)==0?212:327;
			case(365):
			return Random(0,1)==0?15:11;
			case(32):
			return Random(0,1)==0?234:11;
			case(33):
			return Random(0,1)==0?15:212;
			
			case(10):
			case(94):
			return Random(0,1)==0?332:327;
			case(54):
			return Random(0,1)==0?332:327;
			case(4):
			return Random(0,1)==0?211:13;
			case(6):
			return Random(0,1)==0?307:312;
			case(14):
			return Random(0,1)==0?15:212; 
			
			case(17):
			case(25): 
			
			case(26):
			return Random(0,1)==0?394:167;
			default:
			return 211;
		}
	}
	else
	{
		switch(locpid)
		{
			case(352):
			return Random(0,1)==0?212:16;
			case(353):
			return Random(0,1)==0?13:14;
			case(354):
			return Random(0,1)==0?14:396;
			case(355):
			return Random(0,1)==0?211:13;
			
			case(30):
			return Random(0,1)==0?14:396;
			case(365):
			return Random(0,1)==0?211:13;
			case(32):
			return Random(0,1)==0?15:13;
			case(33):
			return Random(0,1)==0?221:16;
			
			case(10):
			case(94):
			return Random(0,1)==0?14:396;
			case(54):
			return Random(0,1)==0?14:396;
			case(4):
			return Random(0,9)==0?16:203;
			case(6):
			return Random(0,1)==0?306:308;
			case(14):
			return Random(0,1)==0?221:16; 
			
			case(17):
			case(25): 
			
			case(26):
			{
				switch(Random(0,3))
				{
					case 0:
					return 191;
					case 1:
					return 394;
					case 2:
					return 194;
					case 3:
					return 396;
					default:
				}
			}
			default:
			return 211;
		}
	}
	return 0;
}        

uint GetLevel(uint locpid,uint mappid,uint type)
{
	return 12+9*type;
}        

uint GetTeamId(uint locpid,uint mappid,uint type)
{
	switch(mappid)
	{
		case(135):
		return(21);
		case(65):
		return(5);     
		
		case(552):
		return(20);
		case(553):
		return(29);
		case(554):
		return(5);
		case(555):
		return(6);
		case(569):
		return(5);
		case(372):
		return(20);
		case(373):
		return(20);
		case(374):
		return(80);
		case(375):
		return(80);
		case(376):
		return(5);
		case(379):
		return(89);
		
	}
	return ReputationIndex(locpid);
}        

uint GetDialog(uint locpid,uint mappid,uint type)
{
	if(type==0)
	{
		switch(locpid)
		{
			case(352):
			return 1444;
			case(353):
			return 9460;
			case(354):
			return 1051;
			case(355):
			return 449;
			
			case(30):
			return 11000;
			case(365):
			return 1700;
			case(32):
			return 226;
			case(33):
			return 1401;
			
			case(10):
			case(94):
			return 11000;
			case(54):
			return 11000;
			case(4):
			return 402;
			case(14):
			return 1401; 
			
			case(17):
			return 1700;
			case(25):
			return 2500;   
			
			case(26):
			return 9459;
		}
	}
	else
	{
		switch(locpid)
		{
			case(352):
			return 1444;
			case(353):
			return 9460;
			case(354):
			return 1051;
			case(355):
			return 449;
			
			case(30):
			return 83;
			case(365):
			return 1700;
			case(32):
			return 226;
			case(33):
			return 1401;
			
			case(10):
			case(94):
			return 83;
			case(54):
			return 83;
			case(4):
			return 402;
			case(14):
			return 1401; 
			
			case(17):
			return 1700;
			case(25):
			return 2500;   
			
			case(26):
			return 9459;
		}
	}
	return 0;
}     

uint CallReinforcements(array<uint>@enemies,CAlertMap&alert,uint amount,uint type)
{
	Map@map=GetMap(alert.MapId);
	if(!(@map!=null))
	return 0;
	
	array<Entire>enter_entires;
	if(ParseEntires(map,enter_entires,(220))==0)
	return 0;
	
	Entire@entire=enter_entires[Random(0,(enter_entires.length()-1))];
	
	if(!(@entire!=null))
	return 0;
	
	uint locpid=map.GetLocation().GetProtoId();
	
	uint mappid=map.GetProtoId(); 
	
	uint pid=GetPid(locpid,mappid,type);
	uint bag=GetBag(locpid,mappid,type);
	uint level=GetLevel(locpid,mappid,type);
	uint teamid=GetTeamId(locpid,mappid,type);
	uint dialog=GetDialog(locpid,mappid,type);
	
	for(uint i=0;i<amount;i++)
	{
		int[]params=
		{
			(106),teamid,
			(121),1,
			(122),1,
			(90),0,
			(91),type,
			(92),alert.Index,
			(107),bag,
			(66),0,
			(84),(-2),
			(77),level,
			(104),dialog
		};
		
		Critter@npc=map.AddNpc(pid,entire.HexX,entire.HexY,Random(0,5),params,null,"reinforcements@_ReinforcementInit");
		array<Item@>items;        
		
		if(!(@npc!=null))
		return i;
		
		for(int i=0,j=enemies.length();i<j;i++)
		{
			Critter@enemy=GetCritter(enemies[i]);
			if((@enemy!=null))
			AddAttackPlane(npc,0,enemy,true);
		}
	}
	
	return amount;
}

void _ReinforcementInit(Critter&npc,bool firstTime)
{
	GuardInit(npc);
	
	if(firstTime)
	GuardPerks(npc);
	
	npc.SetEvent((0),"_ReinforcementIdle");
	npc.SetEvent((36),"_ReinforcementPlaneEnd");
	npc.SetEvent((1),"_ReinforcementFinish");
	npc.ParamBase[(517)]=1;
}

void _ReinforcementIdle(Critter&npc)
{
	if(npc.Param[(90)]==0)
	{
		npc.ParamBase[(90)]=(__FullSecond);
		npc.Wait(500);
	}
	
	if(GetAlertLevel(npc.GetMap())>=Thresholds[npc.Param[(91)]]-4)
	{
		
		uint16 pbx=0;
		uint16 pby=0;
		uint16 bx=0;
		uint16 by=0;
		npc.GetMap().GetCrittersPath(npc.HexX,npc.HexY,npc.HexX,npc.HexY+1,float(Random(0,359)),Random(1,10),0,null,pbx,pby,bx,by);
		AddWalkPlane(npc,0,(32),0,pbx,pby,uint8(-1),false,0);
		return;
	}
	
	if(npc.Param[(90)]+(((1)*__TimeMultiplier*60)>>1)>int((__FullSecond)))
	{
		npc.Wait(10000);
		return;
	}
	
	uint16 hx=npc.HexX,hy=npc.HexY;
	if(!GetNearEntire(npc.GetMap(),(220),hx,hy))
	DeleteNpc(npc);
	else
	{
		NpcPlane@plane=CreatePlane();
		plane.Type=(2);
		plane.Priority=(20);
		plane.Identifier=(29);
		plane.Walk_HexX=hx;
		plane.Walk_HexY=hy;
		plane.Walk_Dir=0xFF;
		plane.Run=false;
		plane.Walk_Cut=1;
		if(!npc.AddPlane(plane))
		DeleteNpc(npc);
	}
}

void _ReinforcementFinish(Critter&npc,bool deleted)
{
	if(!npc.IsDead())
	{
		ReinforcementReturn(npc);
		return;
	}
	uint[]values={npc.Param[(92)],npc.Param[(91)]};
	CreateTimeEvent(((__FullSecond)+(settings.ReinforcementsDelayRet)),"e_ReinforcementReturn",values,true);
}

int _ReinforcementPlaneEnd(Critter&npc,NpcPlane&plane,int reason,Critter@someCr,Item@someItem)
{
	if(plane.Identifier==(32))
	{
		npc.Wait(5000);
		return(2);
	}
	
	if(plane.Identifier==(29))
	{
		DeleteNpc(npc);
		return(2);
	}
	
	npc.ParamBase[(90)]=(__FullSecond);
	
	return(0);
}            

void log(Critter&cr,int,int,int)
{
	for(uint j=1,k=alerts.length();j<k;j++)
	{
		CAlertMap@alert=alerts[j];
		cr.Say((11),"Index: "+alert.Index);
		if(alert.Dead)
		{
			cr.Say((11),"Dead");
			continue;
		}
		cr.Say((11),"MapId: "+alert.MapId);
		cr.Say((11),"Alert level: "+alert.AlertLevel);
		cr.Say((11),"NoReinforcements: "+(alert.NoReinforcements?"true":"false"));
		string s="";
		for(uint i=0;i<(2);i++)
		{
			s+=(alert.Reinforcements[i]+"/"+alert.ReinforcementsMax[i]);
			if(alert.Calling[i])
			s+="!";
			if(i+1!=(2))
			s+=", ";
		}
		cr.Say((11),"Reinforcements: "+s);
	}
}

void logthis(Critter&cr,int,int,int)
{
	if(!IsAlertMap(cr.GetMap()))
	{
		cr.Say((11),"Not an alert map.");
		return;
	}
	CAlertMap@alert=alerts[cr.GetMap().GetData((7))];
	cr.Say((11),"Index: "+alert.Index);
	if(alert.Dead)
	{
		cr.Say((11),"Dead");
		return;
	}
	cr.Say((11),"MapId: "+alert.MapId);
	cr.Say((11),"Alert level: "+alert.AlertLevel);
	cr.Say((11),"NoReinforcements: "+(alert.NoReinforcements?"true":"false"));
	string s="";
	for(uint i=0;i<(2);i++)
	{
		s+=(alert.Reinforcements[i]+"/"+alert.ReinforcementsMax[i]);
		if(alert.Calling[i])
		s+="!";
		if(i+1!=(2))
		s+=", ";
	}
	cr.Say((11),"Reinforcements: "+s);
}                     

void showsettings(Critter&cr,int,int,int)
{
	cr.Say((11),"AlertLevelNone (0) : "+settings.AlertLevelNone);
	cr.Say((11),"AlertLevelLight (1) : "+settings.AlertLevelLight);
	cr.Say((11),"AlertLevelHeavy (2) : "+settings.AlertLevelHeavy);
	
	cr.Say((11),"AlertCountGuard (3) : "+settings.AlertCountGuard);
	cr.Say((11),"AlertCountNpc (4) : "+settings.AlertCountNpc);
	cr.Say((11),"AlertCountDrop (5) : "+settings.AlertCountDrop);
	cr.Say((11),"AlertCountPDrop (6) : "+settings.AlertCountPDrop);
	
	cr.Say((11),"ReinforcementsDelayLow (7) : "+settings.ReinforcementsDelayLow);
	cr.Say((11),"ReinforcementsDelayHigh (8) : "+settings.ReinforcementsDelayHigh);
	cr.Say((11),"ReinforcementsDelayRet (9) : "+settings.ReinforcementsDelayRet);
	cr.Say((11),"ReinforcementsCountLow (10) : "+settings.ReinforcementsCountLow);
	cr.Say((11),"ReinforcementsCountHigh (11) : "+settings.ReinforcementsCountHigh);
	
	cr.Say((11),"CycleLength (12) : "+settings.CycleLength);
	
	cr.Say((11),"AlertLevelReact (13) : "+__AlertLevelReact);
}

void setsettings(Critter&cr,int n,int val,int)
{
	switch(n)
	{
		case 0:
		settings.AlertLevelNone=val;
		break;
		case 1:
		settings.AlertLevelLight=val;
		break;
		case 2:
		settings.AlertLevelHeavy=val;
		break;
		
		case 3:
		settings.AlertCountGuard=val;
		break;
		case 4:
		settings.AlertCountNpc=val;
		break;
		case 5:
		settings.AlertCountDrop=val;
		break;
		case 6:
		settings.AlertCountPDrop=val;
		break;
		
		case 7:
		settings.ReinforcementsDelayLow=val;
		break;
		case 8:
		settings.ReinforcementsDelayHigh=val;
		break;
		case 9:
		settings.ReinforcementsDelayRet=val;
		break;
		case 10:
		settings.ReinforcementsCountLow=val;
		break;
		case 11:
		settings.ReinforcementsCountHigh=val;
		break;
		
		case 12:
		settings.CycleLength=val;
		break;
		
		case 13:
		__AlertLevelReact=val;
		break;
		default:
	}
	settings.Update();
}

void clear(Critter&cr,int,int,int)
{
	alerts.resize(1);
}

void ShowBroadcast(uint16 BShowLocation)
{
	switch(BShowLocation)
	{
		case(355):BTypeLocation="Trainstation 4 TODO is";break;
		case(4):BTypeLocation="Vault City is";break;
		case(6):BTypeLocation="Broken Hills is";break;
		case(33):BTypeLocation="San Francisco Quarry is";break;
		case(14):BTypeLocation="San Francisco is";break;
		case(10):BTypeLocation="NCR";break;
		case(30):BTypeLocation="NCR Quarry is";break;
		case(54):BTypeLocation="Prison";break;
		case(352):BTypeLocation="Trainstation 1 TODO is";break;
		case(354):BTypeLocation="Trainstation 3 TODO is";break;
		case(25):BTypeLocation="Hub is";break;
		case(17):BTypeLocation="Junktown is";break;
		case(365):BTypeLocation="Junktown Quarry is";break;
		case(32):BTypeLocation="Klamath Quarry is";break;
		case(353):BTypeLocation="Trainstation 2 TODO is";break; 
		
		case(26):BTypeLocation="Audytum is";break;
		
		case(94):BTypeLocation="Las Vegas is";break;
		default:BTypeLocation="Chuj go wie, jakis error";break;
	}
	
	switch(BShowType)
	{
		case(1):BShowWave="1st";break;
		case(2):BShowWave="2nd";break;
		case(3):BShowWave="3rd";break;
		case(4):BShowWave="4th";break;
		case(5):BShowWave="5th";break;
		case(6):BShowWave="6th";break;
		case(7):BShowWave="7th";break;
		case(8):BShowWave="8th";break;
		case(9):BShowWave="9th";break;
		case(10):BShowWave="10th";break;
		default:BShowType=(1);BShowWave="1st";break;
	}   
	
	BShowType++;
}                

