                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

int week_patch=1;
int doubleloot=1;
bool dropchance(float chance)
{
	if(chance==0)
	return false;
	if(Random(0,100)<chance)
	return true;
	
	return false;
	
}

bool can_tc_modoc=false;
bool can_tc_klamath=false;
bool can_tc_gecko=false;
bool can_tc_bh=false;
bool can_tc_redding=false;
bool can_tc_den=false;
bool can_tc_necro=false;
bool can_tc_reno=false;

uint when_tc_modoc=0;
uint when_tc_klamath=0;
uint when_tc_gecko=0;
uint when_tc_bh=0;
uint when_tc_redding=0;
uint when_tc_den=0;
uint when_tc_necro=0;
uint when_tc_reno=0;                   

bool dbInitTable(string@,string@){return true;}
bool dbLog(string@,string@){return true;}                   

void InitDBLogs(){}

void LogExperience(Critter&cr,int amount){}
void LogExperience(Critter&cr,int amount,string@info){}
void LogExperience(Critter&cr,int amount,int skill){}
void LogExperience(Critter&cr,int amount,int skill,string@info){}
void LogExperience(Critter&cr,int amount,int skill,int param){}
void LogExperience(Critter&cr,int amount,int skill,string@info,int param){}
void LogQuestExperience(Critter&cr,int amount,string@info){}
void LogQuestExperience(Critter&cr,int amount,int skill,string@info){}
void LogAttack(Map@map,Critter&cr,Critter&target,ProtoItem&weapon,ProtoItem@ammo,uint8 aim,bool isBurst,uint ammoRound,uint weaponRound,bool isHit,bool isCritical,uint critfailFlags){}
void LogDamage(Map@map,Critter@attacker,Critter&target,Item@weapon,ProtoItem@ammo,uint8 aim,bool isBurst,uint damage,bool isCritical,uint eff,uint rounds){}
void LogGathering(Critter&,uint16,int){}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

import Location@GetLocationOf(Critter&critter)from"utils";
import string GetLocationName(uint locId)from"utils";
import string GetLocationName(Location@loc)from"utils";
import bool ReadPids(array<int>&out pids,bool removeinvalid)from"utils";
import void ReadDefines(string@fileName,dictionary&items,array<string>@defines)from"utils";
import bool ParseDefine(const string&in line,string&out spid,int&out id)from"utils";
import int SkipWhitespaces(const string&in str,int start)from"utils";
import int SkipNonWhitespaces(const string&in str,int start)from"utils";
import bool IsParameterTag(string&str)from"utils";
import string GetParameterString(array<string@>@arr,string&parameter)from"utils";
import int GetIndexOfString(array<string@>@arr,string&str)from"utils";
import string GetConcatenatedString(array<string@>@arr,uint startindex,int stopindex)from"utils";
import string GetConditionOfCritter(Critter@cr)from"utils";
import string GetExtConditionOfCritter(Critter@cr)from"utils";
import uint GetAllOnlinePlayers(array<Critter@>&out players)from"utils";
import uint GetAuthenticatedPlayers(array<Critter@>&out players)from"utils";
import uint GetAuthenticatedPlayers(array<Critter@>&out players,bool ignorePriviledges)from"utils";
import uint GetNumberOfPlayersOnline()from"utils";
import void SetTurnBasedAvailability(Location@loc)from"utils";
import bool IsGuarded(Map@map)from"utils";
import bool IsPublic(Map@map)from"utils";
import bool IsEncounterMap(Map@map)from"utils";
import bool IsTown(Map@map)from"utils";
import bool IsDungeon(Map@map)from"utils";
import bool IsBaseControl(Map@map)from"utils";

import uint GetMapType(Map@map)from"utils";
import void LockDoor(uint x,uint y,Map@map,uint complexity,uint lockid)from"utils";
import void UnlockDoor(uint x,uint y,Map@map)from"utils";
import void ClearContainer(Item@container)from"utils";
import void MoveItemsCritterToCont(Critter&crFrom,Item&contTo,uint specid)from"utils";
import string GetCritterInfo(Critter&cr)from"utils";
import bool AddExpTeam(Critter&critter,int xp)from"utils";
import void ClearEnemyStack(Critter&critter)from"utils";
import void ClearEnemyStacksOnMap(Map@map)from"utils";
import bool IsCurrentEnemy(Critter&cr,uint targetId)from"utils";
import string@GetSafePlayerName(uint id)from"utils";
import string GetSafePlayerName(uint id,string&onSuccess,string&onError)from"utils";
import IDateTime@GetCurrentDateTime()from"utils";
import string GetCurrentDateTimeString()from"utils";
import string GetCurrentDateTimeString(bool date,bool time)from"utils";
import Critter@GetMostSkilled(array<Critter@>@group,int skill)from"utils";
import string GetAuthString(Critter&player)from"utils";
import string GetAuthString(int accesslevel)from"utils";
import bool CanRequestHelp(Critter&player)from"utils";
import void SetRequestedHelp(Critter&player)from"utils";
import void SetRequestedHelp(Critter&player,int minutes)from"utils";
import Critter@GetOnlineGM()from"utils";
import void Preprocess(Critter&player,string&commandString)from"utils";
import bool IsHumanoid(Critter@cr)from"utils";
import uint GetGroupIndex(Critter&cr)from"utils";
import uint GetGroupIndex(int st)from"utils";
import void SetGroupIndex(Critter&cr,uint val)from"utils";
import uint GetGroupRank(Critter&cr)from"utils";
import void SetGroupRank(Critter&cr,uint val)from"utils";
import uint GetGroupMode(Critter&cr)from"utils";
import void SetGroupMode(Critter&cr,uint val)from"utils";
import void SetGroupInfo(Critter&cr,uint faction,uint rank,uint mode)from"utils";
import void SetGroupInfoPack(Critter&cr,uint packInfo)from"utils";
import void ClearEvents(Critter&cr)from"utils";

import int GetGvar(uint gvar)from"utils";
import void SetGvar(uint gvar,uint value)from"utils";
import int GetLLvar(Location&location,uint llvar)from"utils";
import int GetLLvar(uint locationId,uint llvar)from"utils";
import void SetLLvar(Location&location,uint llvar,uint value)from"utils";
import int GetLMvar(Map&map,uint llvar)from"utils";
import int GetLMvar(uint mapId,uint llvar)from"utils";
import void SetLMvar(Map&map,uint llvar,uint value)from"utils";
import int GetLIvar(Item&item,uint llvar)from"utils";
import int GetLIvar(uint itemId,uint llvar)from"utils";
import void SetLIvar(Item&item,uint llvar,uint value)from"utils";
import int GetLvar(Critter&critter,uint lvar)from"utils";
import int GetLvar(uint id,uint lvar)from"utils";
import void SetLvar(Critter&critter,uint lvar,uint value)from"utils";
import void SetLvar(uint id,uint lvar,uint value)from"utils";
import int GetUvar(uint uvar,uint key,uint index)from"utils";
import void SetUvar(uint uvar,uint key,uint index,uint value)from"utils";

import uint GetContainerValue(Item@container)from"utils";
import uint BaseItemValue(uint pid,bool ammo)from"utils";
import uint BaseItemValue(uint pid,uint broken,uint det,bool ammo)from"utils";
import uint BaseItemValue(Item@item)from"utils";
import uint BaseItemValue(Item@item,uint proc)from"utils";
import uint BaseSingleItemValue(Item@item)from"utils";
import uint BaseSingleItemValue(Item@item,uint proc)from"utils";

import void SetBloodType(Critter@cr)from"utils";
import string GetBloodType(Critter@cr)from"utils";
import string GetBloodRandom()from"utils";

import void LogCommandUsage(Critter&player,string&commandString)from"utils";
import void DropTimeouts(Critter&cr)from"utils";

import bool HasItem(Critter@cr,uint pid)from"utils";
import bool HasSomeWeapon(Critter@cr)from"utils";
import uint GetBestWeaponSkill(Critter@cr)from"utils";
import void GiveBag(uint bag,Critter@cr)from"utils";
import void SetQuestGarbager(uint time,uint playerid,uint locid,uint var,uint val)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,uint factionRank,uint factionMode,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,array<int>params,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,array<int>params,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,uint factionRank,uint factionMode,bool isMob,uint level)from"utils";
import void AddScore(Critter@cr,uint score,uint points)from"utils";

import bool ReloadWeapon(Critter&cr)from"utils";
import Item@GetRadio(Critter&cr)from"utils";
import Item@GetRepairTool(Critter&cr)from"utils";
import Item@GetEquippedItem(Critter&cr,uint Pid)from"utils";
import Item@GetEquippedItem(Critter&cr,array<uint>&Pids)from"utils";
import Item@GetEquippedItemByType(Critter&cr,uint ItemType)from"utils"; 

import bool SkillRoll(Critter@cr,int skill,int bonus)from"utils";
import int SkillCheck(Critter&cr,int skill,int skillused,Item@item,int bonus)from"utils";
import string SkillName(uint8 skill)from"utils";
import void ChangeCrTypeSafe(Critter&cr,uint8 crType)from"utils";

import bool Pickable(Item@item)from"utils";

import void TransferItemsToContOnMap(Critter&cr,Map@map,int entid,int contpid,int itemtypes)from"utils";
import void TransferItemsFromContOnMap(Critter&cr,Map@map,int entid,int contpid)from"utils";

import string IpToString(uint ip)from"utils";

import void VerboseAction(Critter&cr,string&text)from"utils";
import void VerboseAction(Critter&cr,Critter&target,string&text)from"utils";
import void VerboseExperience(Critter&cr,int xpDiff,int levelDiff)from"utils";

import void SetChosenActions(Critter&cr,array<int>&actions)from"utils";

import void HexLine(uint16 x0,uint16 y0,uint16 x1,uint16 y1,array<uint16>@xList,array<uint16>@yList)from"utils";
import void HexCircle(uint16 x0,uint16 y0,uint16 radius,array<uint16>@xList,array<uint16>@yList)from"utils";

import void StartPersonalDataCleanup()from"utils";

import bool IsPersonalData(Location&location,string&name)from"utils";
import bool GetPersonalData(Location&location,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Location&location,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Location&location,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Location&location,string&name)from"utils";

import bool IsPersonalData(Map&map,string&name)from"utils";
import bool GetPersonalData(Map&map,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Map&map,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Map&map,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Map&map,string&name)from"utils";

import bool IsPersonalData(Critter&critter,string&name)from"utils";
import bool GetPersonalData(Critter&critter,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Critter&critter,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Critter&critter,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Critter&critter,string&name)from"utils";

import bool IsPersonalData(Item&item,string&name)from"utils";
import bool GetPersonalData(Item&item,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Item&item,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Item&item,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Item&item,string&name)from"utils";

import bool FindPreferredGridApprox(Map&map,uint16&hx,uint16&hy)from"utils";           

import bool StrToInt(string@s,uint64&inout val)from"strtoint";
import bool StrToInt(string@s,uint&inout val)from"strtoint";
import bool StrToInt(string@s,uint16&inout val)from"strtoint";
import bool StrToInt(string@s,uint8&inout val)from"strtoint";
import bool StrToInt(string@s,int64&inout val)from"strtoint";
import bool StrToInt(string@s,int16&inout val)from"strtoint";
import bool StrToInt(string@s,int8&inout val)from"strtoint";    

import int FindInArray(array<int>&arr,int value)from"utils";
import int FindInArray(array<uint>&arr,uint value)from"utils";
import int FindInArray(array<uint16>&arr,uint16 value)from"utils";
import int FindInArray(array<uint8>&arr,uint8 value)from"utils";
import bool FindInArray(array<int>&arr,int id,int&index)from"utils";
import bool FindInArray(array<uint>&arr,uint id,int&index)from"utils";
import bool FindInArray(array<uint8>&arr,uint8 id,int&index)from"utils";
import int FindInArray(array<string>&arr,string&value)from"utils";
import int FindInArray(array<string@>@arr,string&value)from"utils";
import bool Present(int what,array<int>&where)from"utils";
import bool Present(uint what,array<uint>&where)from"utils";
import bool Present(uint16 what,array<uint16>&where)from"utils";
import bool Present(string&what,array<string>&where)from"utils";
import bool Present(string&what,array<string@>@where)from"utils";

import uint CreateLocationForGroup(Critter&player,uint16 pid,uint16 worldX,uint16 worldY,array<Critter@>&)from"utils";
import bool FindFirstFreeHex(Map@map,uint16&x,uint16&y,uint8 dir,uint16 maxSteps)from"utils";
import bool FindNearestFreeHex(Map&map,uint16&x,uint16&y,uint radius)from"utils";

import bool GetItemCoordinates(Item&item,uint&mapID,uint16&x,uint16&y)from"utils";
import bool ItemOnHex(uint16 pid,Map@map,uint16 x,uint16 y)from"utils";

import void PrintCallstack()from"utils";
import void PrintCallstack(int level)from"utils";

import bool LocationHasCritters(Location&loc,uint findType)from"utils";
import uint LocationGetCritters(Location&loc,uint findType,array<Critter@>@critters)from"utils";
import uint LocationGetPlayersAndFollowers(Location&loc,uint findType,array<Critter@>@critters)from"utils";
import uint MapGetPlayersAndFollowers(Map&map,uint findType,array<Critter@>@critters)from"utils";
import uint CritterGetPlayersAndFollowers(Critter&critter,bool lookOnMe,uint findType,array<Critter@>@critters)from"utils";
import bool LocationHasItems(Location&loc,uint16 protoId)from"utils";
import uint LocationGetItems(Location&loc,uint16 protoId,array<Item@>@items)from"utils";
import void LocationDeleteItems(Location&loc,uint16 protoId)from"utils";

import bool IsDisposableEncounter(Location@loc)from"utils";

import bool IsT4Item(Item&item)from"utils";
import bool IsT3Item(Item&item)from"utils";
import uint16 AddT3Item()from"utils";
import uint16 AddT4Item()from"utils";
import uint16 AddImplant()from"utils";
import uint16 AddT4BP()from"utils";
import uint16 AddRareAmmo()from"utils";
import uint16 AddTypicalAmmo()from"utils";

import void SetDeterioration(Item&item)from"utils";  

shared class CPosition
{
	uint x;
	uint y;
	uint dir;
};

shared interface IRect
{
	bool IsWithin(Critter&cr);
};

shared class Rect:IRect
{
	uint x1;
	uint y1;
	uint x2;
	uint y2;
	
	Rect(uint x1,uint y1,uint x2,uint y2)
	{
		this.x1=x1;
		this.y1=y1;
		this.x2=x2;
		this.y2=y2;
	}
	
	bool IsWithin(Critter&cr)
	{
		return((cr.HexX>=this.x1&&cr.HexX<=this.x2)&&(cr.HexY>=this.y1&&cr.HexY<=this.y2));
	}
};

shared interface IDateTime
{
	uint16 get_Year();
	uint16 get_Month();
	uint16 get_DayOfWeek();
	uint16 get_Day();
	uint16 get_Hour();
	uint16 get_Minute();
	uint16 get_Second();
	uint16 get_Milliseconds();
	string@ToString();
};                                                                                                                                          

import uint tier3armor()from"item_pools";
import uint tier3helmet()from"item_pools";
import uint tier3weapon()from"item_pools";
import uint tier3alien()from"item_pools";
import uint tier3bp()from"item_pools";
import uint tier3drugs()from"item_pools";
import uint tier3ammo()from"item_pools";
import uint tierlowammo()from"item_pools";
import uint tier4parts()from"item_pools";
import uint tier4bp()from"item_pools";
import uint tier4item()from"item_pools";
import uint tier4ammo()from"item_pools";
import uint rareitem()from"item_pools";
import uint implant()from"item_pools";
import uint implant_combat()from"item_pools";
import uint verti_parts()from"item_pools";
import uint currency()from"item_pools";
import uint low_tier()from"item_pools";
import uint books()from"item_pools";
import uint mats()from"item_pools";
import uint misc()from"item_pools";
import void addbasemap(Critter&player)from"personal_base";
import void addbasemap(Item&con)from"personal_base";

import bool istier3armor(uint pid)from"item_pools";
import bool istier3helmet(uint pid)from"item_pools";
import bool istier3weapon(uint pid)from"item_pools";
import bool istier3bp(uint pid)from"item_pools";
import bool istier3drugs(uint pid)from"item_pools";
import bool istier3ammo(uint pid)from"item_pools";
import bool istierlowammo(uint pid)from"item_pools";
import bool istier4parts(uint pid)from"item_pools";
import bool istier4bp(uint pid)from"item_pools";
import bool istier4item(uint pid)from"item_pools";
import bool istier4ammo(uint pid)from"item_pools";
import bool israreitem(uint pid)from"item_pools";
import bool isimplant(uint pid)from"item_pools";
import bool isimplant_combat(uint pid)from"item_pools";
import bool isverti_parts(uint pid)from"item_pools";
import bool iscurrency(uint pid)from"item_pools";
import bool islow_tier(uint pid)from"item_pools";
import bool isHelmet(uint pid)from"item_pools";

import bool ConsumedBlueprintForPid(Critter&player,uint pid)from"blueprints";
import void CloneWear(Item&to,Item&from)from"repair";
import int GetWearProcent(Item&item)from"repair";
import bool IsBase(Map@map)from"world_common";
import bool IsTent(Map@map)from"world_common";
import bool IsMovableLocker(uint16 pid)from"lockers";                                              

int GetProfessionLevel(Critter&player,uint lvar)
{
	GameVar@prof=GetLocalVar(lvar,player.Id);
	if(!(@prof!=null))
	return 0;
	return prof.GetValue();
}   

bool MapCheck(Critter&player,uint mapPid)
{
	return player.GetMap().GetProtoId()==mapPid;
}   

bool FixboyCheck(Critter&player)
{
	GameVar@var=GetLocalVar((3020),player.Id);
	return var<100;
}

bool WorkbenchCheck(Critter&player)
{
	GameVar@var=GetLocalVar((3020),player.Id);
	return var==1;
} 

bool MfcCheck(Critter&player)
{
	GameVar@var=GetLocalVar((3020),player.Id);
	return var==2;
}

bool MedCheck(Critter&player)
{
	GameVar@var=GetLocalVar((3020),player.Id);
	return var==3;
}

bool AmmoCheck(Critter&player)
{
	GameVar@var=GetLocalVar((3020),player.Id);
	return var==4;
}    

bool IsResource(Item&item)
{
	switch(item.GetProtoId())
	{
		case(272):
		case(271):
		case(278):
		case(286):
		case(536):
		case(537):
		case(1824):
		case(71):
		case(539):
		case(98):
		case(426):
		case(486):
		case(318):
		case(1801):
		
		case(276):
		case(277):
		case(9630):
		case(1803):
		
		case(9633):
		case(9634):
		case(9632):
		case(9629):
		case(9919):
		
		case(9627):
		case(440):
		case(9635):  
		
		case(22071):
		case(22072):
		case(22083):
		
		return true;
	}
	return false;
}  

bool IsHighQualityResource(Item&item)
{
	switch(item.GetProtoId())
	{
		case(9633):
		case(9634):
		case(9632):
		case(9919):
		case(9630):
		case(440):
		case(426):
		case(9918): 
		
		case(22071):
		case(22072):
		return true;
	}
	return false;
}  

bool IsWorkedResource(Item&item)
{
	switch(item.GetProtoId())
	{
		case(469):
		case(284):
		case(127):
		
		case(1804):
		case(1802):
		case(535):
		
		case(9653):
		case(9628):
		case(9631): 
		
		case(538):
		case(22069):
		case(22070):
		case(22073):
		case(22074):
		case(22075):
		case(22076):
		case(22077):
		case(22078):
		case(22079):
		case(22080):
		case(22081):
		case(22082):
		case(22083):
		case(22084):
		case(22085):
		case(22086):
		case(22087):
		case(22088):
		case(22089):
		case(22090):
		case(22091):
		case(22092):
		case(22093):
		case(22094):
		return true;
	}
	return false;
}    

void ApplyTimeout(array<Item@>&items,array<uint>&itemsCount,array<Item@>&resources,Critter&crafter)
{
	uint16 pid=items[0].GetProtoId();
	
	switch(pid)
	{
		case(1802):
		case(535):
		case(1804):
		case(469):
		case(9628):
		case(9631):
		case(9653):
		return;
	} 
	
	int value=0;
	Item@upg;
	for(uint i=0,j=resources.length();i<j;i++)
	{
		if(IsResource(resources[i]))
		value+=BaseItemValue(resources[i])*(IsHighQualityResource(resources[i])?3:2);
		else if(IsWorkedResource(resources[i]))
		value+=BaseItemValue(resources[i]); 
		
		if(!(@upg!=null)&&items.length()==1&&
		resources[i].GetType()==items[0].GetType()&&
		(resources[i].GetType()==(3)||resources[i].GetType()==(1)))
		@upg=resources[i];
	}    
	
	if((@upg!=null))
	CloneWear(items[0],upg);  
	
	int levelmod=items[0].Proto.CraftLevel>1?5000:4000;
	int to=60*value/levelmod; 
	
} 

int TimeoutCheck(Critter&player)
{
	if(player.Timeout[(232)]>int(((360)*__TimeMultiplier*60)))
	{
		player.SayMsg((17),(3),(212));
		return(0xFFFF)^(0x0001)^(0x0400);
	}
	else
	return((0xFFFF)^(0x0004));
} 

uint GetItemType(uint pid)
{
	ProtoItem@proto=GetProtoItem(pid);
	switch(proto.Type)
	{
		case(3):return(1);
		case(1):return(2);
		case(4):return(3);
		case(2):return(4);
		default:return(5);
	};
	return(5);
}

bool FilterItems(Critter&player,uint pid)
{
	uint filter=player.ParamBase[(182)];
	
	if(filter==(0))
	return true;
	
	if(filter==GetItemType(pid))
	return true;
	
	return false;
}

bool CheckMultiplierResources(Critter&player,CraftItem&craft)
{
	bool isFixAll=false;
	uint8 fixall=player.ParamBase[(183)];
	if(fixall>0)
	{
		isFixAll=true;
		fixall=100;
	}
	
	uint8 multiplier=player.ParamBase[(181)];
	if(multiplier<1||multiplier>99)
	{
		multiplier=(((multiplier)>(99))?(99):(((multiplier)<(1))?(1):(multiplier)));
		player.ParamBase[(181)]=multiplier;
	}
	
	array<uint16>resources;
	array<uint>r_cnt;
	for(uint i=0,j=craft.GetNeedItems(resources,r_cnt,null);i<j;i++)
	{
		Item@res=player.GetItem(resources[i],-1);
		if((@res!=null))
		{
			if(isFixAll)
			{
				if(res.IsStackable())
				{
					fixall=(((fixall)<((res.GetCount()/r_cnt[i])))?(fixall):((res.GetCount()/r_cnt[i])));
				}
				else
				{
					fixall=(((fixall)<((player.CountItem(resources[i])/r_cnt[i])))?(fixall):((player.CountItem(resources[i])/r_cnt[i])));
				}
			}
			else
			{
				if(res.IsStackable())
				{
					if(res.GetCount()<r_cnt[i]*multiplier)
					return false;
				}
				else
				{
					if(player.CountItem(resources[i])<r_cnt[i]*multiplier)
					return false;
				}
			}
		}
		else
		return false;
	}
	if(isFixAll)
	{
		switch(fixall)
		{
			case 0:return false;
			case 1:player.Say((11),"Crafted "+fixall+" item.");break;
			default:player.Say((11),"Crafted "+fixall+" items.");break;
		}
		
		player.ParamBase[(183)]=fixall;
	}
	
	return true;
}

uint GetItemRecipe(uint16 itemPid,array<uint16>&pids,array<uint>&cnt)
{
	if(itemPid>=PidRecipe.length())
	return 0;
	CraftItem@craft=GetCraftItem(PidRecipe[itemPid]);
	if(!(@craft!=null))
	return 0;
	
	return craft.GetNeedItems(pids,cnt,null);
} 

int fix_Resource(Critter&player,int stage,CraftItem&craft)
{
	if(stage==(0))
	{
		array<uint16>pids;
		for(uint i=0,j=craft.GetOutItems(pids,null);i<j;i++)
		{
			if(!FilterItems(player,pids[i]))
			return((0xFFFF)^(0x0001));
		}
		return((0xFFFF));
	}
	
	if(stage==(2))
	{
		if(!CheckMultiplierResources(player,craft))
		return((0xFFFF)^(0x0001));
		else
		{
			if(player.ParamBase[(183)]>0)
			player.ParamBase[(76)]+=craft.Experience*(player.ParamBase[(183)]-1)*(GetGvar((62001)));
			else
			player.ParamBase[(76)]+=craft.Experience*(player.ParamBase[(181)]-1)*(GetGvar((62001)));
			return((0xFFFF)^(0x0004));
		}
	}
	return(0xFFFF);
}

int fix_Generic(Critter&player,int stage,CraftItem&craft)
{
	if(stage==(0))
	{
		array<uint16>pids;
		for(uint i=0,j=craft.GetOutItems(pids,null);i<j;i++)
		{
			if(!FilterItems(player,pids[i]))
			return((0xFFFF)^(0x0001));
		}
		return((0xFFFF));
	}
	
	if(stage==(2))
	{
		array<uint16>pids;
		for(uint i=0,j=craft.GetOutItems(pids,null);i<j;i++)
		{
			if(IsMovableLocker(pids[i])&&(!IsTent(player.GetMap())&&!IsBase(player.GetMap())))
			{
				player.Say((11),"You can't craft lockers outside your tent or faction base.");
				return((0xFFFF)^(0x0001));
			}
		}
		
		if(!CheckMultiplierResources(player,craft))
		return((0xFFFF)^(0x0001));
		else
		{
			if(player.ParamBase[(183)]>0)
			player.ParamBase[(76)]+=craft.Experience*(player.ParamBase[(183)]-1)*(GetGvar((62001)));
			else
			player.ParamBase[(76)]+=craft.Experience*(player.ParamBase[(181)]-1)*(GetGvar((62001)));
			return TimeoutCheck(player);
		}
	}
	return(0xFFFF);
}

int fix_Blueprint(Critter&player,int stage,CraftItem&craft)
{
	if(stage==(0)||stage==(1))
	{
		array<uint16>pids;
		for(uint i=0,j=craft.GetOutItems(pids,null);i<j;i++)
		{ 
			
			if(!FilterItems(player,pids[i]))
			return((0xFFFF)^(0x0001));
		}
		return((0xFFFF));
	}
	else if(stage==(2))
	{
		if(!CheckMultiplierResources(player,craft))
		return((0xFFFF)^(0x0001));
		else
		{
			if(player.ParamBase[(183)]>0)
			player.ParamBase[(76)]+=craft.Experience*(player.ParamBase[(183)]-1)*(GetGvar((62001)));
			else
			player.ParamBase[(76)]+=craft.Experience*(player.ParamBase[(181)]-1)*(GetGvar((62001)));
			return TimeoutCheck(player);
		}
	}
	return(0xFFFF);
}

int fix_Lock(Critter&player,int stage,CraftItem&craft)
{
	if(WorkbenchCheck(player))
	{
		if(stage==(0))
		{
			array<uint16>pids;
			for(uint i=0,j=craft.GetOutItems(pids,null);i<j;i++)
			{
				if(!FilterItems(player,pids[i]))
				return((0xFFFF)^(0x0001));
			}
			return((0xFFFF));
		}
		if(stage==(1))
		return((0xFFFF));
		if(stage==(2))
		{
			if(!CheckMultiplierResources(player,craft))
			return((0xFFFF)^(0x0001));
			
			if(player.ParamBase[(183)]>0)
			player.ParamBase[(76)]+=craft.Experience*(player.ParamBase[(183)]-1)*(GetGvar((62001)));
			else
			player.ParamBase[(76)]+=craft.Experience*(player.ParamBase[(181)]-1)*(GetGvar((62001)));
			
			Item@lock=player.AddItem((549),1); 
			
			uint complexity=player.Param[(209)];
			player.Say((11),"Complexity: "+complexity);
			lock.LockerComplexity=complexity;
			
			if(complexity<100)
			{
				lock.Info=2;
				lock.Cost=500;
			}
			else if(complexity<150)
			{
				lock.Info=4;
				lock.Cost=1000;
			}
			else if(complexity<200)
			{
				lock.Info=6;
				lock.Cost=1500;
			}
			else
			{
				lock.Info=8;
				lock.Cost=2000;
			}
			lock.Update();
			player.TimeoutBase[(234)]=((__FullSecond)+((((2700)/player.Param[(209)]+(Random(6,60)/(5+player.Param[(6)])))*__TimeMultiplier)*3));
			
			return((0xFFFF)^(0x0004)^(0x0080));
		}
	}
	return((0xFFFF)^(0x0001));
}         

bool Add(Critter&cr,array<int>&pids,int value,int sk)
{
	bool added=false;
	uint min=uint(-1);
	uint mini=0;
	for(uint i=0,j=pids.length();i<j;i++)
	{
		uint cost=GetProtoItem(pids[i]).Cost;  
		
		if(min>cost)
		{
			min=cost;
			mini=i;
		}
	}
	while(value>0)
	{  
		
		if(value<int(min))
		return added;
		uint i=Random(0,pids.length()-1);
		if(sk>=Random(1,100))
		{
			added=true;
			
			cr.AddItem(pids[i],1);
		}
		value-=GetProtoItem(pids[i]).Cost;  
		
	}
	return added;
}

array<uint>PidRecipe;

bool ReversableItem(Item&item)
{
	uint pid=item.Proto.ProtoId;
	if(istier3armor(pid)||istier3helmet(pid)||istier3weapon(pid)||istier3drugs(pid)||istier3ammo(pid)||istierlowammo(pid)||istier4item(pid)||istier4ammo(pid)||israreitem(pid)||islow_tier(pid)||isHelmet(pid))
	return true;
	
	return false;
}

void InitReverseItem()
{
	array<uint16>outs;
	array<uint>counts;
	for(uint i=1;i<300;i++)
	{
		outs.resize(0);
		counts.resize(0);
		CraftItem@craft=GetCraftItem(i);
		if(!(@craft!=null))
		continue;
		craft.GetOutItems(outs,counts);
		uint16 output=outs[0];
		if(output>=PidRecipe.length())
		{
			uint oldsize=PidRecipe.length();
			PidRecipe.resize(output+1);
			for(uint j=oldsize;j<=output;j++)
			PidRecipe[j]=0;
		}
		PidRecipe[output]=i;
	}
}  

bool ReverseAllItems(Critter&cr,array<Item@>&items,uint cnt,uint max)
{
	for(uint i=0;i<cnt;i++)
	{
		if(!ReversableItem(items[i]))
		continue;
		
		ReverseItemCrafted(cr,items[i],true);
	}
	cr.PlaySound("CARREPAR.ACM",true);
	return true;
}

bool ReverseItem(Critter&cr,Item&item,bool isMassScience)
{
	if(ReversableItem(item))
	ReverseItemCrafted(cr,item,false);
	return true;
}

bool ReverseItem(Critter&cr,Item&item)
{
	if(ReversableItem(item))
	return ReverseItemCrafted(cr,item,false);
	
	return false;
}

uint GetCraftCount(Item&item)
{
	switch(item.Proto.ProtoId)
	{
		case(163):
		return 50;
		case(121):
		case(29):
		case(30):
		case(31):
		case(111):
		case(357):
		case(361):
		case(362):
		case(25586):
		case(95):
		case(575):
		case(574):
		case(576):
		case(850):
		case(33):
		case(34):
		case(35):
		case(36):
		case(363):
		case(38):
		case(39):
		case(25585):
		case(359):
		case(358):
		return 100;
		
		case(260):
		case(273):
		case(40):
		case(144):
		case(525):
		case(48):
		case(109):
		case(53):
		case(87):
		case(110):
		case(259):
		case(25573):
		case(25574):
		case(25575):
		case(45):
		case(25):
		case(26):
		case(1834):
		case(27):
		case(25570):
		case(1273):
		case(1272):
		case(621):
		case(14):
		case(37):
		case(25568):
		case(25584):
		case(274):
		return 10;
		case(1270):
		return 25;
		case(1271):
		return 20;
		case(32):
		return 120;
		case(382):
		return 40;
		case(159):
		return 4;
		case(7):
		return 2;
	}
	return 1;
} 

bool ReverseItemCrafted(Critter&cr,Item&item,bool isMassScience)
{
	uint16 pid=item.GetProtoId();
	CraftItem@craft=GetCraftItem(PidRecipe[pid]);
	bool didntcraft=false;
	if(!(@craft!=null))
	didntcraft=true;
	array<uint16>items;
	array<uint>counts;
	array<bool>ors;
	array<uint16>pids_out;
	array<uint>values_out;
	bool added=false;
	
	if(item.GetType()==(3)&&item.AmmoPid!=0&&item.AmmoCount!=0)
	{
		cr.AddItem(item.AmmoPid,item.AmmoCount);
		item.AmmoCount=0;
	}
	int skillv=cr.Param[(212)];
	if(cr.Param[(456)]>0)
	skillv+=50;
	skillv+=cr.Param[(4)]*10;
	bool deteriorate=item.IsDeteriorable();
	int factor=int((cr.Param[(456)]>0?0.2:0.1)*1000.0f);
	bool notcraftable=false;
	if(!didntcraft)
	if(!item.IsStackable())
	{
		for(uint i=0,j=craft.GetNeedItems(items,counts,ors);i<j;i++)
		{
			if(items[1]==0)
			notcraftable=true;
			ProtoItem@proto=GetProtoItem(items[i]);
			if(Random(1,1000)<skillv)
			{
				
				Item@addedItem=cr.AddItem(items[i],Random(1,counts[i]));
				if(deteriorate&&addedItem.IsDeteriorable())
				{
					ReverseItemCrafted(cr,addedItem,true);
				}
				added=true;
			} 
			
			if(i+1==j||ors[i])
			break;
		}
	}
	else
	{
		for(uint x=0;x<item.GetCount();x+=GetCraftCount(item))
		{
			if(GetCraftCount(item)>item.GetCount())
			continue;
			for(uint i=0,j=craft.GetNeedItems(items,counts,ors);i<j;i++)
			{ 
				
				ProtoItem@proto=GetProtoItem(items[i]);
				if(Random(1,1000)<skillv)
				{
					
					Item@addedItem=cr.AddItem(items[i],Random(1,counts[i]));
					added=true;
				} 
				
				if(i+1==j||ors[i])
				break;
			}
		}
	}
	if(item.Val0>14999&&Random(1,1500)<skillv&&(istier3armor(pid)||istier3weapon(pid)||istier4item(pid)))
	{
		cr.AddItem((9935),1);
		if(!isMassScience)
		cr.Say((11),"|-1 You got Upgrade part");
	}
	if(item.Val0>149999&&Random(1,2000)<skillv&&(istier3armor(pid)||istier3weapon(pid)||istier4item(pid)))
	{
		
		cr.AddItem((9936),1);
		if(!isMassScience)
		cr.Say((11),"|-1 You got Upgrade part MK.II");
	}
	if(item.Val0>1499999&&Random(1,2500)<skillv&&(istier3armor(pid)||istier3weapon(pid)||istier4item(pid)))
	{
		cr.AddItem((9937),1);
		if(!isMassScience)
		cr.Say((11),"|-1 You got Upgrade part MK.III");
	}
	
	if(didntcraft)
	if(Random(1,1000)==1)
	cr.AddItem(((98)),1);
	string type=item.GetType()==(3)?"weapon":"armor";
	uint protoItemCost=item.Proto.Cost;
	if(item.GetProtoId()==(100))
	type="Radio";
	type="Item";
	
	if(!isMassScience)
	{
		if(added)
		cr.Say((11),"You've disassembled the "+type+".");
		else
		cr.Say((11),"You've disassembled the "+type+", but were unable to obtain anything.");
	}
	if(!item.IsStackable())
	{
		uint expAmount=25+protoItemCost/100;
		cr.ParamBase[(76)]+=expAmount*(GetGvar((62001)));
		
	}
	else
	{
		uint expAmount=(25+protoItemCost/100)*(item.GetCount()/GetCraftCount(item));
		if(GetCraftCount(item)<item.GetCount())
		cr.ParamBase[(76)]+=expAmount*(GetGvar((62001)));
	}
	DeleteItem(item);
	if(!isMassScience)
	cr.PlaySound("CARREPAR.ACM",true);
	return true;
}

bool ReverseItemGeneric(Critter&cr,Item&item,bool isMassScience)
{
	ReverseItemCrafted(cr,item,false);
	return false;
} 

bool ReverseItemCustom(Critter&cr,Item&item,bool isMassScience)
{
	ReverseItemCrafted(cr,item,false);return true;
}

void unsafe_counter(Critter&player,int cnt,int,int,string@,int[]@)
{
	player.ParamBase[(181)]=(((cnt)>(99))?(99):(((cnt)<(1))?(1):(cnt)));
	player.ParamBase[(183)]=0;
}

void unsafe_fixall(Critter&player,int cnt,int,int,string@,int[]@)
{
	player.ParamBase[(183)]=cnt;
}

void unsafe_filter(Critter&player,int flt,int,int,string@,int[]@)
{
	player.ParamBase[(182)]=flt;
	player.DropTimers();
	player.ShowScreen((9),0,"");
}