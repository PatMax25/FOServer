                                                                                                                                                                                                                                                                                                            

uint __GetColor(int r,int g,int b,int a=0xFF)
{
	r=(((r)>(255))?(255):(((r)<(0))?(0):(r)));
	g=(((g)>(255))?(255):(((g)<(0))?(0):(g)));
	b=(((b)>(255))?(255):(((b)<(0))?(0):(b)));
	a=(((a)>(255))?(255):(((a)<(0))?(0):(a)));
	return(uint(((a)<<24)|(((r)&0xFF)<<16)|(((g)&0xFF)<<8)|((b)&0xFF)));
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

shared interface Buffer
{
	bool IsRaw(uint len);
	
	Buffer@opCom();
	
	Buffer@opNeg();                    
	
	 Buffer@opShr(int8&value); Buffer@opShl(int8 value); Buffer@Get(int8&value); Buffer@Set(int8&value);
	 Buffer@opShr(int16&value); Buffer@opShl(int16 value); Buffer@Get(int16&value); Buffer@Set(int16&value);
	 Buffer@opShr(int32&value); Buffer@opShl(int32 value); Buffer@Get(int32&value); Buffer@Set(int32&value);
	 Buffer@opShr(int64&value); Buffer@opShl(int64 value); Buffer@Get(int64&value); Buffer@Set(int64&value);
	 Buffer@opShr(uint8&value); Buffer@opShl(uint8 value); Buffer@Get(uint8&value); Buffer@Set(uint8&value);
	 Buffer@opShr(uint16&value); Buffer@opShl(uint16 value); Buffer@Get(uint16&value); Buffer@Set(uint16&value);
	 Buffer@opShr(uint32&value); Buffer@opShl(uint32 value); Buffer@Get(uint32&value); Buffer@Set(uint32&value);
	 Buffer@opShr(uint64&value); Buffer@opShl(uint64 value); Buffer@Get(uint64&value); Buffer@Set(uint64&value);
	 Buffer@opShr(bool&value); Buffer@opShl(bool value); Buffer@Get(bool&value); Buffer@Set(bool&value);
	 Buffer@opShr(string&value); Buffer@opShl(string value); Buffer@Get(string&value); Buffer@Set(string&value);
	 Buffer@opShr(float&value); Buffer@opShl(float value); Buffer@Get(float&value); Buffer@Set(float&value);
	
	 Buffer@opShr(array<int8>&value); Buffer@opShl(array<int8>&value); Buffer@Get(array<int8>&value); Buffer@Set(array<int8>&value);
	 Buffer@opShr(array<int16>&value); Buffer@opShl(array<int16>&value); Buffer@Get(array<int16>&value); Buffer@Set(array<int16>&value);
	 Buffer@opShr(array<int32>&value); Buffer@opShl(array<int32>&value); Buffer@Get(array<int32>&value); Buffer@Set(array<int32>&value);
	 Buffer@opShr(array<int64>&value); Buffer@opShl(array<int64>&value); Buffer@Get(array<int64>&value); Buffer@Set(array<int64>&value);
	 Buffer@opShr(array<uint8>&value); Buffer@opShl(array<uint8>&value); Buffer@Get(array<uint8>&value); Buffer@Set(array<uint8>&value);
	 Buffer@opShr(array<uint16>&value); Buffer@opShl(array<uint16>&value); Buffer@Get(array<uint16>&value); Buffer@Set(array<uint16>&value);
	 Buffer@opShr(array<uint32>&value); Buffer@opShl(array<uint32>&value); Buffer@Get(array<uint32>&value); Buffer@Set(array<uint32>&value);
	 Buffer@opShr(array<uint64>&value); Buffer@opShl(array<uint64>&value); Buffer@Get(array<uint64>&value); Buffer@Set(array<uint64>&value);
	 Buffer@opShr(array<bool>&value); Buffer@opShl(array<bool>&value); Buffer@Get(array<bool>&value); Buffer@Set(array<bool>&value);
	 Buffer@opShr(array<string>&value); Buffer@opShl(array<string>&value); Buffer@Get(array<string>&value); Buffer@Set(array<string>&value);
	 Buffer@opShr(array<float>&value); Buffer@opShl(array<float>&value); Buffer@Get(array<float>&value); Buffer@Set(array<float>&value);
	
	 Buffer@opShr(array<array<int8>>&value); Buffer@opShl(array<array<int8>>&value); Buffer@Get(array<array<int8>>&value); Buffer@Set(array<array<int8>>&value);
	 Buffer@opShr(array<array<int16>>&value); Buffer@opShl(array<array<int16>>&value); Buffer@Get(array<array<int16>>&value); Buffer@Set(array<array<int16>>&value);
	 Buffer@opShr(array<array<int32>>&value); Buffer@opShl(array<array<int32>>&value); Buffer@Get(array<array<int32>>&value); Buffer@Set(array<array<int32>>&value);
	 Buffer@opShr(array<array<int64>>&value); Buffer@opShl(array<array<int64>>&value); Buffer@Get(array<array<int64>>&value); Buffer@Set(array<array<int64>>&value);
	 Buffer@opShr(array<array<uint8>>&value); Buffer@opShl(array<array<uint8>>&value); Buffer@Get(array<array<uint8>>&value); Buffer@Set(array<array<uint8>>&value);
	 Buffer@opShr(array<array<uint16>>&value); Buffer@opShl(array<array<uint16>>&value); Buffer@Get(array<array<uint16>>&value); Buffer@Set(array<array<uint16>>&value);
	 Buffer@opShr(array<array<uint32>>&value); Buffer@opShl(array<array<uint32>>&value); Buffer@Get(array<array<uint32>>&value); Buffer@Set(array<array<uint32>>&value);
	 Buffer@opShr(array<array<uint64>>&value); Buffer@opShl(array<array<uint64>>&value); Buffer@Get(array<array<uint64>>&value); Buffer@Set(array<array<uint64>>&value);
	 Buffer@opShr(array<array<bool>>&value); Buffer@opShl(array<array<bool>>&value); Buffer@Get(array<array<bool>>&value); Buffer@Set(array<array<bool>>&value);
	 Buffer@opShr(array<array<string>>&value); Buffer@opShl(array<array<string>>&value); Buffer@Get(array<array<string>>&value); Buffer@Set(array<array<string>>&value);
	 Buffer@opShr(array<array<float>>&value); Buffer@opShl(array<array<float>>&value); Buffer@Get(array<array<float>>&value); Buffer@Set(array<array<float>>&value);
	
	 Buffer@opShr(array<array<array<int8>>>&value); Buffer@opShl(array<array<array<int8>>>&value); Buffer@Get(array<array<array<int8>>>&value); Buffer@Set(array<array<array<int8>>>&value);
	 Buffer@opShr(array<array<array<int16>>>&value); Buffer@opShl(array<array<array<int16>>>&value); Buffer@Get(array<array<array<int16>>>&value); Buffer@Set(array<array<array<int16>>>&value);
	 Buffer@opShr(array<array<array<int32>>>&value); Buffer@opShl(array<array<array<int32>>>&value); Buffer@Get(array<array<array<int32>>>&value); Buffer@Set(array<array<array<int32>>>&value);
	 Buffer@opShr(array<array<array<int64>>>&value); Buffer@opShl(array<array<array<int64>>>&value); Buffer@Get(array<array<array<int64>>>&value); Buffer@Set(array<array<array<int64>>>&value);
	 Buffer@opShr(array<array<array<uint8>>>&value); Buffer@opShl(array<array<array<uint8>>>&value); Buffer@Get(array<array<array<uint8>>>&value); Buffer@Set(array<array<array<uint8>>>&value);
	 Buffer@opShr(array<array<array<uint16>>>&value); Buffer@opShl(array<array<array<uint16>>>&value); Buffer@Get(array<array<array<uint16>>>&value); Buffer@Set(array<array<array<uint16>>>&value);
	 Buffer@opShr(array<array<array<uint32>>>&value); Buffer@opShl(array<array<array<uint32>>>&value); Buffer@Get(array<array<array<uint32>>>&value); Buffer@Set(array<array<array<uint32>>>&value);
	 Buffer@opShr(array<array<array<uint64>>>&value); Buffer@opShl(array<array<array<uint64>>>&value); Buffer@Get(array<array<array<uint64>>>&value); Buffer@Set(array<array<array<uint64>>>&value);
	 Buffer@opShr(array<array<array<bool>>>&value); Buffer@opShl(array<array<array<bool>>>&value); Buffer@Get(array<array<array<bool>>>&value); Buffer@Set(array<array<array<bool>>>&value);
	 Buffer@opShr(array<array<array<string>>>&value); Buffer@opShl(array<array<array<string>>>&value); Buffer@Get(array<array<array<string>>>&value); Buffer@Set(array<array<array<string>>>&value);
	 Buffer@opShr(array<array<array<float>>>&value); Buffer@opShl(array<array<array<float>>>&value); Buffer@Get(array<array<array<float>>>&value); Buffer@Set(array<array<array<float>>>&value);
	
	 Buffer@opUShr(array<int8>&arr); Buffer@opUShrAssign(array<int8>&arr); array<int8>AsInt8();
	 Buffer@opUShr(array<int16>&arr); Buffer@opUShrAssign(array<int16>&arr); array<int16>AsInt16();
	 Buffer@opUShr(array<int32>&arr); Buffer@opUShrAssign(array<int32>&arr); array<int32>AsInt32();
	 Buffer@opUShr(array<int64>&arr); Buffer@opUShrAssign(array<int64>&arr); array<int64>AsInt64();
	 Buffer@opUShr(array<uint8>&arr); Buffer@opUShrAssign(array<uint8>&arr); array<uint8>AsUint8();
	 Buffer@opUShr(array<uint16>&arr); Buffer@opUShrAssign(array<uint16>&arr); array<uint16>AsUint16();
	 Buffer@opUShr(array<uint32>&arr); Buffer@opUShrAssign(array<uint32>&arr); array<uint32>AsUint32();
	 Buffer@opUShr(array<uint64>&arr); Buffer@opUShrAssign(array<uint64>&arr); array<uint64>AsUint64();
};  

import Buffer@NewBuffer()from"buffer";    

 import Buffer@NewBuffer(array<int8>@data)from"buffer";
 import Buffer@NewBuffer(array<int16>@data)from"buffer";
 import Buffer@NewBuffer(array<int32>@data)from"buffer";
 import Buffer@NewBuffer(array<int64>@data)from"buffer";
 import Buffer@NewBuffer(array<uint8>@data)from"buffer";
 import Buffer@NewBuffer(array<uint16>@data)from"buffer";
 import Buffer@NewBuffer(array<uint32>@data)from"buffer";
 import Buffer@NewBuffer(array<uint64>@data)from"buffer";                                 

import void WLog(string&type,string&message)from"debug";
import void WLog(string&type,string&message,int level)from"debug";
import void InitDebug()from"debug";                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

shared class Entire
{
	int Number;
	uint16 HexX;
	uint16 HexY;
	uint8 Direction;
};

uint ParseEntires(Map&map,array<Entire>&entires,int number)
{
	uint oldCount=entires.length();
	uint count=map.CountEntire(number);
	entires.resize(oldCount+count);
	
	for(uint i=0;i<count;i++)
	{
		Entire@ent=entires[oldCount+i];
		if(map.GetEntireCoords(number,i,ent.HexX,ent.HexY,ent.Direction)==false)
		return 0;
		ent.Number=number;
	}
	
	return count;
}

bool IsEntireFree(uint mappid,int number)
{
	Map@map=GetMapByPid(mappid,0);
	return IsEntireFree(map,number);
}

bool IsEntireFree(Map&map,int number)
{
	uint16 x,y;
	x=0;
	y=0;
	return GetEntireFreeHex(map,number,x,y);
}

bool GetEntireFreeHex(Map&map,int number,uint16&hx,uint16&hy,uint skip=0)
{
	uint count=map.CountEntire(number); 
	
	for(uint i=skip;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy)&&map.IsHexPassed(hx,hy))
		return true;
	}
	
	if(hx==0||hy==0||hx>=map.GetWidth()-1||hy>=map.GetHeight()-1)
	return false; 
	
	for(uint i=0;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy))
		{
			for(int x=-1;x<=1;x++)
			{
				for(int y=-1;y<=1;y++)
				{
					if(x==0&&y==0)
					continue;
					if(__MapHexagonal)
					{
						if((hx%2)==1&&((x==-1&&y==1)||(x==1&&y==1)))
						continue;
						if((hx%2)==0&&((x==-1&&y==-1)||(x==1&&y==-1)))
						continue;
					}
					
					if(map.IsHexPassed(hx+x,hy+y))
					{
						hx+=x;
						hy+=y;
						return true;
					}
				}
			}
		}
	}
	return false;
}

bool GetNearEntire(Map&map,int number,uint16&hx,uint16&hy)
{
	uint16 hxBase=hx;
	uint16 hyBase=hy;
	
	array<Entire>entires;
	uint count=ParseEntires(map,entires,number);
	if(count==0)
	return false;
	
	hx=entires[0].HexX;
	hy=entires[0].HexY;
	for(uint i=1;i<count;i++)
	{
		Entire@ent=entires[i];
		if(GetDistantion(hxBase,hyBase,ent.HexX,ent.HexY)<GetDistantion(hxBase,hyBase,hx,hy))
		{
			hx=ent.HexX;
			hy=ent.HexY;
		}
	}
	
	return true;
}                                                                  

import string GetCritterLexems(Critter&critter)from"lexems";
import string GetItemLexems(Item&item)from"lexems";

import bool IsLexem(Critter&critter,string&lex)from"lexems";
import bool IsLexem(Item&it,string&lex)from"lexems";
import bool IsLexem(string&lexems,string&lex)from"lexems";

import string GetLexem(Critter&critter,string&lex)from"lexems";
import string GetLexem(Item&item,string&lex)from"lexems";
import string GetLexem(string&lexems,string&lex)from"lexems"; 

import void SetLexem(Critter&critter,string&lex,string&value)from"lexems";
import void SetLexem(Item&item,string&lex,string&value)from"lexems";
import string SetLexem(string&lexems,string&lex,string&value)from"lexems";

import void UnsetLexem(Critter&critter,string&lex)from"lexems";
import void UnsetLexem(Item&item,string&lex)from"lexems";
import string UnsetLexem(string&lexems,string&lex)from"lexems";               

import void InitLogs()from"logging";
import void FLog(uint logindex,string&text)from"logging";
import void ILog(string&section,string&text)from"logging";
import void GMLog(Critter&cr,string&text)from"logging";
import void CloseLogs()from"logging";
import uint AddLog(string&filename)from"logging";
import uint AddLog(string&filename,uint index)from"logging";                                                                                                                                                                                 

int GetRootMapData(Map&map,uint index)
{
	return map.GetLocation().GetMapByIndex(0).GetData(index);
}  

void SetRootMapData(Map&map,uint index,int val)
{
	map.GetLocation().GetMapByIndex(0).SetData(index,val);
}   

int GetRootMapData(Location&loc,uint index)
{
	return loc.GetMapByIndex(0).GetData(index);
}  

void SetRootMapData(Location&loc,uint index,int val)
{
	loc.GetMapByIndex(0).SetData(index,val);
}                        

import void AddWaitPlan(Critter&critter,uint waittime)from"npc_common";
import bool AttackCritter(Critter&attacker,Critter&target,uint minhp)from"npc_common";
import bool AttackCritter(Critter&attacker,Critter&target)from"npc_common";
import bool CanUseWeapon(Critter&critter,Item@weapon)from"npc_common";
import bool CanUseWeapon(Critter&critter,uint proto)from"npc_common";
import void ClearIllegalFlags(Critter&critter)from"npc_common";
import bool HasIntelligentBrain(Critter&follower)from"npc_common";
import void SetCritterIllegalFlag(Critter&critter,int reason)from"npc_common";
import void SetCritterIllegalFlag(Critter&critter,int location,int reason)from"npc_common";
import bool HasSameScript(Critter&critter1,Critter&critter2)from"npc_common";
import bool IsFlaggedAsIllegal(Critter&critter)from"npc_common";
import bool IsFlaggedAsIllegal(Critter&critter,int location)from"npc_common";
import bool IsInLocation(Critter&critter,int locationPID)from"npc_common";
import bool MoveByDir(Critter&critter,uint8 dir,uint steps,bool run)from"npc_common";
import void MoveRandom(Critter&npc,uint maxDist)from"npc_common";
import void MoveRandom(Critter&npc,uint maxDist,bool Run)from"npc_common";
import void MoveRandom(Critter&npc,uint maxDist,uint stepDist,bool Run)from"npc_common";
import void TransferToNPCMap(Critter&critter)from"npc_common";
import void UnsetCritterIllegalFlag(Critter&critter)from"npc_common";
import void UnsetCritterIllegalFlag(Critter&critter,int location)from"npc_common";
import void UnsetCritterIllegalFlag(uint id,int location)from"npc_common";
import int GetCritterIllegalFlag(Critter&critter)from"npc_common";
import int GetCritterIllegalFlag(Critter&critter,int location)from"npc_common";
import bool HasUnusableWeapon(Critter&critter,uint bag)from"npc_common";
import bool HasUnusableWeapon(Critter&critter)from"npc_common";
import bool HasUnusableWeapon(uint crpid,uint bag)from"npc_common";
import Item@ArmBestWeapon(Critter&critter)from"npc_common";
import Item@ArmFavoriteWeapon(Critter&critter)from"npc_common";
import void PutAwayItems(Critter&critter)from"npc_common";
import void DropAllItems(Critter&critter)from"npc_common";
import void PickAllItemsOnHex(Critter&critter)from"npc_common";
import void Heal(Critter&cr)from"npc_common";
import void TryReportOffense(Critter@cr,Critter@offender,int reputationdrop)from"npc_common";
import uint GetCrittersWithScript(Map&map,uint16 pid,uint findType,string&scriptName,string&funcDeclaration,array<Critter@>@critters)from"npc_common";
import uint GetCrittersLoc(Location&loc,uint16 pid,uint findType,array<Critter@>@critters)from"npc_common";
import uint GetNearGuards(Map@map,uint16 hexX,uint16 hexY,uint radius,array<Critter@>@crits)from"npc_common";
import uint GetNearFactionGuards(Map@map,uint16 hexX,uint16 hexY,uint radius,uint faction,array<Critter@>@crits)from"npc_common";
import string GenerateNewName(Critter&critter)from"npc_common";
import string GetStoredName(Critter&critter)from"npc_common";
import string GetStoredFirstName(Critter&critter)from"npc_common";
import bool Flee(Critter&cr)from"npc_common";
import bool Flee(Critter&cr,bool Run)from"npc_common";
import void FindFreeHexes(Map@map,uint16 hexX,uint16 hexY,int&num,array<uint16>&coordsX,array<uint16>&coordsY)from"npc_common";
import bool FindNearestFreeHex(Map@map,uint16 hexX,uint16 hexY,uint16&outX,uint16&outY)from"npc_common";
import void SetDeleteEvent(Critter&cr,uint time)from"npc_common";
import void DropDeleteEvent(Critter&cr)from"npc_common";                        

int FindInArray(array<int>&arr,int value)
{
	uint count=arr.length();
	for(uint i=0;i<count;i++)
	{
		if(arr[i]==value)
		return i;
	}
	return-1;
}

bool FindInArray(array<int>&arr,int id,int&index)
{
	for(uint i=0;i<arr.length();i++)
	{
		if(id==arr[i])
		{
			index=i;
			return true;
		}
	}
	index=-1;
	return false;
}

int FindInArray(array<uint>&arr,uint value)
{
	uint count=arr.length();
	for(uint i=0;i<count;i++)
	{
		if(arr[i]==value)
		return i;
	}
	return-1;
}

bool FindInArray(array<uint>&arr,uint id,int&index)
{
	for(uint i=0;i<arr.length();i++)
	{
		if(id==arr[i])
		{
			index=i;
			return true;
		}
	}
	index=-1;
	return false;
}

int FindInArray(array<uint16>&arr,uint16 value)
{
	uint count=arr.length();
	for(uint i=0;i<count;i++)
	{
		if(arr[i]==value)
		return i;
	}
	return-1;
}

int FindInArray(array<uint8>&arr,uint8 value)
{
	uint count=arr.length();
	for(uint i=0;i<count;i++)
	{
		if(arr[i]==value)
		return i;
	}
	return-1;
}

bool FindInArray(array<uint8>&arr,uint8 id,int&index)
{
	for(uint i=0;i<arr.length();i++)
	{
		if(id==arr[i])
		{
			index=i;
			return true;
		}
	}
	index=-1;
	return false;
}

int FindInArray(array<string>&arr,string&value)
{
	uint count=arr.length();
	for(uint i=0;i<count;i++)
	{
		if(arr[i]==value)
		return i;
	}
	return-1;
}

int FindInArray(array<string@>@arr,string&value)
{
	if(@arr==null||arr.length()==0)
	return(-1);
	
	uint count=arr.length();
	for(uint i=0;i<count;i++)
	{
		if(@arr[i]==null)
		continue;
		
		if(arr[i]==value)
		return i;
	}
	return-1;
}

bool Present(int what,array<int>&where)
{
	if(FindInArray(where,what)==-1)
	return false;
	else
	return true;
}

bool Present(uint what,array<uint>&where)
{
	if(FindInArray(where,what)==-1)
	return false;
	else
	return true;
}

bool Present(uint16 what,array<uint16>&where)
{
	if(FindInArray(where,what)==-1)
	return false;
	else
	return true;
}

bool Present(string&what,array<string>&where)
{
	if(FindInArray(where,what)==-1)
	return false;
	else
	return true;
}

bool Present(string&what,array<string@>@where)
{
	if(FindInArray(where,what)==-1)
	return false;
	else
	return true;
}  

import void LogCommand(Critter&,const string&)from"backend";
import void DriveToGlobal(Critter&cr,Item&car,bool requestGroup)from"car";
import int stringReplaceText(string&s,string@f,string@t)from"config_file";
import void DropDrugEffects(Critter&cr)from"drugs";
import Critter@GetMaster(Critter&follower)from"follower";
import void DropRadiation(Critter&cr)from"radiation";
import uint GetDaysInMonth(uint16 year,uint16 month)from"time"; 

import void SetWear(Item&item,int wearProcent)from"repair";
import void SetMinWear(Item&item,int wearProcent)from"repair";                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

int week_patch=1;
int doubleloot=1;
bool dropchance(float chance)
{
	if(chance==0)
	return false;
	if(Random(0,100)<chance)
	return true;
	
	return false;
	
}

bool can_tc_modoc=false;
bool can_tc_klamath=false;
bool can_tc_gecko=false;
bool can_tc_bh=false;
bool can_tc_redding=false;
bool can_tc_den=false;
bool can_tc_necro=false;
bool can_tc_reno=false;

uint when_tc_modoc=0;
uint when_tc_klamath=0;
uint when_tc_gecko=0;
uint when_tc_bh=0;
uint when_tc_redding=0;
uint when_tc_den=0;
uint when_tc_necro=0;
uint when_tc_reno=0;                                                                                                                                                                                                                                                           

shared class CPosition
{
	uint x;
	uint y;
	uint dir;
};

shared interface IRect
{
	bool IsWithin(Critter&cr);
};

shared class Rect:IRect
{
	uint x1;
	uint y1;
	uint x2;
	uint y2;
	
	Rect(uint x1,uint y1,uint x2,uint y2)
	{
		this.x1=x1;
		this.y1=y1;
		this.x2=x2;
		this.y2=y2;
	}
	
	bool IsWithin(Critter&cr)
	{
		return((cr.HexX>=this.x1&&cr.HexX<=this.x2)&&(cr.HexY>=this.y1&&cr.HexY<=this.y2));
	}
};

shared interface IDateTime
{
	uint16 get_Year();
	uint16 get_Month();
	uint16 get_DayOfWeek();
	uint16 get_Day();
	uint16 get_Hour();
	uint16 get_Minute();
	uint16 get_Second();
	uint16 get_Milliseconds();
	string@ToString();
};                                                                             

Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,bool isMob,uint level)
{
	
	if(!(@map!=null))
	{
		Log("Can't add NPC, map is invalid.");
		return null;
	}
	
	array<int>params;
	if((level)!=0){params.insertLast((77));params.insertLast(level);};
	if((dialogId)!=0){params.insertLast((104));params.insertLast(dialogId);};
	if((aiPack)!=0){params.insertLast((105));params.insertLast(aiPack);};
	if((bagId)!=0){params.insertLast((107));params.insertLast(bagId);};
	if((teamId)!=0){params.insertLast((106));params.insertLast(teamId);};
	
	Critter@npc=map.AddNpc(pid,x,y,dir,params,null,script);
	if((@npc!=null))
	return npc;
	return null;
}                    

void item_dialog(Item&item,bool firstTime)
{
	item.SetEvent((4),"_Usedialog");
}

bool _Usedialog(Item&item,Critter&crit,int skill)
{
	
	if((skill==-1)||(skill==(210)))
	{
		return RunDialog(crit,item.Val0,item.HexX,item.HexY,false);
	}
	return false;
}

Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,uint factionRank,uint factionMode,bool isMob,uint level)
{
	if(!(@map!=null))
	{
		Log("Can't add NPC, map is invalid.");
		return null;
	}
	
	array<int>params;
	if((level)!=0){params.insertLast((77));params.insertLast(level);};
	if((dialogId)!=0){params.insertLast((104));params.insertLast(dialogId);};
	if((aiPack)!=0){params.insertLast((105));params.insertLast(aiPack);};
	if((bagId)!=0){params.insertLast((107));params.insertLast(bagId);};
	if((teamId)!=0){params.insertLast((106));params.insertLast(teamId);};
	if((factionRank)!=0){params.insertLast((121));params.insertLast(factionRank);};
	if((factionMode)!=0){params.insertLast((122));params.insertLast(factionMode);};
	
	Critter@npc=map.AddNpc(pid,x,y,dir,params,null,script);
	if((@npc!=null))
	return npc;
	return null;
}                  

Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,array<int>params,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,bool isMob,uint level)
{
	if(!(@map!=null))
	{
		Log("Can't add NPC, map is invalid.");
		return null;
	}
	
	if((level)!=0){params.insertLast((77));params.insertLast(level);};
	if((dialogId)!=0){params.insertLast((104));params.insertLast(dialogId);};
	if((aiPack)!=0){params.insertLast((105));params.insertLast(aiPack);};
	if((bagId)!=0){params.insertLast((107));params.insertLast(bagId);};
	if((teamId)!=0){params.insertLast((106));params.insertLast(teamId);};
	
	Critter@npc=map.AddNpc(pid,x,y,dir,params,null,script);
	if((@npc!=null))
	return npc;
	
	Log("AddNpc fail: pid="+pid+", x="+x+", y="+y+", dir="+dir+", dialogId="+dialogId+", script="+script);
	return null;
}                  

Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,array<int>params,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,uint factionRank,uint factionMode,bool isMob,uint level)
{
	if(!(@map!=null))
	{
		Log("Can't add NPC, map is invalid.");
		return null;
	}
	
	if((level)!=0){params.insertLast((77));params.insertLast(level);};
	if((dialogId)!=0){params.insertLast((104));params.insertLast(dialogId);};
	if((aiPack)!=0){params.insertLast((105));params.insertLast(aiPack);};
	if((bagId)!=0){params.insertLast((107));params.insertLast(bagId);};
	if((teamId)!=0){params.insertLast((106));params.insertLast(teamId);};
	if((factionRank)!=0){params.insertLast((121));params.insertLast(factionRank);};
	if((factionMode)!=0){params.insertLast((122));params.insertLast(factionMode);};
	
	Critter@npc=map.AddNpc(pid,x,y,dir,params,null,script);
	if((@npc!=null))
	return npc;
	
	Log("AddNpc fail: pid="+pid+", x="+x+", y="+y+", dir="+dir+", dialogId="+dialogId+", script="+script);
	return null;
}   

string GetCritterInfo(Critter&cr)
{
	return cr.Name+"("+cr.Id+")"+"("+cr.GetMapId()+")"+((cr.IsPlayer()&&cr.GetAccess()>(0))?("("+GetAuthString(cr)+")"):"");
}      

void AddScore(Critter@cr,uint score,uint points)
{
	if(cr.IsPlayer()&&cr.GetAccess()==(0))
	cr.AddScore(score,points);
}

bool ReloadWeapon(Critter&cr)
{
	Item@weapon=cr.GetItem(0,(1));
	if(!(@weapon!=null)||weapon.GetType()!=(3))
	return false;
	
	int skillNum=GetProtoItem(weapon.GetProtoId()).Weapon_Skill_0;
	if(skillNum==(205))
	return false;
	
	Item@ammo=cr.GetItem(weapon.AmmoPid,-1);
	if(weapon.GetProtoId()==(390)&&(weapon.Proto.Weapon_MaxAmmoCount-weapon.AmmoCount)>0&&!((__Hour)>=22||(__Hour)<=6))
	{
		weapon.AmmoCount=weapon.Proto.Weapon_MaxAmmoCount;
		cr.Action((7),3,weapon);
		weapon.Update();
		return true;
	}
	if(!(@ammo!=null))
	return false; 
	
	uint count=(((ammo.GetCount())<(weapon.Proto.Weapon_MaxAmmoCount-weapon.AmmoCount))?(ammo.GetCount()):(weapon.Proto.Weapon_MaxAmmoCount-weapon.AmmoCount));
	if(count>0)
	{
		weapon.AmmoCount+=count;
		weapon.AmmoPid=ammo.GetProtoId();
		do{if(ammo.GetCount()>(count)) ammo.SetCount(ammo.GetCount()-(count));else DeleteItem(ammo);}while(false);
		cr.Action((7),3,weapon);
		weapon.Update();
	}
	return true;
}     

Item@GetRadio(Critter&cr)
{
	return GetEquippedItem(cr,(100));
}     

Item@GetRepairTool(Critter&cr)
{
	uint[]Pids={(75),(308)};
	return GetEquippedItem(cr,Pids);
}      

Item@GetEquippedItemByType(Critter&cr,uint ItemType)
{
	Item@hand1=cr.GetItem(0,(1));
	Item@hand2=cr.GetItem(0,(2));
	if((@hand1!=null)&&(hand1.GetType()==ItemType))
	return hand1;
	if((@hand2!=null)&&(hand2.GetType()==ItemType))
	return hand2;
	return null;
}      

Item@GetEquippedItem(Critter&cr,uint Pid)
{
	Item@hand1=cr.GetItem(0,(1));
	Item@hand2=cr.GetItem(0,(2));
	if((@hand1!=null)&&(hand1.GetProtoId()==Pid))
	return hand1;
	if((@hand2!=null)&&(hand2.GetProtoId()==Pid))
	return hand2;
	return null;
}      

Item@GetEquippedItem(Critter&cr,array<uint>&Pids)
{
	Item@hand1=cr.GetItem(0,(1));
	Item@hand2=cr.GetItem(0,(2));
	if((@hand1!=null))
	{
		for(uint i=0;i<Pids.length();i++)
		if(hand1.GetProtoId()==Pids[i])
		return hand1;
	}
	if((@hand2!=null))
	{
		for(uint i=0;i<Pids.length();i++)
		if(hand2.GetProtoId()==Pids[i])
		return hand2;
	}
	return null;
}     

string GetConditionOfCritter(Critter@cr)
{
	if(!(@cr!=null))
	return"";
	
	switch(cr.Cond)
	{
		case(1):
		return"COND_LIFE";
		case(2):
		return"COND_KNOCKOUT";
		case(3):
		return"COND_DEAD";
		case(4):
		return"COND_NOT_IN_GAME";
	}
	return"";
}       

bool SkillRoll(Critter@cr,int skill,int bonus)
{
	if(!(@cr!=null))
	return false;
	int sk=cr.Param[skill]+bonus;
	sk=(((sk)>(95))?(95):(((sk)<(5))?(5):(sk)));
	return Random(1,100)<=sk;
}         

int SkillCheck(Critter&cr,int skill,int skillused,Item@item,int bonus)
{
	if(!(@cr!=null))
	return(-1);
	if(skill<int((__SkillBegin))||skill>int((__SkillEnd)))
	return(-1);
	
	if((@item!=null))
	{
		
		skillused=item.Proto.Misc_ToolSkillNum;
		bonus+=item.Proto.Misc_ToolSkillBonus;
	}
	
	if(skill!=skillused)
	return(-1);
	
	int sk=cr.Param[skill]+bonus;
	sk=(((sk)>(95))?(95):(((sk)<(5))?(5):(sk)));
	int margin=sk-Random(1,100);
	if(margin>=0)
	return Random(1,100)<=margin/10+cr.Param[(14)]?(3):(2);
	else
	return Random(1,100)<=(-margin)/10?(0):(1);
}

string SkillName(uint8 skill)
{
	string result="";
	
	if(skill<(200)||skill>(217))
	return(result);
	
	switch(skill)
	{
		case(200):
		result="Small Guns";
		break;
		case(201):
		result="Big Guns";
		break;
		case(202):
		result="Energy Weapons";
		break;
		case(203):
		result="Unarmed";
		break;
		case(204):
		result="Learning";
		break;
		case(205):
		result="Throwing";
		break;
		case(206):
		result="First Aid";
		break;
		case(207):
		result="Doctor";
		break;
		case(208):
		result="Sneak";
		break;
		case(209):
		result="Robbery";
		break;
		case(210):
		result="Engineering";
		break;
		case(211):
		result="Traps";
		break;
		case(212):
		result="Science";
		break;
		case(213):
		result="Repair";
		break;
		case(214):
		result="Speech";
		break;
		case(215):
		result="Barter";
		break;
		case(216):
		result="Crafting";
		break;
		case(217):
		result="Outdoorsman";
		break;
	}
	
	return(result);
}      

string GetExtConditionOfCritter(Critter@cr)
{
	if(!(@cr!=null))
	return"";
	if(cr.Cond==(2))
	{
		switch(cr.Anim2Knockout)
		{
			case(82):
			return"ANIM2_KNOCK_FRONT";
			case(83):
			return"ANIM2_KNOCK_BACK";
		}
	}
	else if(cr.Cond==(3))
	{
		switch(cr.Anim2Dead)
		{
			case(102):
			return"ANIM2_DEAD_FRONT";
			case(103):
			return"ANIM2_DEAD_BACK";
			case(100):
			return"ANIM2_DEAD_PRONE_FRONT";
			case(101):
			return"ANIM2_DEAD_PRONE_BACK";
			case(110):
			return"ANIM2_DEAD_BLOODY_SINGLE";
			case(111):
			return"ANIM2_DEAD_BLOODY_BURST";
			case(112):
			return"ANIM2_DEAD_BURST";
			case(113):
			return"ANIM2_DEAD_PULSE";
			case(114):
			return"ANIM2_DEAD_PULSE_DUST";
			case(115):
			return"ANIM2_DEAD_LASER";
			case(116):
			return"ANIM2_DEAD_FUSED";
			case(117):
			return"ANIM2_DEAD_EXPLODE";
			case(118):
			return"ANIM2_DEAD_BURN";
			case(119):
			return"ANIM2_DEAD_BURN_RUN";
		}
	}
	return"";
}       

bool AddExpTeam(Critter&critter,int xp)
{
	Critter@leader=critter.GetFollowLeader();
	if((@leader!=null))
	{
		array<Critter@>followers;
		int num=leader.GetFollowGroup((0x0F),followers);
		int val=xp/num;
		for(int i=0;i<num;i++)
		followers[i].ParamBase[(76)]+=val;
		return true;
	}
	else
	{
		critter.ParamBase[(76)]+=xp;
		return false;
	}
}    

void DropTimeouts(Critter&cr)
{
	for(uint i=(__TimeoutBegin);i<=(__TimeoutEnd);i++)
	cr.TimeoutBase[i]=(__FullSecond);
}     

void ClearEvents(Critter&cr)
{
	for(uint i=0;i<(44);i++)
	cr.SetEvent(i,null);
}     

void GiveBag(uint bag,Critter@cr)
{
	if(!(@cr!=null))
	return;
	
	array<uint>mincounts,maxcounts;
	array<int>slots;
	array<uint16>pids;
	uint num=GetBagItems(bag,pids,mincounts,maxcounts,slots);
	for(uint i=0;i<num;i++)
	{
		uint count=Random(mincounts[i],maxcounts[i]);
		if(count==0)
		continue;
		Item@item=cr.AddItem(pids[i],count);
		if(!(@item!=null))
		continue;
		cr.MoveItem(item.Id,count,slots[i]);
	}
}

bool HasItem(Critter@cr,uint pid)
{
	Item@item=cr.GetItem(pid,-1);
	return(@item!=null);
}   

bool HasSomeWeapon(Critter@cr)
{
	array<Item@>items;
	uint num=cr.GetItems(-1,items);
	for(uint i=0;i<num;i++)
	{
		if((items[i].GetType()==(3))||items[i].GetType()==(0x00020000))
		return true;
	}
	return false;
}     

uint GetBestWeaponSkill(Critter@cr)
{
	int skill=-1;
	int highest=0;
	for(int i=(200);i<=(205)+1;i++)
	{
		if(cr.Param[i]>highest)
		{
			highest=cr.Param[i];
			skill=i;
		}
	}
	return skill;
}    

void AddOnlinePlayer(Critter&cr)
{
	OnlinePlayers.insertLast(cr.Id);
}    

void RemoveOnlinePlayer(Critter&cr)
{
	for(uint i=0,j=OnlinePlayers.length();i<j;i++)
	{
		if(OnlinePlayers[i]==cr.Id)
		{
			OnlinePlayers.removeAt(i);
			break;
		}
	}
}     

uint GetAllOnlinePlayers(array<Critter@>&out players)
{
	for(uint i=0,j=OnlinePlayers.length();i<j;i++)
	{
		Critter@cr=GetCritter(OnlinePlayers[i]);
		players.insertLast(cr);
	}
	
	return OnlinePlayers.length();
}    

uint GetNumberOfPlayersOnline()
{
	return OnlinePlayers.length();
}       

uint GetAuthenticatedPlayers(array<Critter@>&out players)
{
	return(GetAuthenticatedPlayers(players,false));
}

uint GetAuthenticatedPlayers(array<Critter@>&out players,bool ignorePriviledges)
{
	uint num=0;
	
	for(int i=0,j=OnlinePlayers.length();i<j;i++)
	{
		Critter@player=GetCritter(OnlinePlayers[i]);
		if(!(@player!=null))
		continue;
		
		if(player.GetAccess()==(0))
		continue;
		
		if(!ignorePriviledges)
		{
			if(player.GetAccess()==(3)&&(player.Param[(420)])==1337)
			continue;
		}
		
		players.insertLast(player);
		num+=1;
	}
	return num;
}      

Critter@GetMostSkilled(array<Critter@>@group,int skill)
{
	uint temp=0;
	Critter@best;
	for(uint i=0,j=group.length();i<j;i++)
	{
		uint sk=group[i].Param[skill];
		if(sk>temp)
		{
			@best=@group[i];
			temp=sk;
		}
	}
	return best;
}      

string GetAuthString(Critter&player)
{
	return GetAuthString(player.GetAccess());
}      

string GetAuthString(int accesslevel)
{
	if(accesslevel==(0))
	return"Client";
	if(accesslevel==(1))
	return"Tester";
	else if(accesslevel==(2))
	return"GM";
	else if(accesslevel==(3))
	return"Admin";
	else
	return"Unknown";
}    

bool CanRequestHelp(Critter&player)
{
	return(GetLvar(player,(4123))==0);
}    

void SetRequestedHelp(Critter&player)
{
	SetLvar(player,(4123),1);
	CreateTimeEvent(((__FullSecond)+(((15)*__TimeMultiplier*60))),"e_UnsetRequestedHelp",player.Id,true);
}

void SetRequestedHelp(Critter&player,int minutes)
{
	SetLvar(player,(4123),1);
	CreateTimeEvent(((__FullSecond)+(((minutes)*__TimeMultiplier*60))),"e_UnsetRequestedHelp",player.Id,true);
}    

Critter@GetOnlineGM()
{
	array<Critter@>authenticated;
	uint num=GetAuthenticatedPlayers(authenticated); 
	
	if(num==0)
	return null;
	
	do{Critter@__temp;uint pos;for(uint __i=0;__i<authenticated.length()-1;__i++){pos=Random(__i,authenticated.length()-1);@__temp=authenticated[pos];@authenticated[pos]=authenticated[__i];@authenticated[__i]=__temp;}}while(false);
	
	for(uint i=0;i<num;i++)
	{
		for(uint x=0;x<authenticated.length();x++)
		{
			if(!(@authenticated[i]!=null))
			continue;
			
			if(authenticated[i].GetAccess()<(3))
			return authenticated[i];
		}
	} 
	
	return authenticated[Random(0,num-1)];
}

bool IsHumanoid(Critter@cr)
{
	return((0)<=cr.Param[(67)]&&cr.Param[(67)]<=(4));
}     

void ClearEnemyStack(Critter&critter)
{
	critter.ErasePlane((1),true);
	critter.ClearEnemyStack();
}     

void ClearEnemyStacksOnMap(Map@map)
{
	array<Critter@>crits;
	uint num=map.GetCritters(0,(0x0F)|(0x20),crits);
	for(uint i=0;i<num;i++)
	ClearEnemyStack(crits[i]);
}   

bool IsCurrentEnemy(Critter&cr,uint targetId)
{
	if(cr.CheckEnemyInStack(targetId))
	return true;
	array<NpcPlane@>plans;
	cr.GetPlanes(plans);
	for(uint i=0,j=plans.length();i<j;i++)
	if(plans[i].Type==(1)&&plans[i].Attack_TargId==targetId)
	return true;
	return false;
}

string@GetSafePlayerName(uint id)
{
	string@name=GetPlayerName(id);
	if((@name!=null))
	return name;
	return@"[player not found]";
}

string GetSafePlayerName(uint id,string&onSuccess,string&onError)
{
	string@name=GetPlayerName(id);
	if((@name!=null))
	return(name+onSuccess);
	
	return("["+onError+"]");
}   

uint GetGroupIndex(Critter&cr)
{
	return(cr.Param[(106)]);
}
uint GetGroupIndex(int st)
{
	return st/100;
}  

void SetGroupIndex(Critter&cr,uint val)
{
	cr.ParamBase[(106)]=val;
}
uint GetGroupRank(Critter&cr)
{
	return(cr.Param[(121)]);
}
void SetGroupRank(Critter&cr,uint val)
{
	cr.ParamBase[(121)]=val;
}
uint GetGroupMode(Critter&cr)
{
	return(cr.Param[(122)]);
}
void SetGroupMode(Critter&cr,uint val)
{
	cr.ParamBase[(122)]=val;
}
void SetGroupInfo(Critter&cr,uint faction,uint rank,uint mode)
{
	cr.ParamBase[(106)]=faction;
	cr.ParamBase[(121)]=rank;
	cr.ParamBase[(122)]=mode;
}
void SetGroupInfoPack(Critter&cr,uint packInfo)
{
	cr.ParamBase[(106)]=packInfo/100;
	cr.ParamBase[(121)]=(packInfo/10)%10;
	cr.ParamBase[(122)]=packInfo%10;
}                

bool ReadPids(array<int>&out pids,bool removeinvalid)
{
	file f;
	Log("Reading PIDs");
	
	if(f.open("scripts/ITEMPID.H","r")>=0)
	{
		
		string str;
		int l=f.readString(f.getSize(),str);
		f.close();
		
		array<string@>@lines=split(str,"\n");
		Log("Read "+lines.length()+" lines");
		
		for(uint i=0;i<lines.length();i++)
		{
			
			if(lines[i].length()<7)
			continue;
			if(substring(lines[i],0,7)=="#define")
			{
				string spid="";
				int id=0;
				if(ParseDefine(lines[i],spid,id))
				{
					if(removeinvalid)
					{
						ProtoItem@proto=GetProtoItem(id);
						if(!(@proto!=null))
						continue;
						
						if(proto.Cost==0)
						continue;
					}
					pids.insertLast(id);
				}
			}
		}
	}
	else
	return false;
	return true;
}      

void ReadDefines(string@fileName,dictionary&items,array<string>@defines)
{
	file f;
	Log("Reading defines");
	
	if(f.open(fileName,"r")>=0)
	{
		
		string str;
		int l=f.readString(f.getSize(),str);
		f.close(); 
		
		array<string@>@lines=split(str,"\n");
		Log("Read "+lines.length()+" lines");
		
		for(uint i=0;i<lines.length();i++)
		{
			
			if(lines[i].length()<7)
			continue;
			if(substring(lines[i],0,7)=="#define")
			{
				string spid="";
				int id=0;
				if(ParseDefine(lines[i],spid,id))
				{   
					
					items.set(spid,id);
					if((@defines!=null))
					defines.insertLast(spid);
				}
			}
		}
	}
}                 

bool ParseDefine(const string&in line,string&out spid,int&out id)
{
	
	uint spid_start=SkipWhitespaces(line,7);
	uint spid_end=SkipNonWhitespaces(line,spid_start);
	
	uint id_start=SkipWhitespaces(line,spid_end);
	uint id_end=SkipNonWhitespaces(line,id_start);  
	
	if(id_start==id_end)
	return false; 
	
	spid=substring(line,spid_start,spid_end-spid_start);
	
	string sid=substring(line,id_start+1,id_end-id_start-2);
	if(!StrToInt(sid,id))
	return false;
	
	return true;
}      

int SkipWhitespaces(const string&in str,int start)
{
	uint i;
	for(i=start;i<str.rawLength();i++)
	{
		
		if(str.rawGet(i)==' '||str.rawGet(i)=='\t')
		continue;
		else
		break;
	}
	return i;
}      

int SkipNonWhitespaces(const string&in str,int start)
{
	uint i;
	for(i=start;i<str.rawLength();i++)
	{
		
		if(str.rawGet(i)!=' '&&str.rawGet(i)!='\t')
		continue;
		else
		break;
	}
	if(i==str.rawLength())
	return i-1;
	else
	return i;
}      

bool IsParameterTag(string&str)
{
	
	if(str.rawLength()==2&&str.rawGet(0)=='-')
	return true;
	if(str=="-legit"||str=="-dir"||str=="-full"||str=="-dist"||str=="-role"||str=="-min"||str=="-max"||
	str=="-v0"||str=="-v1"||str=="-v2"||str=="-v3"||str=="-v4"||str=="-v5"||str=="-v6"||str=="-v7"||str=="-v8"||
	str=="-script"||str=="-dmg"||str=="-pid"||str=="-skin"||str=="-map"||str=="-tx"||str=="-ty"||str=="-it")
	return true;
	
	return false;
}      

string GetParameterString(array<string@>@arr,string&parameter)
{
	string retstr="";
	bool saving=false;
	
	for(uint i=0;i<arr.length();i++)
	{
		if(IsParameterTag(arr[i]))
		{
			if(parameter==arr[i]&&(!saving))
			saving=true;
			else
			{
				if(saving==true)
				return retstr;
			}
		}
		
		if((saving==true)&&(!IsParameterTag(arr[i])))
		{
			if(retstr=="")
			retstr+=arr[i];
			else
			retstr+=" "+arr[i];
		}
	}
	return retstr;
}      

int GetIndexOfString(array<string@>@arr,string&str)
{
	if(!(@arr!=null))
	return-1;
	for(uint i=0;i<arr.length();i++)
	{
		if((@arr[i]!=null)&&arr[i]==str)
		return i;
	}
	return-1;
}      

string GetConcatenatedString(array<string@>@arr,uint startindex,int stopindex)
{
	string concat;
	if(stopindex==-1)
	stopindex=arr.length();
	
	if(int(startindex)>stopindex)
	stopindex=startindex+1;
	
	concat=arr[startindex];
	
	for(int i=startindex+1;i<stopindex;i++)
	{
		concat+=" "+arr[i];
	}
	return concat;
} 

string GetMsgStr(int textMsg,uint strNum)
{
	return("@msg "+textMsg+" "+strNum+"@");
}             

void SetTurnBasedAvailability(Location@loc)
{
	for(uint i=0,j=loc.GetMapCount();i<j;i++)
	loc.GetMapByIndex(i).SetTurnBasedAvailability(true);
}     

bool IsEncounterMap(Map@map)
{
	if(!(@map!=null))
	return false;
	return map.GetLocation().IsEncounter();
}     

bool IsTown(Map@map)
{
	if(!(@map!=null))
	return false;
	
	return map.GetLocation().IsTown();
}     

bool IsDungeon(Map@map)
{
	if(!(@map!=null))
	return false;
	
	return map.GetLocation().IsDungeon();
}     

bool IsBaseControl(Map@map)
{
	if(!(@map!=null))
	return false;
	
	switch(map.GetLocation().GetProtoId())
	{
		case(98):
		case(362):
		case(95):
		case(12):
		case(99):
		return true;
		default:
		return false;
	}
	
	return false;
}

bool IsGuarded(Map@map)
{
	if(!(@map!=null))
	return false;
	
	return map.GetLocation().IsGuarded();
}

bool IsPublic(Map@map)
{
	if(!(@map!=null))
	return false;
	
	return map.GetLocation().IsPublic();
}

bool IsInstancedQuest(Map@map)
{
	if(!(@map!=null))
	return false;
	
	return map.GetLocation().IsInstancedQuest();
}                                                    

uint GetMapType(Map@map)
{
	uint pid=map.GetProtoId();    
	
	if(((pid>=(160))&&(pid<=(169)))||((pid>=(345))&&(pid<=(348)))||((pid>=(500))&&(pid<=(504)))||((pid>=(511))&&(pid<=(513))))
	return(2);
	else if(((pid>=(170))&&(pid<=(184)))||((pid>=(129))&&(pid<=(132))))
	return(3);
	else if(((pid>=(185))&&(pid<=(189))))
	return(4);
	else if(((pid>=(190))&&(pid<=(199)))||((pid>=(217))&&(pid<=(218))))
	return(5);
	else if(((pid>=(214))&&(pid<=(216))))
	return(9);  
	
	else if(((pid>=(200))&&(pid<=(204))))
	return(7);
	else if(((pid>=(205))&&(pid<=(211))))
	return(8);
	else
	return(0);
}     

Location@GetLocationOf(Critter&critter)
{
	Map@map=critter.GetMap();
	if(!(@map!=null))
	return null;
	return map.GetLocation();
}

string GetLocationName(uint locId)
{
	Location@loc=GetLocation(locId);
	if((@loc!=null))
	return(GetLocationName(loc));
	
	return("");
}

string GetLocationName(Location@loc)
{
	string result="<location "+loc.Id+">";
	loc.ProtoName(result);
	return(result);
}                     

void SetQuestGarbager(uint time,uint playerid,uint locid,uint var,uint val)
{
	uint[]values={playerid,locid,var,val};
	CreateTimeEvent(((__FullSecond)+(((time==0?__QuestGarbagerTime:time)*__TimeMultiplier*60))),"utils@e_DeleteQuestLoc",values,true);
}        

void LockDoor(uint x,uint y,Map@map,uint complexity,uint lockid)
{
	if(!(@map!=null))
	{
		Log("Map not valid");
		return;
	}
	
	Item@door=map.GetDoor(x,y);
	
	if(!(@door!=null))
	{
		Log("Door not valid");
		return;
	}
	
	door.LockerId=lockid;
	door.LockerComplexity=complexity;
	(not((door.LockerCondition&(0x01))!=0));
}      

void UnlockDoor(uint x,uint y,Map@map)
{
	if(!(@map!=null))
	{
		Log("Map not valid");
		return;
	}
	
	Item@door=map.GetDoor(x,y);
	
	if(!(@door!=null))
	{
		Log("Door not valid");
		return;
	}
	
	door.LockerId=0;
	door.LockerComplexity=0;
}

int gcd(int a,int b)
{
	int c;
	while(a!=0)
	{
		c=a;
		a=b%a;
		b=c;
	}
	return b;
}

array<int>knapsack(array<int>weights,int W)
{
	int len=weights.length();
	int div=W;
	for(int i=0;(i<len)&&(div!=1);i++)
	div=gcd(div,weights[i]);
	
	if(div>1)
	{
		W/=div;
		for(int i=0;i<len;i++)
		weights[i]/=div;
	}
	
	int min=weights[0];
	for(int i=1;i<len;i++)
	if(weights[i]<min)
	min=weights[i];
	
	array<int>tab(W+1);
	array<int>max(W+1);
	array<int>perm(len);
	
	for(int i=0;i<len;i++)
	perm[i]=i;
	
	for(int i=0;i<=W;i++)
	{
		tab[i]=0;
		max[i]=0;
	}
	
	int best=-1;
	int lmax=0;
	
	for(int i=min;i<=W;i++)
	{
		best=0;
		lmax=0; 
		
		for(int k=0;k<len;k++)
		{
			int rm=Random(k,len-1);
			int temp=perm[rm];
			perm[rm]=perm[k];
			perm[k]=temp;
		}
		for(int j=0;j<len;j++)
		{
			if(weights[perm[j]]>i)
			continue;
			if(weights[perm[j]]+max[i-weights[perm[j]]]>lmax)
			{
				lmax=weights[perm[j]]+max[i-weights[perm[j]]];
				best=perm[j];
			}
		}
		
		max[i]=weights[best]+max[i-weights[best]];
		tab[i]=best; 
		
	}
	int w=W;
	array<int>ret;
	ret.resize(0);
	while(w>=min)
	{
		
		ret.insertLast(tab[w]);
		w-=weights[tab[w]];
	}
	return ret;
}           

IDateTime@GetCurrentDateTime()
{
	DateTime dt;
	
	GetTime(dt.year,dt.month,dt.day,dt.dayOfWeek,dt.hour,dt.minute,dt.second,dt.milliseconds);
	
	return dt;
}       

string GetCurrentDateTimeString()
{
	return GetCurrentDateTimeString(true,true);
}      

string GetCurrentDateTimeString(bool date,bool time)
{
	IDateTime@dt=GetCurrentDateTime();
	string timestr="";
	if(date)
	timestr=dt.Day+"/"+dt.Month+"/"+dt.Year;
	
	if(time)
	{
		if(date)
		timestr=timestr+" ";
		timestr=timestr+(dt.Hour<10?"0":"")+dt.Hour+":"+(dt.Minute<10?"0":"")+dt.Minute+":"+(dt.Second<10?"0":"")+dt.Second;
	}
	return timestr;
}                 

Item@GetContainer(Map@map,uint contpid,uint entire)
{
	if(!(@map!=null))
	return null;
	
	uint16 HexX,HexY;
	HexX=0;
	HexY=0;
	
	GetNearEntire(map,entire,HexX,HexY);
	return map.GetItem(HexX,HexY,contpid);
}    

bool TeleportCar(Item@Car,uint MapId)
{
	Map@map=GetMap(MapId);
	if(!(@map!=null))
	return false;
	uint16 x=0;
	uint16 y=0;
	if(!GetEntireFreeHex(map,(243),x,y))
	return false; 
	
	Critter@dummy=map.AddNpc(1,0,0,0,null,null,"");
	DriveToGlobal(dummy,Car,false);
	dummy.TransitToMap(map.Id,0);
	DeleteNpc(dummy);
	return true;
}        

void TransferItemsToContOnMap(Critter&cr,Map@map,int entid,int contpid,int itemtypes)
{
	Item@cont=GetContainer(map,contpid,entid);
	if(!(@cont!=null))
	return;
	array<Item@>items;
	uint n;
	if(itemtypes==(0))
	n=cr.GetItems(-1,items);
	else if(itemtypes==(1))
	n=cr.GetItemsByType((3),items);
	
	for(uint i=0;i<n;i++)
	MoveItem(items[i],items[i].GetCount(),cont,cr.Id);
}      

void TransferItemsFromContOnMap(Critter&cr,Map@map,int entid,int contpid)
{
	Item@cont=GetContainer(map,contpid,entid);
	if(!(@cont!=null))
	return;
	array<Item@>items;
	cont.GetItems(cr.Id,items);
	MoveItems(items,cr);
}    

import bool LockerClose(Item&item)from"lockers";
void ClearContainer(Item@container)
{
	array<Item@>items;
	uint itemCount=container.GetItems(0,items);
	if(itemCount>0)
	{
		uint protoid=container.Proto.ProtoId;
		uint16 x=container.HexX;
		uint16 y=container.HexY;
		Map@map=container.GetMapPosition(x,y);
		uint script=container.GetScriptId();
		Item@it=map.AddItem(x,y,protoid,1);
		
		it.SetScript(GetScriptName(script));
		if(it.Proto.Container_Changeble)
		LockerClose(it);
		DeleteItem(container);
	}
}

void ClearContainerSoft(Item@container)
{
	array<Item@>items;
	uint itemCount=container.GetItems(0,items);
	for(uint i=0;i<itemCount;i++)
	{
		DeleteItem(items[i]);
	}
}        

void MoveItemsCritterToCont(Critter&crFrom,Item&contTo,uint specid)
{
	array<Item@>items;
	uint itemCount=crFrom.GetItems((0),items);
	if(specid==0)
	specid=crFrom.Id;
	MoveItems(items,contTo,specid);
}                

int GetGvar(uint gvar)
{
	GameVar@var=GetGlobalVar(gvar);
	if((@var!=null))
	return var.GetValue();
	else
	Log("GVar "+gvar+" not valid");
	return-1;
}     

void SetGvar(uint gvar,uint value)
{
	GameVar@var=GetGlobalVar(gvar);
	if((@var!=null))
	var=value;
	else
	Log("GVar "+gvar+" not valid");
}

int GetLLvar(Location&location,uint llvar)
{
	return(GetLLvar(location.Id,llvar));
}

int GetLLvar(uint locationId,uint llvar)
{
	return(GetLvar(locationId,llvar,"LLVAR"));
}

void SetLLvar(Location&location,uint llvar,uint value)
{
	SetLvar(location.Id,llvar,value,"LLVAR","location");
}

int GetLMvar(Map&map,uint lmvar)
{
	return(GetLLvar(map.Id,lmvar));
}

int GetLMvar(uint mapId,uint lmvar)
{
	return(GetLvar(mapId,lmvar,"LMVAR"));
}

void SetLMvar(Map&map,uint lmvar,uint value)
{
	SetLvar(map.Id,lmvar,value,"LMVAR","map");
}

int GetLIvar(Item&item,uint livar)
{
	return(GetLIvar(item.Id,livar));
}

int GetLIvar(uint itemId,uint livar)
{
	return(GetLvar(itemId,livar,"LIVAR"));
}

void SetLIvar(Item&item,uint livar,uint value)
{
	SetLvar(item.Id,livar,value,"LIVAR","item");
}      

int GetLvar(Critter&critter,uint lvar)
{
	return GetLvar(critter.Id,lvar);
}      

int GetLvar(uint id,uint lvar)
{
	return(GetLvar(id,lvar,"LVAR"));
}

int GetLvar(uint id,uint lvar,string&typeShort)
{
	GameVar@var=GetLocalVar(lvar,id);
	if((@var!=null))
	return var.GetValue();
	else
	Log(typeShort+" "+lvar+" with id "+id+" not valid");
	return-1;
}      

void SetLvar(Critter&critter,uint lvar,uint value)
{
	SetLvar(critter.Id,lvar,value,"LVAR","critter");
}      

void SetLvar(uint id,uint lvar,uint value)
{
	SetLvar(id,lvar,value,"LVAR","critter");
}

void SetLvar(uint id,uint lvar,uint value,string&typeShort,string&typeLong)
{
	GameVar@var=GetLocalVar(lvar,id);
	if((@var!=null))
	var=value;
	else
	Log(typeShort+" "+lvar+" for "+typeLong+" with id "+id+" not valid");
}       

int GetUvar(uint uvar,uint masterid,uint slaveid)
{
	GameVar@var=GetUnicumVar(uvar,masterid,slaveid);
	if((@var!=null))
	return var.GetValue();
	else
	Log("UVar "+uvar+" with masterid "+masterid+" not valid");
	return-1;
}       

void SetUvar(uint uvar,uint masterid,uint slaveid,uint value)
{
	GameVar@var=GetUnicumVar(uvar,masterid,slaveid);
	if((@var!=null))
	var=value;
	else
	{
		Log("UVar "+uvar+" with masterid "+masterid+" not valid");
	}
} 

class DateTime:IDateTime
{
	uint16 year;
	uint16 month;
	uint16 dayOfWeek;
	uint16 day;
	uint16 hour;
	uint16 minute;
	uint16 second;
	uint16 milliseconds;
	
	DateTime()
	{
		year=0;
		month=0;
		dayOfWeek=0;
		day=0;
		hour=0;
		minute=0;
		second=0;
		milliseconds=0;
	}
	
	uint16 get_Year(){return year;}
	uint16 get_Month(){return month;}
	uint16 get_DayOfWeek(){return dayOfWeek;}
	uint16 get_Day(){return day;}
	uint16 get_Hour(){return hour;}
	uint16 get_Minute(){return minute;}
	uint16 get_Second(){return second;}
	uint16 get_Milliseconds(){return milliseconds;}
	
	string@ToString()
	{
		return""+hour+":"+minute+" "+year+"/"+month+"/"+day;
	}
};              

uint GetContainerValue(Item@container)
{
	uint value=0;
	array<Item@>items;
	uint itemCount=container.GetItems(0,items);
	for(uint i=0;i<itemCount;i++)
	value+=BaseItemValue(items[i]);
	
	return value;
}     

uint BaseItemValue(uint pid,bool ammo)
{
	return BaseItemValue(pid,0,0,ammo);
}        

uint BaseItemValue(uint pid,uint broken,uint det,bool ammo)
{
	ProtoItem@proto=GetProtoItem(pid);
	
	if(!(@proto!=null))
	return 0;
	uint cost=proto.Cost;
	
	if(proto.Deteriorable)
	{
		cost=(cost*((100)-broken))/(100);
		
	}
	
	if(ammo)
	{
		if(proto.Type==(3)&&proto.Weapon_DefaultAmmoPid!=0)
		{
			ProtoItem@ammoproto=GetProtoItem(proto.Weapon_DefaultAmmoPid);
			if((@ammoproto!=null))
			cost+=proto.Weapon_MaxAmmoCount*ammoproto.Cost;
		}
	}
	return cost;
}     

uint BaseItemValue(Item@item)
{
	return BaseItemValue(item,100);
}      

uint BaseItemValue(Item@item,uint proc)
{
	uint cost=item.Cost;
	if(item.IsDeteriorable())
	{
		
		cost=(cost*((10000)-item.Deterioration))/(10000);
	}
	cost*=proc;
	cost/=100; 
	
	return cost*(((1)>(item.GetCount()))?(1):(item.GetCount()));
}       

uint BaseSingleItemValue(Item@item)
{
	return BaseSingleItemValue(item,100);
}      

uint BaseSingleItemValue(Item@item,uint proc)
{
	uint cost=item.Cost;
	if(item.IsDeteriorable())
	{
		cost=(cost*((100)-item.BrokenCount))/(100);
		
	}
	cost*=proc;
	cost/=100;
	
	return cost;
}

bool Pickable(Item@item)
{
	if(item.GetType()>(7)||(((item.Flags)&((0x10000000)))!=0))
	return false;
	if(item.Accessory!=(2))
	return false;
	if(item.Proto.Weight>124575)
	return false;
	uint pid=item.GetProtoId();
	if((1810)<=pid&&pid<=(1827))
	return false;
	switch(pid)
	{
		case(606):
		case(1851):
		case(821):
		case(555):
		return false;
		default:
	}
	return true;
}      

array<uint>OnlinePlayers;

uint e_DeleteQuestLoc(array<uint>@values)
{
	Location@loc=GetLocation(values[1]);
	if(!(@loc!=null))
	return 0;
	DeleteLocation(values[1]);
	if(values[0]==0||values[2]==0)
	return((1)*__TimeMultiplier*3600);
	GameVar@var=GetLocalVar(values[2],values[0]);
	var=values[3];
	return((1)*__TimeMultiplier*3600);
} 

uint e_UnsetRequestedHelp(array<uint>@values)
{
	SetLvar(values[0],(4123),0);
	return 0;
} 

void Preprocess(Critter&player,string&commandString)
{
	LogCommandUsage(player,commandString);
}

void LogCommandUsage(Critter&player,string&commandString)
{
	FLog((1),GetCritterInfo(player)+commandString);
	GMLog(player,GetCritterInfo(player)+commandString);
	LogCommand(player,GetCritterInfo(player)+commandString);
}

void SetSpectator(Critter&cr,bool on)
{
	if(!(@cr!=null)||!cr.IsPlayer())
	return; 
	
	if(on)
	{
		(cr.ParamBase[(534)]=cr.Param[(534)]|((0x00008000)));
		(cr.ParamBase[(534)]=cr.Param[(534)]|((0x00010000)));
		cr.ParamBase[(514)]=1;
		cr.ParamBase[(112)]=(58);
		cr.ChangeCrType(cr.ParamBase[(112)]);
	}
	else
	{
		(cr.ParamBase[(534)]=(cr.Param[(534)]|((0x00010000)))^((0x00010000)));
		(cr.ParamBase[(534)]=(cr.Param[(534)]|((0x00008000)))^((0x00008000)));
		cr.ParamBase[(514)]=0;
		if(cr.Param[(112)]==(58))
		{
			cr.ParamBase[(112)]=(cr.Param[(71)]==(0)?((69)):((4)));
			cr.ChangeCrType(cr.ParamBase[(112)]);
		}
	}
}

void SetSpectator(Critter&cr,bool on,bool egg)
{
	if(egg)
	{
		SetSpectator(cr,on);
		return;
	}
	
	{;};
	if(!(@cr!=null)||!cr.IsPlayer())
	return;
}

string[]blood={"?","0+","0-","A+","A-","B+","B-","AB+","AB-"};

void SetBloodType(Critter@cr)
{
	if(!(@cr!=null))
	return;
	
	if(Random(1,1000)==1)
	SetLvar(cr,(9001),0);
	else
	SetLvar(cr,(9001),Random(1,blood.length()-1));
}

string GetBloodType(Critter@cr)
{
	if(!(@cr!=null))
	return(blood[0]);
	
	int idx=GetLvar(cr,(9001));
	if(idx<0||idx>=int(blood.length()))
	return(blood[0]);
	else
	return(blood[idx]);
}

string GetBloodRandom()
{
	if(Random(1,1000)==1)
	return(blood[0]);
	else
	return(blood[Random(1,blood.length()-1)]);
}

string IpToString(uint ip)
{
	if(ip>0)
	{
		string result="";
		
		for(uint i=0;i<4;i++)
		result+=(i==0?"":".")+((ip>>(i*8))&0xFF);
		
		return(result);
	}
	else
	return("0.0.0.0");
}

string GetCritterName(Critter&cr)
{
	string crName=cr.Name;
	
	if(IsLexem(cr,"$name"))
	crName=GetLexem(cr,"$name");
	
	if(cr.IsNpc()&&!IsLexem(cr,"$name"))
	{
		crName="|dlgName"+cr.Id+"|";
	}
	
	return(crName);
}

void SayEx(uint8 type,Critter&target,string&text)
{
	if(type>=(2))
	{
		Log("Invalid type<"+type+">");
		return;
	}
	
	array<Critter@>players;
	Map@map=target.GetMap();
	if((@map!=null))
	{
		Critter@[]target_={target};
		map.GetCrittersSeeing(target_,true,(0x0F)|(0x10),players);
	}
	else
	players=target.GetGlobalGroup();
	
	uint count=players.length();
	if(count==0)
	return;
	
	for(uint p=0;p<count;p++)
	{
		if(players[p].IsPlayer())
		players[p].RunClientScript("client_messages@sayEx",type,target.Id,0,text,null);
	}
}

void MapMessageEx(uint8 type,uint8 mode,Critter&target,string&text,uint16 hexX,uint16 hexY,uint8 delay=150,uint color=0,bool fade=true,int8 fromX=0,int8 toX=0,int8 fromY=0,int8 toY=0)
{
	if(type>=(3))
	{
		Log("Invalid type<"+type+">");
		return;
	}
	
	if(mode>=(4))
	{
		Log("Invalid mode<"+mode+"> (check #1)");
		return;
	}
	
	if(text.length()==0)
	{
		{;};
		return;
	}
	
	Map@map=target.GetMap();
	if(!(@map!=null))
	return;
	
	if(hexX==0||hexY==0)
	{
		Log("Invalid hex hexX<"+hexX+"> hexY<"+hexY+">");
		PrintCallstack();
		return;
	}
	
	array<Critter@>players;
	
	switch(mode)
	{
		case(1):
		if(target.IsPlayer())
		players.insertLast(target);
		else if(target.IsNpc()&&(((target.Param[(534)]&((0x00000020)))!=0)))
		{
			Critter@master=GetMaster(target);
			if((@master!=null)&&master.GetMapId()==target.GetMapId())
			players.insertLast(master);
		}
		else
		return;
		break;
		
		case(2):
		case(3):
		{
			Critter@[]target_={target};
			map.GetCrittersSeeing(target_,true,(0x0F)|(0x10),players);
			
			if(mode==(3))
			{
				for(uint c=0,cLen=players.length();c<cLen;c++)
				{
					if(players[c].Id==target.Id)
					{
						players.removeAt(c);
						break;
					}
				}
			}
		};
		break;
		
		default:
		Log("Invalid mode<"+mode+"> (check #2)");
	}
	
	if(!(@players!=null))
	return;
	
	uint count=players.length();
	if(count==0)
	return;
	
	Buffer@buff=NewBuffer();
	buff<<delay<<color<<fade<<fromX<<toX<<fromY<<toY;
	
	array<int32>data=buff.AsInt32();
	
	for(uint p=0;p<count;p++)
	{
		if(players[p].IsPlayer())
		players[p].RunClientScript("client_messages@map",type,hexX,hexY,text,data);
	}
}

void VerboseAction(Critter&cr,string&text)
{
	if(text.length()>0)
	{
		stringReplaceText(text,"CRITTER",GetCritterName(cr));   
		
		text="**"+text+"**";
		
		MapMessageEx((1),(2),cr,text,cr.HexX,cr.HexY,150,(uint((0xFF<<24)|(((58)&0xFF)<<16)|(((137)&0xFF)<<8)|((133)&0xFF))),true,-20,20,-20,-20);
		SayEx((1),cr,text);
	}
}

void VerboseActionCombat(Critter&cr,string&text)
{
	if(text.length()>0)
	{
		stringReplaceText(text,"CRITTER",GetCritterName(cr));   
		
		text=" "+text+" ";
		
		MapMessageEx(0,(2),cr,text,cr.HexX,cr.HexY,250,(uint((0xFF<<24)|(((255)&0xFF)<<16)|(((20)&0xFF)<<8)|((13)&0xFF))),true,-20,20,-20,-20);
		SayEx((1),cr,text);
	}
}

void VerboseAction(Critter&cr,Critter&target,string&text)
{
	if(text.length()>0)
	{
		stringReplaceText(text,"TARGET",GetCritterName(target));
		VerboseAction(cr,text);
	}
}

void VerboseExperience(Critter&cr,int xpDiff,int levelDiff)
{
	if(xpDiff==0&&levelDiff==0)
	return;
	
	string floater="";
	if(xpDiff!=0)
	floater+=(xpDiff>0?"+":"")+xpDiff+" experience";
	
	if(levelDiff!=0)
	floater+=(floater.length()>0?"\n":"")+(levelDiff>0?"+":"")+levelDiff+" level"+(levelDiff>1?"s":"");
	
	MapMessageEx((2),(1),cr,floater,cr.HexX,cr.HexY,150,(uint((0xFF<<24)|(((0)&0xFF)<<16)|(((200)&0xFF)<<8)|((0)&0xFF))),true,-20,20,-20,-30);
}   

uint CreateLocationForGroup(Critter&player,uint16 pid,uint16 worldX,uint16 worldY,array<Critter@>&group)
{
	player.GetFollowGroup((0x0F),group);
	
	array<Critter@>crits;
	uint n=player.GetMap().GetCritters(0,(0x0F)|(0x20),crits);
	for(uint i=0;i<n;i++)
	if((((crits[i].Param[(534)]&((0x00000020)))!=0)))
	group.insertLast(crits[i]);
	
	group.insertLast(player);
	
	return CreateLocation(pid,worldX,worldY,group);
}

void ChangeCrTypeSafe(Critter&cr,uint8 crType)
{
	Item@armor=cr.GetItem(0,(3));
	
	if((@armor!=null))
	cr.MoveItem(armor.Id,0,(0));
	
	if(cr.ChangeCrType(crType))
	cr.ParamBase[(112)]=crType;
	
	if((@armor!=null))
	cr.MoveItem(armor.Id,0,(3));
}

void SetChosenActions(Critter&cr,array<int>&actions)
{
	cr.RunClientScript("_SetChosenActions",0,0,0,null,actions);
}

void PrintCallstack()
{
	PrintCallstack(1);
}

void PrintCallstack(int level)
{
	level++;
	array<string@>modules;
	array<string@>names;
	array<uint>lines;
	array<uint>columns;
	uint n=GetCallstack(modules,names,lines,columns);
	for(uint i=level;i<n;i++)
	Log("  "+(n-i-1)+") "+modules[i]+" : "+names[i]+" : "+lines[i]+","+columns[i]);
} 

void FixDrugs(Critter&cr)
{
	GameVar@var=GetLocalVar((60001),cr.Id);
	if(var.GetValue()==(1))
	return;
	DropDrugEffects(cr);
	DropRadiation(cr);
	for(int i=(32);i<=(63);i++)
	cr.ParamBase[i]=0;
	var=(1);
}      

bool FindFirstFreeHex(Map@map,uint16&x,uint16&y,uint8 dir,uint16 maxSteps)
{
	for(uint i=0;i<maxSteps;i++)
	{
		map.MoveHexByDir(x,y,dir,1);
		if(map.IsHexPassed(x,y))
		return true;
	}
	return false;
}     

bool FindNearestFreeHex(Map&map,uint16&x,uint16&y,uint radius)
{
	if(map.IsHexPassed(x,y))
	{
		return true;
	}
	for(uint r=1;r<=radius;r++)
	{
		map.MoveHexByDir(x,y,4,1);
		for(uint side=0;side<6;side++)
		{
			for(uint step=0;step<r;step++)
			{
				map.MoveHexByDir(x,y,side,1);
				if(map.IsHexPassed(x,y))
				{
					return true;
				}
			}
		}
	}
	return false;
}     

bool GetItemCoordinates(Item&item,uint&mapID,uint16&x,uint16&y)
{
	if(!(@item!=null))
	return false;
	
	if(item.Accessory==(2))
	{
		Map@map=GetMap(item.MapId);
		if(!(@map!=null))
		return false;
		mapID=item.MapId;
		x=item.HexX;
		y=item.HexY;
		return true;
	}
	else if(item.Accessory==(1))
	{
		Critter@critter=GetCritter(item.CritId);
		if(!(@critter!=null))
		return false;
		mapID=critter.GetMapId();
		x=critter.HexX;
		y=critter.HexY;
		return true;
	}
	else if(item.Accessory==(3))
	{
		Item@container=GetItem(item.ContainerId);
		if(!(@container!=null))
		return false;
		mapID=container.MapId;
		x=container.HexX;
		y=container.HexY;
		return true;
	}
	else
	return false;
}    

bool ItemOnHex(uint16 pid,Map@map,uint16 x,uint16 y)
{
	if(!(@map!=null))
	return false;
	Item@item=map.GetItem(x,y,pid);
	if(!(@item!=null))
	return false;
	return true;
}         

void HexLine(uint16 x0,uint16 y0,uint16 x1,uint16 y1,array<uint16>@xList,array<uint16>@yList)
{
	
	int w=x1-x0;
	int h=y1-y0;
	int dx0=0,dy0=0,dx1=0,dy1=0;
	
	if(w<0)
	dx0=-1;
	else if(w>0)
	dx0=1;
	if(h<0)
	dy0=-1;
	else if(h>0)
	dy0=1;
	if(w<0)
	dx1=-1;
	else if(w>0)
	dx1=1;
	
	int longest=abs(w);
	int shortest=abs(h);
	if(!(longest>shortest))
	{
		longest=abs(h);
		shortest=abs(w);
		if(h<0)
		dy1=-1;
		else if(h>0)
		dy1=1;
		dx1=0;
	}
	
	int numerator=longest>>1;
	for(int i=0;i<=longest;i++)
	{
		do{if(x0>=0&&y0>=0){xList.insertLast(x0);yList.insertLast(y0);}}while(false);
		numerator+=shortest;
		if(!(numerator<longest))
		{
			numerator-=longest;
			x0+=dx0;
			y0+=dy0;
		}
		else
		{
			x0+=dx1;
			y0+=dy1;
		}
	}
}

void HexCircle(uint16 x0,uint16 y0,uint16 radius,array<uint16>@xList,array<uint16>@yList)
{
	
	int f=1-radius;
	int ddF_x=1;
	int ddF_y=-2*int(radius);
	int x=0;
	int y=radius;
	do{if(x0>=0&&y0+radius>=0){xList.insertLast(x0);yList.insertLast(y0+radius);}}while(false);
	do{if(x0>=0&&y0-radius>=0){xList.insertLast(x0);yList.insertLast(y0-radius);}}while(false);
	do{if(x0+radius>=0&&y0>=0){xList.insertLast(x0+radius);yList.insertLast(y0);}}while(false);
	do{if(x0-radius>=0&&y0>=0){xList.insertLast(x0-radius);yList.insertLast(y0);}}while(false);
	while(x<y)
	{
		if(f>=0)
		{
			y--;
			ddF_y+=2;
			f+=ddF_y;
		}
		x++;
		ddF_x+=2;
		f+=ddF_x;
		do{if(x0+x>=0&&y0+y>=0){xList.insertLast(x0+x);yList.insertLast(y0+y);}}while(false);
		do{if(x0-x>=0&&y0+y>=0){xList.insertLast(x0-x);yList.insertLast(y0+y);}}while(false);
		do{if(x0+x>=0&&y0-y>=0){xList.insertLast(x0+x);yList.insertLast(y0-y);}}while(false);
		do{if(x0-x>=0&&y0-y>=0){xList.insertLast(x0-x);yList.insertLast(y0-y);}}while(false);
		do{if(x0+y>=0&&y0+x>=0){xList.insertLast(x0+y);yList.insertLast(y0+x);}}while(false);
		do{if(x0-y>=0&&y0+x>=0){xList.insertLast(x0-y);yList.insertLast(y0+x);}}while(false);
		do{if(x0+y>=0&&y0-x>=0){xList.insertLast(x0+y);yList.insertLast(y0-x);}}while(false);
		do{if(x0-y>=0&&y0-x>=0){xList.insertLast(x0-y);yList.insertLast(y0-x);}}while(false);
	}
}     

enum PDataType
{
	PDataLoc,
	PDataMap,
	PDataCr,
	PDataIt
};

string PDataString(PDataType type)
{
	string result="";
	
	if(EnumContains("PDataType",type))
	{
		array<string@>names;
		array<int>values;
		uint count=GetEnum("PDataType",names,values);
		for(uint e=0;e<count;e++)
		{
			if(values[e]==type)
			return(names[e]);
		}
	}
	
	return("");
};    

bool IsPData(PDataType type,uint id)
{
	string prefix=PDataString(type);
	if(prefix.length()==0||id==0)
	return(false);
	
	return(IsAnyData(prefix+":"+id));
}

bool GetPData(PDataType type,uint id,array<uint8>&raw)
{
	string prefix=PDataString(type);
	if(prefix.length()==0||id==0)
	return(false);
	
	return(GetAnyData(prefix+":"+id,raw));
}

bool SetPData(PDataType type,uint id,array<uint8>&raw)
{
	string prefix=PDataString(type);
	if(prefix.length()==0||id==0)
	return(false);
	
	if(SetAnyData(prefix+":"+id,raw))
	{
		array<uint>list;
		bool add=true;
		if(IsAnyData(prefix)&&GetAnyData(prefix,list))
		{
			if(list.find(id)>=0)
			add=false;
		}
		
		if(add)
		{
			list.insertLast(id);
			list.sortAsc();
		}
		
		SetAnyData(prefix,list);
		
		return(true);
	}
	
	return(false);
}

bool UnsetPData(PDataType type,uint id)
{
	string prefix=PDataString(type);
	if(prefix.length()==0||id==0)
	return(false);
	
	EraseAnyData(prefix+":"+id);
	
	array<uint>list;
	if(IsAnyData(prefix)&&GetAnyData(prefix,list))
	{
		int idx=-1;
		if((idx=list.find(id))>=0)
		list.removeAt(idx);
	}
	
	if(list.length()>0)
	SetAnyData(prefix,list);
	else
	EraseAnyData(prefix);
	
	return(true);
}

void StartPersonalDataCleanup()
{
	CreateTimeEvent(((__FullSecond)+(((1)*__TimeMultiplier))),"utils@e_CleanupPData",false);
}

uint e_CleanupPData(array<uint>@)
{
	array<string>pdataName;
	array<int>pdataType;
	
	array<string@>names;
	array<int>values;
	uint count=GetEnum("PDataType",names,values);
	for(uint e=0;e<count;e++)
	{
		if(IsAnyData(names[e]))
		{
			pdataName.insertLast(names[e]);
			pdataType.insertLast(values[e]);
		}
	}
	
	for(uint d=0,dLen=pdataName.length();d<dLen;d++)
	{
		array<uint>list;
		if(IsAnyData(pdataName[d])&&GetAnyData(pdataName[d],list))
		{
			for(uint l=0,len=list.length();l<len;l++)
			{
				bool exists=true;
				string what="something";
				
				switch(pdataType[d])
				{
					case PDataLoc:
					exists=(@GetLocation(list[l])!=null);
					what="location";
					break;
					case PDataMap:
					exists=(@GetMap(list[l])!=null);
					what="map";
					break;
					case PDataCr:
					if(list[l]>=(5000000))
					{
						exists=(@GetCritter(list[l])!=null);
						what="npc";
					}
					else
					{
						exists=(@GetPlayerName(list[l])!=null);
						what="player";
					}
					break;
					case PDataIt:
					exists=(@GetItem(list[l])!=null);
					what="item";
				}
				
				if(!exists)
				{
					Log("Removing personal data for "+what+"<"+list[l]+">");
					UnsetPData(PDataType(pdataType[d]),list[l]);
				}
			}
		}
	}    
	
	return(((10)*__TimeMultiplier*60));
	
}

bool IsPersonalData(PDataType type,uint id,string&name)
{
	array<uint8>dataRaw;
	
	if(IsPData(type,id)&&GetPData(type,id,dataRaw))
	{
		array<string>dataNames;
		
		Buffer@buffer=NewBuffer(dataRaw);
		buffer>>dataNames;
		
		if(dataNames.length()==0)
		return(false);
		
		for(uint d=0,dLen=dataNames.length();d<dLen;d++)
		{
			if(dataNames[d]==name)
			return(true);
		}
	}
	
	return(false);
}

bool GetPersonalData(PDataType type,uint id,string&name,array<uint8>&data)
{
	array<uint8>dataRaw;
	
	if(IsPData(type,id)&&GetPData(type,id,dataRaw))
	{
		array<string>dataNames;
		array<array<uint8>>dataValues;
		
		Buffer@buffer=NewBuffer(dataRaw);
		buffer>>dataNames>>dataValues;
		
		if(dataNames.length()==0||dataValues.length()==0)
		return(false);
		if(dataNames.length()!=dataValues.length())
		return(false);
		
		for(uint d=0,dLen=dataNames.length();d<dLen;d++)
		{
			if(dataNames[d]==name)
			{
				data=dataValues[d];
				return(true);
			}
		}
	}
	
	return(false);
}

uint GetPersonalData(PDataType type,uint id,array<string>&outNames,array<array<uint8>>&outValues)
{
	uint count=0;
	array<uint8>dataRaw;
	
	if(IsPData(type,id)&&GetPData(type,id,dataRaw))
	{
		array<string>dataNames;
		array<array<uint8>>dataValues;
		
		Buffer@buffer=NewBuffer(dataRaw);
		buffer>>dataNames>>dataValues;
		
		if(dataNames.length()==0||dataValues.length()==0)
		return(0);
		if(dataNames.length()!=dataValues.length())
		return(0);
		
		for(uint d=0,dLen=dataNames.length();d<dLen;d++)
		{
			outNames.insertLast(dataNames[d]);
			outValues.insertLast(dataValues[d]);
			count++;
		}
	}
	
	return(count);
}

bool SetPersonalData(PDataType type,uint id,string&name,array<uint8>&value)
{
	array<uint8>dataRaw;
	array<string>dataNames;
	array<array<uint8>>dataValues;
	
	Buffer@buffer=null;
	
	bool added=false;
	
	if(IsPData(type,id)&&GetPData(type,id,dataRaw))
	{
		@buffer=NewBuffer(dataRaw);
		buffer>>dataNames>>dataValues;
		
		if(dataNames.length()==0||dataValues.length()==0)
		return(false);
		if(dataNames.length()!=dataValues.length())
		return(false);
		
		for(uint d=0,dLen=dataNames.length();d<dLen;d++)
		{
			if(dataNames[d]==name)
			{
				dataValues[d]=value;
				added=true;
				break;
			}
		}
	}
	
	if(!added)
	{
		dataNames.insertLast(name);
		dataValues.insertLast(value);
	}
	
	@buffer=NewBuffer();
	buffer<<dataNames<<dataValues;
	
	return(SetPData(type,id,buffer.AsUint8()));
}

bool UnsetPersonalData(PDataType type,uint id,string&name)
{
	array<uint8>dataRaw;
	
	if(IsPData(type,id)&&GetPData(type,id,dataRaw))
	{
		array<string>dataNames;
		array<array<uint8>>dataValues;
		
		Buffer@buffer=NewBuffer(dataRaw);
		buffer>>dataNames>>dataValues;
		
		if(dataNames.length()==0||dataValues.length()==0)
		return(false);
		if(dataNames.length()!=dataValues.length())
		return(false);
		
		for(uint d=0,dLen=dataNames.length();d<dLen;d++)
		{
			if(dataNames[d]==name)
			{
				dataNames.removeAt(d);
				dataValues.removeAt(d);
				break;
			}
		}
		
		if(dataNames.length()==0||dataValues.length()==0)
		{
			UnsetPData(type,id);
			
			return(true);
		}
		
		@buffer=NewBuffer();
		buffer<<dataNames<<dataValues;
		
		return(SetPData(type,id,buffer.AsUint8()));
	}
	
	return(false);
}

bool PersonalDataAllowed(Item&item)
{
	if(item.IsStackable())
	{
		WLog("utils","[PersonalData] Stackable items not supported",10);
		PrintCallstack();
		return(false);
	}
	
	return(true);
}

bool IsPersonalData(Location&location,string&name)
{
	return(IsPersonalData(PDataLoc,location.Id,name));
}

bool GetPersonalData(Location&location,string&name,array<uint8>&value)
{
	return(GetPersonalData(PDataLoc,location.Id,name,value));
}

uint GetPersonalData(Location&location,array<string>&names,array<array<uint8>>&values)
{
	return(GetPersonalData(PDataLoc,location.Id,names,values));
}

bool SetPersonalData(Location&location,string&name,array<uint8>&value)
{
	return(SetPersonalData(PDataLoc,location.Id,name,value));
}

bool UnsetPersonalData(Location&location,string&name)
{
	return(UnsetPersonalData(PDataLoc,location.Id,name));
}

bool IsPersonalData(Map&map,string&name)
{
	return(IsPersonalData(PDataMap,map.Id,name));
}

bool GetPersonalData(Map&map,string&name,array<uint8>&value)
{
	return(GetPersonalData(PDataMap,map.Id,name,value));
}

uint GetPersonalData(Map&map,array<string>&names,array<array<uint8>>&values)
{
	return(GetPersonalData(PDataMap,map.Id,names,values));
}

bool SetPersonalData(Map&map,string&name,array<uint8>&value)
{
	return(SetPersonalData(PDataMap,map.Id,name,value));
}

bool UnsetPersonalData(Map&map,string&name)
{
	return(UnsetPersonalData(PDataMap,map.Id,name));
}

bool IsPersonalData(Critter&critter,string&name)
{
	return(IsPersonalData(PDataCr,critter.Id,name));
}

bool GetPersonalData(Critter&critter,string&name,array<uint8>&value)
{
	return(GetPersonalData(PDataCr,critter.Id,name,value));
}

uint GetPersonalData(Critter&critter,array<string>&names,array<array<uint8>>&values)
{
	return(GetPersonalData(PDataCr,critter.Id,names,values));
}

bool SetPersonalData(Critter&critter,string&name,array<uint8>&value)
{
	return(SetPersonalData(PDataCr,critter.Id,name,value));
}

bool UnsetPersonalData(Critter&critter,string&name)
{
	return(UnsetPersonalData(PDataCr,critter.Id,name));
}

bool IsPersonalData(Item&item,string&name)
{
	if(!PersonalDataAllowed(item))
	return(false);
	
	return(IsPersonalData(PDataIt,item.Id,name));
}

bool GetPersonalData(Item&item,string&name,array<uint8>&value)
{
	if(!PersonalDataAllowed(item))
	return(false);
	
	return(GetPersonalData(PDataIt,item.Id,name,value));
}

uint GetPersonalData(Item&item,array<string>&names,array<array<uint8>>&values)
{
	if(!PersonalDataAllowed(item))
	return(0);
	
	return(GetPersonalData(PDataIt,item.Id,names,values));
}

bool SetPersonalData(Item&item,string&name,array<uint8>&value)
{
	if(!PersonalDataAllowed(item))
	return(false);
	
	return(SetPersonalData(PDataIt,item.Id,name,value));
}

bool UnsetPersonalData(Item&item,string&name)
{
	if(!PersonalDataAllowed(item))
	return(false);
	
	return(UnsetPersonalData(PDataIt,item.Id,name));
}

bool FindPreferredGridApprox(Map&map,uint16&hx,uint16&hy)
{
	if(map.FindNearestGridApprox(hx,hy,true))
	return true;
	return map.FindNearestGridApprox(hx,hy,false);
}                                         

bool LocationHasCritters(Location&loc,uint findType)
{
	array<Map@>maps;
	uint num=loc.GetMaps(maps);
	array<Critter@>critters;
	for(uint i=0;i<num;i++)
	{
		if(maps[i].GetCritters(0,findType,critters)>0)
		{
			return true;
		}
	}
	return false;
}  

uint LocationGetCritters(Location&loc,uint findType,array<Critter@>@critters)
{
	array<Map@>maps;
	uint num=loc.GetMaps(maps);
	for(uint i=0;i<num;i++)
	{
		maps[i].GetCritters(0,findType,critters);
	}
	return critters.length();
}  

uint LocationGetPlayersAndFollowers(Location&loc,uint findType,array<Critter@>@critters)
{
	array<Map@>maps;
	uint num=loc.GetMaps(maps);
	for(uint i=0;i<num;i++)
	{
		maps[i].GetCritters(0,(0x10)|findType,critters);
	}
	
	array<Critter@>npcs;
	for(uint i=0;i<num;i++)
	{
		maps[i].GetCritters(0,(0x20)|findType,npcs);
	}
	
	for(uint i=0;i<npcs.length();i++)
	{
		if((((npcs[i].Param[(534)]&((0x00000020)))!=0))&&npcs[i].FollowerVarBase[(933)]!=0)
		{
			uint16 addfollower=critters.length()+1;
			critters.resize(addfollower);
			@critters[addfollower-1]=GetCritter(npcs[i].Id);
		}
	}
	
	return critters.length();
}  

uint MapGetPlayersAndFollowers(Map&map,uint findType,array<Critter@>@critters)
{
	map.GetCritters(0,(0x10)|findType,critters);
	
	array<Critter@>npcs;
	map.GetCritters(0,(0x20)|findType,npcs);
	
	for(uint i=0;i<npcs.length();i++)
	{
		if((((npcs[i].Param[(534)]&((0x00000020)))!=0))&&npcs[i].FollowerVarBase[(933)]!=0)
		{
			uint16 addfollower=critters.length()+1;
			critters.resize(addfollower);
			@critters[addfollower-1]=GetCritter(npcs[i].Id);
		}
	}
	
	return critters.length();
}  

uint CritterGetPlayersAndFollowers(Critter&critter,bool lookOnMe,uint findType,array<Critter@>@critters)
{
	critter.GetCritters(lookOnMe,(0x10)|findType,critters);
	
	array<Critter@>npcs;
	critter.GetCritters(lookOnMe,(0x20)|findType,npcs);
	
	for(uint i=0;i<npcs.length();i++)
	{
		if((((npcs[i].Param[(534)]&((0x00000020)))!=0))&&npcs[i].FollowerVarBase[(933)]!=0)
		{
			uint16 addfollower=critters.length()+1;
			critters.resize(addfollower);
			@critters[addfollower-1]=GetCritter(npcs[i].Id);
		}
	}
	
	return critters.length();
}   

bool LocationHasItems(Location&loc,uint16 protoId)
{
	array<Map@>maps;
	uint num=loc.GetMaps(maps);
	array<Item@>items;
	for(uint i=0;i<num;i++)
	{
		if(maps[i].GetItems(protoId,items)>0)
		{
			return true;
		}
	}
	return false;
}  

uint LocationGetItems(Location&loc,uint16 protoId,array<Item@>@items)
{
	array<Map@>maps;
	uint num=loc.GetMaps(maps);
	for(uint i=0;i<num;i++)
	{
		maps[i].GetItems(protoId,items);
	}
	return items.length();
}  

void LocationDeleteItems(Location&loc,uint16 protoId)
{
	array<Item@>items;
	LocationGetItems(loc,protoId,items);
	DeleteItems(items);
}     

bool IsDisposableEncounter(Location@loc)
{
	if((@loc!=null)&&loc.IsEncounter()&&loc.GeckCount==0)
	{
		return(!LocationHasCritters(loc,(0x10)|(0x0F)));
	}
	return false;
}

string IntToIp(int d)
{
	int v1=d&0xff;
	int v2=(d>>8)&0xff;
	int v3=(d>>16)&0xff;
	int v4=(d>>24);
	return v1+"."+v2+"."+v3+"."+v4;
}  

bool IsT4Item(Item&item)
{
	if(item.GetProtoId()==(721)||item.GetProtoId()==(25600)||item.GetProtoId()==(25598)||item.GetProtoId()==(25599)||item.GetProtoId()==(735)||
	item.GetProtoId()==(736)||item.GetProtoId()==(737)||item.GetProtoId()==(391)||
	item.GetProtoId()==(3)||item.GetProtoId()==(232)||item.GetProtoId()==(352)||
	item.GetProtoId()==(348)||item.GetProtoId()==(349)||
	item.GetProtoId()==(394)||item.GetProtoId()==(392)||
	item.GetProtoId()==(395)||item.GetProtoId()==(350)||
	item.GetProtoId()==(120)||item.GetProtoId()==(233)||
	item.GetProtoId()==(397)||
	item.GetProtoId()==(25452)||item.GetProtoId()==(25445)||item.GetProtoId()==(77)||item.GetProtoId()==(411)||item.GetProtoId()==(22120)||item.GetProtoId()==(610)||item.GetProtoId()==(25569))
	return true;
	else
	return false;
}

bool IsT3Item(Item&item)
{
	if(item.GetProtoId()==(726)||item.GetProtoId()==(727)||
	item.GetProtoId()==(738)||item.GetProtoId()==(739)||
	item.GetProtoId()==(740)||item.GetProtoId()==(741)||
	item.GetProtoId()==(239)||item.GetProtoId()==(381)||
	item.GetProtoId()==(752)||item.GetProtoId()==(9654)||item.GetProtoId()==(389)||
	item.GetProtoId()==(28)||
	item.GetProtoId()==(761))
	return true;
	else
	return false;
}   

uint16 AddT3Item()
{
	uint16 itempid;
	switch(Random(1,34))
	{
		case 1:itempid=(241);break;
		case 2:itempid=(353);break;
		case 3:itempid=(268);break;
		case 4:itempid=(354);break;
		case 5:itempid=(296);break;
		case 6:itempid=(13);break;
		case 7:itempid=(389);break;
		case 8:itempid=(355);break;
		case 9:itempid=(15);break;
		case 10:itempid=(28);break;
		
		case 11:itempid=(22095);break;
		case 12:itempid=(240);break;
		case 13:itempid=(25566);break;
		case 14:itempid=(381);break;
		case 15:itempid=(239);break;
		case 16:itempid=(9654);break;
		
		case 17:itempid=(752);break;
		
		case 18:itempid=(25567);break;
		
		case 19:itempid=(778);break;
		
		case 20:itempid=(407);break;
		case 21:itempid=(396);break;
		case 22:itempid=(524);break;  
		
		case 23:itempid=(25551);break;
		case 24:itempid=(25550);break;
		case 25:itempid=(761);break;
		case 26:itempid=(25547);break;
		case 27:itempid=(25549);break;
		case 28:itempid=(25582);break;
		case 29:itempid=(402);break;
		case 30:itempid=(406);break;
		case 31:itempid=(388);break;
		case 32:itempid=(1217);break;
		case 33:itempid=(27228);break;
		case 34:itempid=(27227);break;
	}
	
	return itempid;
}

uint16 AddT4Item()
{
	uint16 itempid;
	switch(Random(1,38))
	{
		case 1:itempid=(25476);break;
		case 2:itempid=(25477);break;
		case 3:itempid=(25478);break;
		case 4:itempid=(25479);break;
		case 5:itempid=(25480);break;
		case 6:itempid=(25481);break;
		case 7:itempid=(25482);break;
		case 8:itempid=(25483);break;
		case 9:itempid=(25484);break;
		case 10:itempid=(25485);break;
		case 11:itempid=(25486);break;
		case 12:itempid=(25487);break;
		case 13:itempid=(25488);break;
		
		case 14:itempid=(22072);break;
		case 15:itempid=(22073);break;
		case 16:itempid=(22074);break;
		case 17:itempid=(22075);break;
		
		case 18:itempid=(22076);break;
		case 19:itempid=(22077);break;
		case 20:itempid=(22078);break;
		case 21:itempid=(22079);break;
		case 22:itempid=(22080);break;
		case 23:itempid=(22081);break;
		
		case 24:itempid=(22082);break;
		case 25:itempid=(22083);break;
		case 26:itempid=(22084);break;
		case 27:itempid=(22085);break;
		
		case 28:itempid=(22086);break;
		case 29:itempid=(22087);break;
		case 30:itempid=(22088);break;
		case 31:itempid=(22089);break;
		case 32:itempid=(22090);break;
		case 33:itempid=(22091);break;
		
		case 34:itempid=(22092);break;
		case 35:itempid=(22093);break;
		case 36:itempid=(22094);break;
		case 37:itempid=(25572);break;
		case 38:itempid=(25587);break;
	}
	
	return itempid;
}

uint16 AddImplant()
{
	uint16 itempid;
	switch(Random(1,64))
	{
		case 1:itempid=(22054);break;
		case 2:itempid=(22055);break;
		case 3:itempid=(22056);break;
		case 4:itempid=(22057);break;
		case 5:itempid=(22058);break;
		case 6:itempid=(22059);break;
		case 7:itempid=(22060);break;
		case 8:itempid=(22054);break;
		case 9:itempid=(22055);break;
		case 10:itempid=(22056);break;
		case 11:itempid=(22057);break;
		case 12:itempid=(22058);break;
		case 13:itempid=(22059);break;
		case 14:itempid=(22060);break;
		case 15:itempid=(22054);break;
		case 16:itempid=(22055);break;
		case 17:itempid=(22056);break;
		case 18:itempid=(22057);break;
		case 19:itempid=(22058);break;
		case 20:itempid=(22059);break;
		case 21:itempid=(22060);break;
		case 22:itempid=(22054);break;
		case 23:itempid=(22055);break;
		case 24:itempid=(22056);break;
		case 25:itempid=(22057);break;
		case 26:itempid=(22058);break;
		case 27:itempid=(22059);break;
		case 28:itempid=(22060);break;
		case 29:itempid=(22054);break;
		case 30:itempid=(22055);break;
		case 41:itempid=(22056);break;
		case 42:itempid=(22057);break;
		case 43:itempid=(22058);break;
		case 44:itempid=(22059);break;
		case 45:itempid=(22060);break;
		case 46:itempid=(22054);break;
		case 47:itempid=(22055);break;
		case 48:itempid=(22056);break;
		case 49:itempid=(22057);break;
		case 50:itempid=(22058);break;
		case 51:itempid=(22059);break;
		case 52:itempid=(22060);break;
		case 53:itempid=(22054);break;
		case 54:itempid=(22055);break;
		case 55:itempid=(22056);break;
		case 56:itempid=(22057);break;
		case 57:itempid=(22058);break;
		case 58:itempid=(22059);break;
		case 59:itempid=(22060);break;
		case 60:itempid=(22054);break;
		case 61:itempid=(22055);break;
		case 62:itempid=(22056);break;
		case 63:itempid=(22056);break;
		case 64:if(Random(1,500)==1)
		{
			switch(Random(1,8))
			{
				case 1:itempid=(22051);break;
				case 2:itempid=(22052);break;
				case 3:itempid=(22053);break;
				case 4:itempid=(25552);break;
				case 5:itempid=(25553);break;
				case 6:itempid=(25554);break;
				case 7:itempid=(25555);break;
				case 8:itempid=(25556);break;
			}
		}
		break; 
		
	}
	return itempid;
}

uint16 AddT4BP()
{
	uint16 itempid;
	switch(Random(1,37))
	{
		case 1:itempid=(9773);break;
		case 2:itempid=(9774);break;
		case 3:itempid=(9775);break;
		case 4:itempid=(9776);break;
		case 5:itempid=(9777);break;
		case 6:itempid=(9778);break;
		case 7:itempid=(9779);break;
		case 8:itempid=(9825);break;
		case 9:itempid=(9826);break;
		case 10:itempid=(9827);break;
		case 11:itempid=(9828);break;
		case 12:itempid=(9829);break;
		case 13:itempid=(9830);break;
		case 14:itempid=(9831);break;
		case 15:itempid=(9819);break;
		case 16:itempid=(9820);break;
		case 17:itempid=(9821);break;
		case 18:itempid=(9822);break;
		case 19:itempid=(9783);break;
		case 20:itempid=(9784);break;
		case 21:itempid=(9785);break;
		case 22:itempid=(9786);break;
		case 23:itempid=(9787);break;
		case 24:itempid=(9788);break;
		case 25:itempid=(9789);break;
		case 26:itempid=(9823);break;
		case 27:itempid=(9824);break;
		
		case 28:itempid=(9798);break;
		case 29:itempid=(9799);break;
		case 30:itempid=(9832);break;
		case 31:itempid=(9834);break;
		case 32:itempid=(9835);break;
		case 33:itempid=(9837);break;
		case 34:itempid=(9838);break;
		case 35:itempid=(9860);break;
		case 36:itempid=(9858);break;
		case 37:itempid=(9856);break;
		case 38:itempid=(9859);break;
	}
	
	return itempid;
}

uint16 AddRareAmmo()
{
	uint16 itempid;
	switch(Random(1,3))
	{
		case 1:itempid=(359);break;
		case 2:itempid=(358);break;
		case 3:itempid=(850);break;
	}
	
	return itempid;
}

uint16 AddTypicalAmmo()
{
	uint16 itempid;
	switch(Random(1,17))
	{
		case 1:itempid=(36);break;
		case 2:itempid=(363);break;
		case 3:itempid=(30);break;
		case 4:itempid=(33);break;
		case 5:itempid=(34);break;
		case 6:itempid=(95);break;
		
		case 7:itempid=(574);break;
		case 8:itempid=(575);break;
		case 9:itempid=(576);break;
		case 10:itempid=(621);break;
		case 11:itempid=(38);break;
		
		case 12:itempid=(39);break;
		case 13:itempid=(14);break;
		case 14:itempid=(37);break;
		case 15:itempid=(32);break;
		case 16:itempid=(382);break;
		case 17:itempid=(25583);break;
	}
	
	return itempid;
}

void SetDeterioration(Item&item)
{
	if(!(@item!=null))
	return;
	
	if(item.IsDeteriorable()&&!item.IsStackable()&&(item.GetType()==(1)||item.GetType()==(3)))
	{
		uint8 maxwear=Random(0,95);
		SetMinWear(item,maxwear);
		SetWear(item,Random(maxwear,95));
	}
}
void _door(Item&doors,bool firstTime)
{
	doors.Val7=9999999;
	doors.Val6=9999999;
}

void _door2(Item&doors,bool firstTime)
{
	doors.SetEvent((3),"_UseItemOnDoor");
	doors.SetEvent((4),"_UseSkillOnDoor");
	doors.Val7=9999999;
	doors.Val6=9999999;
}

bool _UseItemOnDoor(Item&item,Critter&crit,Item@usedItem)
{
	return true;
}

bool _UseSkillOnDoor(Item&item,Critter&crit,int skill)
{
	return true;
}
void warspawner(Item&item,bool firstTime)
{
	switch(item.Val0)
	{
		case 1:CreateTimeEvent(((__FullSecond)+(((Random(45,60))*__TimeMultiplier*60))),"e_Spawncaps",item.Id,false);break;
		case 2:CreateTimeEvent(((__FullSecond)+(((Random(45,60))*__TimeMultiplier*60))),"e_Spawndrugs",item.Id,false);break;
		case 3:CreateTimeEvent(((__FullSecond)+(((Random(45,60))*__TimeMultiplier*60))),"e_Spawnammo",item.Id,false);break;
		case 4:CreateTimeEvent(((__FullSecond)+(((Random(45,60))*__TimeMultiplier*60))),"e_Spawnores",item.Id,false);break;
		case 5:CreateTimeEvent(((__FullSecond)+(((Random(45,60))*__TimeMultiplier*60))),"e_Spawnjunk",item.Id,false);break;
	}
} 

uint e_Spawncaps(array<uint>@values)
{
	Item@item=GetItem(values[0]);
	if(!(@item!=null))
	return 0;
	item.AddItem((41),500,3500);
	
	return((60)*__TimeMultiplier*60);
}

uint e_Spawndrugs(array<uint>@values)
{
	Item@item=GetItem(values[0]);
	if(!(@item!=null))
	return 0;
	if(item.Val1>160)
	return 0;
	for(int k=0;k<Random(1,10);k++)
	{
		switch(Random(1,18))
		{
			case 1:{item.AddItem((48),1,20);break;}
			case 2:{item.AddItem((109),1,20);break;}
			case 3:{item.AddItem((144),1,20);break;}
			case 4:{item.AddItem((260),1,20);break;}
			case 5:{item.AddItem((106),1,20);break;}
			case 6:{item.AddItem((124),1,20);break;}
			case 7:{item.AddItem((125),1,20);break;}
			case 8:{item.AddItem((310),1,20);break;}
			case 9:{item.AddItem((311),1,20);break;}
			case 10:{item.AddItem((469),1,20);break;}
			case 11:{item.AddItem((53),1,20);break;}
			case 12:{item.AddItem((87),1,20);break;}
			case 13:{item.AddItem((110),1,20);break;}
			case 14:{item.AddItem((259),1,20);break;}
			case 15:{item.AddItem((25573),1,20);break;}
			case 16:{item.AddItem((25574),1,20);break;}
			case 17:{item.AddItem((25575),1,20);break;}
			case 18:{item.AddItem((273),1,20);break;}
		}
	}
	
	return((60)*__TimeMultiplier*60);
}

uint e_Spawnammo(array<uint>@values)
{
	Item@item=GetItem(values[0]);
	if(!(@item!=null))
	return 0;
	if(item.Val1>160)
	return 0;
	for(int k=0;k<Random(2,5);k++)
	{
		switch(Random(1,15))
		{
			case 1:{item.AddItem((36),500,3000);break;}
			case 2:{item.AddItem((363),300,1000);break;}
			case 3:{item.AddItem((30),250,1500);break;}
			case 4:{item.AddItem((34),150,900);break;}
			case 5:{item.AddItem((575),150,500);break;}
			case 6:{item.AddItem((621),20,70);break;}
			case 7:{item.AddItem((37),20,70);break;}
			case 8:{item.AddItem((382),20,70);break;}
			case 9:{item.AddItem((38),100,500);break;}
			case 10:{item.AddItem((39),100,500);break;}
			case 11:{item.AddItem((25568),20,70);break;}
			case 12:{item.AddItem((25570),5,30);break;}
			case 13:{item.AddItem((26),5,30);break;}
			case 14:{item.AddItem((25),5,30);break;}
			case 15:{item.AddItem((25583),1,5);break;}
		}
	}
	
	return((60)*__TimeMultiplier*60);
}

uint e_Spawnores(array<uint>@values)
{
	Item@item=GetItem(values[0]);
	if(!(@item!=null))
	return 0;
	if(item.Val1>160)
	return 0;
	for(int k=0;k<Random(2,3);k++)
	{
		switch(Random(1,4))
		{
			case 1:{item.AddItem((9633),10,30);break;}
			case 2:{item.AddItem((9634),10,30);break;}
			case 3:{item.AddItem((536),20,40);break;}
			case 4:{item.AddItem((537),20,40);break;}
		}
	}
	item.Val1+=1;
	
	return((60)*__TimeMultiplier*60);
}

uint e_Spawnojunk(array<uint>@values)
{
	Item@item=GetItem(values[0]);
	if(!(@item!=null))
	return 0;
	if(item.Val1>160)
	return 0;
	for(int k=0;k<Random(2,3);k++)
	{
		switch(Random(1,4))
		{
			case 1:{item.AddItem((286),10,30);break;}
			case 2:{item.AddItem((98),10,30);break;}
			case 3:{item.AddItem((278),20,40);break;}
			case 4:{item.AddItem((1824),20,40);break;}
		}
	}
	
	return((60)*__TimeMultiplier*60);
} 

uint CountTimeEvents(string&scriptName)
{
	return CountTimeEvents(scriptName,false);
}

uint CountTimeEvents(string&scriptName,bool ignoreValues)
{
	array<uint>nums=GetTimeEventsByNameExt(scriptName,ignoreValues);
	return nums.length();
}

uint CountTimeEvents(string&scriptName,uint withValue)
{
	array<uint>nums=GetTimeEventsByNameExt(scriptName,withValue);
	return nums.length();
}

uint CountTimeEvents(string&scriptName,int withValue)
{
	array<uint>nums=GetTimeEventsByNameExt(scriptName,withValue);
	return nums.length();
}
uint CountTimeEvents(string&scriptName,array<uint>@withValues)
{
	array<uint>nums=GetTimeEventsByNameExt(scriptName,withValues);
	return nums.length();
}

uint CountTimeEvents(string&scriptName,array<int>@withValues)
{
	array<uint>nums=GetTimeEventsByNameExt(scriptName,withValues);
	return nums.length();
}
uint EraseTimeEvents(string&scriptName)
{
	return EraseTimeEvents(scriptName,false);
}

uint EraseTimeEvents(string&scriptName,bool ignoreValues)
{
	array<uint>nums=GetTimeEventsByNameExt(scriptName,ignoreValues);
	
	for(uint i=0;i<nums.length();i++)
	{
		EraseTimeEvent(nums[i]);
	}
	
	return nums.length();
}

uint EraseTimeEvents(string&scriptName,uint withValue)
{
	array<uint>nums=GetTimeEventsByNameExt(scriptName,withValue);
	
	for(uint i=0;i<nums.length();i++)
	{
		EraseTimeEvent(nums[i]);
	}
	
	return nums.length();
}

uint EraseTimeEvents(string&scriptName,int withValue)
{
	array<uint>nums=GetTimeEventsByNameExt(scriptName,withValue);
	
	for(uint i=0;i<nums.length();i++)
	{
		EraseTimeEvent(nums[i]);
	}
	
	return nums.length();
}

uint EraseTimeEvents(string&scriptName,array<uint>@withValues)
{
	array<uint>nums=GetTimeEventsByNameExt(scriptName,withValues);
	
	for(uint i=0;i<nums.length();i++)
	{
		EraseTimeEvent(nums[i]);
	}
	
	return nums.length();
}

uint EraseTimeEvents(string&scriptName,array<int>@withValues)
{
	array<uint>nums=GetTimeEventsByNameExt(scriptName,withValues);
	
	for(uint i=0;i<nums.length();i++)
	{
		EraseTimeEvent(nums[i]);
	}
	
	return nums.length();
}
array<uint>@GetTimeEventsByNameExt(string&scriptName)
{
	return GetTimeEventsByNameExt(scriptName,false);
}

array<uint>@GetTimeEventsByNameExt(string&scriptName,bool ignoreValues)
{
	array<uint>nums;
	GetTimeEventsByName(scriptName,nums);
	
	for(int i=0,j=nums.length();i<j;i++)
	{
		uint duration=0;
		array<uint>values;
		if(!GetTimeEvent(nums[i],duration,values))
		{
			nums.removeAt(i);
			i--;j--;
			continue;
		}
		
		if(!ignoreValues)
		{
			if(values.length()>0)
			{
				nums.removeAt(i);
				i--;j--;
				continue;
			}
		}
	}
	
	return nums;
}

array<uint>@GetTimeEventsByNameExt(string&scriptName,uint withValue)
{
	array<uint>withValues={withValue};
	return GetTimeEventsByNameExt(scriptName,withValues);
}

array<uint>@GetTimeEventsByNameExt(string&scriptName,int withValue)
{
	array<int>withValues={withValue};
	return GetTimeEventsByNameExt(scriptName,withValues);
}
array<uint>@GetTimeEventsByNameExt(string&scriptName,array<uint>@withValues)
{
	array<uint>nums;
	GetTimeEventsByName(scriptName,nums);
	
	for(int i=0,j=nums.length();i<j;i++)
	{
		uint duration=0;
		array<uint>values;
		if(!GetTimeEvent(nums[i],duration,values))
		{
			nums.removeAt(i);
			i--;j--;
			continue;
		}
		
		if(values.length()==0)
		{
			nums.removeAt(i);
			i--;j--;
			continue;
		}
		
		if(values.length()!=withValues.length())
		{
			nums.removeAt(i);
			i--;j--;
			continue;
		}
		
		for(int8 k=0,l=values.length();k<l;k++)
		{
			if(values[k]!=withValues[k])
			{
				nums.removeAt(i);
				i--;j--;
				break;
			}
		}
	}
	
	return nums;
}

array<uint>@GetTimeEventsByNameExt(string&scriptName,array<int>@withValues)
{
	array<uint>nums;
	GetTimeEventsByName(scriptName,nums);
	
	for(int i=0,j=nums.length();i<j;i++)
	{
		uint duration=0;
		array<int>values;
		if(!GetTimeEvent(nums[i],duration,values))
		{
			nums.removeAt(i);
			i--;j--;
			continue;
		}
		
		if(values.length()==0)
		{
			nums.removeAt(i);
			i--;j--;
			continue;
		}
		
		if(values.length()!=withValues.length())
		{
			nums.removeAt(i);
			i--;j--;
			continue;
		}
		
		for(int8 k=0,l=values.length();k<l;k++)
		{
			if(values[k]!=withValues[k])
			{
				nums.removeAt(i);
				i--;j--;
				break;
			}
		}
	}
	
	return nums;
}
array<uint>@GetTimeEventsByPartValues(string&scriptName,array<uint>@partValues)
{
	array<uint>nums;
	GetTimeEventsByName(scriptName,nums);
	
	for(int i=0,j=nums.length();i<j;i++)
	{
		uint duration=0;
		array<uint>values;
		if(!GetTimeEvent(nums[i],duration,values))
		{
			nums.removeAt(i);
			i--;j--;
			continue;
		}
		
		if(values.length()==0)
		{
			nums.removeAt(i);
			i--;j--;
			continue;
		}
		
		if(values.length()<partValues.length())
		{
			nums.removeAt(i);
			i--;j--;
			continue;
		}
		
		for(int8 k=0,l=partValues.length();k<l;k++)
		{
			if(values[k]!=partValues[k])
			{
				nums.removeAt(i);
				i--;j--;
				break;
			}
		}
	}
	
	return nums;
}

array<uint>@GetTimeEventsByPartValues(string&scriptName,array<int>@partValues)
{
	array<uint>nums;
	GetTimeEventsByName(scriptName,nums);
	
	for(int i=0,j=nums.length();i<j;i++)
	{
		uint duration=0;
		array<int>values;
		if(!GetTimeEvent(nums[i],duration,values))
		{
			nums.removeAt(i);
			i--;j--;
			continue;
		}
		
		if(values.length()==0)
		{
			nums.removeAt(i);
			i--;j--;
			continue;
		}
		
		if(values.length()<partValues.length())
		{
			nums.removeAt(i);
			i--;j--;
			continue;
		}
		
		for(int8 k=0,l=partValues.length();k<l;k++)
		{
			if(values[k]!=partValues[k])
			{
				nums.removeAt(i);
				i--;j--;
				break;
			}
		}
	}
	
	return nums;
}                                                                                                                                                                                                                                                                                                                                                                                                                                              

import void _weapon_perk(Item&item,bool firstTime)from"item_level";
import void _armor_perk(Item&item,bool firstTime)from"item_level"; 

import void AddSpecialBonus(Item@it)from"item_bonus";

void init_high(Item&item,bool firstTime)
{
	
	CreateTimeEvent(((__FullSecond)+(((1)*__TimeMultiplier*60))),"e_SpawnHigh",item.Id,false);
}

void init_low(Item&item,bool firstTime)
{
	
	CreateTimeEvent(((__FullSecond)+(((1)*__TimeMultiplier*60))),"e_SpawnLow",item.Id,false);
}             

bool _UseRewardContainer(Item&item,Critter&crit,int skill)
{
	
	if((skill==-1)||(skill==(210)))
	{
		if(!isOnlyOneTeam(crit,item))
		{
			uint16 hexX=0;
			uint16 hexY=0;
			Map@map=item.GetMapPosition(hexX,hexY);
			map.SetText(hexX,hexY,((uint((0xFF<<24)|(((0xFF)&0xFF)<<16)|(((0xFF)&0xFF)<<8)|((0xFF)&0xFF)))),"Your team didn't win this battle yet.");
			return true;
		}
		
		if(isWeakPlayer(crit))
		{
			uint16 hexX=0;
			uint16 hexY=0;
			Map@map=item.GetMapPosition(hexX,hexY);
			map.SetText(hexX,hexY,((uint((0xFF<<24)|(((0xFF)&0xFF)<<16)|(((0xFF)&0xFF)<<8)|((0xFF)&0xFF)))),"You're too weak to open this locker.");
			return true;
		} 
		
		if((not((item.LockerCondition&(0x01))!=0)))
		{
			return false;
		}
	}
	return false;
}

bool isOnlyOneTeam(Critter&player,Item&locker,uint8 radius=40)
{
	uint16 lockerhexX1=0,lockerhexY1=0;
	locker.GetMapPosition(lockerhexX1,lockerhexY1);
	
	array<Critter@>crits;
	player.GetMap().GetCrittersHex(lockerhexX1,lockerhexY1,radius,(0x03),crits);
	for(uint8 i=0;i<crits.length();i++)
	if((crits[i].IsPlayer()||(((crits[i].Param[(534)]&((0x00000020)))!=0)))&&crits[i].Param[(106)]!=player.Param[(106)])
	return false;
	
	return true;
}

bool isWeakPlayer(Critter&player)
{
	return(((player.Param[(510)]==0||player.Param[(208)]<250))||player.Param[(77)]<18);
}

bool isInArmor(Critter&player)
{
	Item@armor=player.GetItem(0,(3));
	if(!(@armor!=null))return false;
	
	uint16 protoid=armor.GetProtoId();
	
	return protoid==(2)||protoid==(240)
	||protoid==(380)||protoid==(22095)
	||protoid==(17)||protoid==(239)
	||protoid==(381)||protoid==(752)
	||protoid==(3)||protoid==(232)
	||protoid==(348)||protoid==(349)
	||protoid==(9654)||protoid==(778);
}    

import uint tier3armor()from"item_pools";
import uint tier3helmet()from"item_pools";
import uint tier3weapon()from"item_pools";
import uint tier3alien()from"item_pools";
import uint tier3bp()from"item_pools";
import uint tier3drugs()from"item_pools";
import uint tier3ammo()from"item_pools";
import uint tierlowammo()from"item_pools";
import uint tier4parts()from"item_pools";
import uint tier4bp()from"item_pools";
import uint tier4item()from"item_pools";
import uint tier4ammo()from"item_pools";
import uint rareitem()from"item_pools";
import uint implant()from"item_pools";
import uint implant_combat()from"item_pools";
import uint verti_parts()from"item_pools";
import uint currency()from"item_pools";
import uint low_tier()from"item_pools";
import uint books()from"item_pools";
import uint mats()from"item_pools";
import uint misc()from"item_pools";
import void addbasemap(Critter&player)from"personal_base";
import void addbasemap(Item&con)from"personal_base";

import bool istier3armor(uint pid)from"item_pools";
import bool istier3helmet(uint pid)from"item_pools";
import bool istier3weapon(uint pid)from"item_pools";
import bool istier3bp(uint pid)from"item_pools";
import bool istier3drugs(uint pid)from"item_pools";
import bool istier3ammo(uint pid)from"item_pools";
import bool istierlowammo(uint pid)from"item_pools";
import bool istier4parts(uint pid)from"item_pools";
import bool istier4bp(uint pid)from"item_pools";
import bool istier4item(uint pid)from"item_pools";
import bool istier4ammo(uint pid)from"item_pools";
import bool israreitem(uint pid)from"item_pools";
import bool isimplant(uint pid)from"item_pools";
import bool isimplant_combat(uint pid)from"item_pools";
import bool isverti_parts(uint pid)from"item_pools";
import bool iscurrency(uint pid)from"item_pools";
import bool islow_tier(uint pid)from"item_pools";
import bool isHelmet(uint pid)from"item_pools";
uint e_SpawnHigh(array<uint>@values)
{
	float tier4ammochance=0;
	float tier4partschance=0;
	float tier4bpchance=0;
	float implantchance=0;
	float rarechance=0;
	float implant_combatchance=0;
	float verti_partschance=0;
	float addbasemapchance=0;
	float t4chance=0;
	
	switch(week_patch)
	{
		case 1:
		case 2:
		tier4ammochance=5;tier4partschance=10;tier4bpchance=0;implantchance=15;rarechance=25;
		implant_combatchance=0.3;verti_partschance=0;t4chance=0;addbasemapchance=50;break;
		
	}
	
	Item@item=GetItem(values[0]);
	if(!(@item!=null))
	return 0;
	ClearContainer(item);
	SpawnBuffItem(item,tier3armor());
	SpawnBuffItem(item,tier3helmet());
	SpawnBuffItem(item,tier3weapon());
	
	item.AddItem(tier3drugs(),Random(5,8),0);
	item.AddItem(tier3bp(),Random(5,8),0);
	
	if(dropchance(tier4ammochance*doubleloot))
	item.AddItem(tier4ammo(),Random(10,25),5);
	
	if(dropchance(rarechance*doubleloot))
	item.AddItem(rareitem(),1,0);
	
	if(dropchance(tier4partschance*doubleloot))
	item.AddItem(tier4parts(),1,0);
	
	if(dropchance(implantchance*doubleloot))
	item.AddItem(implant(),1,0);
	
	if(dropchance(implant_combatchance*doubleloot))
	item.AddItem(implant_combat(),1,0);
	if(dropchance(addbasemapchance*doubleloot))
	addbasemap(item);
	
	if(dropchance(tier4bpchance*doubleloot))
	item.AddItem(tier4bp(),1,0);
	
	if(dropchance(verti_partschance*doubleloot))
	item.AddItem(verti_parts(),1,0);
	if(dropchance(t4chance*doubleloot))
	item.AddItem(tier4item(),1,0);
	item.AddItem(currency(),Random(1,15000),0);
	item.AddItem((9935),Random(2,8),0);
	if((((item.LockerCondition)&((0x01)))!=0))LockerClose(item);    
	
	return((Random(90,150))*__TimeMultiplier*60);
} 

uint e_SpawnLow(array<uint>@values)
{   
	
	return 0;
} 

void SpawnBuffItem(Item&container,uint16 pid)
{
	Item@it=container.AddItem(pid,1,0);
	it.Val0=Random(1,300000);
	it.Update();
	if(it.GetType()==(3))
	_weapon_perk(it,false);
	
	if(it.GetType()==(1))
	_armor_perk(it,false);
}

