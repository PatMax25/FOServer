                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

int week_patch=1;
int doubleloot=1;
bool dropchance(float chance)
{
	if(chance==0)
	return false;
	if(Random(0,100)<chance)
	return true;
	
	return false;
	
}

bool can_tc_modoc=false;
bool can_tc_klamath=false;
bool can_tc_gecko=false;
bool can_tc_bh=false;
bool can_tc_redding=false;
bool can_tc_den=false;
bool can_tc_necro=false;
bool can_tc_reno=false;

uint when_tc_modoc=0;
uint when_tc_klamath=0;
uint when_tc_gecko=0;
uint when_tc_bh=0;
uint when_tc_redding=0;
uint when_tc_den=0;
uint when_tc_necro=0;
uint when_tc_reno=0;                    

uint __GetColor(int r,int g,int b,int a=0xFF)
{
	r=(((r)>(255))?(255):(((r)<(0))?(0):(r)));
	g=(((g)>(255))?(255):(((g)<(0))?(0):(g)));
	b=(((b)>(255))?(255):(((b)<(0))?(0):(b)));
	a=(((a)>(255))?(255):(((a)<(0))?(0):(a)));
	return(uint(((a)<<24)|(((r)&0xFF)<<16)|(((g)&0xFF)<<8)|((b)&0xFF)));
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                

import Location@GetLocationOf(Critter&critter)from"utils";
import string GetLocationName(uint locId)from"utils";
import string GetLocationName(Location@loc)from"utils";
import bool ReadPids(array<int>&out pids,bool removeinvalid)from"utils";
import void ReadDefines(string@fileName,dictionary&items,array<string>@defines)from"utils";
import bool ParseDefine(const string&in line,string&out spid,int&out id)from"utils";
import int SkipWhitespaces(const string&in str,int start)from"utils";
import int SkipNonWhitespaces(const string&in str,int start)from"utils";
import bool IsParameterTag(string&str)from"utils";
import string GetParameterString(array<string@>@arr,string&parameter)from"utils";
import int GetIndexOfString(array<string@>@arr,string&str)from"utils";
import string GetConcatenatedString(array<string@>@arr,uint startindex,int stopindex)from"utils";
import string GetConditionOfCritter(Critter@cr)from"utils";
import string GetExtConditionOfCritter(Critter@cr)from"utils";
import uint GetAllOnlinePlayers(array<Critter@>&out players)from"utils";
import uint GetAuthenticatedPlayers(array<Critter@>&out players)from"utils";
import uint GetAuthenticatedPlayers(array<Critter@>&out players,bool ignorePriviledges)from"utils";
import uint GetNumberOfPlayersOnline()from"utils";
import void SetTurnBasedAvailability(Location@loc)from"utils";
import bool IsGuarded(Map@map)from"utils";
import bool IsPublic(Map@map)from"utils";
import bool IsEncounterMap(Map@map)from"utils";
import bool IsTown(Map@map)from"utils";
import bool IsDungeon(Map@map)from"utils";
import bool IsBaseControl(Map@map)from"utils";

import uint GetMapType(Map@map)from"utils";
import void LockDoor(uint x,uint y,Map@map,uint complexity,uint lockid)from"utils";
import void UnlockDoor(uint x,uint y,Map@map)from"utils";
import void ClearContainer(Item@container)from"utils";
import void MoveItemsCritterToCont(Critter&crFrom,Item&contTo,uint specid)from"utils";
import string GetCritterInfo(Critter&cr)from"utils";
import bool AddExpTeam(Critter&critter,int xp)from"utils";
import void ClearEnemyStack(Critter&critter)from"utils";
import void ClearEnemyStacksOnMap(Map@map)from"utils";
import bool IsCurrentEnemy(Critter&cr,uint targetId)from"utils";
import string@GetSafePlayerName(uint id)from"utils";
import string GetSafePlayerName(uint id,string&onSuccess,string&onError)from"utils";
import IDateTime@GetCurrentDateTime()from"utils";
import string GetCurrentDateTimeString()from"utils";
import string GetCurrentDateTimeString(bool date,bool time)from"utils";
import Critter@GetMostSkilled(array<Critter@>@group,int skill)from"utils";
import string GetAuthString(Critter&player)from"utils";
import string GetAuthString(int accesslevel)from"utils";
import bool CanRequestHelp(Critter&player)from"utils";
import void SetRequestedHelp(Critter&player)from"utils";
import void SetRequestedHelp(Critter&player,int minutes)from"utils";
import Critter@GetOnlineGM()from"utils";
import void Preprocess(Critter&player,string&commandString)from"utils";
import bool IsHumanoid(Critter@cr)from"utils";
import uint GetGroupIndex(Critter&cr)from"utils";
import uint GetGroupIndex(int st)from"utils";
import void SetGroupIndex(Critter&cr,uint val)from"utils";
import uint GetGroupRank(Critter&cr)from"utils";
import void SetGroupRank(Critter&cr,uint val)from"utils";
import uint GetGroupMode(Critter&cr)from"utils";
import void SetGroupMode(Critter&cr,uint val)from"utils";
import void SetGroupInfo(Critter&cr,uint faction,uint rank,uint mode)from"utils";
import void SetGroupInfoPack(Critter&cr,uint packInfo)from"utils";
import void ClearEvents(Critter&cr)from"utils";

import int GetGvar(uint gvar)from"utils";
import void SetGvar(uint gvar,uint value)from"utils";
import int GetLLvar(Location&location,uint llvar)from"utils";
import int GetLLvar(uint locationId,uint llvar)from"utils";
import void SetLLvar(Location&location,uint llvar,uint value)from"utils";
import int GetLMvar(Map&map,uint llvar)from"utils";
import int GetLMvar(uint mapId,uint llvar)from"utils";
import void SetLMvar(Map&map,uint llvar,uint value)from"utils";
import int GetLIvar(Item&item,uint llvar)from"utils";
import int GetLIvar(uint itemId,uint llvar)from"utils";
import void SetLIvar(Item&item,uint llvar,uint value)from"utils";
import int GetLvar(Critter&critter,uint lvar)from"utils";
import int GetLvar(uint id,uint lvar)from"utils";
import void SetLvar(Critter&critter,uint lvar,uint value)from"utils";
import void SetLvar(uint id,uint lvar,uint value)from"utils";
import int GetUvar(uint uvar,uint key,uint index)from"utils";
import void SetUvar(uint uvar,uint key,uint index,uint value)from"utils";

import uint GetContainerValue(Item@container)from"utils";
import uint BaseItemValue(uint pid,bool ammo)from"utils";
import uint BaseItemValue(uint pid,uint broken,uint det,bool ammo)from"utils";
import uint BaseItemValue(Item@item)from"utils";
import uint BaseItemValue(Item@item,uint proc)from"utils";
import uint BaseSingleItemValue(Item@item)from"utils";
import uint BaseSingleItemValue(Item@item,uint proc)from"utils";

import void SetBloodType(Critter@cr)from"utils";
import string GetBloodType(Critter@cr)from"utils";
import string GetBloodRandom()from"utils";

import void LogCommandUsage(Critter&player,string&commandString)from"utils";
import void DropTimeouts(Critter&cr)from"utils";

import bool HasItem(Critter@cr,uint pid)from"utils";
import bool HasSomeWeapon(Critter@cr)from"utils";
import uint GetBestWeaponSkill(Critter@cr)from"utils";
import void GiveBag(uint bag,Critter@cr)from"utils";
import void SetQuestGarbager(uint time,uint playerid,uint locid,uint var,uint val)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,uint factionRank,uint factionMode,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,array<int>params,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,array<int>params,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,uint factionRank,uint factionMode,bool isMob,uint level)from"utils";
import void AddScore(Critter@cr,uint score,uint points)from"utils";

import bool ReloadWeapon(Critter&cr)from"utils";
import Item@GetRadio(Critter&cr)from"utils";
import Item@GetRepairTool(Critter&cr)from"utils";
import Item@GetEquippedItem(Critter&cr,uint Pid)from"utils";
import Item@GetEquippedItem(Critter&cr,array<uint>&Pids)from"utils";
import Item@GetEquippedItemByType(Critter&cr,uint ItemType)from"utils"; 

import bool SkillRoll(Critter@cr,int skill,int bonus)from"utils";
import int SkillCheck(Critter&cr,int skill,int skillused,Item@item,int bonus)from"utils";
import string SkillName(uint8 skill)from"utils";
import void ChangeCrTypeSafe(Critter&cr,uint8 crType)from"utils";

import bool Pickable(Item@item)from"utils";

import void TransferItemsToContOnMap(Critter&cr,Map@map,int entid,int contpid,int itemtypes)from"utils";
import void TransferItemsFromContOnMap(Critter&cr,Map@map,int entid,int contpid)from"utils";

import string IpToString(uint ip)from"utils";

import void VerboseAction(Critter&cr,string&text)from"utils";
import void VerboseAction(Critter&cr,Critter&target,string&text)from"utils";
import void VerboseExperience(Critter&cr,int xpDiff,int levelDiff)from"utils";

import void SetChosenActions(Critter&cr,array<int>&actions)from"utils";

import void HexLine(uint16 x0,uint16 y0,uint16 x1,uint16 y1,array<uint16>@xList,array<uint16>@yList)from"utils";
import void HexCircle(uint16 x0,uint16 y0,uint16 radius,array<uint16>@xList,array<uint16>@yList)from"utils";

import void StartPersonalDataCleanup()from"utils";

import bool IsPersonalData(Location&location,string&name)from"utils";
import bool GetPersonalData(Location&location,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Location&location,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Location&location,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Location&location,string&name)from"utils";

import bool IsPersonalData(Map&map,string&name)from"utils";
import bool GetPersonalData(Map&map,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Map&map,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Map&map,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Map&map,string&name)from"utils";

import bool IsPersonalData(Critter&critter,string&name)from"utils";
import bool GetPersonalData(Critter&critter,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Critter&critter,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Critter&critter,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Critter&critter,string&name)from"utils";

import bool IsPersonalData(Item&item,string&name)from"utils";
import bool GetPersonalData(Item&item,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Item&item,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Item&item,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Item&item,string&name)from"utils";

import bool FindPreferredGridApprox(Map&map,uint16&hx,uint16&hy)from"utils";           

import bool StrToInt(string@s,uint64&inout val)from"strtoint";
import bool StrToInt(string@s,uint&inout val)from"strtoint";
import bool StrToInt(string@s,uint16&inout val)from"strtoint";
import bool StrToInt(string@s,uint8&inout val)from"strtoint";
import bool StrToInt(string@s,int64&inout val)from"strtoint";
import bool StrToInt(string@s,int16&inout val)from"strtoint";
import bool StrToInt(string@s,int8&inout val)from"strtoint";    

import int FindInArray(array<int>&arr,int value)from"utils";
import int FindInArray(array<uint>&arr,uint value)from"utils";
import int FindInArray(array<uint16>&arr,uint16 value)from"utils";
import int FindInArray(array<uint8>&arr,uint8 value)from"utils";
import bool FindInArray(array<int>&arr,int id,int&index)from"utils";
import bool FindInArray(array<uint>&arr,uint id,int&index)from"utils";
import bool FindInArray(array<uint8>&arr,uint8 id,int&index)from"utils";
import int FindInArray(array<string>&arr,string&value)from"utils";
import int FindInArray(array<string@>@arr,string&value)from"utils";
import bool Present(int what,array<int>&where)from"utils";
import bool Present(uint what,array<uint>&where)from"utils";
import bool Present(uint16 what,array<uint16>&where)from"utils";
import bool Present(string&what,array<string>&where)from"utils";
import bool Present(string&what,array<string@>@where)from"utils";

import uint CreateLocationForGroup(Critter&player,uint16 pid,uint16 worldX,uint16 worldY,array<Critter@>&)from"utils";
import bool FindFirstFreeHex(Map@map,uint16&x,uint16&y,uint8 dir,uint16 maxSteps)from"utils";
import bool FindNearestFreeHex(Map&map,uint16&x,uint16&y,uint radius)from"utils";

import bool GetItemCoordinates(Item&item,uint&mapID,uint16&x,uint16&y)from"utils";
import bool ItemOnHex(uint16 pid,Map@map,uint16 x,uint16 y)from"utils";

import void PrintCallstack()from"utils";
import void PrintCallstack(int level)from"utils";

import bool LocationHasCritters(Location&loc,uint findType)from"utils";
import uint LocationGetCritters(Location&loc,uint findType,array<Critter@>@critters)from"utils";
import uint LocationGetPlayersAndFollowers(Location&loc,uint findType,array<Critter@>@critters)from"utils";
import uint MapGetPlayersAndFollowers(Map&map,uint findType,array<Critter@>@critters)from"utils";
import uint CritterGetPlayersAndFollowers(Critter&critter,bool lookOnMe,uint findType,array<Critter@>@critters)from"utils";
import bool LocationHasItems(Location&loc,uint16 protoId)from"utils";
import uint LocationGetItems(Location&loc,uint16 protoId,array<Item@>@items)from"utils";
import void LocationDeleteItems(Location&loc,uint16 protoId)from"utils";

import bool IsDisposableEncounter(Location@loc)from"utils";

import bool IsT4Item(Item&item)from"utils";
import bool IsT3Item(Item&item)from"utils";
import uint16 AddT3Item()from"utils";
import uint16 AddT4Item()from"utils";
import uint16 AddImplant()from"utils";
import uint16 AddT4BP()from"utils";
import uint16 AddRareAmmo()from"utils";
import uint16 AddTypicalAmmo()from"utils";

import void SetDeterioration(Item&item)from"utils";  

shared class CPosition
{
	uint x;
	uint y;
	uint dir;
};

shared interface IRect
{
	bool IsWithin(Critter&cr);
};

shared class Rect:IRect
{
	uint x1;
	uint y1;
	uint x2;
	uint y2;
	
	Rect(uint x1,uint y1,uint x2,uint y2)
	{
		this.x1=x1;
		this.y1=y1;
		this.x2=x2;
		this.y2=y2;
	}
	
	bool IsWithin(Critter&cr)
	{
		return((cr.HexX>=this.x1&&cr.HexX<=this.x2)&&(cr.HexY>=this.y1&&cr.HexY<=this.y2));
	}
};

shared interface IDateTime
{
	uint16 get_Year();
	uint16 get_Month();
	uint16 get_DayOfWeek();
	uint16 get_Day();
	uint16 get_Hour();
	uint16 get_Minute();
	uint16 get_Second();
	uint16 get_Milliseconds();
	string@ToString();
};                                                                                                                                                      

const string@FD_Result2String(int res)
{
	if(res==(0))
	return"FD_RESULT_SUCCESS";
	else if(res==(1))
	return"FD_RESULT_ALREADY_EXISTS";
	else if(res==(2))
	return"FD_RESULT_NOT_FOUND";
	else if(res==(3))
	return"FD_RESULT_ANY_DATA_ERROR";
	else if(res==(4))
	return"FD_RESULT_INVALID_ARGUMENT";
	else if(res==(5))
	return"FD_RESULT_LVAR_ERROR";
	else if(res==(6))
	return"FD_RESULT_DB_NOT_FOUND";
	else if(res==(7))
	return"FD_RESULT_DB_FULL";
	else if(res==(8))
	return"FD_RESULT_DB_EMPTY";
	else
	return"FD_Result: Unknown error code";
}      

import bool IsBigFaction(uint faction)from"factions";
import bool IsTheSameFaction(uint player1Id,uint player2Id)from"factions";
import void _Resign(uint playerId)from"factions"; 

import int RegisterFaction(uint id,const string@name,bool playerDriven)from"factions";
import int RegisterFaction(const string@name,bool playerDriven,uint&out id)from"factions";

import bool RemoveFaction(uint faction)from"factions"; 

import bool GetFactionNameStr(uint faction,string&out name)from"factions";
import bool GetFactionId(const string@name,uint&out id)from"factions"; 

import bool IsFactionNameFree(const string&)from"factions";
import bool IsFactionNameValid(const string&)from"factions";

import bool IsGang(uint faction)from"factions";

import uint16 GetFactionRadioChannel(uint faction)from"factions";
import void SetFactionRadioChannel(uint faction,uint16 channel)from"factions"; 

import int AddPlayer(uint faction,uint id)from"factions";
import int AddPlayer(uint faction,uint id,uint playerFaction)from"factions";
import int AddPlayer(uint faction,uint id,uint playerFaction,uint rank)from"factions";
import int AddPlayer(uint faction,uint id,uint playerFaction,uint rank,uint status)from"factions"; 

import int RemovePlayer(uint faction,uint id)from"factions"; 

import int GetFaction(uint faction,uint id)from"factions";
import int GetStatus(uint faction,uint id)from"factions";
import int GetRank(uint faction,uint id)from"factions";
import bool IsMember(uint faction,Critter&cr)from"factions";
import bool IsMemberOffline(uint faction,uint id)from"factions";
import bool StoredInDB(uint faction,uint id)from"factions";
import uint GetRecordsCount(uint faction)from"factions";
import uint GetMembersCount(uint faction)from"factions";
import uint GetMembers(uint faction,array<uint>&ids)from"factions";
import uint GetLeaderId(uint faction)from"factions";
import void SetLeaderId(uint faction,uint id)from"factions";
import uint GetClaimId(uint faction)from"factions";
import void SetClaimId(uint faction,uint id)from"factions";
import uint GetLeaderTime(uint faction)from"factions";
import void SetLeaderTime(uint faction,uint time)from"factions";
import uint GetClaimTime(uint faction)from"factions";
import void SetClaimTime(uint faction,uint time)from"factions";
import uint GetFactionLocationId(uint faction)from"factions";
import bool GetFactionLocation(uint faction,uint&out locId,uint&out pid,uint&out x,uint&out y)from"factions";

import void GetFactionLocationCoords(uint faction,uint&out x,uint&out y)from"factions";

import uint GetFactionScore(uint faction)from"factions";
import void ModifyFactionScore(uint faction,int amount)from"factions";
import void UpdateLastUsed(uint faction)from"factions";
import uint GetFactionsCount()from"factions"; 

import int GetPrevId(uint faction,uint currId,bool members,uint&out prevId)from"factions";
import int GetNextId(uint faction,uint currId,bool members,uint&out nextId)from"factions";
import int GetFirstId(uint faction,bool members,uint&out id)from"factions"; 

import int ModifyRank(uint faction,uint id,uint newRank)from"factions";
import int ModifyStatus(uint faction,uint id,uint newStatus)from"factions";
import int ModifyFaction(uint faction,uint id,uint newFaction)from"factions"; 

import int InvitePlayer(uint faction,uint playerId)from"factions";
import int ConfirmInvitation(uint faction,uint playerId)from"factions";
import int AddMember(uint faction,uint playerId)from"factions";
import int AddMember(uint faction,uint playerId,bool applyModifiers)from"factions";
import int ChangeRank(uint faction,uint playerId,uint newRank)from"factions";
import int ExpelMember(uint faction,uint playerId)from"factions";
import int ExpelMember(uint faction,uint playerId,bool applyModifiers)from"factions";

import uint GetPlayerFaction(uint playerId)from"factions";
import uint GetPlayerRank(uint playerId)from"factions"; 

import void AddFactionNews(uint faction,uint master,uint slave,uint type)from"factions";
import bool GetFactionNews(uint faction,uint index,uint&out master,uint&out slave,uint&out type,uint16&out year,uint8&out month,uint8&out day,uint8&out hour,uint8&out minute)from"factions";
import uint GetFactionNewsCount(uint faction)from"factions"; 

import uint CheckFactionBaseCoords(uint x,uint y)from"factions";

import bool SaveFactionData(uint faction)from"factions";
import bool FactionExists(uint faction)from"factions"; 

import uint GetFactionLog(uint faction,bool fullLog,array<string>&strings,uint begin,uint end)from"factions";   

import void InitFactions()from"factions";
import void UpdateFactionsInfo(Critter&cr)from"factions";
import IFaction@GetFaction(int)from"factions";
import IFaction@GetFaction(const string&)from"factions";
import IFaction@GetFactionByIdx(int idx)from"factions";
import void UpdateGroupVars(Critter&player)from"factions";     

shared interface IFaction
{
	int get_Id()const;
	string get_Name()const;
	int get_StringId()const;
	string get_Database()const;
	int get_UpdateSeq()const;
	void set_UpdateSeq(int);
	
	int GetStatus(int id)const;
	void SetStatus(int id,int status);
	int GetRank(int id)const;
	void SetRank(int id,int rank);
	void settag(int index,int tag,int r,int g,int b);
	int get_tag(int index);
	int get_b(int index);
	int get_r(int index);
	int get_g(int index);  
	
	int GetMembers(array<uint>&)const;
	int GetRecords(array<uint>&)const;  
	
	void AddKnownFaction(int);   
	
	int GetKnownFactions(array<int>&)const;
	void Remove();
};                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

shared interface IFactionBase
{
	
	uint get_Id()const;
	
	uint get_FactionId()const;
	
	const string&get_Name()const;
	
	uint get_LocationId()const; 
	
	void Show(Critter&cr)const;
	
	void Hide(Critter&cr)const; 
	
	bool IsRankAllowed(int rank)const;
	
	void AllowRank(int rank,bool allow);
	
	bool IsStatusAllowed(int status)const;
	
	void AllowStatus(int status,bool allow); 
	
	void Remove();
};  

import IFactionBase@GetFactionBase(uint faction_id,const string&faction_name)from"factions_bases";
import IFactionBase@GetFactionBase(uint id)from"factions_bases";
import IFactionBase@GetFactionBaseByLocId(uint id)from"factions_bases";
import uint GetFactionBases(uint faction_id,array<IFactionBase@>@)from"factions_bases";
import bool AddFactionBase(IFactionBase&)from"factions_bases";
import void AddFactionBase(uint)from"factions_bases";
import IFactionBase@CreateFactionBase(uint faction_id,const string&name,uint location_id)from"factions_bases";
import void RemoveFactionBase(uint,const string&)from"factions_bases";
import void RemoveFactionBase(IFactionBase&)from"factions_bases";                                                                                                                                                        

int GetRootMapData(Map&map,uint index)
{
	return map.GetLocation().GetMapByIndex(0).GetData(index);
}  

void SetRootMapData(Map&map,uint index,int val)
{
	map.GetLocation().GetMapByIndex(0).SetData(index,val);
}   

int GetRootMapData(Location&loc,uint index)
{
	return loc.GetMapByIndex(0).GetData(index);
}  

void SetRootMapData(Location&loc,uint index,int val)
{
	loc.GetMapByIndex(0).SetData(index,val);
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

import void InitLogs()from"logging";
import void FLog(uint logindex,string&text)from"logging";
import void ILog(string&section,string&text)from"logging";
import void GMLog(Critter&cr,string&text)from"logging";
import void CloseLogs()from"logging";
import uint AddLog(string&filename)from"logging";
import uint AddLog(string&filename,uint index)from"logging";                                                         

import void WLog(string&type,string&message)from"debug";
import void WLog(string&type,string&message,int level)from"debug";
import void InitDebug()from"debug";          

import void InitEconomy()from"economy";
import void SendLevelThresholds(Critter&)from"economy"; 

import bool BankAccountExists(uint bankid,uint account)from"economy";
import bool BankAccountRemoveMoney(uint bankid,uint account,uint amount)from"economy";
import bool BankHasAccess(uint bankid,uint account,uint playerid)from"economy";
import int BankGetAccountBalance(uint bankid,uint account)from"economy";
import int BankGetAccountID(uint bankid,uint playerid)from"economy";
import uint BankAddAccess(uint bankid,uint account,uint playerid)from"economy";
import uint BankCreateAccount(uint bankid,uint playerid)from"economy";
import uint BankDepositMoney(uint bankid,uint playerid,uint account,int amount)from"economy";
import uint BankGetAccessCount(uint bankid,uint account)from"economy";
import uint BankGetAccountOwner(uint bankid,uint account)from"economy";
import uint BankGetAccountType(uint bankid,uint account)from"economy";
import uint BankGetCreditRating(uint bankid,uint account)from"economy";
import uint BankGetLoan(uint bankid,uint account)from"economy";
import uint BankRemoveAccess(uint bankid,uint account,uint playerid)from"economy";
import uint BankSetAccountType(uint bankid,uint account,uint accounttype)from"economy";
import uint BankSetCreditRating(uint bankid,uint account,uint rating)from"economy";
import uint BankSetLoan(uint bankid,uint account,uint loan)from"economy";
import uint BankTakeLoan(uint bankid,uint account,uint amount)from"economy";
import uint BankTransferMoney(uint bankid,uint fromaccount,uint toaccount,uint amount)from"economy";
import uint BankWithdrawMoney(uint bankid,uint playerid,uint account,int amount)from"economy"; 

import bool BanksTransferFromCritter(Critter&critter,uint amount,uint type,bool virtual)from"economy";
import bool BanksTransferToCritter(Critter&critter,uint amount,uint type,bool virtual)from"economy";
import uint BanksGetTotalMoney()from"economy";
import void BanksAddMoney(uint amount)from"economy";
import void BanksRemoveMoney(uint amount)from"economy"; 

import bool BankAddMoney(uint bankid,uint amount)from"economy";
import bool BankRemoveMoney(uint bankid,uint amount)from"economy";
import bool BankSetMoney(uint bankid,uint amount)from"economy";
import uint BankGetLoanInterest(uint bankid)from"economy";
import uint BankGetNumberOfAccounts(uint bankid)from"economy";
import float BankGetSaveInterest(uint bankid)from"economy";
import uint BankGetTotalMoney(uint bankid)from"economy";
import uint BankGetTotalBalance(uint bankid)from"economy";
import float BankGetReserveRatio(uint bankid)from"economy";
import uint BankSetLoanInterest(uint bankid,uint interest)from"economy";
import uint BankSetSaveInterest(uint bankid,float interest)from"economy";
import bool BankTransferFromCritter(uint bankId,Critter&critter,uint amount,uint type,bool virtual)from"economy";

import void SaveBankData()from"economy";   

import int GetItemSellModifier(Critter&player,Critter&trader)from"economy";
import int GetItemBuyModifier(Critter&player,Critter&trader)from"economy";
import uint GetItemCost(Item&item,Critter&cr,Critter&trader,bool sell)from"economy";
import uint GetItemCostPlain(Item&item,Critter&cr,Critter&trader)from"economy";

import array<int>GetTraderLevels(Critter@npc)from"economy";
import uint GetTraderLevel(Critter@npc,uint type)from"economy";

import uint ItemLevel(Item&item)from"economy";
import uint ItemLevel(uint pid)from"economy";
import uint TraderCapacity(Critter@npc)from"economy";
import uint TraderCapacity(Critter@npc,uint type,uint level)from"economy";
import uint TraderMoneyCapacity(Critter@npc)from"economy";
import uint TradingItemType(Item&item)from"economy";
import uint TradingItemType(uint pid)from"economy";                                                                                                          

const string@FD_Bank_Result2String(uint res)
{
	if(res==(1))
	return"FD_BANK_RESULT_SUCCESS";
	else if(res==(2))
	return"FD_BANK_RESULT_UNKNOWN";
	else if(res==(3))
	return"FD_BANK_RESULT_TOO_MANY_ACCOUNTS";
	else if(res==(4))
	return"FD_BANK_RESULT_ALREADY_HAS_ACCOUNT";
	else if(res==(5))
	return"FD_BANK_RESULT_NOT_ENOUGH_MONEY";
	else if(res==(6))
	return"FD_BANK_RESULT_BANK_FULL";
	else if(res==(7))
	return"FD_BANK_RESULT_BANK_EMPTY";
	else if(res==(8))
	return"FD_BANK_RESULT_DATA_ERROR";
	else if(res==(9))
	return"FD_BANK_RESULT_INVALID_PLAYER";
	else if(res==(10))
	return"FD_BANK_RESULT_NO_ACCOUNT";
	else
	return"FD_Result: Unknown error code";
}                                                                                                                                                                                                                                                                                                                                                                                                                                               

void _InitLightItem(Item&item,bool firstTime)
{
	item.LightColor=item.Val0;
	item.LightIntensity=item.Val4>0?int8(item.Val1):0;
	item.LightDistance=item.Val2;
	item.Update();
}                                                       

void SwitchGroupLights(Map&map,int groupId,bool on)
{
	array<Item@>lights;
	map.GetItems((20015),lights);
	
	if(lights.length()>0)
	{
		for(uint i=0,j=lights.length();i<j;i++)
		{
			if(lights[i].Val3==groupId)
			{
				on?lights[i].LightIntensity=int8(lights[i].Val1):lights[i].LightIntensity=0;
				lights[i].Update();
			}
		}
	}
}
void forcelights(Critter&cr,int groupId,int on,int nono)
{
	array<Item@>lights;
	cr.GetMap().GetItems((20015),lights);
	bool turnOn=false;
	if(on>0)
	turnOn=true;
	if(lights.length()>0)
	{
		for(uint i=0,j=lights.length();i<j;i++)
		{
			if(lights[i].Val3==groupId)
			{
				turnOn?lights[i].LightIntensity=int8(lights[i].Val1):lights[i].LightIntensity=0;
				lights[i].Update();
			}
		}
	}
}

void changelights(Critter&cr,int groupId,int paramId,int paramVal)
{
	array<Item@>lights;
	cr.GetMap().GetItems((20015),lights);
	
	if(lights.length()>0)
	{
		for(uint i=0,j=lights.length();i<j;i++)
		{
			if(lights[i].Val3==groupId)
			{
				switch(paramId)
				{
					case(0):
					lights[i].LightColor=paramVal;
					lights[i].Update();
					break;
					case(1):
					lights[i].LightIntensity=int8(paramVal);
					lights[i].Update();
					break;
					case(2):
					lights[i].LightDistance=paramVal;
					lights[i].Update();
					break;
					case(3):
					lights[i].LightColor=lights[i].Val0;
					lights[i].LightIntensity=int8(lights[i].Val1);
					lights[i].LightDistance=lights[i].Val2;
					lights[i].Update();
					break;
				}
			}
		}
	}
} 

void ChangeGroupLightsParam(Map&map,int groupId,int paramId,int paramVal)
{
	array<Item@>lights;
	map.GetItems((20015),lights);
	
	if(lights.length()>0)
	{
		for(uint i=0,j=lights.length();i<j;i++)
		{
			if(lights[i].Val3==groupId)
			{
				switch(paramId)
				{
					case(0):
					lights[i].LightColor=paramVal;
					lights[i].Update();
					break;
					case(1):
					lights[i].LightIntensity=int8(paramVal);
					lights[i].Update();
					break;
					case(2):
					lights[i].LightDistance=paramVal;
					lights[i].Update();
					break;
					case(3):
					lights[i].LightColor=lights[i].Val0;
					lights[i].LightIntensity=int8(lights[i].Val1);
					lights[i].LightDistance=lights[i].Val2;
					lights[i].Update();
					break;
				}
			}
		}
	}
}                                                                                             

shared interface IBroadcastBuffer
{
	string GetString();
	
	void SetType(int type);
	int GetType();
	void SetTime(int time);
	int GetTime();
	void SetSetup(int setup);
	int GetSetup();
	void SetMessage(string message);
	void AppendMessage(string message);
	string GetMessage();
	void SetData(array<int>data);
	
	void SetStart(int time);
	void ResetStart();
	
	void SetLifetime(int lifetime);
	
	void SetFilters(int filters);
	void SetFilter(int filter);
	void SetFilter(int filter,int data);
	void UnsetFilter(int filter);
	bool Filter(int filter);
	bool CheckFilters(Critter@player);
	
	bool Send(Critter@player);
	uint SendToAll();
	
	void SetGM(int id);
	void UnsetGM();
	
	void ToDelete();
};  

import void UpdateBroadcast()from"broadcast";

import IBroadcastBuffer@AddBroadcastBuffer(int type,int time,int setup,string&message,array<int>&data,int lifetime,int flags)from"broadcast";
import void DumpBroadcastBuffer(Critter@player)from"broadcast";
import uint FindBroadcastBufferByType(int type,array<IBroadcastBuffer@>&buf)from"broadcast";
import uint FindBroadcastBufferByGM(int id,array<IBroadcastBuffer@>&buf)from"broadcast"; 

import IBroadcastBuffer@Broadcast_Message(string&message,int time,int filters,bool send)from"broadcast";
import IBroadcastBuffer@Broadcast_Message(string&message,int time,int filters)from"broadcast";
import IBroadcastBuffer@Broadcast_Message(string&message,int&time)from"broadcast";
import IBroadcastBuffer@Broadcast_Message(string&message,bool send)from"broadcast";
import IBroadcastBuffer@Broadcast_Message(string&message)from"broadcast"; 

import void Broadcast_TownControl_Set(string&message,int location,int time,int faction)from"broadcast";
import void Broadcast_TownControl_Set(int location,int time,int faction,Critter&player)from"broadcast";
import void Broadcast_TownControl_Stop(int location)from"broadcast"; 

import IBroadcastBuffer@Broadcast_Influence(int location,int time,string&message)from"broadcast"; 

import uint Broadcast_RequestHelp(Critter@player,string&message)from"broadcast";
import void Broadcast_CheckRequestHelpBuffer(Critter@gm)from"broadcast";
import void Broadcast_DumpRequestHelpBuffer(Critter@gm)from"broadcast"; 

import void baseControl(string msg,int mapId,uint time)from"broadcast";
import void baseControlRadio(string msg,uint time,int mapId,uint factionId)from"broadcast"; 

import void ServerEventMSG(uint time,string msg)from"broadcast"; 

import IBroadcastBuffer@GetEventCountDownBuffer(int location,int type)from"broadcast";
import void ServerEventCNTSet(string message,uint location,uint type,uint time)from"broadcast";
import void ServerEventCNTSet(uint location,uint type,uint time)from"broadcast";
import void ServerEventCNTStop(uint location,uint type)from"broadcast";          

import uint tier3armor()from"item_pools";
import uint tier3helmet()from"item_pools";
import uint tier3weapon()from"item_pools";
import uint tier3alien()from"item_pools";
import uint tier3bp()from"item_pools";
import uint tier3drugs()from"item_pools";
import uint tier3ammo()from"item_pools";
import uint tierlowammo()from"item_pools";
import uint tier4parts()from"item_pools";
import uint tier4bp()from"item_pools";
import uint tier4item()from"item_pools";
import uint tier4ammo()from"item_pools";
import uint rareitem()from"item_pools";
import uint implant()from"item_pools";
import uint implant_combat()from"item_pools";
import uint verti_parts()from"item_pools";
import uint currency()from"item_pools";
import uint low_tier()from"item_pools";
import uint books()from"item_pools";
import uint mats()from"item_pools";
import uint misc()from"item_pools";
import void addbasemap(Critter&player)from"personal_base";
import void addbasemap(Item&con)from"personal_base";

import bool istier3armor(uint pid)from"item_pools";
import bool istier3helmet(uint pid)from"item_pools";
import bool istier3weapon(uint pid)from"item_pools";
import bool istier3bp(uint pid)from"item_pools";
import bool istier3drugs(uint pid)from"item_pools";
import bool istier3ammo(uint pid)from"item_pools";
import bool istierlowammo(uint pid)from"item_pools";
import bool istier4parts(uint pid)from"item_pools";
import bool istier4bp(uint pid)from"item_pools";
import bool istier4item(uint pid)from"item_pools";
import bool istier4ammo(uint pid)from"item_pools";
import bool israreitem(uint pid)from"item_pools";
import bool isimplant(uint pid)from"item_pools";
import bool isimplant_combat(uint pid)from"item_pools";
import bool isverti_parts(uint pid)from"item_pools";
import bool iscurrency(uint pid)from"item_pools";
import bool islow_tier(uint pid)from"item_pools";
import bool isHelmet(uint pid)from"item_pools";                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 

shared class Entire
{
	int Number;
	uint16 HexX;
	uint16 HexY;
	uint8 Direction;
};

uint ParseEntires(Map&map,array<Entire>&entires,int number)
{
	uint oldCount=entires.length();
	uint count=map.CountEntire(number);
	entires.resize(oldCount+count);
	
	for(uint i=0;i<count;i++)
	{
		Entire@ent=entires[oldCount+i];
		if(map.GetEntireCoords(number,i,ent.HexX,ent.HexY,ent.Direction)==false)
		return 0;
		ent.Number=number;
	}
	
	return count;
}

bool IsEntireFree(uint mappid,int number)
{
	Map@map=GetMapByPid(mappid,0);
	return IsEntireFree(map,number);
}

bool IsEntireFree(Map&map,int number)
{
	uint16 x,y;
	x=0;
	y=0;
	return GetEntireFreeHex(map,number,x,y);
}

bool GetEntireFreeHex(Map&map,int number,uint16&hx,uint16&hy,uint skip=0)
{
	uint count=map.CountEntire(number); 
	
	for(uint i=skip;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy)&&map.IsHexPassed(hx,hy))
		return true;
	}
	
	if(hx==0||hy==0||hx>=map.GetWidth()-1||hy>=map.GetHeight()-1)
	return false; 
	
	for(uint i=0;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy))
		{
			for(int x=-1;x<=1;x++)
			{
				for(int y=-1;y<=1;y++)
				{
					if(x==0&&y==0)
					continue;
					if(__MapHexagonal)
					{
						if((hx%2)==1&&((x==-1&&y==1)||(x==1&&y==1)))
						continue;
						if((hx%2)==0&&((x==-1&&y==-1)||(x==1&&y==-1)))
						continue;
					}
					
					if(map.IsHexPassed(hx+x,hy+y))
					{
						hx+=x;
						hy+=y;
						return true;
					}
				}
			}
		}
	}
	return false;
}

bool GetNearEntire(Map&map,int number,uint16&hx,uint16&hy)
{
	uint16 hxBase=hx;
	uint16 hyBase=hy;
	
	array<Entire>entires;
	uint count=ParseEntires(map,entires,number);
	if(count==0)
	return false;
	
	hx=entires[0].HexX;
	hy=entires[0].HexY;
	for(uint i=1;i<count;i++)
	{
		Entire@ent=entires[i];
		if(GetDistantion(hxBase,hyBase,ent.HexX,ent.HexY)<GetDistantion(hxBase,hyBase,hx,hy))
		{
			hx=ent.HexX;
			hy=ent.HexY;
		}
	}
	
	return true;
}                                                      

import void UpdateBasesVisibility(IFaction@faction,Critter&player)from"factions";
import void UpdateOneBaseVisibility(IFaction@faction,Critter&player,IFactionBase@base)from"factions";
import bool AddWalkPlane(Critter&npc,uint priority,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)from"npc_planes";
import bool AddWalkPlane(Critter&npc,uint priority,int identifier,uint identifierExt,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)from"npc_planes";

import bool AttackCritter(Critter&attacker,Critter&target,uint minhp)from"npc_common";
import bool AttackCritter(Critter&attacker,Critter&target)from"npc_common";

import void _weapon_perk(Item&item,bool firstTime)from"item_level";
import void _armor_perk(Item&item,bool firstTime)from"item_level";      

uint GetTerminalFaction(Critter&player)
{
	Map@map=player.GetMap();
	if(!(@map!=null))
	{
		Log("ERR: Couldn't obtain map object");
		return 0;
	}
	uint faction=map.GetData((0));
	if(faction<=(1))
	Log("ERR: Faction id hasn't been assigned to the map");
	return faction;
}  

void IncreaseUpdateSeq(uint faction_id)
{
	IFaction@faction=GetFaction(faction_id);
	faction.UpdateSeq=faction.UpdateSeq+1;
}

bool s_Terminal(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(!player.IsPlayer()||skill!=-1||(@item!=null))
	return false;
	
	uint faction=GetTerminalFaction(player);
	
	if(faction==0)
	{
		player.Say((11),"This terminal seems to be inactive");
		return false;
	}
	
	RunDialog(player,(9060),terminal.HexX,terminal.HexY,false);
	return true;
} 

bool s_terminal(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(!player.IsPlayer()||skill!=-1||(@item!=null))
	return false;
	
	uint faction=GetTerminalFaction(player);
	
	if(faction==0)
	{
		player.Say((11),"This terminal seems to be inactive");
		return false;
	}
	
	RunDialog(player,(9060),terminal.HexX,terminal.HexY,false);
	return true;
}

bool s_TerminalDoor(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(!player.IsPlayer()||skill!=-1||(@item!=null))
	return false;
	
	uint faction=GetTerminalFaction(player);
	
	if(faction==0)
	{
		player.Say((11),"This terminal seems to be inactive");
		return false;
	}
	
	RunDialog(player,9062,terminal.HexX,terminal.HexY,false);
	return true;
}

bool s_TerminalSettlement(Critter&player,Scenery&terminal,int skill,Item@item)
{
	if(!player.IsPlayer()||skill!=-1||(@item!=null))
	return false;
	
	uint faction=GetTerminalFaction(player);
	
	if(faction==0)
	{
		player.Say((11),"This terminal seems to be inactive");
		return false;
	}
	
	RunDialog(player,9063,terminal.HexX,terminal.HexY,false);
	return true;
}  

void dlg_TerminalWelcome(Critter&player,Critter@terminal,string@text)
{
	if(!((@text!=null)&&text.length()==0))
	return;
	uint faction_id=GetTerminalFaction(player);
	IFaction@faction=GetFaction(faction_id);
	text+="$faction"+faction.Name;
}  

void dlg_FactionName(Critter&player,Critter@terminal,string@text)
{
	if(!((@text!=null)&&text.length()==0))
	return;
	uint faction_id=GetTerminalFaction(player);
	IFaction@faction=GetFaction(faction_id);
	text+="$faction"+faction.Name;
}      

uint dlg_ChoosePlayer(Critter&player,Critter@terminal,string@playerName)
{
	if(!(@playerName!=null)||playerName.length()==0)
	return 0;
	
	GameVar@var=GetLocalVar((3029),player.Id);
	if(!(@var!=null))
	{
		Log("Variable LVAR_terminal_current not defined");
		return 0;
	}
	
	var=0;
	
	uint chosenId=GetPlayerId(playerName);
	if(chosenId==0)
	{
		player.Say((12),"Incorrect name");
		return 0;
	}
	
	uint faction=GetTerminalFaction(player);
	
	if(!StoredInDB(faction,chosenId))
	{
		player.Say((12),"Record not found");
		return 0;
	}
	
	var=chosenId;
	
	return(18);
}  

void dlg_ShowRecord(Critter&player,Critter@npc,string@say)
{
	if(((@say!=null)&&say.length()==0))
	{
		GameVar@var=GetLocalVar((3029),player.Id);
		if(!(@var!=null))
		{
			Log("Variable LVAR_terminal_current not defined");
			return;
		}
		
		uint faction=GetTerminalFaction(player);
		
		uint id=var.GetValue();
		
		uint storedFaction=GetFaction(faction,id);
		uint storedRank=GetRank(faction,id);
		uint storedStatus=GetStatus(faction,id);
		int8 rep=0;
		
		say+=GenerateDescription(id,storedFaction,storedRank,storedStatus,0);
	}
}  

string@GenerateDescription(uint id,uint faction_id,uint rank,uint status,int8 reputation)
{
	string say;
	
	say+="$name"+GetSafePlayerName(id);
	IFaction@faction=GetFaction(faction_id);
	say+="$faction"+faction.Name;
	say+="$rank@msg dlg "+(1000000000+((9060))*100000+((20)+rank))+"@";       
	
	say+="$status@msg dlg "+(1000000000+((9060))*100000+((10)+status))+"@";
	say+="$reputation"+reputation;
	return say;
}       

uint r_SelectMember(Critter&player,Critter@npc,int value)
{
	
	GameVar@var=GetLocalVar((3029),player.Id);
	uint curr=var.GetValue();
	if(!(@var!=null))
	{
		Log("Variable LVAR_terminal_current not defined");
		return(29);
	}
	IFaction@faction=GetFaction(GetTerminalFaction(player));
	array<uint>members;
	int num=faction.GetMembers(members); 
	
	var=members[0];
	
	if(value==1)
	{
		for(int i=0;i<num;i++)
		{
			if(members[i]==curr)
			{
				
				int idx=i+1<num?i+1:0;
				var=members[idx];
				break;
			}
		}
	}
	else if(value==-1)
	{
		for(int i=0;i<num;i++)
		{
			if(members[i]==curr)
			{
				
				int idx=i-1<0?num-1:i-1;
				var=members[idx];
				break;
			}
		}
	}
	return 0;
}        

uint r_SelectRecord(Critter&player,Critter@npc,int value)
{
	
	GameVar@var=GetLocalVar((3029),player.Id);
	uint curr=var.GetValue();
	if(!(@var!=null))
	{
		Log("Variable LVAR_terminal_current not defined");
		return 0;
	}
	IFaction@faction=GetFaction(GetTerminalFaction(player));
	array<uint>records;
	int num=faction.GetRecords(records);
	
	var=records[0];
	
	if(value==1)
	{
		for(int i=0;i<num;i++)
		{
			if(records[i]==curr)
			{
				
				int idx=i+1<num?i+1:0;
				var=records[idx];
				break;
			}
		}
	}
	else if(value==-1)
	{
		for(int i=0;i<num;i++)
		{
			if(records[i]==curr)
			{
				
				int idx=i-1<0?num-1:i-1;
				var=records[idx];
				break;
			}
		}
	}
	return 0;
}    

bool IsReadOnly(uint faction,uint id)
{
	uint chosenPlayerFaction=GetPlayerFaction(id);
	{;}; 
	
	if(chosenPlayerFaction==faction)
	return true;
	else
	return false;
}     

uint r_ModifyStatus(Critter&player,Critter@npc,int value)
{
	
	GameVar@var=GetLocalVar((3029),player.Id);
	if(!(@var!=null))
	{
		Log("Variable LVAR_terminal_current not defined");
		return 0;
	}
	
	if(!(value<=4))
	{
		Log("ERR: Invalid status value");
		return(29);
	}
	
	uint factionId=GetTerminalFaction(player);
	
	if(IsReadOnly(factionId,var.GetValue()))
	{
		return(30);
	}
	ModifyStatus(factionId,var.GetValue(),value);
	
	Critter@cr=GetCritter(var.GetValue());
	IFaction@faction=GetFaction(factionId);
	
	IncreaseUpdateSeq(factionId);
	
	if((@cr!=null))
	UpdateBasesVisibility(faction,cr);
	return 0;
}       

void r_ModifyReputation(Critter&player,Critter@npc,int value)
{
	
	GameVar@var=GetLocalVar((3029),player.Id);
	if(!(@var!=null))
	{
		Log("Variable LVAR_terminal_current not defined");
		return;
	}
	if(player.Id==uint(var.GetValue()))
	{
		player.Say((12),"You narcist!!!");
		return;
	} 
	
}

void r_ModifyTag(Critter&player,Critter@npc,int letter)
{
	IFaction@faction=GetFaction(player.Param[(106)]);
	
	faction.settag(player.Param[(1028)],letter,player.Param[(1025)],player.Param[(1026)],player.Param[(1027)]);
	
}

void r_Set_index(Critter&player,Critter@npc,int index)
{
	player.ParamBase[(1028)]=index;
	
}     

uint r_ModifyRank(Critter&player,Critter@npc,int value)
{
	
	GameVar@var=GetLocalVar((3029),player.Id);
	if(!(@var!=null))
	{
		Log("Variable LVAR_terminal_current not defined");
		return 0;
	}
	
	if(!(value<=5))
	{
		Log("ERR: Invalid rank value");
		return(29);
	}
	
	uint factionId=GetTerminalFaction(player);
	if(IsReadOnly(factionId,var.GetValue()))
	{
		return(30);
	}
	ModifyRank(factionId,var.GetValue(),value);
	
	Critter@cr=GetCritter(var.GetValue());
	IFaction@faction=GetFaction(factionId);
	
	IncreaseUpdateSeq(factionId);
	
	if((@cr!=null))
	UpdateBasesVisibility(faction,cr);
	return 0;
}     

uint r_ModifyFaction(Critter&player,Critter@npc,int value)
{
	
	GameVar@var=GetLocalVar((3029),player.Id);
	if(!(@var!=null))
	{
		Log("Variable LVAR_terminal_current not defined");
		return 0;
	}
	
	if(!(value<((4096))))
	{
		Log("ERR: Invalid faction value");
		return(29);
	}
	
	uint factionId=GetTerminalFaction(player);
	if(IsReadOnly(factionId,var.GetValue()))
	{
		return(30);
	}
	
	ModifyFaction(factionId,var.GetValue(),value);
	
	Critter@cr=GetCritter(var.GetValue());
	IFaction@faction=GetFaction(factionId);
	if((@cr!=null))
	UpdateBasesVisibility(faction,cr);
	
	return 0;
}      

uint dlg_ModifyFactionByName(Critter&player,Critter@npc,string@say)
{
	if(!((@say!=null)&&say.length()>0))
	return 0; 
	
	GameVar@var=GetLocalVar((3029),player.Id);
	if(!(@var!=null))
	{
		Log("Variable LVAR_terminal_current not defined");
		return 0;
	}
	
	uint faction=GetTerminalFaction(player);
	if(IsReadOnly(faction,var.GetValue()))
	{
		return(30);
	}
	uint modifiedFaction=0;
	
	if(!GetFactionId(say,modifiedFaction))
	{
		player.SayMsg((12),(1),(1000000000+((9060))*100000+((30))));
		return 0;
	}
	
	ModifyFaction(faction,var.GetValue(),modifiedFaction);
	return(22);
}       

uint dlg_Invite(Critter&recruiter,Critter@npc,string@playerName)
{
	if(!(@playerName!=null)||playerName.length()==0)
	return 0; 
	
	uint initiateId=GetPlayerId(playerName);
	if(initiateId==0)
	{
		recruiter.Say((12),"Player not found");
		return 0;
	}
	
	uint factionId=GetTerminalFaction(recruiter);
	
	if(IsMemberOffline(factionId,initiateId))
	{
		recruiter.Say((12),"Already a member");
		return 0;
	}
	
	int res=InvitePlayer(factionId,initiateId);
	if(res!=(0))
	recruiter.Say((11),"ERR: "+FD_Result2String(res));
	else
	{
		
		GameVar@var=GetLocalVar((3029),recruiter.Id);
		if(!(@var!=null))
		{
			Log("ERR: Variable LVAR_terminal_current not defined");
		}
		var=initiateId;
		
		IFaction@faction=GetFaction(factionId);
		Critter@initiate=GetCritter(initiateId);
		if((@initiate!=null))
		UpdateBasesVisibility(faction,initiate);
		
		return(22);
	}
	return 0;
}   

void r_ConfirmInvitation(Critter&player,Critter@npc,int value)
{
	uint factionId=GetTerminalFaction(player);
	
	if(factionId==0)
	{
		Log("ERR: Faction hasn't been stored in map");
		return;
	}
	if(IsMember(factionId,player))
	{
		Log("ERR: Already a member");
		return;
	} 
	
	int res=ConfirmInvitation(factionId,player.Id);
	if(res!=(0))
	Log("ERR: "+FD_Result2String(res)); 
	
	AddFactionNews(factionId,player.Id,0,(1));
	
	IFaction@faction=GetFaction(factionId);
	UpdateBasesVisibility(faction,player);
}      

uint dlg_PromoteMember(Critter&player,Critter@npc,string@playerName)
{
	if(!(@playerName!=null)||playerName.length()==0)
	return 0; 
	
	uint promoteeId=GetPlayerId(playerName);
	if(promoteeId==0)
	{
		player.Say((12),"Player not found");
		return 0;
	}
	if(!IsTheSameFaction(player.Id,promoteeId))
	{
		player.Say((12),"Not a member");
		return 0;
	}
	
	if(!PromoteMember(player.Id,promoteeId))
	{
		player.Say((12),"You cannot promote that member");
	}
	else
	{
		
		return(43);
	}
	return 0;
}   

uint r_PromoteMember(Critter&player,Critter@npc,int value)
{
	
	GameVar@var=GetLocalVar((3029),player.Id);
	if(!(@var!=null))
	{
		Log("Variable LVAR_terminal_current not defined");
		return 0;
	}
	
	if(!PromoteMember(player.Id,var.GetValue()))
	{
		return(45);
	}
	return 0;
}   

bool PromoteMember(uint promoterId,uint promoteeId)
{
	
	uint promoterFaction=GetPlayerFaction(promoterId);
	uint promoterRank=GetPlayerRank(promoterId);
	uint promoteeFaction=GetPlayerFaction(promoteeId);
	uint promoteeRank=GetPlayerRank(promoteeId);
	
	if(promoterFaction!=promoteeFaction)
	{
		Log("ERR: Invalid function call - you should only call it on members");
		return false;
	}
	
	if(promoterRank>promoteeRank+1)
	{
		int res=ChangeRank(promoterFaction,promoteeId,promoteeRank+1);
		if(res==(0))
		{
			
			AddFactionNews(promoterFaction,promoterId,promoteeId,(4));
			
			Critter@player=GetCritter(promoterId);
			if((@player!=null))
			{
				uint factionId=GetTerminalFaction(player);
				IFaction@faction=GetFaction(factionId);
				Critter@promotee=GetCritter(promoteeId);
				if((@promotee!=null))
				UpdateBasesVisibility(faction,promotee);
			}
			return true;
		}
		else
		{
			Log("ERR: "+FD_Result2String(res));
			return false;
		}
	}
	else
	{
		return false;
	}
}      

uint dlg_DemoteMember(Critter&player,Critter@npc,string@playerName)
{
	if(!(@playerName!=null)||playerName.length()==0)
	return 0; 
	
	uint demoteeId=GetPlayerId(playerName);
	if(demoteeId==0)
	{
		player.Say((12),"Player not found");
		return 0;
	}
	if(!IsTheSameFaction(player.Id,demoteeId))
	{
		player.Say((12),"Not a member");
		return 0;
	}
	
	if(!DemoteMember(player.Id,demoteeId))
	{
		player.Say((12),"You cannot demote that member");
	}
	else
	
	return(43);
	return 0;
}   

uint r_DemoteMember(Critter&player,Critter@npc,int value)
{
	
	GameVar@var=GetLocalVar((3029),player.Id);
	if(!(@var!=null))
	{
		Log("Variable LVAR_terminal_current not defined");
		return 0;
	}
	
	if(!DemoteMember(player.Id,var.GetValue()))
	{
		return(45);
	}
	return 0;
}  

bool DemoteMember(uint demoterId,uint demoteeId)
{
	
	uint demoterFaction=GetPlayerFaction(demoterId);
	uint demoterRank=GetPlayerRank(demoterId);
	uint demoteeFaction=GetPlayerFaction(demoteeId);
	uint demoteeRank=GetPlayerRank(demoteeId);
	
	if(demoterFaction!=demoteeFaction)
	{
		Log("ERR: Invalid function call - you should only call it on members");
		return false;
	}
	
	if(demoterRank>demoteeRank&&demoteeRank>2)
	{
		int res=ChangeRank(demoterFaction,demoteeId,demoteeRank-1);
		if(res==(0))
		{
			
			AddFactionNews(demoterFaction,demoterId,demoteeId,(7));
			
			Critter@player=GetCritter(demoterId);
			if((@player!=null))
			{
				uint factionId=GetTerminalFaction(player);
				IFaction@faction=GetFaction(factionId);
				Critter@demotee=GetCritter(demoteeId);
				if((@demotee!=null))
				UpdateBasesVisibility(faction,demotee);
			}
			return true;
		}
		else
		{
			Log("ERR: "+FD_Result2String(res));
			return false;
		}
	}
	else
	{
		return false;
	}
}      

uint dlg_ExpelMember(Critter&player,Critter@npc,string@playerName)
{
	if(!(@playerName!=null)||playerName.length()==0)
	return 0; 
	
	uint exileId=GetPlayerId(playerName);
	if(exileId==0)
	{
		player.Say((12),"Player not found");
		return 0;
	}
	if(!IsTheSameFaction(player.Id,exileId))
	{
		player.Say((12),"Not a member");
		return 0;
	}
	if(!_ExpelMember(player.Id,exileId))
	{
		player.Say((12),"You cannot promote that member");
	}
	else
	
	return(43);
	return 0;
}   

uint r_ExpelMember(Critter&player,Critter@npc,int value)
{
	
	GameVar@var=GetLocalVar((3029),player.Id);
	if(!(@var!=null))
	{
		Log("Variable LVAR_terminal_current not defined");
		return 0;
	}
	
	if(!_ExpelMember(player.Id,var.GetValue()))
	{
		return(45);
	}
	else
	return(5);
}  

bool _ExpelMember(uint expellerId,uint exileId)
{
	uint faction=GetPlayerFaction(expellerId);
	uint exileFaction=GetPlayerFaction(exileId);
	
	if(faction!=exileFaction)
	{
		Log("ERR: Invalid function call - you should only call it on members");
		return false;
	}
	if(expellerId==exileId)
	{
		
		return false;
	}
	int res=ExpelMember(faction,exileId);
	if(res==(0))
	{
		
		AddFactionNews(faction,expellerId,exileId,(3));
		
		Critter@player=GetCritter(expellerId);
		if((@player!=null))
		{
			uint factionId=GetTerminalFaction(player);
			IFaction@faction=GetFaction(factionId);
			Critter@exile=GetCritter(exileId);
			if((@exile!=null))
			UpdateBasesVisibility(faction,exile);
		}
		return true;
	}
	else
	{
		Log("ERR: "+FD_Result2String(res));
		return false;
	}
}   

void r_Resign(Critter&player,Critter@npc,int value)
{
	_Resign(player.Id);
	uint factionId=GetTerminalFaction(player);
	IFaction@faction=GetFaction(factionId);
	UpdateBasesVisibility(faction,player);
	
}      

uint dlg_ChooseBase(Critter&player,Critter@terminal,string@baseName)
{
	if(!(@baseName!=null)||baseName.length()==0)
	return 0;
	
	GameVar@var=GetLocalVar((3029),player.Id);
	if(!(@var!=null))
	{
		Log("Variable LVAR_terminal_current not defined");
		return 0;
	}
	
	var=0;
	
	uint faction=GetTerminalFaction(player);
	IFactionBase@base=GetFactionBase(faction,baseName);
	if(!(@base!=null))
	{
		player.Say((12),"Incorrect name");
		return 0;
	}
	
	var=base.Id;
	
	return(200);
}  

void dlg_ShowBase(Critter&player,Critter@npc,string@say)
{
	if(((@say!=null)&&say.length()==0))
	{
		GameVar@var=GetLocalVar((3029),player.Id);
		if(!(@var!=null))
		{
			Log("Variable LVAR_terminal_current not defined");
			return;
		}
		
		uint faction=GetTerminalFaction(player);
		
		uint id=var.GetValue();
		IFactionBase@base=GetFactionBase(id);
		Location@loc=GetLocation(base.LocationId);
		say+="$name"+base.Name+
		"$x"+loc.WorldX+
		"$y"+loc.WorldY+
		"$recruits_allowed"+(base.IsRankAllowed(1)?"allowed":"disallowed")+
		"$accepted_allowed"+(base.IsRankAllowed(2)?"allowed":"disallowed")+
		"$trusted_allowed"+(base.IsRankAllowed(3)?"allowed":"disallowed")+
		"$important_allowed"+(base.IsRankAllowed(4)?"allowed":"disallowed")+
		"$invited_allowed"+(base.IsStatusAllowed((4))?"allowed":"disallowed")+
		"$friends_allowed"+(base.IsStatusAllowed((1))?"allowed":"disallowed");
	}
}       

uint r_SelectBase(Critter&player,Critter@npc,int value)
{
	
	GameVar@var=GetLocalVar((3029),player.Id);
	uint curr=var.GetValue();
	uint faction=GetTerminalFaction(player);
	array<IFactionBase@>bases;
	uint num=GetFactionBases(faction,bases);
	
	var=bases[0].Id;
	
	if(value==1)
	{
		for(int i=0,iend=bases.length();i<iend;i++)
		{
			if(bases[i].Id==curr)
			{
				
				int idx=i+1<iend?i+1:0;
				var=bases[idx].Id;
				break;
			}
		}
	}
	else if(value==-1)
	{
		for(int i=0,iend=bases.length();i<iend;i++)
		{
			if(bases[i].Id==curr)
			{
				
				int idx=i-1<0?iend-1:i-1;
				var=bases[idx].Id;
				break;
			}
		}
	}
	
	return 0;
}

bool d_BaseRankAllowed(Critter&player,Critter@,int rank,int allowed)
{
	GameVar@var=GetLocalVar((3029),player.Id);
	IFactionBase@base=GetFactionBase(var.GetValue());
	if(allowed!=0&&base.IsRankAllowed(rank))
	return true;
	if(allowed==0&&!base.IsRankAllowed(rank))
	return true;
	return false;
}

void r_BaseRankAllow(Critter&player,Critter@,int rank,int allowed)
{
	GameVar@var=GetLocalVar((3029),player.Id);
	IFactionBase@base=GetFactionBase(var.GetValue());
	base.AllowRank(rank,allowed==0?false:true);
	
	array<Critter@>players;
	uint count=GetAllOnlinePlayers(players);
	uint factionId=GetTerminalFaction(player);
	IFaction@faction=GetFaction(factionId);
	
	IncreaseUpdateSeq(factionId);
	
	for(uint i=0;i<count;i++)
	{
		if((@players[i]!=null))
		UpdateOneBaseVisibility(faction,players[i],base);
	}
}

bool d_BaseStatusAllowed(Critter&player,Critter@,int status,int allowed)
{
	GameVar@var=GetLocalVar((3029),player.Id);
	IFactionBase@base=GetFactionBase(var.GetValue());
	if(allowed!=0&&base.IsStatusAllowed(status))
	return true;
	if(allowed==0&&!base.IsStatusAllowed(status))
	return true;
	return false;
}

void r_BaseStatusAllow(Critter&player,Critter@,int status,int allowed)
{
	GameVar@var=GetLocalVar((3029),player.Id);
	IFactionBase@base=GetFactionBase(var.GetValue());
	base.AllowStatus(status,allowed==0?false:true);
	
	array<Critter@>players;
	uint count=GetAllOnlinePlayers(players);
	uint factionId=GetTerminalFaction(player);
	IFaction@faction=GetFaction(factionId);
	
	IncreaseUpdateSeq(factionId);
	
	for(uint i=0;i<count;i++)
	{
		if((@players[i]!=null))
		UpdateOneBaseVisibility(faction,players[i],base);
	}
}            

uint r_SelectFaction(Critter&player,Critter@npc,int value)
{
	
	GameVar@var=GetLocalVar((3029),player.Id);
	int curr=var.GetValue();
	uint faction_id=GetTerminalFaction(player);
	IFaction@faction=GetFaction(faction_id);
	array<int>factions;
	uint num=faction.GetKnownFactions(factions);
	if(num<1)
	return 0;
	
	if(value==0)
	{
		var=factions[0];
	}
	
	else if(value==1)
	{
		for(int i=0,iend=factions.length();i<iend;i++)
		{
			if(factions[i]==curr)
			{
				
				int idx=i+1<iend?i+1:0;
				var=factions[idx];
				break;
			}
		}
	}
	else if(value==-1)
	{
		for(int i=0,iend=factions.length();i<iend;i++)
		{
			if(factions[i]==curr)
			{
				
				int idx=i-1<0?iend-1:i-1;
				var=factions[idx];
				break;
			}
		}
	}
	
	return 0;
}  

void dlg_ShowKnownFaction(Critter&player,Critter@,string@say)
{
	if(((@say!=null)&&say.length()==0))
	{
		GameVar@var=GetLocalVar((3029),player.Id);
		
		IFaction@faction=GetFaction(var.GetValue());
		if((@faction!=null))
		say+="$name"+faction.Name;
		else
		say+="$nameFaction does not exist";
	}
}   

void r_ChangeFactionStatus(Critter&player,Critter@,int status)
{
	GameVar@var=GetLocalVar((3029),player.Id);
	IFaction@faction=GetFaction(GetTerminalFaction(player));
	IFaction@known_faction=GetFaction(var.GetValue());
	array<uint>members;
	int num=known_faction.GetMembers(members);
	for(int i=0;i<num;i++)
	{
		faction.SetStatus(members[i],status);
	}
	player.Say((12),"Done");
}   

uint dlg_AddKnownFaction(Critter&player,Critter@,string@say)
{
	if(((@say!=null)&&say.length()>0))
	{
		IFaction@faction=GetFaction(GetTerminalFaction(player));
		IFaction@known_faction=GetFaction(say);
		if((@known_faction!=null))
		{
			player.Say((12),"Adding faction");
			faction.AddKnownFaction(known_faction.Id);
			GameVar@var=GetLocalVar((3029),player.Id);
			var=known_faction.Id;
			{;};
			return(300);
		}
		else
		{
			player.Say((12),"Faction does not exist");
			return 0;
		}
	}
	return 0;
}       

void dlg_ShowInfo(Critter&player,Critter@npc,string@text)
{
	if(!((@text!=null)&&text.length()==0))
	return;
	uint faction=GetTerminalFaction(player);
	uint claimId=GetClaimId(faction);
	if(claimId!=0)
	{
		if(claimId==player.Id)
		{
			text=(1000000000+((9060))*100000+((41)))+
			((__FullSecond)-GetLeaderTime(faction));
		}
		else
		{
			text=GetSafePlayerName(claimId)+
			(1000000000+((9060))*100000+((40)));
		}
	}
	else
	text="$info"+"Good morning!";
	text+="\n"+(1000000000+((9060))*100000+((42)));
}      

bool d_CanClaimLeadership(Critter&player,Critter@npc,int value)
{
	uint faction=GetTerminalFaction(player);
	
	if(IsBigFaction(faction))
	return false; 
	
	if(GetClaimId(faction)!=0)
	{
		
		if((__FullSecond)>=GetClaimTime(faction))
		return GetClaimId(faction)!=player.Id;
		else
		return false;
	}
	
	if(GetLeaderId(faction)==0)
	return true;
	
	uint rank=GetPlayerRank(player.Id);
	
	if(rank==(1)||rank==(5))
	return false;          
	
	return true;
}   

void r_ClaimLeadership(Critter&player,Critter@npc,int value)
{
	{;};
	uint faction=GetTerminalFaction(player);
	SetClaimId(faction,player.Id);
	
	SetLeaderTime(faction,((__FullSecond)+(((1)*__TimeMultiplier*86400))));
	
	SetClaimTime(faction,((__FullSecond)+(((2)*__TimeMultiplier*86400))));      
	
	AddFactionNews(faction,player.Id,0,(9));
}   

bool d_ClaimedLeadership(Critter&player,Critter@npc,int value)
{
	uint faction=GetTerminalFaction(player);
	return GetClaimId(faction)==player.Id;
}   

void r_CancelClaim(Critter&player,Critter@npc,int value)
{
	uint faction=GetTerminalFaction(player);
	SetClaimId(faction,0);
	SetLeaderTime(faction,0);
	SetClaimTime(faction,0);
}    

bool d_CanConfirmLeadership(Critter&player,Critter@npc,int value)
{
	uint faction=GetTerminalFaction(player);
	if(GetClaimId(faction)!=player.Id)
	return false; 
	
	if((__FullSecond)>=GetLeaderTime(faction))
	return true;
	if(GetLeaderId(faction)!=0)
	return false;
	return true;
}   

void r_ConfirmLeadership(Critter&player,Critter@npc,int value)
{
	{;};
	uint faction=GetTerminalFaction(player);
	int res;
	uint leaderId=GetLeaderId(faction); 
	
	if(leaderId!=0)
	{
		{;};
		ChangeRank(faction,leaderId,(2));
	}
	else
	{;};
	{;};
	ChangeRank(faction,player.Id,(5));
	SetClaimId(faction,0);
	SetClaimTime(faction,0);
	
	AddFactionNews(faction,player.Id,0,(10));
}          

uint dlg_AddPlayer(Critter&player,Critter@terminal,string@playerName)
{
	if(!(@playerName!=null)||playerName.length()==0)
	return 0; 
	
	uint playerToAddId=GetPlayerId(playerName);
	if(playerToAddId==0)
	{
		player.Say((12),"Incorrect name");
		return 0;
	}
	
	uint faction=GetTerminalFaction(player);
	
	if(faction!=(0)&&faction!=(1))
	{
		int res=AddPlayer(faction,playerToAddId);
		if(res==(0))
		{
			
			GameVar@var=GetLocalVar((3029),player.Id);
			if(!(@var!=null))
			{
				Log("ERR: Variable LVAR_terminal_current not defined");
			}
			var=playerToAddId;
			
			return(22);
		}
		else if(res==(1))
		player.Say((12),"Person is already filed in the database.");
		else
		player.Say((12),"ERR: Couldn't add the player to the faction's database.");
	}
	else
	Log("ERR: Unable to determine the player's faction");
	return 0;
}      

void dlg_RemovePlayer(Critter&player,Critter@terminal,string@playerName)
{
	if(!(@playerName!=null)||playerName.length()==0)
	return; 
	
	uint removedId=GetPlayerId(playerName);
	if(removedId==0)
	{
		player.Say((12),"Player not found");
		return;
	}
	
	uint faction=GetTerminalFaction(player);
	int res=RemovePlayer(faction,removedId);
	
	if(res==(0))
	player.Say((12),"Player succesfully removed.");
	else if(res==(2))
	player.Say((12),"Player not found in database.");
	else
	player.Say((12),"ERR: "+FD_Result2String(res));
}    

void dlg_RadioChannel(Critter&player,Critter@terminal,string@say)
{
	uint faction=GetTerminalFaction(player);
	if(((@say!=null)&&say.length()==0))
	{
		
		say+="$channel"+GetFactionRadioChannel(faction);
	}
	if(((@say!=null)&&say.length()>0))
	{
		
		if(GetPlayerRank(player.Id)<(4))
		return;
		
		int newChannel=0;
		if(StrToInt(say,newChannel)&&newChannel>=0&&newChannel<(2<<16))
		{
			SetFactionRadioChannel(faction,uint16(newChannel));
			player.SayMsg((12),(1),(1000000000+((9060))*100000+((31))));
		}
		else
		{
			player.SayMsg((12),(1),(1000000000+((9060))*100000+((32))));
		}
	}
}      

bool d_Terminal_IsMember(Critter&player,Critter@terminal,int val)
{
	uint faction=GetTerminalFaction(player);
	
	return faction==GetGroupIndex(player);
}
bool d_Terminal_NotMember(Critter&player,Critter@terminal,int val)
{
	uint faction=GetTerminalFaction(player);
	
	return faction!=GetGroupIndex(player);
}   

bool d_IsInvited(Critter&player,Critter@terminal,int val)
{
	uint faction=GetTerminalFaction(player);
	uint status=(0);
	
	return GetStatus(faction,player.Id)==(4);
}   

bool d_InvitationsAllowed(Critter&player,Critter@terminal,int val)
{
	uint faction=GetTerminalFaction(player);
	return!IsBigFaction(faction);
}        

void dlg_ShowNews(Critter&player,Critter@npc,string@text)
{
	if(!((@text!=null)&&text.length()==0))
	return;
	
	uint faction=GetTerminalFaction(player);
	uint newsCount=GetFactionNewsCount(faction);
	uint index=newsCount-player.Param[(90)]-1;
	
	uint master=0;
	uint slave=0;
	uint type=0;
	uint16 year=0;
	uint8 month=0;
	uint8 day=0;
	uint8 hour=0;
	uint8 minute=0;
	
	if(GetFactionNews(faction,index,master,slave,type,
	year,month,day,hour,minute))
	{
		
		text+="$datetime"+day+"/"+month+"/"+year+" at: "+hour+":"+minute;
		if(master!=0)
		text+="$master"+GetSafePlayerName(master);
		if(slave!=0)
		text+="$slave"+GetSafePlayerName(slave);
	}
	else
	text="No news stored";
}    

uint r_NextNews(Critter&player,Critter@npc,int val)
{
	uint faction=GetTerminalFaction(player);
	uint newsCount=GetFactionNewsCount(faction);
	if(newsCount==0)
	return 0;
	
	player.ParamBase[(90)]--;
	if(player.Param[(90)]<0)
	player.ParamBase[(90)]=0;
	if(uint(player.Param[(90)])>=newsCount)
	player.ParamBase[(90)]=newsCount-1;
	
	return GoToNewsNode(faction,newsCount-player.Param[(90)]-1);
}    

uint r_PreviousNews(Critter&player,Critter@npc,int val)
{
	uint faction=GetTerminalFaction(player);
	uint newsCount=GetFactionNewsCount(faction);
	if(newsCount==0)
	return 0;
	
	player.ParamBase[(90)]++;
	if(player.Param[(90)]<0)
	player.ParamBase[(90)]=0;
	if(uint(player.Param[(90)])>=newsCount)
	player.ParamBase[(90)]=newsCount-1;
	
	return GoToNewsNode(faction,newsCount-player.Param[(90)]-1);
}    

uint r_GoToNews(Critter&player,Critter@npc,int val)
{
	uint faction=GetTerminalFaction(player);
	uint newsCount=GetFactionNewsCount(faction);
	{;};
	player.ParamBase[(90)]=0;
	
	if(newsCount>0)
	{
		return GoToNewsNode(faction,newsCount-1);
	}
	return 0;
}    

uint GoToNewsNode(uint faction,uint index)
{
	uint type=0;
	uint master=0,slave=0;
	uint16 year;
	uint8 month,day,hour,minute;
	if(GetFactionNews(faction,index,master,slave,type,year,month,day,hour,minute))
	{
		uint force=0;
		{;};
		switch(type)
		{
			case(1):
			force=(110);
			break;
			case(2):
			force=(111);
			break;
			case(3):
			force=(112);
			break;
			case(4):
			force=(113);
			break;
			case(7):
			force=(114);
			break;
			case(9):
			force=(115);
			break;
			case(10):
			force=(116);
			break;
			case(11):
			force=(117);
			break;
		}
		return force;
	}
	return 0;
	
}   

void r_UpdateLastUsed(Critter&player,Critter@npc)
{
	{};
	uint faction=GetTerminalFaction(player);
	UpdateLastUsed(faction);
}

void r_DeleteBase(Critter&player,Critter@npc)
{
	DeleteLocation(player.GetMap().GetLocation().Id);
}      

void r_status(Critter&player,Critter@npc)
{
	array<Critter@>workers;
	uint workerscount=npc.GetMap().GetCritters(417,(0x20)|(0x03),workers);
	array<Critter@>Guards;
	uint guardcount=npc.GetMap().GetCritters(422,(0x20)|(0x03),Guards);
	array<Critter@>caravaners;
	uint caravanerscount=npc.GetMap().GetCritters(416,(0x20)|(0x03),caravaners);
	int count2=npc.Param[(124)];
	int income=500;
	uint t4count=npc.GetMap().GetCritters(666,(0x20)|(0x03),caravaners);
	
	income-=t4count*50000;
	income+=workerscount*1000;
	income-=guardcount*500;
	player.ShowScreen((0),0,"");
	player.ShowScreen((2),0,"");
	player.Say((18),"Settlement budget is: "+count2+"\nSettlement income: "+income+"\nGuards: "+guardcount+"\nWorkers: "+workerscount);
}

void r_statusgenerator(Critter&player,Critter@npc)
{
	int count=npc.Param[(129)];
	player.ShowScreen((0),0,"");
	player.ShowScreen((2),0,"");
	player.Say((18),"Generator charges: "+count);
}

void r_delete(Critter&player,Critter@npc)
{
	DeleteNpc(npc);
}

void Payout(Critter&player,Critter@npc)
{
	if(npc.CountItem(Addpropermoney(npc))<1)
	return;
	uint money=npc.CountItem(Addpropermoney(npc))/4;
	
	Item@currency=npc.GetItem(Addpropermoney(npc),-1);
	currency.SetCount(money);
	
	array<Item@>items;
	uint n=npc.GetItems(-1,items);
	MoveItems(items,player);
}

void Payout_trader(Critter&player,Critter@npc)
{
	Item@SafeContainer=player.GetMap().AddItem(1,1,(42),1);
	if(npc.CountItem(Addpropermoney(npc))<1)
	return;
	uint money=npc.CountItem(Addpropermoney(npc))/4;
	npc.ParamBase[(128)]=money;
	
	Item@currency=npc.GetItem(Addpropermoney(npc),-1);
	
	SafeContainer.AddItem(Addpropermoney(npc),money,money);
	array<Item@>items2;
	SafeContainer.GetItems(Addpropermoney(npc),items2);
	MoveItems(items2,player);
	if((@currency!=null))
	{
		DeleteItem(currency);
	}
	if((@SafeContainer!=null))
	{
		DeleteItem(SafeContainer);
	}
	player.AddItem(Addpropermoney(npc),money);
	npc.ParamBase[(128)]=0;
}

void Pay(Critter&player,Critter@npc,int cost)
{
	Item@currency=npc.GetItem(Addpropermoney(npc),-1);
	if(npc.CountItem(Addpropermoney(npc))<1)
	{
		npc.AddItem(Addpropermoney(npc),cost);
		return;
	}
	currency.SetCount(currency.GetCount()+cost);
	
}

void r_payout(Critter&player,Critter@npc)
{
	array<Item@>items;
	uint n=npc.GetItems(-1,items);
	
	npc.Say((2),"I'm sorry everything is in Black Cross Bank");
}

void r_upgrate(Critter&player,Critter@npc,int what)
{
	Map@map=player.GetMap();
	uint16 x,y;
	x=y=0;
	switch(what)
	{
		case 1:
		{
			map.GetEntireCoords(75,0,x,y);
			Item@it=map.AddItem(x,y,9914,1);
			it.SetScript("workbench@_Advanced");
			npc.ParamBase[(96)]=1;
			break;
		}
		case 2:
		{
			map.GetEntireCoords(76,0,x,y);
			Item@it=map.AddItem(x,y,25447,1);
			it.SetScript("workbench@_VCMed");
			npc.ParamBase[(97)]=1;
			break;
		}
		case 3:
		{
			map.GetEntireCoords(77,0,x,y);
			Item@it=map.AddItem(x,y,3189,1);
			it.SetScript("workbench@_HiTechSG");
			npc.ParamBase[(98)]=1;
			break;
		}
		case 4:
		{
			map.GetEntireCoords(78,0,x,y);
			Item@it=map.AddItem(x,y,3004,1);
			npc.ParamBase[(99)]=1;
			break;
		}
	}
	
}

bool d_canbuild1(Critter&player,Critter@npc)
{
	return(npc.ParamBase[(96)]<1);
}

bool d_canbuild2(Critter&player,Critter@npc)
{
	return(npc.ParamBase[(97)]<1);
}

bool d_canbuild3(Critter&player,Critter@npc)
{
	return(npc.ParamBase[(98)]<1);
}

bool d_canbuild4(Critter&player,Critter@npc)
{
	return(npc.ParamBase[(99)]<1);
}
bool d_generator(Critter&player,Critter@npc)
{
	return(npc.ParamBase[(99)]!=0);
}
bool d_canrecruitworkers(Critter&player,Critter@npc)
{
	Map@map=player.GetMap();
	array<Critter@>workers;
	uint workerscount=map.GetCritters(417,(0x20)|(0x0F),workers);
	return(workerscount<30);
}

bool d_canrecruitguards(Critter&player,Critter@npc)
{
	Map@map=player.GetMap();
	array<Critter@>workers;
	uint workerscount=map.GetCritters(422,(0x20)|(0x0F),workers);
	return(workerscount<25);
}

bool d_canrecruit(Critter&player,Critter@npc,int npcpid)
{
	Map@map=player.GetMap();
	array<Critter@>workers;
	uint workerscount=map.GetCritters(npcpid,(0x20)|(0x0F),workers);
	return(workerscount<1);
}

bool d_canupgrade(Critter&player,Critter@npc,int npcpid)
{
	Map@map=player.GetMap();
	array<Critter@>workers;
	uint workerscount=map.GetCritters(npcpid,(0x20)|(0x0F),workers);
	return(workerscount>0);
}

uint Addpropermoney(Critter@npc)
{
	switch(npc.Param[(139)])
	{
		case 0:return(41);
		case 1:return(1212);
		case 2:return(1211);
		case 3:return(1214);
		case 4:return(1213);
		case 5:return(1215);
	}
	return(41);
	
}

bool d_canupgradeshop(Critter&player,Critter@npc)
{
	Map@map=player.GetMap();
	array<Critter@>workers;
	uint workerscount=map.GetCritters(416,(0x20)|(0x0F),workers);
	switch(workerscount)
	{
		case 0:if(player.CountItem((22081))>0&&player.CountItem(Addpropermoney(npc))>74999)return true;
		case 1:if(player.CountItem((22082))>0&&player.CountItem(Addpropermoney(npc))>99999)return true;
		case 2:if(player.CountItem((22083))>0&&player.CountItem((22078))>0&&player.CountItem(Addpropermoney(npc))>149999)return true;
		case 3:if(player.CountItem((22085))>0&&player.CountItem((22086))>0&&player.CountItem(Addpropermoney(npc))>249999)return true;
		case 4:if(player.CountItem((22087))>0&&player.CountItem((22088))>0&&player.CountItem((22090))>0&&player.CountItem(Addpropermoney(npc))>349999)return true;
		case 5:if(player.CountItem((22093))>0&&player.CountItem((22074))>0&&player.CountItem((22080))>0&&player.CountItem(Addpropermoney(npc))>349999)return true;
		case 6:if(player.CountItem((22081))>1&&player.CountItem(Addpropermoney(npc))>349999)return true;
		case 7:if(player.CountItem((22082))>1&&player.CountItem(Addpropermoney(npc))>349999)return true;
		case 8:if(player.CountItem((22083))>1&&player.CountItem((22078))>1&&player.CountItem(Addpropermoney(npc))>349999)return true;
		case 9:if(player.CountItem((22085))>1&&player.CountItem((22086))>1&&player.CountItem(Addpropermoney(npc))>349999)return true;
		case 10:if(player.CountItem((22087))>1&&player.CountItem((22088))>1&&player.CountItem((22090))>1&&player.CountItem(Addpropermoney(npc))>349999)return true;
		case 11:if(player.CountItem((22093))>1&&player.CountItem((22074))>1&&player.CountItem((22080))>1&&player.CountItem(Addpropermoney(npc))>349999)return true;
		case 12:if(player.CountItem((22081))>2&&player.CountItem(Addpropermoney(npc))>499999)return true;
		case 13:if(player.CountItem((22082))>2&&player.CountItem(Addpropermoney(npc))>499999)return true;
		case 14:if(player.CountItem((22083))>2&&player.CountItem((22078))>2&&player.CountItem(Addpropermoney(npc))>499999)return true;
		case 15:if(player.CountItem((22085))>2&&player.CountItem((22086))>2&&player.CountItem(Addpropermoney(npc))>499999)return true;
		case 16:if(player.CountItem((22087))>2&&player.CountItem((22088))>2&&player.CountItem((22090))>2&&player.CountItem(Addpropermoney(npc))>499999)return true;
		case 17:if(player.CountItem((22093))>2&&player.CountItem((22074))>2&&player.CountItem((22080))>2&&player.CountItem(Addpropermoney(npc))>499999)return true;
		case 18:if(player.CountItem((22081))>3&&player.CountItem(Addpropermoney(npc))>749999)return true;
		case 19:if(player.CountItem((22082))>3&&player.CountItem(Addpropermoney(npc))>749999)return true;
		case 20:if(player.CountItem((22083))>3&&player.CountItem((22078))>3&&player.CountItem(Addpropermoney(npc))>749999)return true;
		case 21:if(player.CountItem((22085))>3&&player.CountItem((22086))>3&&player.CountItem(Addpropermoney(npc))>749999)return true;
		case 22:if(player.CountItem((22087))>3&&player.CountItem((22088))>3&&player.CountItem((22090))>3&&player.CountItem(Addpropermoney(npc))>749999)return true;
		case 23:if(player.CountItem((22093))>3&&player.CountItem((22074))>3&&player.CountItem((22080))>3&&player.CountItem(Addpropermoney(npc))>749999)return true;
		case 24:if(player.CountItem((22081))>4&&player.CountItem(Addpropermoney(npc))>999999)return true;
		case 25:if(player.CountItem((22082))>4&&player.CountItem(Addpropermoney(npc))>999999)return true;
		case 26:if(player.CountItem((22083))>4&&player.CountItem((22078))>4&&player.CountItem(Addpropermoney(npc))>999999)return true;
		case 27:if(player.CountItem((22085))>4&&player.CountItem((22086))>4&&player.CountItem(Addpropermoney(npc))>999999)return true;
		case 28:if(player.CountItem((22087))>4&&player.CountItem((22088))>4&&player.CountItem((22090))>4&&player.CountItem(Addpropermoney(npc))>999999)return true;
		case 29:if(player.CountItem((22093))>4&&player.CountItem((22074))>4&&player.CountItem((22080))>4&&player.CountItem(Addpropermoney(npc))>999999)return true;
		case 30:if(player.CountItem((22081))>4&&player.CountItem((22082))>4&&player.CountItem((22083))>4&&player.CountItem((22078))>4&&player.CountItem((22085))>4&&player.CountItem((22086))>4&&player.CountItem((22087))>4&&player.CountItem((22088))>4&&player.CountItem((22090))>4&&player.CountItem((22093))>4&&player.CountItem((22074))>4&&player.CountItem((22080))>4&&player.CountItem(Addpropermoney(npc))>2999999)return true;
	} 
	
	return false;
}

bool d_canupgradebanker(Critter&player,Critter@npc)
{
	Map@map=player.GetMap();
	array<Critter@>workers;
	uint workerscount=map.GetCritters(415,(0x20)|(0x0F),workers);
	switch(workerscount)
	{
		case 0:if(player.CountItem((22073))>0&&player.CountItem(Addpropermoney(npc))>74999)return true;
		case 1:if(player.CountItem((22089))>0&&player.CountItem(Addpropermoney(npc))>99999)return true;
		case 2:if(player.CountItem((22091))>0&&player.CountItem((22092))>0&&player.CountItem(Addpropermoney(npc))>149999)return true;
		case 3:if(player.CountItem((22094))>0&&player.CountItem((25476))>0&&player.CountItem(Addpropermoney(npc))>249999)return true;
		case 4:if(player.CountItem((25478))>0&&player.CountItem((25479))>0&&player.CountItem((25480))>0&&player.CountItem(Addpropermoney(npc))>349999)return true;
		case 5:if(player.CountItem((25482))>0&&player.CountItem((25484))>0&&player.CountItem((25487))>0&&player.CountItem(Addpropermoney(npc))>349999)return true;
		case 6:if(player.CountItem((22073))>1&&player.CountItem(Addpropermoney(npc))>349999)return true;
		case 7:if(player.CountItem((22089))>1&&player.CountItem(Addpropermoney(npc))>349999)return true;
		case 8:if(player.CountItem((22091))>1&&player.CountItem((22092))>1&&player.CountItem(Addpropermoney(npc))>349999)return true;
		case 9:if(player.CountItem((22094))>1&&player.CountItem((25476))>1&&player.CountItem(Addpropermoney(npc))>349999)return true;
		case 10:if(player.CountItem((25478))>1&&player.CountItem((25479))>1&&player.CountItem((25480))>1&&player.CountItem(Addpropermoney(npc))>349999)return true;
		case 11:if(player.CountItem((25482))>1&&player.CountItem((25484))>1&&player.CountItem((25487))>1&&player.CountItem(Addpropermoney(npc))>349999)return true;
		case 12:if(player.CountItem((22073))>2&&player.CountItem(Addpropermoney(npc))>499999)return true;
		case 13:if(player.CountItem((22089))>2&&player.CountItem(Addpropermoney(npc))>499999)return true;
		case 14:if(player.CountItem((22091))>2&&player.CountItem((22092))>2&&player.CountItem(Addpropermoney(npc))>499999)return true;
		case 15:if(player.CountItem((22094))>2&&player.CountItem((25476))>2&&player.CountItem(Addpropermoney(npc))>499999)return true;
		case 16:if(player.CountItem((25478))>2&&player.CountItem((25479))>2&&player.CountItem((25480))>2&&player.CountItem(Addpropermoney(npc))>499999)return true;
		case 17:if(player.CountItem((25482))>2&&player.CountItem((25484))>2&&player.CountItem((25487))>2&&player.CountItem(Addpropermoney(npc))>499999)return true;
		case 18:if(player.CountItem((22073))>3&&player.CountItem(Addpropermoney(npc))>749999)return true;
		case 19:if(player.CountItem((22089))>3&&player.CountItem(Addpropermoney(npc))>749999)return true;
		case 20:if(player.CountItem((22091))>3&&player.CountItem((22092))>3&&player.CountItem(Addpropermoney(npc))>749999)return true;
		case 21:if(player.CountItem((22094))>3&&player.CountItem((25476))>3&&player.CountItem(Addpropermoney(npc))>749999)return true;
		case 22:if(player.CountItem((25478))>3&&player.CountItem((25479))>3&&player.CountItem((25480))>3&&player.CountItem(Addpropermoney(npc))>749999)return true;
		case 23:if(player.CountItem((25482))>3&&player.CountItem((25484))>3&&player.CountItem((25487))>3&&player.CountItem(Addpropermoney(npc))>749999)return true;
		case 24:if(player.CountItem((22073))>4&&player.CountItem(Addpropermoney(npc))>999999)return true;
		case 25:if(player.CountItem((22089))>4&&player.CountItem(Addpropermoney(npc))>999999)return true;
		case 26:if(player.CountItem((22091))>4&&player.CountItem((22092))>4&&player.CountItem(Addpropermoney(npc))>999999)return true;
		case 27:if(player.CountItem((22094))>4&&player.CountItem((25476))>4&&player.CountItem(Addpropermoney(npc))>999999)return true;
		case 28:if(player.CountItem((25478))>4&&player.CountItem((25479))>4&&player.CountItem((25480))>4&&player.CountItem(Addpropermoney(npc))>999999)return true;
		case 29:if(player.CountItem((25482))>4&&player.CountItem((25484))>4&&player.CountItem((25487))>4&&player.CountItem(Addpropermoney(npc))>999999)return true;
		case 30:if(player.CountItem((22073))>4&&player.CountItem((22089))>4&&player.CountItem((22091))>4&&player.CountItem((22092))>4&&player.CountItem((22094))>4&&player.CountItem((25476))>4&&player.CountItem((25478))>4&&player.CountItem((25479))>4&&player.CountItem((25480))>4&&player.CountItem((25482))>4&&player.CountItem((25484))>4&&player.CountItem((25487))>4&&player.CountItem(Addpropermoney(npc))>2999999)return true;
	} 
	
	return false;
}

void r_upgradeshop(Critter&player,Critter@npc)
{
	Map@map=player.GetMap();
	array<Critter@>workers;
	uint workerscount=map.GetCritters(416,(0x20)|(0x0F),workers);
	Item@currency=player.GetItem(Addpropermoney(npc),-1);
	Item@condens=player.GetItem((22081),-1);
	Item@trans=player.GetItem((22082),-1);
	Item@wires=player.GetItem((22083),-1);
	Item@engine=player.GetItem((22078),-1);
	Item@ceramis=player.GetItem((22085),-1);
	Item@kevlar=player.GetItem((22086),-1);
	Item@carbon=player.GetItem((22087),-1);
	Item@goretex=player.GetItem((22088),-1);
	Item@polymer=player.GetItem((22090),-1);
	Item@polycar=player.GetItem((22093),-1);
	Item@motor=player.GetItem((22074),-1);
	Item@microchips=player.GetItem((22080),-1);
	
	switch(workerscount)
	{
		case 0:
		if(condens.GetCount()>1)
		condens.SetCount(condens.GetCount()-1);
		else DeleteItem(condens);
		if(currency.GetCount()>75000)
		currency.SetCount(currency.GetCount()-75000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 1:
		if(trans.GetCount()>1)
		trans.SetCount(trans.GetCount()-1);
		else DeleteItem(trans);
		if(currency.GetCount()>100000)
		currency.SetCount(currency.GetCount()-100000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 2:
		if(wires.GetCount()>1)
		wires.SetCount(wires.GetCount()-1);
		else DeleteItem(wires);
		if(engine.GetCount()>1)
		engine.SetCount(engine.GetCount()-1);
		else DeleteItem(engine);
		if(currency.GetCount()>150000)
		currency.SetCount(currency.GetCount()-150000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 3:
		if(ceramis.GetCount()>1)
		ceramis.SetCount(ceramis.GetCount()-1);
		else DeleteItem(ceramis);
		if(kevlar.GetCount()>1)
		kevlar.SetCount(kevlar.GetCount()-1);
		else DeleteItem(kevlar);
		if(currency.GetCount()>250000)
		currency.SetCount(currency.GetCount()-250000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 4:
		if(carbon.GetCount()>1)
		carbon.SetCount(carbon.GetCount()-1);
		else DeleteItem(carbon);
		if(goretex.GetCount()>1)
		goretex.SetCount(goretex.GetCount()-1);
		else DeleteItem(goretex);
		if(polymer.GetCount()>1)
		polymer.SetCount(polymer.GetCount()-1);
		else DeleteItem(polymer);
		if(currency.GetCount()>350000)
		currency.SetCount(currency.GetCount()-350000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 5:
		if(polycar.GetCount()>1)
		polycar.SetCount(polycar.GetCount()-1);
		else DeleteItem(polycar);
		if(motor.GetCount()>1)
		motor.SetCount(motor.GetCount()-1);
		else DeleteItem(motor);
		if(microchips.GetCount()>1)
		microchips.SetCount(microchips.GetCount()-1);
		else DeleteItem(microchips);
		if(currency.GetCount()>350000)
		currency.SetCount(currency.GetCount()-350000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 6:
		if(condens.GetCount()>2)
		condens.SetCount(condens.GetCount()-2);
		else DeleteItem(condens);
		if(currency.GetCount()>350000)
		currency.SetCount(currency.GetCount()-350000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 7:
		if(trans.GetCount()>2)
		trans.SetCount(trans.GetCount()-2);
		else DeleteItem(trans);
		if(currency.GetCount()>350000)
		currency.SetCount(currency.GetCount()-350000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 8:
		if(wires.GetCount()>2)
		wires.SetCount(wires.GetCount()-2);
		else DeleteItem(wires);
		if(engine.GetCount()>2)
		engine.SetCount(engine.GetCount()-2);
		else DeleteItem(engine);
		if(currency.GetCount()>350000)
		currency.SetCount(currency.GetCount()-350000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 9:
		if(ceramis.GetCount()>2)
		ceramis.SetCount(ceramis.GetCount()-2);
		else DeleteItem(ceramis);
		if(kevlar.GetCount()>2)
		kevlar.SetCount(kevlar.GetCount()-2);
		else DeleteItem(kevlar);
		if(currency.GetCount()>350000)
		currency.SetCount(currency.GetCount()-350000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 10:
		if(carbon.GetCount()>2)
		carbon.SetCount(carbon.GetCount()-2);
		else DeleteItem(carbon);
		if(goretex.GetCount()>2)
		goretex.SetCount(goretex.GetCount()-2);
		else DeleteItem(goretex);
		if(polymer.GetCount()>2)
		polymer.SetCount(polymer.GetCount()-2);
		else DeleteItem(polymer);
		if(currency.GetCount()>350000)
		currency.SetCount(currency.GetCount()-350000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 11:
		if(polycar.GetCount()>2)
		polycar.SetCount(polycar.GetCount()-2);
		else DeleteItem(polycar);
		if(motor.GetCount()>2)
		motor.SetCount(motor.GetCount()-2);
		else DeleteItem(motor);
		if(microchips.GetCount()>2)
		microchips.SetCount(microchips.GetCount()-2);
		else DeleteItem(microchips);
		if(currency.GetCount()>350000)
		currency.SetCount(currency.GetCount()-350000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 12:
		if(condens.GetCount()>3)
		condens.SetCount(condens.GetCount()-3);
		else DeleteItem(condens);
		if(currency.GetCount()>500000)
		currency.SetCount(currency.GetCount()-500000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 13:
		if(trans.GetCount()>3)
		trans.SetCount(trans.GetCount()-3);
		else DeleteItem(trans);
		if(currency.GetCount()>500000)
		currency.SetCount(currency.GetCount()-500000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 14:
		if(wires.GetCount()>3)
		wires.SetCount(wires.GetCount()-3);
		else DeleteItem(wires);
		if(engine.GetCount()>3)
		engine.SetCount(engine.GetCount()-3);
		else DeleteItem(engine);
		if(currency.GetCount()>500000)
		currency.SetCount(currency.GetCount()-500000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 15:
		if(ceramis.GetCount()>3)
		ceramis.SetCount(ceramis.GetCount()-3);
		else DeleteItem(ceramis);
		if(kevlar.GetCount()>3)
		kevlar.SetCount(kevlar.GetCount()-3);
		else DeleteItem(kevlar);
		if(currency.GetCount()>500000)
		currency.SetCount(currency.GetCount()-500000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 16:
		if(carbon.GetCount()>3)
		carbon.SetCount(carbon.GetCount()-3);
		else DeleteItem(carbon);
		if(goretex.GetCount()>3)
		goretex.SetCount(goretex.GetCount()-3);
		else DeleteItem(goretex);
		if(polymer.GetCount()>3)
		polymer.SetCount(polymer.GetCount()-3);
		else DeleteItem(polymer);
		if(currency.GetCount()>500000)
		currency.SetCount(currency.GetCount()-500000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 17:
		if(polycar.GetCount()>3)
		polycar.SetCount(polycar.GetCount()-3);
		else DeleteItem(polycar);
		if(motor.GetCount()>3)
		motor.SetCount(motor.GetCount()-3);
		else DeleteItem(motor);
		if(microchips.GetCount()>3)
		microchips.SetCount(microchips.GetCount()-3);
		else DeleteItem(microchips);
		if(currency.GetCount()>500000)
		currency.SetCount(currency.GetCount()-500000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 18:
		if(condens.GetCount()>4)
		condens.SetCount(condens.GetCount()-4);
		else DeleteItem(condens);
		if(currency.GetCount()>750000)
		currency.SetCount(currency.GetCount()-750000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 19:
		if(trans.GetCount()>4)
		trans.SetCount(trans.GetCount()-4);
		else DeleteItem(trans);
		if(currency.GetCount()>750000)
		currency.SetCount(currency.GetCount()-750000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 20:
		if(wires.GetCount()>4)
		wires.SetCount(wires.GetCount()-4);
		else DeleteItem(wires);
		if(engine.GetCount()>4)
		engine.SetCount(engine.GetCount()-4);
		else DeleteItem(engine);
		if(currency.GetCount()>750000)
		currency.SetCount(currency.GetCount()-750000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		case 21:
		if(ceramis.GetCount()>4)
		ceramis.SetCount(ceramis.GetCount()-4);
		else DeleteItem(ceramis);
		if(kevlar.GetCount()>4)
		kevlar.SetCount(kevlar.GetCount()-4);
		else DeleteItem(kevlar);
		if(currency.GetCount()>750000)
		currency.SetCount(currency.GetCount()-750000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 22:
		if(carbon.GetCount()>4)
		carbon.SetCount(carbon.GetCount()-4);
		else DeleteItem(carbon);
		if(goretex.GetCount()>4)
		goretex.SetCount(goretex.GetCount()-4);
		else DeleteItem(goretex);
		if(polymer.GetCount()>4)
		polymer.SetCount(polymer.GetCount()-4);
		else DeleteItem(polymer);
		if(currency.GetCount()>750000)
		currency.SetCount(currency.GetCount()-750000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 23:
		if(polycar.GetCount()>4)
		polycar.SetCount(polycar.GetCount()-4);
		else DeleteItem(polycar);
		if(motor.GetCount()>4)
		motor.SetCount(motor.GetCount()-4);
		else DeleteItem(motor);
		if(microchips.GetCount()>4)
		microchips.SetCount(microchips.GetCount()-4);
		else DeleteItem(microchips);
		if(currency.GetCount()>750000)
		currency.SetCount(currency.GetCount()-750000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 24:
		if(condens.GetCount()>5)
		condens.SetCount(condens.GetCount()-5);
		else DeleteItem(condens);
		if(currency.GetCount()>1000000)
		currency.SetCount(currency.GetCount()-1000000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 25:
		if(trans.GetCount()>5)
		trans.SetCount(trans.GetCount()-5);
		else DeleteItem(trans);
		if(currency.GetCount()>1000000)
		currency.SetCount(currency.GetCount()-1000000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 26:
		if(wires.GetCount()>5)
		wires.SetCount(wires.GetCount()-5);
		else DeleteItem(wires);
		if(engine.GetCount()>5)
		engine.SetCount(engine.GetCount()-5);
		else DeleteItem(engine);
		if(currency.GetCount()>1000000)
		currency.SetCount(currency.GetCount()-1000000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 27:
		if(ceramis.GetCount()>5)
		ceramis.SetCount(ceramis.GetCount()-5);
		else DeleteItem(ceramis);
		if(kevlar.GetCount()>5)
		kevlar.SetCount(kevlar.GetCount()-5);
		else DeleteItem(kevlar);
		if(currency.GetCount()>1000000)
		currency.SetCount(currency.GetCount()-1000000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 28:
		if(carbon.GetCount()>5)
		carbon.SetCount(carbon.GetCount()-5);
		else DeleteItem(carbon);
		if(goretex.GetCount()>5)
		goretex.SetCount(goretex.GetCount()-5);
		else DeleteItem(goretex);
		if(polymer.GetCount()>5)
		polymer.SetCount(polymer.GetCount()-5);
		else DeleteItem(polymer);
		if(currency.GetCount()>1000000)
		currency.SetCount(currency.GetCount()-1000000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 29:
		if(polycar.GetCount()>5)
		polycar.SetCount(polycar.GetCount()-5);
		else DeleteItem(polycar);
		if(motor.GetCount()>5)
		motor.SetCount(motor.GetCount()-5);
		else DeleteItem(motor);
		if(microchips.GetCount()>5)
		microchips.SetCount(microchips.GetCount()-5);
		else DeleteItem(microchips);
		if(currency.GetCount()>1000000)
		currency.SetCount(currency.GetCount()-1000000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
		case 30:
		if(condens.GetCount()>5)
		condens.SetCount(condens.GetCount()-5);
		if(trans.GetCount()>5)
		trans.SetCount(trans.GetCount()-5);
		if(wires.GetCount()>5)
		wires.SetCount(wires.GetCount()-5);
		else DeleteItem(wires);
		if(engine.GetCount()>5)
		engine.SetCount(engine.GetCount()-5);
		if(ceramis.GetCount()>5)
		ceramis.SetCount(ceramis.GetCount()-5);
		else DeleteItem(ceramis);
		if(kevlar.GetCount()>5)
		kevlar.SetCount(kevlar.GetCount()-5);
		if(carbon.GetCount()>5)
		carbon.SetCount(carbon.GetCount()-5);
		else DeleteItem(carbon);
		if(goretex.GetCount()>5)
		goretex.SetCount(goretex.GetCount()-5);
		else DeleteItem(goretex);
		if(polymer.GetCount()>5)
		polymer.SetCount(polymer.GetCount()-5);
		if(polycar.GetCount()>5)
		polycar.SetCount(polycar.GetCount()-5);
		else DeleteItem(polycar);
		if(motor.GetCount()>5)
		motor.SetCount(motor.GetCount()-5);
		else DeleteItem(motor);
		if(microchips.GetCount()>5)
		microchips.SetCount(microchips.GetCount()-5);
		else DeleteItem(microchips);
		if(currency.GetCount()>3000000)
		currency.SetCount(currency.GetCount()-3000000);
		else DeleteItem(currency);
		r_recruit(player,npc,2,0,5);
		break;
	}
}

void r_upgradebanker(Critter&player,Critter@npc)
{
	Map@map=player.GetMap();
	array<Critter@>workers;
	uint workerscount=map.GetCritters(415,(0x20)|(0x0F),workers);
	Item@currency=player.GetItem(Addpropermoney(npc),-1);
	Item@condens=player.GetItem((22073),-1);
	Item@trans=player.GetItem((22089),-1);
	Item@wires=player.GetItem((22091),-1);
	Item@engine=player.GetItem((22092),-1);
	Item@ceramis=player.GetItem((22094),-1);
	Item@kevlar=player.GetItem((25476),-1);
	Item@carbon=player.GetItem((25478),-1);
	Item@goretex=player.GetItem((25479),-1);
	Item@polymer=player.GetItem((25480),-1);
	Item@polycar=player.GetItem((25482),-1);
	Item@motor=player.GetItem((25484),-1);
	Item@microchips=player.GetItem((25487),-1);
	
	switch(workerscount)
	{
		case 0:
		if(condens.GetCount()>1)
		condens.SetCount(condens.GetCount()-1);
		else DeleteItem(condens);
		if(currency.GetCount()>75000)
		currency.SetCount(currency.GetCount()-75000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 1:
		if(trans.GetCount()>1)
		trans.SetCount(trans.GetCount()-1);
		else DeleteItem(trans);
		if(currency.GetCount()>100000)
		currency.SetCount(currency.GetCount()-100000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 2:
		if(wires.GetCount()>1)
		wires.SetCount(wires.GetCount()-1);
		else DeleteItem(wires);
		if(engine.GetCount()>1)
		engine.SetCount(engine.GetCount()-1);
		else DeleteItem(engine);
		if(currency.GetCount()>150000)
		currency.SetCount(currency.GetCount()-150000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 3:
		if(ceramis.GetCount()>1)
		ceramis.SetCount(ceramis.GetCount()-1);
		else DeleteItem(ceramis);
		if(kevlar.GetCount()>1)
		kevlar.SetCount(kevlar.GetCount()-1);
		else DeleteItem(kevlar);
		if(currency.GetCount()>250000)
		currency.SetCount(currency.GetCount()-250000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 4:
		if(carbon.GetCount()>1)
		carbon.SetCount(carbon.GetCount()-1);
		else DeleteItem(carbon);
		if(goretex.GetCount()>1)
		goretex.SetCount(goretex.GetCount()-1);
		else DeleteItem(goretex);
		if(polymer.GetCount()>1)
		polymer.SetCount(polymer.GetCount()-1);
		else DeleteItem(polymer);
		if(currency.GetCount()>350000)
		currency.SetCount(currency.GetCount()-350000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 5:
		if(polycar.GetCount()>1)
		polycar.SetCount(polycar.GetCount()-1);
		else DeleteItem(polycar);
		if(motor.GetCount()>1)
		motor.SetCount(motor.GetCount()-1);
		else DeleteItem(motor);
		if(microchips.GetCount()>1)
		microchips.SetCount(microchips.GetCount()-1);
		else DeleteItem(microchips);
		if(currency.GetCount()>350000)
		currency.SetCount(currency.GetCount()-350000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 6:
		if(condens.GetCount()>2)
		condens.SetCount(condens.GetCount()-2);
		else DeleteItem(condens);
		if(currency.GetCount()>350000)
		currency.SetCount(currency.GetCount()-350000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 7:
		if(trans.GetCount()>2)
		trans.SetCount(trans.GetCount()-2);
		else DeleteItem(trans);
		if(currency.GetCount()>350000)
		currency.SetCount(currency.GetCount()-350000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 8:
		if(wires.GetCount()>2)
		wires.SetCount(wires.GetCount()-2);
		else DeleteItem(wires);
		if(engine.GetCount()>2)
		engine.SetCount(engine.GetCount()-2);
		else DeleteItem(engine);
		if(currency.GetCount()>350000)
		currency.SetCount(currency.GetCount()-350000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 9:
		if(ceramis.GetCount()>2)
		ceramis.SetCount(ceramis.GetCount()-2);
		else DeleteItem(ceramis);
		if(kevlar.GetCount()>2)
		kevlar.SetCount(kevlar.GetCount()-2);
		else DeleteItem(kevlar);
		if(currency.GetCount()>350000)
		currency.SetCount(currency.GetCount()-350000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 10:
		if(carbon.GetCount()>2)
		carbon.SetCount(carbon.GetCount()-2);
		else DeleteItem(carbon);
		if(goretex.GetCount()>2)
		goretex.SetCount(goretex.GetCount()-2);
		else DeleteItem(goretex);
		if(polymer.GetCount()>2)
		polymer.SetCount(polymer.GetCount()-2);
		else DeleteItem(polymer);
		if(currency.GetCount()>350000)
		currency.SetCount(currency.GetCount()-350000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 11:
		if(polycar.GetCount()>2)
		polycar.SetCount(polycar.GetCount()-2);
		else DeleteItem(polycar);
		if(motor.GetCount()>2)
		motor.SetCount(motor.GetCount()-2);
		else DeleteItem(motor);
		if(microchips.GetCount()>2)
		microchips.SetCount(microchips.GetCount()-2);
		else DeleteItem(microchips);
		if(currency.GetCount()>350000)
		currency.SetCount(currency.GetCount()-350000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 12:
		if(condens.GetCount()>3)
		condens.SetCount(condens.GetCount()-3);
		else DeleteItem(condens);
		if(currency.GetCount()>500000)
		currency.SetCount(currency.GetCount()-500000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 13:
		if(trans.GetCount()>3)
		trans.SetCount(trans.GetCount()-3);
		else DeleteItem(trans);
		if(currency.GetCount()>500000)
		currency.SetCount(currency.GetCount()-500000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 14:
		if(wires.GetCount()>3)
		wires.SetCount(wires.GetCount()-3);
		else DeleteItem(wires);
		if(engine.GetCount()>3)
		engine.SetCount(engine.GetCount()-3);
		else DeleteItem(engine);
		if(currency.GetCount()>500000)
		currency.SetCount(currency.GetCount()-500000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 15:
		if(ceramis.GetCount()>3)
		ceramis.SetCount(ceramis.GetCount()-3);
		else DeleteItem(ceramis);
		if(kevlar.GetCount()>3)
		kevlar.SetCount(kevlar.GetCount()-3);
		else DeleteItem(kevlar);
		if(currency.GetCount()>500000)
		currency.SetCount(currency.GetCount()-500000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 16:
		if(carbon.GetCount()>3)
		carbon.SetCount(carbon.GetCount()-3);
		else DeleteItem(carbon);
		if(goretex.GetCount()>3)
		goretex.SetCount(goretex.GetCount()-3);
		else DeleteItem(goretex);
		if(polymer.GetCount()>3)
		polymer.SetCount(polymer.GetCount()-3);
		else DeleteItem(polymer);
		if(currency.GetCount()>500000)
		currency.SetCount(currency.GetCount()-500000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 17:
		if(polycar.GetCount()>3)
		polycar.SetCount(polycar.GetCount()-3);
		else DeleteItem(polycar);
		if(motor.GetCount()>3)
		motor.SetCount(motor.GetCount()-3);
		else DeleteItem(motor);
		if(microchips.GetCount()>3)
		microchips.SetCount(microchips.GetCount()-3);
		else DeleteItem(microchips);
		if(currency.GetCount()>500000)
		currency.SetCount(currency.GetCount()-500000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 18:
		if(condens.GetCount()>4)
		condens.SetCount(condens.GetCount()-4);
		else DeleteItem(condens);
		if(currency.GetCount()>750000)
		currency.SetCount(currency.GetCount()-750000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 19:
		if(trans.GetCount()>4)
		trans.SetCount(trans.GetCount()-4);
		else DeleteItem(trans);
		if(currency.GetCount()>750000)
		currency.SetCount(currency.GetCount()-750000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 20:
		if(wires.GetCount()>4)
		wires.SetCount(wires.GetCount()-4);
		else DeleteItem(wires);
		if(engine.GetCount()>4)
		engine.SetCount(engine.GetCount()-4);
		else DeleteItem(engine);
		if(currency.GetCount()>750000)
		currency.SetCount(currency.GetCount()-750000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		case 21:
		if(ceramis.GetCount()>4)
		ceramis.SetCount(ceramis.GetCount()-4);
		else DeleteItem(ceramis);
		if(kevlar.GetCount()>4)
		kevlar.SetCount(kevlar.GetCount()-4);
		else DeleteItem(kevlar);
		if(currency.GetCount()>750000)
		currency.SetCount(currency.GetCount()-750000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 22:
		if(carbon.GetCount()>4)
		carbon.SetCount(carbon.GetCount()-4);
		else DeleteItem(carbon);
		if(goretex.GetCount()>4)
		goretex.SetCount(goretex.GetCount()-4);
		else DeleteItem(goretex);
		if(polymer.GetCount()>4)
		polymer.SetCount(polymer.GetCount()-4);
		else DeleteItem(polymer);
		if(currency.GetCount()>750000)
		currency.SetCount(currency.GetCount()-750000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 23:
		if(polycar.GetCount()>4)
		polycar.SetCount(polycar.GetCount()-4);
		else DeleteItem(polycar);
		if(motor.GetCount()>4)
		motor.SetCount(motor.GetCount()-4);
		else DeleteItem(motor);
		if(microchips.GetCount()>4)
		microchips.SetCount(microchips.GetCount()-4);
		else DeleteItem(microchips);
		if(currency.GetCount()>750000)
		currency.SetCount(currency.GetCount()-750000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 24:
		if(condens.GetCount()>5)
		condens.SetCount(condens.GetCount()-5);
		else DeleteItem(condens);
		if(currency.GetCount()>1000000)
		currency.SetCount(currency.GetCount()-1000000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 25:
		if(trans.GetCount()>5)
		trans.SetCount(trans.GetCount()-5);
		else DeleteItem(trans);
		if(currency.GetCount()>1000000)
		currency.SetCount(currency.GetCount()-1000000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 26:
		if(wires.GetCount()>5)
		wires.SetCount(wires.GetCount()-5);
		else DeleteItem(wires);
		if(engine.GetCount()>5)
		engine.SetCount(engine.GetCount()-5);
		else DeleteItem(engine);
		if(currency.GetCount()>1000000)
		currency.SetCount(currency.GetCount()-1000000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 27:
		if(ceramis.GetCount()>5)
		ceramis.SetCount(ceramis.GetCount()-5);
		else DeleteItem(ceramis);
		if(kevlar.GetCount()>5)
		kevlar.SetCount(kevlar.GetCount()-5);
		else DeleteItem(kevlar);
		if(currency.GetCount()>1000000)
		currency.SetCount(currency.GetCount()-1000000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 28:
		if(carbon.GetCount()>5)
		carbon.SetCount(carbon.GetCount()-5);
		else DeleteItem(carbon);
		if(goretex.GetCount()>5)
		goretex.SetCount(goretex.GetCount()-5);
		else DeleteItem(goretex);
		if(polymer.GetCount()>5)
		polymer.SetCount(polymer.GetCount()-5);
		else DeleteItem(polymer);
		if(currency.GetCount()>1000000)
		currency.SetCount(currency.GetCount()-1000000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 29:
		if(polycar.GetCount()>5)
		polycar.SetCount(polycar.GetCount()-5);
		else DeleteItem(polycar);
		if(motor.GetCount()>5)
		motor.SetCount(motor.GetCount()-5);
		else DeleteItem(motor);
		if(microchips.GetCount()>5)
		microchips.SetCount(microchips.GetCount()-5);
		else DeleteItem(microchips);
		if(currency.GetCount()>1000000)
		currency.SetCount(currency.GetCount()-1000000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
		case 30:
		if(condens.GetCount()>5)
		condens.SetCount(condens.GetCount()-5);
		if(trans.GetCount()>5)
		trans.SetCount(trans.GetCount()-5);
		if(wires.GetCount()>5)
		wires.SetCount(wires.GetCount()-5);
		else DeleteItem(wires);
		if(engine.GetCount()>5)
		engine.SetCount(engine.GetCount()-5);
		if(ceramis.GetCount()>5)
		ceramis.SetCount(ceramis.GetCount()-5);
		else DeleteItem(ceramis);
		if(kevlar.GetCount()>5)
		kevlar.SetCount(kevlar.GetCount()-5);
		if(carbon.GetCount()>5)
		carbon.SetCount(carbon.GetCount()-5);
		else DeleteItem(carbon);
		if(goretex.GetCount()>5)
		goretex.SetCount(goretex.GetCount()-5);
		else DeleteItem(goretex);
		if(polymer.GetCount()>5)
		polymer.SetCount(polymer.GetCount()-5);
		if(polycar.GetCount()>5)
		polycar.SetCount(polycar.GetCount()-5);
		else DeleteItem(polycar);
		if(motor.GetCount()>5)
		motor.SetCount(motor.GetCount()-5);
		else DeleteItem(motor);
		if(microchips.GetCount()>5)
		microchips.SetCount(microchips.GetCount()-5);
		else DeleteItem(microchips);
		if(currency.GetCount()>3000000)
		currency.SetCount(currency.GetCount()-3000000);
		else DeleteItem(currency);
		r_recruit(player,npc,11,0,5);
		break;
	}
} 

void dlg_Upgradeshop(Critter&player,Critter@npc,string@text)
{
	Map@map=player.GetMap();
	array<Critter@>workers;
	uint workerscount=map.GetCritters(416,(0x20)|(0x0F),workers);
	switch(workerscount)
	{
		case 0:text+=("$cost"+" 1xCapacitors, 75k currency ");break;
		case 1:text+=("$cost"+" 1xElectrical transformer, 100k currency ");break;
		case 2:text+=("$cost"+" 1xWires, 1x engine, 150k currency ");break;
		case 3:text+=("$cost"+" 1xCeramic plate, 1x kevlar, 250k currency ");break;
		case 4:text+=("$cost"+" 1xGoretex, 1xcarbon polymer,1xpolymer, 350k currency ");break;
		case 5:text+=("$cost"+" 1xpolycarbonate, 1xelectric motor,1xmicrochips, 350k currency ");break;
		case 6:text+=("$cost"+" 2xCapacitors, 350k currency ");break;
		case 7:text+=("$cost"+" 2xElectrical transformer, 350k currency ");break;
		case 8:text+=("$cost"+" 2xWires, 2x engine, 350k currency ");break;
		case 9:text+=("$cost"+" 2xCeramic plate, 2x kevlar, 350k currency ");break;
		case 10:text+=("$cost"+" 2xGoretex, 2xcarbon polymer,2xpolymer, 350k currency ");break;
		case 11:text+=("$cost"+" 2xpolycarbonate, 2xelectric motor,2xmicrochips, 350k currency ");break;
		case 12:text+=("$cost"+" 3xCapacitors, 500k currency ");break;
		case 13:text+=("$cost"+" 3xElectrical transformer, 500k currency ");break;
		case 14:text+=("$cost"+" 3xWires, 3x engine, 500k currency ");break;
		case 15:text+=("$cost"+" 3xCeramic plate, 3x kevlar, 500k currency ");break;
		case 16:text+=("$cost"+" 3xGoretex, 3xcarbon polymer,3xpolymer, 500k currency ");break;
		case 17:text+=("$cost"+" 3xpolycarbonate, 3xelectric motor,3xmicrochips, 500k currency ");break;
		case 18:text+=("$cost"+" 4xCapacitors, 750k currency ");break;
		case 19:text+=("$cost"+" 4xElectrical transformer, 750k currency ");break;
		case 20:text+=("$cost"+" 4xWires, 4x engine, 750k currency ");break;
		case 21:text+=("$cost"+" 4xCeramic plate, 4x kevlar, 750k currency ");break;
		case 22:text+=("$cost"+" 4xGoretex, 4xcarbon polymer,4xpolymer, 750k currency ");break;
		case 23:text+=("$cost"+" 4xpolycarbonate, 4xelectric motor,4xmicrochips, 750k currency ");break;
		case 24:text+=("$cost"+" 5xCapacitors, 1kk currency ");break;
		case 25:text+=("$cost"+" 5xElectrical transformer, 1kk currency ");break;
		case 26:text+=("$cost"+" 5xWires, 5x engine, 1kk currency ");break;
		case 27:text+=("$cost"+" 5xCeramic plate, 5x kevlar, 1kk currency ");break;
		case 28:text+=("$cost"+" 5xGoretex, 5xcarbon polymer,5xpolymer, 1kk currency ");break;
		case 29:text+=("$cost"+" 5xpolycarbonate, 5xelectric motor,5xmicrochips, 1kk currency ");break;
		case 30:text+=("$cost"+" 5x capacitors, 5xElectrical transformer,5xWires, 5x engine,5xCeramic plate, 5x kevlar,5xGoretex, 5xcarbon polymer,5xpolymer,5xpolycarbonate, 5xelectric motor,5xmicrochips, 3kk currency ");break;
		
		case 31:text+=(" can't Upgrade anymore");break;
		
	}
	
}

void dlg_Upgradebanker(Critter&player,Critter@npc,string@text)
{
	Map@map=player.GetMap();
	array<Critter@>workers;
	uint workerscount=map.GetCritters(415,(0x20)|(0x0F),workers);
	switch(workerscount)
	{
		case 0:text+=("$cost"+" 1xDelinker Mechanism, 75k currency ");break;
		case 1:text+=("$cost"+" 1xLeather Hide, 100k currency ");break;
		case 2:text+=("$cost"+" 1xAdv. Polymers, 1x Glass Polymers, 150k currency ");break;
		case 3:text+=("$cost"+" 1xSteel Plate, 1x Absorbers, 250k currency ");break;
		case 4:text+=("$cost"+" 1x Carbon Barrels, 1xCylindrical Lock,1xElectric Amplifier, 350k currency ");break;
		case 5:text+=("$cost"+" 1xHiflo, 1xPlasma Accelerator,1xServomotors, 350k currency ");break;
		case 6:text+=("$cost"+" 2xDelinker Mechanism, 350k currency ");break;
		case 7:text+=("$cost"+" 2xLeather Hide, 350k currency ");break;
		case 8:text+=("$cost"+" 2xAdv. Polymers, 2x Glass Polymers, 350k currency ");break;
		case 9:text+=("$cost"+" 2xSteel Plate, 2x Absorbers, 350k currency ");break;
		case 10:text+=("$cost"+" 2x Carbon Barrels, 2xCylindrical Lock,2xElectric Amplifier, 350k currency ");break;
		case 11:text+=("$cost"+" 2xHiflo, 2xPlasma Accelerator,2xServomotors, 350k currency ");break;
		case 12:text+=("$cost"+" 3xDelinker Mechanism, 500k currency ");break;
		case 13:text+=("$cost"+" 3xLeather Hide, 500k currency ");break;
		case 14:text+=("$cost"+" 3xAdv. Polymers, 3x Glass Polymers, 500k currency ");break;
		case 15:text+=("$cost"+" 3xSteel Plate, 3x Absorbers, 500k currency ");break;
		case 16:text+=("$cost"+" 3x Carbon Barrels, 3xCylindrical Lock,3xElectric Amplifier, 500k currency ");break;
		case 17:text+=("$cost"+" 3xHiflo, 3xPlasma Accelerator,3xServomotors, 500k currency ");break;
		case 18:text+=("$cost"+" 4xDelinker Mechanism, 750k currency ");break;
		case 19:text+=("$cost"+" 4xLeather Hide, 750k currency ");break;
		case 20:text+=("$cost"+" 4xAdv. Polymers, 4x Glass Polymers, 750k currency ");break;
		case 21:text+=("$cost"+" 4xSteel Plate, 4x Absorbers, 750k currency ");break;
		case 22:text+=("$cost"+" 4x Carbon Barrels, 4xCylindrical Lock,4xElectric Amplifier, 750k currency ");break;
		case 23:text+=("$cost"+" 4xHiflo, 4xPlasma Accelerator,4xServomotors, 750k currency ");break;
		case 24:text+=("$cost"+" 5xDelinker Mechanism, 1kk currency ");break;
		case 25:text+=("$cost"+" 5xLeather Hide, 1kk currency ");break;
		case 26:text+=("$cost"+" 5xAdv. Polymers, 5x Glass Polymers, 1kk currency ");break;
		case 27:text+=("$cost"+" 5xSteel Plate, 5x Absorbers, 1kk currency ");break;
		case 28:text+=("$cost"+" 5x Carbon Barrels, 5xCylindrical Lock,5xElectric Amplifier, 1kk currency ");break;
		case 29:text+=("$cost"+" 5xHiflo, 5xPlasma Accelerator,5xServomotors, 1kk currency ");break;
		case 30:text+=("$cost"+" 5x Delinker Mechanism, 5xLeather Hide,5xAdv. Polymers, 5x Glass Polymers,5xSteel Plate, 5x Absorbers,5x Carbon Barrels, 5xCylindrical Lock,5xElectric Amplifier,5xHiflo, 5xPlasma Accelerator,5xServomotors, 3kk currency ");break;
		
		case 31:text+=(" can't Upgrade anymore");break;
		
	}
	
}

void r_move(Critter&player,Critter@npc)
{
	guardsMoveToFreeHex(npc);
}

void r_setcurrency(Critter&player,Critter@npc,int what)
{
	switch(what)
	{
		case 1:npc.ParamBase[(139)]=1;break;
		case 2:npc.ParamBase[(139)]=2;break;
		case 3:npc.ParamBase[(139)]=3;break;
		case 4:npc.ParamBase[(139)]=4;break;
		case 5:npc.ParamBase[(139)]=5;break;
	}
	
	for(int i=0;i<npc.Param[(139)];i++)
	{
		Critter@worker=AddNpc(npc.GetMap(),69,0,i,0,0,"",0,0,0,true,0);
	}
}
void r_restart(Critter&player,Critter@cr)
{
	int generatorCharge=cr.Param[(129)];
	if(generatorCharge>0)
	{
		SwitchGroupLights(cr.GetMap(),5,true);
		changelights(cr,5,0,-1);
		changelights(cr,5,1,45);
	}
	int generatorUse=100;
	generatorUse+=cr.Param[(128)]*50;
	generatorUse+=cr.Param[(127)]*100;
	generatorCharge-=generatorUse;
	cr.ParamBase[(129)]-=generatorUse;
	if(generatorUse<1)
	{
		SwitchGroupLights(cr.GetMap(),5,false);
	}
}

void r_recruit(Critter&player,Critter@npc,int what,int skin,int level)
{
	Map@map=player.GetMap();
	array<Critter@>workers;
	uint workerscount=map.GetCritters(417,(0x20)|(0x0F),workers);
	array<Critter@>Guards;
	uint guardcount=map.GetCritters(422,(0x20)|(0x0F),Guards);
	array<Critter@>caravaners;
	uint caravanerscount=map.GetCritters(416,(0x20)|(0x0F),caravaners);
	array<Critter@>bankers;
	uint bankerscount=map.GetCritters(415,(0x20)|(0x0F),bankers);
	
	uint8 dir;
	uint16 x,y;
	x=y=dir=0;
	dir=Random(0,5);
	switch(what)
	{
		case 1:
		{
			if(workerscount>29)
			{
				npc.Say((2),"We are full, can't take new person for that position");
				return;
			}
			map.GetEntireCoords(5,Random(0,2),x,y);
			Critter@worker=AddNpc(map,417,x,y,dir,9065,"factions_terminal@worker_init",0,0,0,true,Random(level,level*2));
			array<int>skins={6,13,27,31,33,36,37,39,39,39,40,41,42,43,48};
			worker.ChangeCrType(skins[Random(0,14)]);
			map.GetEntireCoords(300,Random(0,175),x,y);
			AddWalkPlane(worker,0,x,y,dir,true,0);
			worker.SetHomePos(x,y,dir);
			worker.ParamBase[(106)]=player.Param[(106)];
			worker.ParamBase[(139)]=npc.Param[(139)];
			worker.ParamBase[(84)]=1200;
			worker.ParamBase[(511)]=1;
			worker.ParamBase[(532)]=1;
			worker.ParamBase[(523)]=1;
			worker.ParamBase[(512)]=0;
			worker.ParamBase[(541)]=0;
			break;
		}
		case 2:
		{
			map.GetEntireCoords(6,Random(0,2),x,y);
			Critter@worker=AddNpc(map,416,x,y,dir,9067,"",0,0,0,true,Random(level,level*2));
			array<int>skins={6,13,27,31,33,36,37,39,39,39,40,41,42,43,48};
			worker.ChangeCrType(skins[Random(0,14)]);
			map.GetEntireCoords(400,Random(0,39),x,y);
			AddWalkPlane(worker,0,x,y,dir,true,0);
			worker.SetHomePos(x,y,dir);
			worker.ParamBase[(106)]=player.Param[(106)];
			worker.ParamBase[(139)]=npc.Param[(139)];
			npc.ParamBase[(126)]+=1;
			worker.ParamBase[(84)]=1200;
		}
		break;
		case 3:
		{
			if(guardcount>24)
			{
				npc.Say((2),"We are full, can't take new person for that position");
				return;
			}
			map.GetEntireCoords(5,Random(0,2),x,y);
			Critter@worker=AddNpc(map,422,x,y,dir,9066,"factions_terminal@guard_init",0,0,0,true,level);
			worker.ChangeCrType(skin);
			giveres(worker,skin);
			uint entires=worker.GetMap().CountEntire(150);
			bool heisonplace=false;
			while(!heisonplace)
			{
				worker.GetMap().GetEntireCoords(150,Random(0,entires),x,y);
				
				if(map.IsHexPassed(x,y))
				{
					AddWalkPlane(worker,0,x,y,dir,true,0);
					worker.SetHomePos(x,y,dir);
					return;
				}
				else worker.GetMap().GetEntireCoords(150,Random(0,entires),x,y);
			}
			worker.ParamBase[(106)]=player.Param[(106)];
			worker.ParamBase[(521)]=1;
			worker.ParamBase[(139)]=npc.Param[(139)];
			break;
		}
		case 4:
		{
			Critter@worker=AddNpc(map,666,0,0,dir,9066,"",0,0,0,true,level);
			break;
		}
		case 5:
		{
			map.GetEntireCoords(5,Random(0,2),x,y);
			Critter@worker=AddNpc(map,42,x,y,dir,2541,"",0,0,0,true,level);
			worker.ChangeCrType(skin);
			giveres(worker,skin);
			map.GetEntireCoords(159,0,x,y);
			AddWalkPlane(worker,0,x,y,dir,true,0);
			worker.SetHomePos(x,y,dir);
			worker.ParamBase[(106)]=player.Param[(106)];
			worker.ParamBase[(139)]=npc.Param[(139)];
			worker.ParamBase[(84)]=1200;
			worker.ParamBase[(511)]=1;
			worker.ParamBase[(532)]=1;
			worker.ParamBase[(523)]=1;
			worker.ParamBase[(512)]=1;
			worker.ParamBase[(541)]=0;
			break;
		}
		case 6:
		{
			map.GetEntireCoords(5,Random(0,2),x,y);
			Critter@worker=AddNpc(map,36,x,y,dir,9068,"",0,0,0,true,level);
			worker.ChangeCrType(skin);
			giveres(worker,skin);
			map.GetEntireCoords(152,0,x,y);
			AddWalkPlane(worker,0,x,y,dir,true,0);
			worker.SetHomePos(x,y,dir);
			worker.ParamBase[(106)]=player.Param[(106)];
			worker.ParamBase[(139)]=npc.Param[(139)];
			worker.ParamBase[(84)]=1200;
			worker.ParamBase[(511)]=1;
			worker.ParamBase[(532)]=1;
			worker.ParamBase[(523)]=1;
			worker.ParamBase[(512)]=1;
			worker.ParamBase[(541)]=0;
			break;
		}
		case 7:
		{
			map.GetEntireCoords(5,Random(0,2),x,y);
			Critter@worker=AddNpc(map,167,x,y,dir,9300,"factions_terminal@init_banker",0,0,0,true,level);
			
			giveres(worker,skin);
			map.GetEntireCoords(155,0,x,y);
			AddWalkPlane(worker,0,x,y,dir,true,0);
			worker.SetHomePos(x,y,dir);
			worker.ParamBase[(106)]=player.Param[(106)];
			worker.ParamBase[(139)]=6;
			worker.ParamBase[(84)]=1200;
			break;
		}
		case 8:
		{
			map.GetEntireCoords(5,Random(0,2),x,y);
			Critter@worker=AddNpc(map,297,x,y,dir,9069,"",0,0,0,true,level);
			
			giveres(worker,skin);
			map.GetEntireCoords(154,0,x,y);
			AddWalkPlane(worker,0,x,y,dir,true,0);
			worker.SetHomePos(x,y,dir);
			worker.ParamBase[(106)]=player.Param[(106)];
			worker.ParamBase[(139)]=npc.Param[(139)];
			worker.ParamBase[(84)]=1200;
			worker.ParamBase[(511)]=1;
			worker.ParamBase[(532)]=1;
			worker.ParamBase[(523)]=1;
			worker.ParamBase[(512)]=1;
			worker.ParamBase[(541)]=0;
			break;
		}
		case 9:
		{
			map.GetEntireCoords(5,Random(0,2),x,y);
			Critter@worker=AddNpc(map,303,x,y,dir,9070,"",0,0,0,true,level);
			
			giveres(worker,skin);
			map.GetEntireCoords(160,0,x,y);
			AddWalkPlane(worker,0,x,y,dir,true,0);
			worker.SetHomePos(x,y,dir);
			worker.ParamBase[(106)]=player.Param[(106)];
			worker.ParamBase[(139)]=npc.Param[(139)];
			worker.ParamBase[(84)]=1200;
			worker.ParamBase[(511)]=1;
			worker.ParamBase[(532)]=1;
			worker.ParamBase[(523)]=1;
			worker.ParamBase[(512)]=1;
			worker.ParamBase[(541)]=0;
			break;
		}
		case 10:
		{
			map.GetEntireCoords(5,Random(0,2),x,y);
			Critter@worker=AddNpc(map,95,x,y,dir,9064,"factions_terminal@init_trader",0,0,0,true,level);
			
			giveres(worker,skin);
			map.GetEntireCoords(158,0,x,y);
			AddWalkPlane(worker,0,x,y,dir,true,0);
			worker.SetHomePos(x,y,dir);
			worker.ParamBase[(106)]=player.Param[(106)];
			worker.ParamBase[(139)]=npc.Param[(139)];
			worker.ParamBase[(84)]=1200;
			worker.ParamBase[(124)]=1;
			break;
		}
		case 11:
		{
			map.GetEntireCoords(6,Random(0,2),x,y);
			Critter@worker=AddNpc(map,415,x,y,dir,9067,"",0,0,0,true,Random(level,level*2));
			array<int>skins={6,13,27,31,33,36,37,39,39,39,40,41,42,43,48};
			worker.ChangeCrType(skins[Random(0,14)]);
			map.GetEntireCoords(400,Random(0,60),x,y);
			AddWalkPlane(worker,0,x,y,dir,true,0);
			worker.SetHomePos(x,y,dir);
			worker.ParamBase[(106)]=player.Param[(106)];
			worker.ParamBase[(139)]=npc.Param[(139)];
			worker.ParamBase[(84)]=1200;
			npc.ParamBase[(125)]+=1;
			worker.ParamBase[(511)]=1;
			worker.ParamBase[(532)]=1;
			worker.ParamBase[(523)]=1;
			worker.ParamBase[(512)]=0;
			worker.ParamBase[(541)]=0;
			break;
		}
		case 12:
		{
			map.GetEntireCoords(90,0,x,y);
			Critter@worker=AddNpc(map,480,x,y,dir,9064,"factions_terminal@guard_init_turret",0,421,0,true,level);
			
			giveres(worker,skin); 
			
			worker.SetHomePos(x,y,dir);
			worker.ParamBase[(106)]=player.Param[(106)];
			worker.ParamBase[(139)]=npc.Param[(139)];
			worker.ParamBase[(84)]=600;
			worker.ParamBase[(522)]=1;
			worker.ParamBase[(511)]=1;
			worker.ParamBase[(532)]=1;
			worker.ParamBase[(523)]=1;
			worker.ParamBase[(512)]=0;
			worker.ParamBase[(541)]=0;
			break;
		}
		case 13:
		{
			map.GetEntireCoords(91,0,x,y);
			Critter@worker=AddNpc(map,480,x,y,dir,9064,"factions_terminal@guard_init_turret",0,421,0,true,level);
			
			giveres(worker,skin); 
			
			worker.SetHomePos(x,y,dir);
			worker.ParamBase[(106)]=player.Param[(106)];
			worker.ParamBase[(139)]=npc.Param[(139)];
			worker.ParamBase[(84)]=600;
			worker.ParamBase[(522)]=1;
			worker.ParamBase[(511)]=1;
			worker.ParamBase[(532)]=1;
			worker.ParamBase[(523)]=1;
			worker.ParamBase[(512)]=0;
			worker.ParamBase[(541)]=0;
			break;
		}
	}
}

void giveres(Critter@npc,int skin)
{
	int mod=1;
	switch(skin)
	{
		case 1:{mod=4;break;}
		case 71:{mod=5;break;}
		case 140:{mod=3;break;}
		case 12:{mod=1;break;}
		case 14:{mod=2;break;}
		default:mod=1;break;
	}
	npc.ParamBase[(16)]=5*mod;
	npc.ParamBase[(17)]=5*mod;
	npc.ParamBase[(18)]=5*mod;
	npc.ParamBase[(19)]=5*mod;
	npc.ParamBase[(20)]=5*mod;
	npc.ParamBase[(22)]=5*mod;
	
	npc.ParamBase[(23)]=20*mod;
	npc.ParamBase[(24)]=17*mod;
	npc.ParamBase[(25)]=15*mod;
	npc.ParamBase[(26)]=15*mod;
	npc.ParamBase[(27)]=10*mod;
	npc.ParamBase[(29)]=10*mod;
}

void init_manager(Critter&guard,bool firstTime)
{
	if(firstTime)
	{
		guard.ParamBase[(512)]=0;
		guard.ParamBase[(532)]=0;
		guard.ParamBase[(541)]=0;
		guard.ParamBase[(539)]=0;
		guard.ParamBase[(540)]=0;
		guard.ParamBase[(541)]=0;
	}
	array<Critter@>crits2;
	uint m=guard.GetMap().GetCritters(69,(0x0F)|(0x20),crits2);
	array<Critter@>crits;
	uint n=0;
	n=guard.GetMap().GetCritters(0,(0x0F)|(0x20),crits);
	for(uint i=0;i<n;i++)
	{
		if(crits[i].ParamBase[(139)]==6)
		continue;
		crits[i].ParamBase[(139)]=m;
	}
	array<uint>values={guard.Id};
	CreateTimeEvent(((__FullSecond)+(((1)*__TimeMultiplier*60))),"e_income",values,false);
	
}

uint e_income(array<uint>@values)
{
	Critter@cr=GetCritter(values[0]);
	Map@map=cr.GetMap();
	array<Critter@>workers;
	uint workerscount=cr.GetMap().GetCritters(417,(0x20)|(0x03),workers);
	array<Critter@>Guards;
	uint guardcount=cr.GetMap().GetCritters(422,(0x20)|(0x03),Guards);
	array<Critter@>caravaners;
	uint caravanerscount=cr.GetMap().GetCritters(416,(0x20)|(0x03),caravaners);
	
	uint t4count=cr.GetMap().GetCritters(666,(0x20)|(0x03),caravaners);
	array<Item@>items;
	int count=cr.Param[(124)];
	int income=500;
	income+=workerscount*1000;
	income-=guardcount*500;
	
	income-=t4count*50000;
	count+=income;
	if(count<0)
	{
		DeleteLocation(map.GetLocation().Id);
		return 0;
	}
	
	cr.ParamBase[(124)]+=income;
	
	if(cr.Param[(99)]>0)
	{
		int generatorCharge=cr.Param[(129)];
		if(generatorCharge>0)
		{
			SwitchGroupLights(map,5,true);
			changelights(cr,5,0,-1);
			changelights(cr,5,1,99);
		}
		int generatorUse=100;
		generatorUse+=cr.Param[(128)]*50;
		generatorUse+=cr.Param[(127)]*100;
		generatorCharge-=generatorUse;
		cr.ParamBase[(129)]-=generatorUse;
		if(generatorUse<1)
		{
			SwitchGroupLights(map,5,false);
		}
	}
	return((60)*__TimeMultiplier*60);
}

void init_trader(Critter&guard,bool firstTime)
{
	array<uint>values={guard.Id};
	if(firstTime)
	{
		
		guard.ParamBase[(511)]=1;
		guard.ParamBase[(532)]=1;
		guard.ParamBase[(523)]=1;
		guard.ParamBase[(512)]=0;
		guard.ParamBase[(541)]=0;
		guard.ParamBase[(521)]=1;
		
		CreateTimeEvent(((__FullSecond)+(((1)*__TimeMultiplier*60))),"e_fill",values,false);
	}
	
	CreateTimeEvent(((__FullSecond)+(((1)*__TimeMultiplier*60))),"e_fill",values,false); 
	
}

void init_banker(Critter&guard,bool firstTime)
{
	array<uint>values={guard.Id};
	if(firstTime)
	{
		
		guard.ParamBase[(511)]=1;
		guard.ParamBase[(532)]=1;
		guard.ParamBase[(523)]=1;
		guard.ParamBase[(512)]=0;
		guard.ParamBase[(541)]=0;
		guard.ParamBase[(541)]=0;
		guard.ParamBase[(521)]=1;
		
		CreateTimeEvent(((__FullSecond)+(((1)*__TimeMultiplier*60))),"e_fillb",values,false);
	}
	
	CreateTimeEvent(((__FullSecond)+(((1)*__TimeMultiplier*60))),"e_fillb",values,false); 
	
}

uint e_fillb(array<uint>@values)
{
	Critter@cr=GetCritter(values[0]);
	cr.ParamBase[(139)]=6;
	uint ec=0;
	uint bc=0;
	uint nc=0;
	uint vc=0;
	uint mc=0;
	uint eco=5;
	uint bco=5;
	uint nco=5;
	uint vco=5;
	uint mco=5;
	array<Item@>eitems;
	uint e=0;
	e=GetAllItems((1212),eitems);
	for(uint i=0;i<e;i++)
	{
		ec+=eitems[i].GetCount();
	}
	array<Item@>bitems;
	uint b=0;
	b=GetAllItems((1211),bitems);
	for(uint i=0;i<b;i++)
	{
		bc+=bitems[i].GetCount();
	}
	array<Item@>nitems;
	uint n=0;
	n=GetAllItems((1214),nitems);
	for(uint i=0;i<n;i++)
	{
		nc+=nitems[i].GetCount();
	}
	array<Item@>vitems;
	uint v=0;
	v=GetAllItems((1213),vitems);
	for(uint i=0;i<v;i++)
	{
		vc+=vitems[i].GetCount();
	}
	array<Item@>mitems;
	uint m=0;
	m=GetAllItems((1215),mitems);
	for(uint i=0;i<m;i++)
	{
		mc+=mitems[i].GetCount();
	}
	if(ec<bc){eco+=5;bco+=1;}
	if(ec>bc){eco+=1;bco+=5;}
	if(ec==bc){eco+=3;bco+=3;}
	if(ec<nc){eco+=5;nco+=1;}
	if(ec>nc){eco+=1;nco+=5;}
	if(ec==nc){eco+=3;nco+=3;}
	if(ec<vc){eco+=5;vco+=1;}
	if(ec>vc){eco+=1;vco+=5;}
	if(ec==vc){eco+=3;vco+=3;}
	if(ec<mc){eco+=5;mco+=1;}
	if(ec>mc){eco+=1;mco+=5;}
	if(ec==mc){eco+=3;mco+=3;}
	if(bc<nc){bco+=5;nco+=1;}
	if(bc>nc){bco+=1;nco+=5;}
	if(bc==nc){bco+=3;nco+=3;}
	if(bc<vc){bco+=5;vco+=1;}
	if(bc>vc){bco+=1;vco+=5;}
	if(bc==vc){bco+=3;vco+=3;}
	if(bc<mc){bco+=5;mco+=1;}
	if(bc>mc){bco+=1;mco+=5;}
	if(bc==mc){bco+=3;mco+=3;}
	if(nc<vc){nco+=5;vco+=1;}
	if(nc>vc){nco+=1;vco+=5;}
	if(nc==vc){nco+=3;vco+=3;}
	if(nc<mc){nco+=5;mco+=1;}
	if(nc>mc){nco+=1;mco+=5;}
	if(nc==mc){nco+=3;mco+=3;}
	if(mc<vc){mco+=5;vco+=1;}
	if(mc>vc){mco+=1;vco+=5;}
	if(mc==vc){mco+=3;vco+=3;}
	
	cr.ParamBase[(124)]=eco-1;
	cr.ParamBase[(125)]=bco-1;
	cr.ParamBase[(126)]=nco-1;
	cr.ParamBase[(127)]=vco-1;
	cr.ParamBase[(128)]=mco-1;   
	
	array<Item@>items;
	int count=cr.GetItems((0),items);
	if(count>0)
	{
		cr.Animate(0,(28),null,true,true);
		DeleteItems(items);
	}
	array<Critter@>caravaners;
	uint caravanerscount=cr.GetMap().GetCritters(415,(0x20)|(0x03),caravaners);
	cr.AddItem((41),100000*caravanerscount+1);
	cr.AddItem((1212),25000*caravanerscount+1);
	cr.AddItem((1211),25000*caravanerscount+1);
	cr.AddItem((1214),25000*caravanerscount+1);
	cr.AddItem((1213),25000*caravanerscount+1);
	cr.AddItem((1215),25000*caravanerscount+1);
	
	return((60)*__TimeMultiplier*60);
}
uint e_fill(array<uint>@values)
{
	Critter@item=GetCritter(values[0]);
	array<Item@>items;
	int count=item.GetItems((0),items);
	uint money=item.CountItem(Addpropermoney(item));
	if(count>0)
	{
		item.Animate(0,(28),null,true,true);
		DeleteItems(items);
	}
	item.AddItem(Addpropermoney(item),money);
	array<Critter@>caravaners;
	uint caravanerscount=item.GetMap().GetCritters(416,(0x20)|(0x03),caravaners);
	item.ParamBase[(215)]=150-caravanerscount*5;
	for(uint i=1;i<=10+(5*caravanerscount);i++)
	{
		SpawnBuffItem(item,tier3armor());
		SpawnBuffItem(item,tier3helmet());
		SpawnBuffItem(item,tier3weapon());
		item.AddItem(tier3ammo(),Random(20,70)*caravanerscount);
		item.AddItem(tier3drugs(),Random(1,20)*caravanerscount);
	}
	
	int chanceweak=0;
	if(caravanerscount>0)
	chanceweak=caravanerscount*3;
	if(Random(1,100)<chanceweak)
	item.AddItem(tier4ammo(),caravanerscount);
	int chancekeys=0;
	if(caravanerscount>2)
	chancekeys=(caravanerscount-3)*2;
	if(Random(1,100)<chancekeys)
	item.AddItem(rareitem(),1);
	int chancet4part=0;
	if(caravanerscount>5)
	chancet4part=(caravanerscount-6);
	if(Random(1,100)<chancet4part)
	item.AddItem(tier4parts(),1);
	int chancet4bp=0;
	if(caravanerscount>9)
	chancet4bp=(caravanerscount-9)*3;
	if(Random(0,1000)<chancet4bp)
	item.AddItem(tier4bp(),1);
	
	if(Random(0,1000)<chancet4bp)
	item.AddItem(implant(),1);
	int chanceimplant=0;
	if(caravanerscount>14)
	chanceimplant=(caravanerscount-14);
	if(Random(0,1000)<chanceimplant)
	item.AddItem(implant_combat(),1);
	int chanceverti=0;
	if(caravanerscount>19)
	chanceverti=(caravanerscount-19);
	if(Random(0,1000)<chanceverti)
	item.AddItem(verti_parts(),1);
	int t4chance=0;
	if(caravanerscount>24)
	t4chance=(caravanerscount-24)*5;
	if(Random(0,10000)<t4chance)
	item.AddItem(tier4item(),1);
	return((60)*__TimeMultiplier*60);
	
}

import void AddSpecialBonus(Item@it)from"item_bonus";
void SpawnBuffItem(Critter&cr,uint pid)
{
	array<Critter@>caravaners;
	uint caravanerscount=cr.GetMap().GetCritters(416,(0x20)|(0x03),caravaners);
	Item@it=cr.AddItem(pid,1);
	if(caravanerscount==0)
	caravanerscount=1;
	it.Val0+=Random(1,50000)*caravanerscount;
	it.Update();
	if(it.GetType()==(3))
	_weapon_perk(it,false);
	if(it.GetType()==(1))
	_armor_perk(it,false);
}

void SpawnBuffItem(Critter&cr,uint pid,int,int)
{
	Item@it=cr.AddItem(pid,1);
	AddSpecialBonus(it);
}

void guard_init(Critter&cr,bool firstTime)
{
	cr.SetEvent((28),"_SomeoneAttacked");
	cr.SetEvent((16),"_Attacked");
	cr.SetEvent((0),"_Idle"); 
	
	cr.ParamBase[(517)]=0;
	
	cr.ParamBase[(511)]=1;
	cr.ParamBase[(523)]=1;
	cr.ParamBase[(532)]=1;
	cr.ParamBase[(531)]=1;
	cr.ParamBase[(513)]=0;
	cr.ParamBase[(521)]=1;
	cr.ParamBase[(84)]=600;
	cr.ParamBase[(106)]=cr.GetMap().GetData((0));
	if(firstTime)
	{
		guardsMoveToFreeHex(cr);
		
		cr.ParamBase[(302)]+=Random(0,1);
		cr.ParamBase[(306)]=1;
		cr.ParamBase[(305)]+=Random(1,2);
		cr.ParamBase[(303)]+=Random(1,2);
		cr.ParamBase[(512)]=0;
		cr.ParamBase[(541)]=0;
		cr.ParamBase[(521)]=1;
		cr.ParamBase[(84)]=600;
		for(uint i=(200);i<=(205);i++)
		cr.ParamBase[i]=Random(180,240);
		if(cr.GetProtoId()!=422)
		cr.ParamBase[(77)]=Random(45,70);
		cr.ParamBase[(4)]=Random(7,10);
		cr.ParamBase[(1)]=Random(7,10);
		cr.ParamBase[(72)]=cr.Param[(7)];
		cr.ParamBase[(106)]=cr.GetMap().GetData((0));
		
	}
	
}

void guard_init_turret(Critter&cr,bool firstTime)
{
	cr.SetEvent((28),"_SomeoneAttacked");
	cr.SetEvent((16),"_Attacked");
	cr.SetEvent((0),"_Idle2"); 
	
	cr.ParamBase[(517)]=0;
	
	cr.ParamBase[(511)]=1;
	cr.ParamBase[(523)]=1;
	cr.ParamBase[(532)]=1;
	cr.ParamBase[(531)]=1;
	cr.ParamBase[(513)]=0;
	cr.ParamBase[(84)]=600;
	if(firstTime)
	{
		guardsMoveToFreeHex(cr);
		
		cr.ParamBase[(302)]+=Random(0,1);
		cr.ParamBase[(306)]=1;
		cr.ParamBase[(305)]+=Random(1,2);
		cr.ParamBase[(303)]+=Random(1,2);
		cr.ParamBase[(512)]=0;
		cr.ParamBase[(541)]=0;
		cr.ParamBase[(84)]=600;
		for(uint i=(200);i<=(205);i++)
		cr.ParamBase[i]=Random(180,240);
		if(cr.GetProtoId()!=422)
		cr.ParamBase[(77)]=Random(45,70);
		cr.ParamBase[(4)]=Random(7,10);
		cr.ParamBase[(1)]=Random(7,10);
		cr.ParamBase[(72)]=cr.Param[(7)];
		
	}
	CreateTimeEvent(((__FullSecond)+(((1)*__TimeMultiplier*60))),"e_generator_check",cr.Id,false);
}

uint e_generator_check(array<uint>@values)
{
	Critter@cr=GetCritter(values[0]);
	if(!(@cr!=null))
	{
		cr.Say((1),"something wrong");
		return 0;
	}
	array<Critter@>leaders;
	uint caravanerscount=cr.GetMap().GetCritters(279,(0x20)|(0x03),leaders);
	for(uint i=0;i<caravanerscount;i++)
	{
		uint charges=leaders[i].Param[(129)];
		if(charges<1)
		{
			cr.ParamBase[(8)]=-5;
			cr.ParamBase[(129)]=0;
			return((10)*__TimeMultiplier*60);
		}
		if(charges>0)
		{
			if(cr.Param[(129)]<1)
			{
				cr.ParamBase[(8)]=15;
				cr.ParamBase[(129)]=1;
			}
			
		}
		
	}
	
	return((60)*__TimeMultiplier*60);
}

void guard2_init(Critter&cr,bool firstTime)
{
	cr.SetEvent((28),"_SomeoneAttacked");
	cr.SetEvent((16),"_Attacked");
	cr.SetEvent((0),"_Idle2"); 
	
	cr.ParamBase[(517)]=0;
	
	cr.ParamBase[(511)]=1;
	cr.ParamBase[(523)]=1;
	cr.ParamBase[(532)]=1;
	cr.ParamBase[(531)]=1;
	cr.ParamBase[(513)]=0;
	cr.ParamBase[(84)]=600;
	if(firstTime)
	{ 
		
		cr.ParamBase[(302)]+=Random(0,1);
		cr.ParamBase[(306)]=1;
		cr.ParamBase[(305)]+=Random(1,2);
		cr.ParamBase[(303)]+=Random(1,2);
		cr.ParamBase[(512)]=0;
		cr.ParamBase[(541)]=0;
		cr.ParamBase[(84)]=600;
		for(uint i=(200);i<=(205);i++)
		cr.ParamBase[i]=Random(180,240);
		if(cr.GetProtoId()!=422)
		cr.ParamBase[(77)]=Random(45,70);
		cr.ParamBase[(4)]=Random(7,10);
		cr.ParamBase[(1)]=Random(7,10);
		cr.ParamBase[(72)]=cr.Param[(7)];
		
	}
}

void worker_init(Critter&cr,bool firstTime)
{
	cr.SetEvent((28),"_SomeoneAttacked");
	cr.SetEvent((16),"_Attacked");
	cr.SetEvent((2),"_deupgrade_check");
	cr.ParamBase[(511)]=1;
	cr.ParamBase[(523)]=1;
	cr.ParamBase[(532)]=1;
	cr.ParamBase[(531)]=1;
	cr.ParamBase[(513)]=0;
}

void _deupgrade_check(Critter&mob,Critter@killer)
{
	Map@map=mob.GetMap();
	int factionId=map.GetData((0));
	if(killer.IsPlayer()&&killer.Param[(106)]!=factionId)
	killer.ParamBase[(795)]=factionId; 
	
	if(killer.Param[(89)]!=203)
	return;
	CreateTimeEvent(((__FullSecond)+(((1)*__TimeMultiplier))),"deupgrade",mob.Id,false); 
	
} 

void r_fire(Critter&player,Critter@npc)
{
	array<Item@>fire;
	uint numlockers=npc.GetMap().GetItems((608),fire);
	Item@currency=player.GetItem(Addpropermoney(npc),-1);
	if(numlockers==0)
	{
		npc.Say((2),"There is no fire");
		return;
	}
	if(player.CountItem(Addpropermoney(npc))<1000)
	{
		npc.Say((2),"We need 1000 currency to fix this problem");
		return;
	}
	
	DeleteItem(fire[0]);
	if(currency.GetCount()>1000)
	currency.SetCount(currency.GetCount()-1000);
	else DeleteItem(currency);
	
}
uint deupgrade(array<uint>@values)
{
	Map@map=GetCritter(values[0]).GetMap();
	DeleteNpc(GetCritter(values[0]));
	array<Critter@>caravaners;
	uint caravanerscount=map.GetCritters(416,(0x20)|(0x0F),caravaners);
	array<Critter@>bankers;
	uint bankerscount=map.GetCritters(415,(0x20)|(0x0F),bankers);
	array<Critter@>workers;
	uint workerscount=map.GetCritters(417,(0x20)|(0x0F),workers);
	
	uint16 x,y;
	x=y=0;
	for(int i=0;i<20;i++)
	{
		map.GetEntireCoords(900+i,0,x,y);
		x+=Random(0,2);
		y+=Random(0,2);
		Item@it=map.AddItem(x,y,(608),1);
	}
	if(workerscount-1>0)
	{
		
		return 0;
	}
	
	bool notcaravaners=false;
	if(caravanerscount<1)
	{
		notcaravaners=true;
		
	}
	
	bool notbankers=false;
	if(bankerscount<1)
	{
		notbankers=true;
		
	} 
	
	if(!notcaravaners)
	{
		DeleteNpc(caravaners[0]);
		
	}
	if(!notbankers)
	{
		DeleteNpc(bankers[0]);
		
	}
	
	if(notcaravaners&&notbankers)
	{
		DeleteLocation(map.GetLocation().Id);
		
	}
	
	return 0;
}

void guardsMoveToFreeHex(Critter&cr)
{
	uint8 dir=Random(0,5);
	uint16 x,y;
	x=y=0;
	uint entires=cr.GetMap().CountEntire(150);
	bool heisonplace=false;
	while(!heisonplace)
	{
		cr.GetMap().GetEntireCoords(150,Random(0,entires),x,y);
		
		if(cr.GetMap().IsHexPassed(x,y))
		{
			AddWalkPlane(cr,0,x,y,dir,true,0);
			cr.SetHomePos(x,y,dir);
			return;
		}
		else cr.GetMap().GetEntireCoords(150,Random(0,entires),x,y);
	}
}

void _Idle(Critter&cr)
{
	cr.ParamBase[(106)]=cr.GetMap().GetData((0));
	if(Random(0,99)==0)
	guardsMoveToFreeHex(cr);
	if(Random(0,300)==0)
	ReloadWeapon(cr);
}

void _Idle2(Critter&cr)
{
	if(Random(0,300)==0)
	ReloadWeapon(cr);
}

bool _Attacked(Critter&follower,Critter&attacker)
{
	
	if(IsFriend(follower,attacker))
	{
		follower.ErasePlane((1),true);
		return true;
	}
	return false;
}

bool IsFriend(Critter&cr,Critter&target)
{
	if(target.Param[(106)]==cr.Param[(106)])
	return true;
	else return false;
	
}

void _SomeoneAttacked(Critter&cr,Critter&fromCrit,Critter&target)
{
	int factionId=cr.GetMap().GetData((0));
	
	if(IsFriend(cr,fromCrit)&&!(IsFriend(cr,target)))
	AttackCritter(cr,target,__DeadHitPoints); 
	
	if(IsFriend(cr,target)&&!IsFriend(cr,fromCrit))
	AttackCritter(cr,fromCrit,__DeadHitPoints); 
	
	if(!IsFriend(cr,fromCrit))
	AttackCritter(cr,fromCrit,__DeadHitPoints);
	
	array<Critter@>players;
	uint num=GetAllOnlinePlayers(players);
	for(uint i=0;i<num;i++)
	{
		if(players[i].Param[(106)]!=factionId)
		continue;
		if(fromCrit.IsPlayer())
		players[i].Say((11),"|"+getfactionprefix(factionId)+" [FACTION]Settlement Guard: "+fromCrit.Name+" started attacking us ");
	}
	string factionname;
	GetFactionNameStr(factionId,factionname);
	for(uint i=0;i<num;i++)
	{
		if(players[i].GetAccess()!=(3))
		continue;
		players[i].Say((11),"|-65536 "+cr.Name+" attacking in settlement of "+factionname);
	}
}

bool d_canlevelup(Critter&player,Critter@npc)
{
	int capssum=player.CountItem(Addpropermoney(npc));
	return(npc.Param[(77)]*5000<capssum);
}
import int NextLevelNeedExp(Critter&cr)from"parameters";

void r_canlevelup(Critter&player,Critter@npc)
{
	int capssum=player.CountItem(Addpropermoney(npc));
	int price=npc.Param[(77)]*500;
	BanksTransferFromCritter(player,price,(0),false);
	npc.ParamBase[(76)]=NextLevelNeedExp(npc);
}
import Item@ArmBestWeapon(Critter&critter)from"npc_common";
void r_ArmBestWeapon(Critter&player,Critter@follower)
{
	ArmBestWeapon(follower);
}

void r_faction(Critter&player,Critter@follower)
{
	follower.ParamBase[(106)]=player.Param[(106)];
} 

void map_init(Map&map,bool firstTime)
{ 
	
	map.SetEvent((6),"_OnEnterMap");
	CreateTimeEvent(((__FullSecond)+(((Random(1740,1860))*__TimeMultiplier*60))),"prepare_raid",map.Id,false);
}

uint getfactionprefix(uint factionId)
{
	
	switch(factionId)
	{
		case 2:return(uint((0xFF<<24)|(((255)&0xFF)<<16)|(((255)&0xFF)<<8)|((255)&0xFF)));
		case 3:return(uint((0xFF<<24)|(((166)&0xFF)<<16)|(((166)&0xFF)<<8)|((166)&0xFF)));
		case 4:return(uint((0xFF<<24)|(((255)&0xFF)<<16)|(((0)&0xFF)<<8)|((102)&0xFF)));
		case 5:return(uint((0xFF<<24)|(((230)&0xFF)<<16)|(((150)&0xFF)<<8)|((14)&0xFF)));
		case 6:return(uint((0xFF<<24)|(((14)&0xFF)<<16)|(((88)&0xFF)<<8)|((203)&0xFF)));
		case 7:return(uint((0xFF<<24)|(((255)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)));
		case 23:return(uint((0xFF<<24)|(((14)&0xFF)<<16)|(((154)&0xFF)<<8)|((233)&0xFF)));
		case 44:return(uint((0xFF<<24)|(((0)&0xFF)<<16)|(((184)&0xFF)<<8)|((46)&0xFF)));
		case 47:return(uint((0xFF<<24)|(((255)&0xFF)<<16)|(((255)&0xFF)<<8)|((0)&0xFF)));
		case 49:return(uint((0xFF<<24)|(((136)&0xFF)<<16)|(((0)&0xFF)<<8)|((200)&0xFF)));
		case 51:return(uint((0xFF<<24)|(((255)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)));
		case 64:return(uint((0xFF<<24)|(((0)&0xFF)<<16)|(((255)&0xFF)<<8)|((255)&0xFF)));
		case 102:return(uint((0xFF<<24)|(((127)&0xFF)<<16)|(((51)&0xFF)<<8)|((1)&0xFF)));
		case 113:return(uint((0xFF<<24)|(((102)&0xFF)<<16)|(((51)&0xFF)<<8)|((1)&0xFF)));
		case 118:return(uint((0xFF<<24)|(((255)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)));
		case 127:return(uint((0xFF<<24)|(((220)&0xFF)<<16)|(((20)&0xFF)<<8)|((60)&0xFF)));
		case 164:return(uint((0xFF<<24)|(((244)&0xFF)<<16)|(((244)&0xFF)<<8)|((244)&0xFF)));
		default:return(uint((0xFF<<24)|(((1)&0xFF)<<16)|(((255)&0xFF)<<8)|((1)&0xFF)));
	}
	return(uint((0xFF<<24)|(((1)&0xFF)<<16)|(((255)&0xFF)<<8)|((1)&0xFF)));
}

void _OnEnterMap(Map&map,Critter&cr)
{
	int factionId=map.GetData((0));
	
	array<Critter@>leaders;
	uint caravanerscount=cr.GetMap().GetCritters(279,(0x20)|(0x03),leaders);
	if(leaders[0].Param[(127)]>0)
	if(cr.Param[(106)]!=factionId)
	if(cr.Param[(510)]>0)
	cr.ParamBase[(510)]=0;
	int status=GetStatus(factionId,cr.Id);
	
	array<Critter@>Guards;
	uint guardcount=map.GetCritters(422,(0x20)|(0x03),Guards);
	
	array<Critter@>Turrets;
	uint turretcount=map.GetCritters(480,(0x20)|(0x03),Guards);
	if(status==(3))
	{
		if(guardcount>0)
		for(uint i=0;i<guardcount;i++)
		{
			AttackCritter(Guards[i],cr,__DeadHitPoints);
		}
		if(turretcount>0)
		for(uint i=0;i<turretcount;i++)
		{
			AttackCritter(Turrets[i],cr,__DeadHitPoints);
		}
	}
	if(cr.ParamBase[(795)]==factionId)
	{
		if(guardcount>0)
		for(uint i=0;i<guardcount;i++)
		{
			int status=GetStatus(cr.Param[(106)],cr.Id);
			AttackCritter(Guards[i],cr,__DeadHitPoints);
		}
		if(turretcount>0)
		for(uint i=0;i<turretcount;i++)
		{
			AttackCritter(Turrets[i],cr,__DeadHitPoints);
		}
	}
	array<Critter@>players;
	uint num=GetAllOnlinePlayers(players);
	for(uint i=0;i<num;i++)
	{
		if(players[i].Param[(106)]!=factionId)
		continue;
		players[i].Say((11),"|"+getfactionprefix(factionId)+" [FACTION]Settlement Guard: "+cr.Name+" enter our settlement ");
	}
	string factionname;
	GetFactionNameStr(factionId,factionname);
	for(uint i=0;i<num;i++)
	{
		if(players[i].GetAccess()!=(3))
		continue;
		players[i].Say((11),"|-1 "+cr.Name+" enter settlement of "+factionname);
	}
}

uint prepare_raid(array<uint>@values)
{
	Map@map=GetMap(values[0]);
	if(!(@map!=null))
	return 0;
	uint factionId=map.GetData((0));
	IFaction@faction=GetFaction(factionId);
	string factionname;
	GetFactionNameStr(factionId,factionname);
	string message="Raiders preparing to raid a "+factionname+" Settlement. %COUNTDOWN% left.";
	ServerEventCNTSet(message,map.Id+1,21,((15)*__TimeMultiplier*60));
	CreateTimeEvent(((__FullSecond)+(((15)*__TimeMultiplier*60))),"raid",map.Id,false);
	return((Random(1740,1860))*__TimeMultiplier*60);
}
import void SpawnMobsRaid(Map&map,int howmany,int whatkind,int whattype)from"mob_dynamic";
uint raid(array<uint>@values)
{
	Map@map=GetMap(values[0]);
	if(!(@map!=null))
	return 0;
	string message="Faction Settlement has been raided";
	ServerEventCNTSet(message,map.Id,21,((10)*__TimeMultiplier));
	SpawnMobsRaid(map,Random(15,30),Random(1,3),1);
	return 0;
}

bool d_cansettlement(Critter&player,Critter@npc)
{
	if(player.CountItem((1211))>1999999&&player.CountItem((22089))>14&&player.CountItem((286))>24999&&player.CountItem((1804))>9999&&player.CountItem((9628))>9999)
	return true;
	else return false;
}

bool d_havefaction(Critter&player,Critter@npc)
{
	if(player.Param[(106)]>1)
	return true;
	else return false;
}

void createsettlement(Critter&player,Critter@npc,int ranczo)
{
	array<uint>farmzones={1000,1275,1425,1001,925,1625,1002,525,975,1003,825,675,1004,1075,1325,1005,975,1925,1006,1375,1975,1007,775,1475,1008,1275,2025,1009,875,975};
	array<uint>ranczozones={1100,1325,1525,1001,1375,1675,1102,825,1825,1103,1025,1625,1104,575,875,1105,825,975,1106,1025,1175,1107,1075,1325,1108,725,1325,1109,1225,2125};
	uint bases=0;
	Item@boscash=player.GetItem((1211),-1);
	Item@leather_hide=player.GetItem((22089),-1);
	Item@wood=player.GetItem((286),-1);
	Item@parts=player.GetItem((1804),-1);
	Item@alloys=player.GetItem((9628),-1); 
	
	if(boscash.GetCount()>2000000)
	boscash.SetCount(boscash.GetCount()-2000000);
	else DeleteItem(boscash);
	
	if(wood.GetCount()>25000)
	wood.SetCount(wood.GetCount()-25000);
	else DeleteItem(wood);
	
	if(leather_hide.GetCount()>15)
	leather_hide.SetCount(leather_hide.GetCount()-15);
	else DeleteItem(leather_hide);
	
	if(parts.GetCount()>10000)
	parts.SetCount(parts.GetCount()-10000);
	else DeleteItem(parts);
	
	if(alloys.GetCount()>10000)
	alloys.SetCount(alloys.GetCount()-10000);
	else DeleteItem(alloys);
	
	array<Map@>maps;
	uint num=GetAllMaps(0,maps);
	if(ranczo==0)
	{
		for(uint x=0;x<num;x++)
		for(uint i=0;i<farmzones.length();i++)
		if((@maps[x]!=null))
		{
			if(maps[x].GetProtoId()==farmzones[0+bases]+2000)
			{
				bases+=3;
			}
			break;
		} 
		
		createbase(farmzones[0+bases],farmzones[1+bases],farmzones[2+bases],player.Param[(106)]);
	}
	if(ranczo==1)
	{
		for(uint x=0;x<num;x++)
		for(uint i=0;i<ranczozones.length();i++)
		if((@maps[x]!=null))
		{
			if(maps[x].GetProtoId()==ranczozones[0+bases]+2000)
			{
				bases+=3;
			}
		}
		createbase(ranczozones[0+bases],ranczozones[1+bases],ranczozones[2+bases],player.Param[(106)]);
	}
}

void createbase(uint locID,uint x,uint y,uint faction)
{
	array<Critter@>players;
	uint count=GetAllPlayers(players);
	
	int id=CreateLocation(locID,x,y,players);
	
	Location@loc=GetLocation(id);
	Map@map=loc.GetMapByIndex(0);
	map.SetData((0),faction);
}

string getsymbol(int letter)
{
	switch(letter)
	{
		case 0:return"0";
		case 1:return"1";
		case 2:return"2";
		case 3:return"3";
		case 4:return"4";
		case 5:return"5";
		case 6:return"6";
		case 7:return"7";
		case 8:return"8";
		case 9:return"9";
		
		case 10:return"a";
		case 11:return"A";
		case 12:return"b";
		case 13:return"B";
		case 14:return"c";
		case 15:return"C";
		case 16:return"d";
		case 17:return"D";
		case 18:return"e";
		case 19:return"E";
		
		case 20:return"f";
		case 21:return"F";
		case 22:return"g";
		case 23:return"G";
		case 24:return"h";
		case 25:return"H";
		case 26:return"i";
		case 27:return"I";
		case 28:return"j";
		case 29:return"J";
		
		case 30:return"k";
		case 31:return"K";
		case 32:return"l";
		case 33:return"L";
		case 34:return"m";
		case 35:return"M";
		case 36:return"n";
		case 37:return"M";
		case 38:return"o";
		case 39:return"O";
		
		case 40:return"p";
		case 41:return"P";
		case 42:return"q";
		case 43:return"Q";
		case 44:return"r";
		case 45:return"R";
		case 46:return"s";
		case 47:return"S";
		case 48:return"t";
		case 49:return"T";
		
		case 50:return"u";
		case 51:return"U";
		case 52:return"v";
		case 53:return"V";
		case 54:return"w";
		case 55:return"W";
		case 56:return"x";
		case 57:return"X";
		case 58:return"y";
		case 59:return"Y";
		
		case 60:return"z";
		case 61:return"Z";
		case 62:return".";
		case 63:return"-";
		case 64:return"_";
		case 65:return"!";
		case 66:return" ";
	}
	return"";
}