                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             

int week_patch=1;
int doubleloot=1;
bool dropchance(float chance)
{
	if(chance==0)
	return false;
	if(Random(0,100)<chance)
	return true;
	
	return false;
	
}

bool can_tc_modoc=false;
bool can_tc_klamath=false;
bool can_tc_gecko=false;
bool can_tc_bh=false;
bool can_tc_redding=false;
bool can_tc_den=false;
bool can_tc_necro=false;
bool can_tc_reno=false;

uint when_tc_modoc=0;
uint when_tc_klamath=0;
uint when_tc_gecko=0;
uint when_tc_bh=0;
uint when_tc_redding=0;
uint when_tc_den=0;
uint when_tc_necro=0;
uint when_tc_reno=0;                    

uint __GetColor(int r,int g,int b,int a=0xFF)
{
	r=(((r)>(255))?(255):(((r)<(0))?(0):(r)));
	g=(((g)>(255))?(255):(((g)<(0))?(0):(g)));
	b=(((b)>(255))?(255):(((b)<(0))?(0):(b)));
	a=(((a)>(255))?(255):(((a)<(0))?(0):(a)));
	return(uint(((a)<<24)|(((r)&0xFF)<<16)|(((g)&0xFF)<<8)|((b)&0xFF)));
}                                                                                                                                                                                                                                                                                                                                                                                                             

shared interface Buffer
{
	bool IsRaw(uint len);
	
	Buffer@opCom();
	
	Buffer@opNeg();                    
	
	 Buffer@opShr(int8&value); Buffer@opShl(int8 value); Buffer@Get(int8&value); Buffer@Set(int8&value);
	 Buffer@opShr(int16&value); Buffer@opShl(int16 value); Buffer@Get(int16&value); Buffer@Set(int16&value);
	 Buffer@opShr(int32&value); Buffer@opShl(int32 value); Buffer@Get(int32&value); Buffer@Set(int32&value);
	 Buffer@opShr(int64&value); Buffer@opShl(int64 value); Buffer@Get(int64&value); Buffer@Set(int64&value);
	 Buffer@opShr(uint8&value); Buffer@opShl(uint8 value); Buffer@Get(uint8&value); Buffer@Set(uint8&value);
	 Buffer@opShr(uint16&value); Buffer@opShl(uint16 value); Buffer@Get(uint16&value); Buffer@Set(uint16&value);
	 Buffer@opShr(uint32&value); Buffer@opShl(uint32 value); Buffer@Get(uint32&value); Buffer@Set(uint32&value);
	 Buffer@opShr(uint64&value); Buffer@opShl(uint64 value); Buffer@Get(uint64&value); Buffer@Set(uint64&value);
	 Buffer@opShr(bool&value); Buffer@opShl(bool value); Buffer@Get(bool&value); Buffer@Set(bool&value);
	 Buffer@opShr(string&value); Buffer@opShl(string value); Buffer@Get(string&value); Buffer@Set(string&value);
	 Buffer@opShr(float&value); Buffer@opShl(float value); Buffer@Get(float&value); Buffer@Set(float&value);
	
	 Buffer@opShr(array<int8>&value); Buffer@opShl(array<int8>&value); Buffer@Get(array<int8>&value); Buffer@Set(array<int8>&value);
	 Buffer@opShr(array<int16>&value); Buffer@opShl(array<int16>&value); Buffer@Get(array<int16>&value); Buffer@Set(array<int16>&value);
	 Buffer@opShr(array<int32>&value); Buffer@opShl(array<int32>&value); Buffer@Get(array<int32>&value); Buffer@Set(array<int32>&value);
	 Buffer@opShr(array<int64>&value); Buffer@opShl(array<int64>&value); Buffer@Get(array<int64>&value); Buffer@Set(array<int64>&value);
	 Buffer@opShr(array<uint8>&value); Buffer@opShl(array<uint8>&value); Buffer@Get(array<uint8>&value); Buffer@Set(array<uint8>&value);
	 Buffer@opShr(array<uint16>&value); Buffer@opShl(array<uint16>&value); Buffer@Get(array<uint16>&value); Buffer@Set(array<uint16>&value);
	 Buffer@opShr(array<uint32>&value); Buffer@opShl(array<uint32>&value); Buffer@Get(array<uint32>&value); Buffer@Set(array<uint32>&value);
	 Buffer@opShr(array<uint64>&value); Buffer@opShl(array<uint64>&value); Buffer@Get(array<uint64>&value); Buffer@Set(array<uint64>&value);
	 Buffer@opShr(array<bool>&value); Buffer@opShl(array<bool>&value); Buffer@Get(array<bool>&value); Buffer@Set(array<bool>&value);
	 Buffer@opShr(array<string>&value); Buffer@opShl(array<string>&value); Buffer@Get(array<string>&value); Buffer@Set(array<string>&value);
	 Buffer@opShr(array<float>&value); Buffer@opShl(array<float>&value); Buffer@Get(array<float>&value); Buffer@Set(array<float>&value);
	
	 Buffer@opShr(array<array<int8>>&value); Buffer@opShl(array<array<int8>>&value); Buffer@Get(array<array<int8>>&value); Buffer@Set(array<array<int8>>&value);
	 Buffer@opShr(array<array<int16>>&value); Buffer@opShl(array<array<int16>>&value); Buffer@Get(array<array<int16>>&value); Buffer@Set(array<array<int16>>&value);
	 Buffer@opShr(array<array<int32>>&value); Buffer@opShl(array<array<int32>>&value); Buffer@Get(array<array<int32>>&value); Buffer@Set(array<array<int32>>&value);
	 Buffer@opShr(array<array<int64>>&value); Buffer@opShl(array<array<int64>>&value); Buffer@Get(array<array<int64>>&value); Buffer@Set(array<array<int64>>&value);
	 Buffer@opShr(array<array<uint8>>&value); Buffer@opShl(array<array<uint8>>&value); Buffer@Get(array<array<uint8>>&value); Buffer@Set(array<array<uint8>>&value);
	 Buffer@opShr(array<array<uint16>>&value); Buffer@opShl(array<array<uint16>>&value); Buffer@Get(array<array<uint16>>&value); Buffer@Set(array<array<uint16>>&value);
	 Buffer@opShr(array<array<uint32>>&value); Buffer@opShl(array<array<uint32>>&value); Buffer@Get(array<array<uint32>>&value); Buffer@Set(array<array<uint32>>&value);
	 Buffer@opShr(array<array<uint64>>&value); Buffer@opShl(array<array<uint64>>&value); Buffer@Get(array<array<uint64>>&value); Buffer@Set(array<array<uint64>>&value);
	 Buffer@opShr(array<array<bool>>&value); Buffer@opShl(array<array<bool>>&value); Buffer@Get(array<array<bool>>&value); Buffer@Set(array<array<bool>>&value);
	 Buffer@opShr(array<array<string>>&value); Buffer@opShl(array<array<string>>&value); Buffer@Get(array<array<string>>&value); Buffer@Set(array<array<string>>&value);
	 Buffer@opShr(array<array<float>>&value); Buffer@opShl(array<array<float>>&value); Buffer@Get(array<array<float>>&value); Buffer@Set(array<array<float>>&value);
	
	 Buffer@opShr(array<array<array<int8>>>&value); Buffer@opShl(array<array<array<int8>>>&value); Buffer@Get(array<array<array<int8>>>&value); Buffer@Set(array<array<array<int8>>>&value);
	 Buffer@opShr(array<array<array<int16>>>&value); Buffer@opShl(array<array<array<int16>>>&value); Buffer@Get(array<array<array<int16>>>&value); Buffer@Set(array<array<array<int16>>>&value);
	 Buffer@opShr(array<array<array<int32>>>&value); Buffer@opShl(array<array<array<int32>>>&value); Buffer@Get(array<array<array<int32>>>&value); Buffer@Set(array<array<array<int32>>>&value);
	 Buffer@opShr(array<array<array<int64>>>&value); Buffer@opShl(array<array<array<int64>>>&value); Buffer@Get(array<array<array<int64>>>&value); Buffer@Set(array<array<array<int64>>>&value);
	 Buffer@opShr(array<array<array<uint8>>>&value); Buffer@opShl(array<array<array<uint8>>>&value); Buffer@Get(array<array<array<uint8>>>&value); Buffer@Set(array<array<array<uint8>>>&value);
	 Buffer@opShr(array<array<array<uint16>>>&value); Buffer@opShl(array<array<array<uint16>>>&value); Buffer@Get(array<array<array<uint16>>>&value); Buffer@Set(array<array<array<uint16>>>&value);
	 Buffer@opShr(array<array<array<uint32>>>&value); Buffer@opShl(array<array<array<uint32>>>&value); Buffer@Get(array<array<array<uint32>>>&value); Buffer@Set(array<array<array<uint32>>>&value);
	 Buffer@opShr(array<array<array<uint64>>>&value); Buffer@opShl(array<array<array<uint64>>>&value); Buffer@Get(array<array<array<uint64>>>&value); Buffer@Set(array<array<array<uint64>>>&value);
	 Buffer@opShr(array<array<array<bool>>>&value); Buffer@opShl(array<array<array<bool>>>&value); Buffer@Get(array<array<array<bool>>>&value); Buffer@Set(array<array<array<bool>>>&value);
	 Buffer@opShr(array<array<array<string>>>&value); Buffer@opShl(array<array<array<string>>>&value); Buffer@Get(array<array<array<string>>>&value); Buffer@Set(array<array<array<string>>>&value);
	 Buffer@opShr(array<array<array<float>>>&value); Buffer@opShl(array<array<array<float>>>&value); Buffer@Get(array<array<array<float>>>&value); Buffer@Set(array<array<array<float>>>&value);
	
	 Buffer@opUShr(array<int8>&arr); Buffer@opUShrAssign(array<int8>&arr); array<int8>AsInt8();
	 Buffer@opUShr(array<int16>&arr); Buffer@opUShrAssign(array<int16>&arr); array<int16>AsInt16();
	 Buffer@opUShr(array<int32>&arr); Buffer@opUShrAssign(array<int32>&arr); array<int32>AsInt32();
	 Buffer@opUShr(array<int64>&arr); Buffer@opUShrAssign(array<int64>&arr); array<int64>AsInt64();
	 Buffer@opUShr(array<uint8>&arr); Buffer@opUShrAssign(array<uint8>&arr); array<uint8>AsUint8();
	 Buffer@opUShr(array<uint16>&arr); Buffer@opUShrAssign(array<uint16>&arr); array<uint16>AsUint16();
	 Buffer@opUShr(array<uint32>&arr); Buffer@opUShrAssign(array<uint32>&arr); array<uint32>AsUint32();
	 Buffer@opUShr(array<uint64>&arr); Buffer@opUShrAssign(array<uint64>&arr); array<uint64>AsUint64();
};  

import Buffer@NewBuffer()from"buffer";    

 import Buffer@NewBuffer(array<int8>@data)from"buffer";
 import Buffer@NewBuffer(array<int16>@data)from"buffer";
 import Buffer@NewBuffer(array<int32>@data)from"buffer";
 import Buffer@NewBuffer(array<int64>@data)from"buffer";
 import Buffer@NewBuffer(array<uint8>@data)from"buffer";
 import Buffer@NewBuffer(array<uint16>@data)from"buffer";
 import Buffer@NewBuffer(array<uint32>@data)from"buffer";
 import Buffer@NewBuffer(array<uint64>@data)from"buffer";                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        

shared class Sprite
{
	Sprite()
	{
		Id=0;
		Width=0;
		Height=0;
		FrmCount=0;
	}
	
	bool Load(string&name,int path)
	{
		if(name.length()>0)
		{
			Id=LoadSprite(name,path);
			Filename=name;
		}
		else
		Id=0;
		RefreshData();
		return Id!=0;
	}
	
	void LoadHash(uint nameHash,uint8 dir)
	{
		Id=LoadSprite(nameHash,dir);
		RefreshData();
	}
	
	void LoadByIni(string&iniKey,int path)
	{
		string@name=GetIfaceIniStr(iniKey);
		if(@name!=null&&name.length()>0)
		Id=LoadSprite(name,path);
		else
		Id=0;
		RefreshData();
	}
	
	void Draw(int x,int y)
	{
		if(Id!=0)
		DrawSprite(Id,-1,x,y,0);
	}
	
	private void RefreshData()
	{
		if(Id!=0)
		{
			Width=GetSpriteWidth(Id,0);
			Height=GetSpriteHeight(Id,0);
			FrmCount=GetSpriteCount(Id);
		}
		else
		{
			Width=0;
			Height=0;
			FrmCount=0;
			Filename="";
		}
	}
	
	uint Id;
	int Width;
	int Height;
	uint FrmCount;
	string Filename;
};     

shared interface IControl
{
	void SetParent(IControl@parent); 
	
	bool IsVisible();
	bool IsActive();
	
	void Disable();
	void Enable();
	
	void Show(bool showAll=false);
	void Show(int left,int top);
	void Hide(); 
	
	void ShowWindow();
	void ShowWindow(int left,int top);
	void HideWindow();
	void Center();
	
	int Left();
	int Right();
	int Top();
	int Bottom();
	int Width();
	int Height();
	
	IControl@Position(int,int);
	IControl@Position(string&iniKey);
	IControl@Left(int);
	IControl@Top(int);
	IControl@Width(int);
	IControl@Height(int);
	IControl@Size(int,int);
	
	void Init();
	void Draw();
	void Update();
	bool MouseDown(int x,int y,int click);
	bool MouseUp(int x,int y,int click);
	void MouseMove(int fromX,int fromY,int toX,int toY);
	bool KeyDown(uint8 key,string&keyText);
	void KeyUp(uint8 key,string&keyText);
};   

class Control:IControl
{
	
	IControl@parent;
	
	array<IControl@>controls; 
	
	int left;
	int top;
	int width;
	int height;     
	
	bool active;
	
	bool visible;
	
	bool focus; 
	
	bool mousePressed;
	int mouseX;
	int mouseY;
	
	Control()
	{
		active=true;
		visible=true;
		focus=false;
		
		mousePressed=false;
		mouseX=0;
		mouseY=0;
		
		left=top=width=height=0;
	}
	
	Control(int left,int top,int width,int height)
	{
		active=true;
		visible=true;
		focus=false;
		
		mousePressed=false;
		mouseX=0;
		mouseY=0;
		
		this.left=left;
		this.top=top;
		this.width=width;
		this.height=height;
	}    
	
	bool IsVisible(){return visible;}
	bool IsActive(){return active;}   
	
	int Left()
	{
		if((@parent!=null))
		return parent.Left()+left;
		else
		return left;
	}
	int Top()
	{
		if((@parent!=null))
		return parent.Top()+top;
		else
		return top;
	}
	int Right(){return Left()+Width();}
	int Bottom(){return Top()+Height();}
	int Height(){return height;}
	int Width(){return width;}
	
	IControl@Position(int x,int y){left=x;top=y;return this;}
	IControl@Left(int x){left=x;return this;}
	IControl@Top(int y){top=y;return this;}
	IControl@Width(int w){width=w;return this;}
	IControl@Height(int h){height=h;return this;}
	IControl@Size(int w,int h){height=h;width=w;return this;}
	
	IControl@Position(string&iniKey)
	{
		left=0;
		top=0;
		width=0;
		height=0; 
		
		string@str=GetIfaceIniStr(iniKey);
		if(@str==null||str=="")
		return this;
		
		array<string@>@valuesStr=split(str," ");
		if(valuesStr.length()!=4)
		return this;
		
		array<int>values(4);
		for(int i=0;i<4;i++)
		if(!StrToInt(valuesStr[i],values[i]))
		return this;
		
		left=values[0];
		top=values[1];
		width=values[2]-values[0]+1;
		height=values[3]-values[1]+1;
		return this;
	}   
	
	bool IsInside(int x,int y)
	{
		return(x>=Left())&&(x<Right())&&(y>=Top())&&(y<Bottom());
	}   
	
	void SetParent(IControl@control)
	{
		@parent=control;
	}   
	
	void Enable()
	{
		active=true;
		OnEnabled();
	}
	void Disable()
	{
		active=false;
		OnDisabled();
	}   
	
	void Show(bool showAll=false)
	{
		visible=true;
		if(showAll)
		{
			for(uint i=0,j=controls.length();i<j;i++)
			controls[i].Show(showAll);
		}
		OnShow();
	}
	void Show(int left,int top)
	{
		this.left=left;
		this.top=top;
		visible=true;
		OnShow();
	}
	void Hide()
	{
		visible=false;
		for(uint i=0,j=controls.length();i<j;i++)
		controls[i].Hide();
		OnHide();
	}
	
	void ShowWindow()
	{
		Message("This control does not have window attached.");
	}
	void ShowWindow(int x,int y)
	{
		Message("This control does not have window attached.");
	}
	void HideWindow()
	{
		Message("This control does not have window attached.");
	}  
	
	void Center()
	{
		Position(parent.Width()/2-Width()/2,parent.Height()/2-Height()/2);
	}
	void Init()
	{
		for(uint i=0,j=controls.length();i<j;i++)
		controls[i].Init();
	}  
	
	void SetFocus(bool focused)
	{
		this.focus=focused;
		
		if(focused)
		GotFocus();
		else
		LostFocus();
	}   
	
	void AddControl(IControl@control)
	{
		control.SetParent(this);
		controls.insertLast(@control);
	}    
	
	bool MouseDown(int x,int y,int click)
	{
		bool intercepted=false;
		for(uint i=0,j=controls.length();i<j;i++)
		{
			if(controls[i].IsVisible()&&controls[i].IsActive())
			intercepted=controls[i].MouseDown(x,y,click)?true:intercepted;
		}
		if(!intercepted)
		{
			if(click!=(4)&&click!=(3))
			{
				if(IsInside(x,y))
				{
					mousePressed=true;
					mouseX=x;
					mouseY=y;
					SetFocus(true);
					intercepted=true;
				}
				else
				{
					SetFocus(false);
				}
			}
		}
		return intercepted;
	}
	bool MouseUp(int x,int y,int click)
	{
		bool intercepted=false;
		if(IsInside(x,y)&&mousePressed)
		{
			
			Click();
			intercepted=true;
		}
		
		mousePressed=false;
		
		for(uint i=0,j=controls.length();i<j;i++)
		{
			if(controls[i].IsVisible()&&controls[i].IsActive())
			intercepted=controls[i].MouseUp(x,y,click)?true:intercepted;
		}
		return intercepted;
	}
	void MouseMove(int fromX,int fromY,int toX,int toY)
	{
		for(uint i=0,j=controls.length();i<j;i++)
		{
			if(controls[i].IsVisible()&&controls[i].IsActive())
			controls[i].MouseMove(fromX,fromY,toX,toY);
		}
	}
	bool KeyDown(uint8 key,string&keyText)
	{
		bool intercepted=false;
		for(uint i=0,j=controls.length();i<j;i++)
		{
			if(controls[i].IsVisible()&&controls[i].IsActive())
			intercepted=controls[i].KeyDown(key,keyText)?true:intercepted;
		}
		return intercepted;
	}
	void KeyUp(uint8 key,string&keyText)
	{
		for(uint i=0,j=controls.length();i<j;i++)
		{
			if(controls[i].IsVisible()&&controls[i].IsActive())
			controls[i].KeyUp(key,keyText);
		}
	}   
	
	void Draw()
	{
		for(uint i=0,j=controls.length();i<j;i++)
		if(controls[i].IsVisible())
		controls[i].Draw();
	}  
	
	void Update()
	{
		for(uint i=0,j=controls.length();i<j;i++)
		{
			if(controls[i].IsActive())
			controls[i].Update();
		}
	}        
	
	void Click()
	{}  
	
	void GotFocus()
	{}  
	
	void LostFocus()
	{}  
	
	void OnShow()
	{}  
	
	void OnHide()
	{}  
	
	void OnEnabled()
	{}  
	
	void OnDisabled()
	{}
};      

class CButton:Control
{
	string caption;
	Sprite spriteUp;
	Sprite spriteDown;
	
	int textBorder;
	
	CButton(int left,int top,string@caption)
	{
		super(left,top,119,30);
		spriteUp.Load("wm_tab.png",(4));
		spriteDown.Load("wm_blanktab.png",(4));
		this.caption=caption;
		textBorder=30;
	}
	CButton(int left,int top,int width,int height,string&down)
	{ 
		
		if(!spriteDown.Load(down,(4)))
		Message("Couldn't load sprite: "+down);
		super(left,top,(((width)>(spriteDown.Width))?(width):(spriteDown.Width)),(((height)>(spriteDown.Height))?(height):(spriteDown.Height)));
		textBorder=0;
	}
	CButton(int left,int top,int width,int height,string&up,string&down)
	{
		if(!spriteUp.Load(up,(4)))
		Message("Couldn't load sprite(up): "+up);
		if(!spriteDown.Load(down,(4)))
		Message("Couldn't load sprite(down): "+down);
		super(left,top,(((width)>(spriteUp.Width))?(width):(spriteUp.Width)),(((height)>(spriteUp.Height))?(height):(spriteUp.Height)));
		textBorder=0;
	}
	CButton(string&iniKey,string&down)
	{ 
		
		if(!spriteDown.Load(down,(4)))
		Message("Couldn't load sprite: "+down);
		Control::Position(iniKey);
		textBorder=0;
	}  
	
	void SetCaption(string@caption){this.caption=caption;}
	
	void Draw()
	{
		if(mousePressed)
		{
			if(spriteDown.Id!=0)
			DrawSprite(spriteDown.Id,0,Left(),Top(),0);
		}
		else
		{
			if(spriteUp.Id!=0)
			DrawSprite(spriteUp.Id,0,Left(),Top(),0);
		}
		int color=active?0:int(0xffaaaaaa);
		if(caption!="")
		DrawText(caption,Left()+textBorder,Top(),Width()-textBorder,Height(),color,(5),(0x0008)|(0x0200));
	}
}; 

class CDialogRedButton:Control
{
	Sprite spriteDown;
	
	CDialogRedButton(int left,int top)
	{
		super(left,top,16,16);
		spriteDown.Load("di_rdbt1.frm",(4));
	}  
	
	void Draw()
	{
		if(mousePressed)
		DrawSprite(spriteDown.Id,0,Left(),Top(),0);
	}
};

class CSmallButton:Control
{
	Sprite spriteDown;
	
	CSmallButton(int left,int top)
	{
		super(left,top,16,16);
		spriteDown.Load("lilreddn.frm",(4));
	}  
	
	void Draw()
	{
		if(mousePressed)
		DrawSprite(spriteDown.Id,0,Left(),Top(),0);
	}
};

class CSmallArrowUp:Control
{
	Sprite spriteDown;
	
	CSmallArrowUp(int left,int top)
	{
		super(left,top,16,16); 
		
	}  
	
	void Draw()
	{ 
		
	}
};

class CSmallArrowDown:Control
{
	Sprite spriteDown;
	
	CSmallArrowDown(int left,int top)
	{
		super(left,top,16,16); 
		
	}  
	
	void Draw()
	{ 
		
	}
};   

class CLabel:Control
{
	int font;
	int color;
	int format;
	string@caption;
	
	CLabel(int left,int top,int width,int height,string@caption)
	{
		super(left,top,width,height);
		@this.caption=@caption;
		this.color=0;
		font=(5);
		format=(0x0008)|(0x0200);
	}
	CLabel(int left,int top,int width,int height,string@caption,int font)
	{
		super(left,top,width,height);
		@this.caption=@caption;
		this.color=0;
		this.font=font;
		format=(0x0008)|(0x0200);
	}
	void SetCaption(string@caption)
	{
		@this.caption=@caption;
	}
	void set_Caption(string@caption)
	{
		@this.caption=@caption;
	}
	string@get_Caption()
	{
		return@caption;
	}
	void SetColor(uint color)
	{
		this.color=color;
	}
	void set_Color(uint color)
	{
		this.color=color;
	}
	void SetFont(uint font)
	{
		this.font=font;
	}
	void set_Font(uint font)
	{
		this.font=font;
	}
	void SetFormat(uint format)
	{
		this.format=format;
	}
	void Draw()
	{
		DrawText(caption,Left(),Top(),Width(),Height(),color,font,format);
	}
};   

class CTextBox:Control
{
	
	string text;
	
	string drawnText;
	uint cursorPos;
	
	uint cursorTime;
	
	uint cursorChangedTime;
	
	int showCursor;
	
	string cursor1;
	string cursor2; 
	
	int color;
	int format;
	int font;
	uint maxlength;
	
	CTextBox(int left,int top,int width,int height,string@text)
	{
		super(left,top,width,height);
		this.text=text;
		cursorPos=text.rawLength();
		cursorTime=400;
		cursorChangedTime=0;
		showCursor=0;
		cursor1="!";
		cursor2=".";
		drawnText=text;
		
		color=0;
		font=(5);
		format=(0x0200);
		maxlength=0;
	}  
	
	string@Text()
	{
		return text;
	}  
	
	string@GetCursor()
	{
		if(showCursor==0)
		return"";
		else if(showCursor==1)
		return cursor1;
		else
		return cursor2;
	}
	void SetColor(uint color)
	{
		this.color=color;
	}
	void SetFormat(uint format)
	{
		this.format=format;
	}
	void SetText(string@text)
	{
		this.text=text;
		cursorPos=text.rawLength();
		RefreshDrawnText();
	}
	void SetMaxLength(uint ml)
	{
		maxlength=ml;
	}  
	
	void ShowCursor(int show)
	{
		showCursor=show;
		RefreshDrawnText();
	}  
	
	void RefreshDrawnText()
	{
		if(showCursor>0)
		{
			if(cursorPos==text.rawLength())
			drawnText=text+GetCursor();
			else
			drawnText=substring(text,0,cursorPos)+GetCursor()+substring(text,cursorPos,text.rawLength()-cursorPos);
		}
		else
		drawnText=text;
	}                                   
	
	void InsertChar(uint8 key,string&keyText)
	{
		text=substring(text,0,cursorPos)+keyText+substring(text,cursorPos,text.length()-cursorPos);
		cursorPos++;
	}
	
	void Draw()
	{
		uint tick=GetTick();
		
		if(tick-cursorChangedTime>cursorTime)
		{
			cursorChangedTime=tick;
			if(showCursor==1)
			ShowCursor(2);
			else if(focus)
			ShowCursor(1);
			else
			ShowCursor(0);
		} 
		
		DrawText(drawnText,Left(),Top(),Width(),Height(),color,font,format);
	}
	
	bool KeyDown(uint8 key,string&keyText)
	{
		if(focus)
		{
			
			if(key==0x0E)
			{
				if(text.rawLength()>0&&cursorPos>0)
				{
					text=substring(text,0,cursorPos-1)+substring(text,cursorPos,text.rawLength()-cursorPos);
					cursorPos--;
				}
			}
			else if(key==0xD3)
			{
				if(text.rawLength()>0&&cursorPos<text.rawLength())
				{
					text=substring(text,0,cursorPos)+substring(text,cursorPos+1,text.rawLength()-cursorPos-1);
				}
			}
			
			else if(key==0xC7)
			{
				cursorPos=0;
			}
			else if(key==0xCF)
			{
				cursorPos=text.rawLength();
			}
			
			else if(key==0xCB)
			{
				if(cursorPos>0)
				cursorPos--;
			}
			else if(key==0xCD)
			{
				if(cursorPos<text.rawLength())
				cursorPos++;
			}
			
			else if(key==0x01||key==0x1C||key==0x9C)
			{
				SetFocus(false);
			}
			else
			{
				if(maxlength==0||maxlength>text.rawLength())
				InsertChar(key,keyText);
			}
			
			RefreshDrawnText();
			return true;
		}
		return Control::KeyDown(key,keyText);
	}
};   

class CSprite:Control
{
	Sprite sprite;
	
	CSprite(string@spriteName,int path=(4))
	{
		super();
		sprite.Load(spriteName,path);
	}
	CSprite(uint nameHash,int path=(4))
	{
		super();
		sprite.LoadHash(nameHash,path);
	}
	CSprite(int left,int top,int width,int height,string@spriteName,int path=(4))
	{
		super(left,top,width,height);
		sprite.Load(spriteName,path);
	}
	
	void Draw()
	{
		DrawSprite(sprite.Id,-1,Left(),Top(),0);
		Control::Draw();
	}
};   

class CSpriteEx:CSprite
{
	int index;
	bool scratch;
	bool center;
	uint color;
	bool applyOffsets;
	
	CSpriteEx(string@spriteName)
	{
		super(spriteName);
		Init();
	}
	
	CSpriteEx(uint nameHash,int path=(4))
	{
		super(nameHash,path);
		Init();
	}
	
	CSpriteEx(int left,int top,int width,int height,string@spriteName)
	{
		super(left,top,width,height,spriteName);
		Init();
	}
	
	private void Init()
	{
		CSprite::Init();
		this.index=-1;
		this.scratch=false;
		this.center=false;
		this.color=0;
		this.applyOffsets=true;
	}
	
	void Draw()
	{
		if(this.sprite.Id>0)
		DrawSprite(this.sprite.Id,this.index,Left(),Top(),this.sprite.Width,this.sprite.Height,this.scratch,this.center,this.color,this.applyOffsets);
		Control::Draw();
	}
};   

class CListBox:Control
{
	array<string@>elements;
	
	uint start;
	
	uint index;
	
	uint textHeight;
	
	CListBox(int left,int top,int width,int height)
	{
		super(left,top,width,height);
		start=0;
		textHeight=12;
	}   
	
	uint GetRowCount()
	{
		return height/textHeight;
	}  
	
	uint GetIndex()
	{
		return index;
	}  
	
	void AddElement(string@elem)
	{
		elements.insertLast(elem);
	}  
	
	void Scroll(int d)
	{
		start=(((int(start)+d)>(int(elements.length()-1)))?(int(elements.length()-1)):(((int(start)+d)<(0))?(0):(int(start)+d)));
	}  
	
	void Draw()
	{
		for(uint i=start,j=(((elements.length())<(start+uint(Height()/textHeight)))?(elements.length()):(start+uint(Height()/textHeight)));i<j;i++)
		{
			DrawText(elements[i],Left(),Top()+(i-start)*textHeight,Width(),textHeight,i==index?0xffffffff:0,(5),(0x0200));
		}
	}   
	
	void Click()
	{
		uint el=start+(mouseY-Top())/textHeight;
		if(el<elements.length())
		index=el;
		Control::Click();
	}
};   

class CContextButton:CButton
{
	uint crId;
	uint itemId;
	uint16 hexX;
	uint16 hexY;
	
	CContextButton(string caption)
	{
		super(0,0,caption);
		hexX=0;
		hexY=0;
	}   
	
	void SetCritter(CritterCl@cr)
	{
		crId=itemId=0;
		if((@cr!=null))
		crId=cr.Id;
	}  
	
	void SetItem(ItemCl@item)
	{
		crId=itemId=0;
		if((@item!=null))
		itemId=item.Id;
	}  
	
	void SetHex(uint16 x,uint16 y)
	{
		this.hexX=x;
		this.hexY=y;
	}
};   

class Window:Control,IGUIScreenCallbackFocus,IGUIScreenCallbackShow
{
	IGUIScreenOpt@screen;
	
	int Left(){return screen.GetPosX();}
	int Top(){return screen.GetPosY();}
	int Width(){return screen.GetWidth();}
	int Height(){return screen.GetHeight();}
	
	bool autoMode;
	
	Window()
	{
		super();
		autoMode=false;
	}
	
	void Init()
	{
		@screen=GUI_GetScreenOptions();
		Control::Init();
	}
	
	IControl@Position(int x,int y)
	{
		screen.Position(x,y);
		return this;
	}
	IControl@Size(int w,int h)
	{
		screen.Size(w,h);
		return this;
	}  
	
	void Center()
	{
		Position(__ScreenWidth/2-Width()/2,__ScreenHeight/2-Height()/2);
	} 
	
	void OnShow(int p0,int p1,int p2)
	{
		if(p0!=0||p1!=0)
		Show(p0,p1);
		else
		Show();
	}
	
	void Show(int x,int y)
	{
		screen.Position(x,y);
		Control::Show(x,y);
	} 
	
	void ShowWindow()
	{
		GUI_ShowScreen(screen.GetIndex(),0,0,0);
	}
	void ShowWindow(int x,int y)
	{
		screen.Position(x,y);
		GUI_ShowScreen(screen.GetIndex(),x,y,0);
	}
	void HideWindow()
	{
		GUI_HideScreen(screen.GetIndex(),0,0,0);
		Disable();
	}
	void OnLostFocus()
	{
		HideWindow();
		Disable();
	}
	
	bool MouseDown(int x,int y,int click)
	{
		bool intercepted=false;
		for(uint i=0,j=controls.length();i<j;i++)
		{
			if(controls[i].IsVisible()&&controls[i].IsActive())
			intercepted=controls[i].MouseDown(x,y,click)?true:intercepted;
		}
		if(!intercepted)
		{
			if(click!=(4)&&click!=(3))
			{
				if(IsInside(x,y))
				{
					mousePressed=true;
					mouseX=x;
					mouseY=y;
					SetFocus(true);
					intercepted=true;
				}
				else
				{
					SetFocus(false);
				}
				
				return false;
			}
		}
		return intercepted;
	}   
	
	void Auto(bool v){autoMode=v;}
	bool Auto(){return autoMode;}
};       

import void GUI_Init()from"client_gui";
import void GUI_GetActiveScreens(array<int>&result)from"client_gui";
import int GUI_GetActiveScreen()from"client_gui";
import int GUI_GetActiveMainScreen()from"client_gui";
import int GUI_GetMainScreen()from"client_gui";
import void GUI_ShowScreen(int screenIndex,int p0,int p1,int p2)from"client_gui";
import void GUI_HideScreen(int screenIndex,int p0,int p1,int p2)from"client_gui";
import void GUI_Render(bool mainScreen)from"client_gui";

import void GUI_Update(uint dt)from"client_gui";
import bool GUI_MouseDown(int x,int y,int click)from"client_gui";
import bool GUI_MouseUp(int x,int y,int click)from"client_gui";
import void GUI_MouseMove(int fromX,int fromY,int toX,int toY)from"client_gui";
import bool GUI_KeyDown(uint8 key,string&keyText)from"client_gui";
import bool GUI_KeyUp(uint8 key,string&keyText)from"client_gui";
import void GUI_InputLost()from"client_gui";
import bool GUI_IsKeyPressed(uint8 key)from"client_gui"; 

import void GUI_GetIniCoords(string&ini,int&left,int&top,int&right,int&bottom)from"client_gui"; 

import IGUIScreenOpt@GUI_CreateScreen(int screenIndex,string@sprName)from"client_gui";

import IGUIScreenOpt@GUI_GetScreen(int screenIndex)from"client_gui"; 

import IGUIElementTextOpt@GUI_AddText(int screenIndex)from"client_gui";
import IGUIElementTextOpt@GUI_AddText(int screenIndex,string@text,int x,int y)from"client_gui";
import IGUIElementImageOpt@GUI_AddImage(int screenIndex)from"client_gui";
import IGUIElementImageOpt@GUI_AddImage(int screenIndex,string@sprName,int patch,int x,int y)from"client_gui";
import IGUIElementButtonOpt@GUI_AddButton(int screenIndex)from"client_gui";
import IGUIElementButtonOpt@GUI_AddButton(int screenIndex,int x,int y)from"client_gui";

import void GUI_DeleteScreen(int screenIndex)from"client_gui"; 

import IGUIScreenOpt@GUI_GetScreenOptions()from"client_gui"; 

import void SetScreenPos(int screenIndex,int posX,int posY)from"client_gui";
import IGUIElementEditBoxOpt@GUI_AddEditBox(int screenIndex)from"client_gui";
import IGUIElementEditBoxOpt@GUI_AddEditBox(int screenIndex,int x,int y)from"client_gui";
import void SetPipBoyCallbackShow(IGUIScreenCallbackShow@callback)from"client_gui";     

shared interface IGUIScreenCallbackShow
{
	void OnShow(int p0,int p1,int p2);
};
shared interface IGUIScreenCallbackHide
{
	void OnHide(int p0,int p1,int p2);
};

shared interface IGUIScreenCallbackFocus
{
	void OnLostFocus();
};

shared interface IGUIScreenCallbackMouseClick{bool OnMouseClick(int click);}
shared interface IGUIScreenCallbackMouseMove{bool OnMouseMove(int x,int y);}

shared interface IGUIScreenCallbackKeyPress
{
	bool OnKeyPress(uint8 key,string&keyText);
}

shared interface IGUIScreenCallbackMouseDown
{
	bool OnMouseDown(int click);
}
shared interface IGUIScreenCallbackMove{void OnMove(int posX,int posY);}

shared interface IGUIScreenOpt
{
	IGUIScreenOpt@SetCallbackShow(IGUIScreenCallbackShow@callback);
	IGUIScreenOpt@SetCallbackHide(IGUIScreenCallbackHide@callback);
	IGUIScreenOpt@SetCallbackMove(IGUIScreenCallbackMove@callback);
	
	IGUIScreenOpt@SetCallbackFocus(IGUIScreenCallbackFocus@callback);
	IGUIScreenOpt@SetCallbackMouseDown(IGUIScreenCallbackMouseDown@callback);
	IGUIScreenOpt@SetCallbackKeyPress(IGUIScreenCallbackKeyPress@callback);
	
	IControl@Control();
	IGUIScreenOpt@Control(IControl@control);
	IGUIScreenOpt@Position(int x,int y);
	IGUIScreenOpt@Size(int w,int h);
	IGUIScreenOpt@CanMove(bool enabled);
	IGUIScreenOpt@Modal(bool enabled);
	IGUIScreenOpt@Multiinstance(bool enabled);
	IGUIScreenOpt@SizeByMultipleImages(int horizontalCount,int verticalCount);
	IGUIScreenOpt@IgnoreBorders(bool enabled);
	IGUIScreenOpt@CloseOnMiss(bool enabled);
	IGUIScreenOpt@AutoCursor(bool enabled,int cursorType);
	IGUIScreenOpt@Hardcoded(bool enabled); 
	
	int GetPosX();
	int GetPosY();
	int GetWidth();
	int GetHeight();
	int GetIndex();
};

shared interface IGUIElementCallbackInit{void OnInit(int id);}
shared interface IGUIElementCallbackDraw{void OnDraw(int id);}
shared interface IGUIElementCallbackKeyPress{bool OnKeyPress(uint8 key,string&keyText);}
shared interface IGUIElementCallbackMouseDown{void OnMouseDown(int click);}
shared interface IGUIElementCallbackMouseClick{void OnMouseClick(int id,int click);}
shared interface IGUIElementCallbackMouseMove{void OnMouseMove(int x,int y);}
shared interface IGUIElementCallbackValueChange{void OnValueChange(int newValue);}
shared interface IGUIElementCallbackStateChange{void OnStateChange(bool state);}

shared interface IGUIElementOpt
{
	IGUIElementOpt@CallbackInit(IGUIElementCallbackInit@callback);
	IGUIElementOpt@CallbackDraw(IGUIElementCallbackDraw@callback);
	IGUIElementOpt@CallbackKeyPress(IGUIElementCallbackKeyPress@callback);
	IGUIElementOpt@CallbackMouseDown(IGUIElementCallbackMouseDown@callback);
	IGUIElementOpt@CallbackMouseClick(IGUIElementCallbackMouseClick@callback);
	IGUIElementOpt@CallbackMouseMove(IGUIElementCallbackMouseMove@callback);
	IGUIElementOpt@Position(int x,int y);
	IGUIElementOpt@Position(int x,int y,int w,int h);
	IGUIElementOpt@Position(string&iniKey);
	IGUIElementOpt@Visible(bool visible);
	IGUIElementOpt@AbsolutePosition(bool absolutePosition);
	IGUIElementOpt@AbsolutePosition(int x,int y);
	IGUIElementOpt@CollisionTransparent(bool collisionTransparent);
	IGUIElementOpt@AddText(int id,string@text,int x,int y,int width,int height,int font,uint color,int flags);
	IGUIElementOpt@AddImage(int id,string@sprName,int x,int y);
	IGUIElementOpt@AddImage(int id,int patch,string@sprName,int x,int y);
	IGUIElementCallbackInit@GetCallbackInit();
	
	void MouseDown(int click);
	void MouseUp(int click,bool IsCollision);
	void MouseMove(int x,int y);
	
	void Draw(int screenX,int screenY);
	void Update(uint dt);
	void SetFocused(bool state);
	void SetVisible(bool visible);
	void SetAbsolutePosition(bool absolutePosition);
	
	void SetCollisionTransparent(bool collisionTransparent);
	void InputLost();
	
	IGUIElementOpt@GetNewInstance(); 
	
	bool IsVisible();
	bool IsFocused();
	bool IsAbsolutePosition();
	bool IsCollisionTransparent();
	bool IsCollision(int screenX,int screenY,int mouseX,int mouseY);
	int GetId();
	int GetPosX();
	int GetPosY();
	int GetHeight();
	int GetWidth();
	
	bool KeyPress(uint8 key,string&keyText);
	void KeyUp(uint8 key,string&keyText);
}

shared interface IGUIElementTextOpt
{
	IGUIElementTextOpt@CallbackInit(IGUIElementCallbackInit@callback);
	IGUIElementTextOpt@CallbackDraw(IGUIElementCallbackDraw@callback);
	IGUIElementTextOpt@CallbackMouseDown(IGUIElementCallbackMouseDown@callback);
	IGUIElementTextOpt@CallbackMouseClick(IGUIElementCallbackMouseClick@callback);
	IGUIElementTextOpt@CallbackMouseMove(IGUIElementCallbackMouseMove@callback);
	
	IGUIElementTextOpt@Position(int x,int y);
	IGUIElementTextOpt@Position(int x,int y,int w,int h);
	IGUIElementTextOpt@Position(string&iniKey);
	IGUIElementTextOpt@AbsolutePosition(int x,int y);
	IGUIElementTextOpt@AbsolutePosition(bool absolutePosition);
	IGUIElementTextOpt@Text(string@text);
	IGUIElementTextOpt@Text(string@text,int font,uint color);
	IGUIElementTextOpt@Text(string@text,int font,uint color,int flags);
	IGUIElementTextOpt@Text(string@text,int font,uint color,uint downColor,int flags);
	IGUIElementTextOpt@Visible(bool visible);
	IGUIElementTextOpt@TextBoxSize(int width,int height);
	IGUIElementTextOpt@TextOptions(int font,uint color);
	IGUIElementTextOpt@TextOptions(int font,uint color,int flags);
	IGUIElementTextOpt@TextOptions(int font,uint color,uint colorDown,int flags);
	IGUIElementTextOpt@TextColor(uint color);
	
	void Draw(int screenX,int screenY);
	void SetText(string&text);
	void SetVisible(bool visible);
	void SetFocused(bool state); 
	
	bool IsVisible();
	string@GetText();
	int GetFont();
	uint GetTextColor(); 
	
	int GetId();
}

shared interface IGUIElementImageOpt
{
	IGUIElementImageOpt@CallbackInit(IGUIElementCallbackInit@callback);
	IGUIElementImageOpt@CallbackDraw(IGUIElementCallbackDraw@callback);
	IGUIElementImageOpt@CallbackMouseDown(IGUIElementCallbackMouseDown@callback);
	IGUIElementImageOpt@CallbackMouseClick(IGUIElementCallbackMouseClick@callback);
	
	IGUIElementImageOpt@Position(int x,int y);
	IGUIElementImageOpt@Position(int x,int y,int w,int h);
	IGUIElementImageOpt@Position(string&iniKey);
	IGUIElementImageOpt@AbsolutePosition(bool absolutePosition);
	IGUIElementImageOpt@Visible(bool visible); 
	
	void SetVisible(bool visible);
	void SetPosX(int x);
	void SetPosY(int y);
	void SetFocused(bool state);
	void SetAbsolutePosition(bool absolute);
	void Draw(int screenX,int screenY);  
	
	bool IsVisible();
	int GetPosX();
	int GetPosY();
	int GetImageWidth();
	int GetImageHeight();
	
	bool IsCollision(int screenX,int screenY,int mouseX,int mouseY);
}

shared interface IGUIElementButtonOpt
{
	IGUIElementButtonOpt@CallbackInit(IGUIElementCallbackInit@callback);
	IGUIElementButtonOpt@CallbackDraw(IGUIElementCallbackDraw@callback);
	IGUIElementButtonOpt@CallbackMouseDown(IGUIElementCallbackMouseDown@callback);
	IGUIElementButtonOpt@CallbackMouseClick(IGUIElementCallbackMouseClick@callback);
	
	IGUIElementButtonOpt@Position(int x,int y);
	IGUIElementButtonOpt@Position(int x,int y,int w,int h);
	IGUIElementButtonOpt@Position(string&iniKey);
	IGUIElementButtonOpt@AbsolutePosition(bool absolutePosition);
	IGUIElementButtonOpt@Text(string@text);
	IGUIElementButtonOpt@Text(string@text,int font,uint color);
	IGUIElementButtonOpt@Text(string@text,int font,uint color,int flags);
	IGUIElementButtonOpt@Text(string@text,int font,uint color,uint downColor,int flags);
	IGUIElementButtonOpt@Visible(bool visible);
	IGUIElementButtonOpt@TextShift(int deltaX,int deltaY,int deltaDownX,int deltaDownY);
	IGUIElementButtonOpt@TextWidth(int width);
	IGUIElementButtonOpt@UpPic(string@sprName);
	IGUIElementButtonOpt@DownPic(string@sprName);
	IGUIElementButtonOpt@ClickableZone(int width,int height);
	IGUIElementButtonOpt@ClickableZone(int x,int y,int width,int height);
	
	void SetVisible(bool visible);
	void SetFocused(bool state);
	void Hide();
	void Show();
	
	bool IsVisible();
	string getText();
	int GetPosX();
	int GetPosY();
}

shared interface IGUIElementEditBoxOpt
{
	IGUIElementEditBoxOpt@CallbackInit(IGUIElementCallbackInit@callback);
	IGUIElementEditBoxOpt@CallbackDraw(IGUIElementCallbackDraw@callback);
	IGUIElementEditBoxOpt@CallbackMouseDown(IGUIElementCallbackMouseDown@callback);
	IGUIElementEditBoxOpt@CallbackMouseClick(IGUIElementCallbackMouseClick@callback);
	IGUIElementEditBoxOpt@CallbackMouseMove(IGUIElementCallbackMouseMove@callback);
	IGUIElementEditBoxOpt@CallbackKeyPress(IGUIElementCallbackKeyPress@callback);
	
	IGUIElementEditBoxOpt@Position(int x,int y);
	IGUIElementEditBoxOpt@Position(int x,int y,int w,int h);
	IGUIElementEditBoxOpt@Position(string&iniKey);
	IGUIElementEditBoxOpt@AbsolutePosition(bool absolutePosition);
	IGUIElementEditBoxOpt@Text(string@text);
	IGUIElementEditBoxOpt@Text(string@text,int font,uint color);
	IGUIElementEditBoxOpt@Text(string@text,int font,uint color,int flags);
	IGUIElementEditBoxOpt@Text(string@text,int font,uint color,uint downColor,int flags);
	IGUIElementEditBoxOpt@Visible(bool visible);
	IGUIElementEditBoxOpt@TextBoxSize(int width,int height);
	IGUIElementEditBoxOpt@TextOptions(int font,uint color);
	IGUIElementEditBoxOpt@TextOptions(int font,uint color,int flags);
	IGUIElementEditBoxOpt@TextOptions(int font,uint color,uint colorDown,int flags);
	IGUIElementEditBoxOpt@TextColor(uint color);
	IGUIElementEditBoxOpt@VisibleText(string@text);
	IGUIElementEditBoxOpt@BackgroundPic(string@sprName);
	IGUIElementEditBoxOpt@MaxLen(int maxLen);
	IGUIElementEditBoxOpt@EditBoxSize(int width,int height);
	IGUIElementEditBoxOpt@LeftMargin(int lMargin);
	IGUIElementEditBoxOpt@RightMargin(int rMargin);
	IGUIElementEditBoxOpt@UpMargin(int uMargin);
	IGUIElementEditBoxOpt@DownMargin(int dMargin);
	IGUIElementEditBoxOpt@Margins(int lMargin,int rMargin,int uMargin,int dMargin);
	IGUIElementEditBoxOpt@PasswordMode(bool isPasswordMode);
	IGUIElementEditBoxOpt@PasswordChar(string@passChar);
	IGUIElementEditBoxOpt@NumericMode(bool isNumericMode);
	
	void Draw(int screenX,int screenY);
	void setVisible(bool visible);
	void setFocused(bool state);
	void NoInput(bool var);
	
	string@getText();
	bool isVisible();
	
	int getId();
}                                                                                                                                                                                                                            

import string GetCritterLexems(CritterCl&critter)from"lexems";
import string GetItemLexems(ItemCl&item)from"lexems";

import bool IsLexem(CritterCl&critter,string&lex)from"lexems";
import bool IsLexem(ItemCl&it,string&lex)from"lexems";
import bool IsLexem(string&lexems,string&lex)from"lexems";

import string GetLexem(CritterCl&critter,string&lex)from"lexems";
import string GetLexem(ItemCl&item,string&lex)from"lexems";
import string GetLexem(string&lexems,string&lex)from"lexems";                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

shared interface IPolygon
{
	IPolygon@AddVertex(uint16 x,uint16 y);
	IPolygon@AddVertices(array<uint16>&hexes);
	
	void GetTriangulation(array<uint16>&triangles);      
	
	bool IsWithin(uint16 x,uint16 y);
};  

import IPolygon@NewPolygon()from"polygon";     

import void GetDrawHexAreaData(array<uint16>&area,bool triangles,int color,array<int>&data)from"polygon";
import void DrawHexArea(array<uint16>&area,bool triangles,int color)from"polygon";             

uint16[]klamath_we_area_v=
{
	10000,10000,
	10000,20000,
	20000,20000,
	20000,30000,
	40000,30000,
	40000,20000,
	30000,20000,
	20000,25000,
	10000,20000
}; 

uint16[]modoc_area_v=
{
	214,217,
	107,217,
	107,126,
	70,126,
	70,90,
	93,90,
	93,71,
	145,71,
	214,174
}; 

uint16[]redding_area_v=
{
	130,140,
	130,155,
	172,155,
	172,183,
	170,183,
	170,197,
	172,197,
	172,217,
	148,217,
	148,230,
	106,230,
	106,147,
	64,147,
	64,60,
	135,60,
	135,97,
	155,97,
	155,140
};

uint16[]klamath_area_v=
{
	289,161,
	319,161,
	394,275,
	294,275,
	294,262,
	266,262,
	266,237,
	246,237,
	246,226,
	127,226,
	127,156,
	191,156,
	191,191,
	241,191,
	241,149,
	249,149,
	249,164,
	261,164,
	261,157,
	257,157,
	257,150,
	283,150,
	283,152,
	289,152
	
};

uint16[]den_area_v=
{
	40,100,
	125,100,
	125,70,
	210,70,
	210,130,
	195,130,
	195,210,
	125,210,
	125,188,
	40,188
}; 

uint16[]bh_area_v=
{
	258,147,
	287,147,
	288,171,
	340,171,
	340,203,
	262,203,
	262,235,
	226,235,
	226,210,
	120,210,
	120,173,
	76,173,
	76,153,
	181,153,
	181,155,
	200,155,
	200,143,
	210,143,
	210,117,
	240,117,
	246,122,
	258,122
}; 

uint16[]gecko_area_v=
{
	236,135,
	236,155,
	282,155,
	282,203,
	282,313,
	223,313,
	223,278,
	226,278,
	226,255,
	242,255,
	242,223,
	236,223,
	235,203,
	220,203,
	220,201,
	216,201,
	216,197,
	207,197,
	208,189,
	204,189,
	204,135
};

uint16[]necro_area_v=
{
	212,80,
	214,80,
	214,117,
	166,117,
	166,153,
	138,153,
	138,149,
	128,149,
	128,155,
	102,155,
	102,165,
	78,165,
	78,139,
	54,139,
	54,97,
	150,97,
	150,81,
	164,81,
	164,68,
	212,68
	
};

uint16[]reno_area_v=
{
	212,80,
	214,80,
	214,117,
	166,117,
	166,153,
	138,153,
	138,149,
	128,149,
	128,155,
	102,155,
	102,165,
	78,165,
	78,139,
	54,139,
	54,97,
	150,97,
	150,81,
	164,81,
	164,68,
	212,68
};             

enum Ingredients
{ 
	
	INGREDIENT_NONE=0,
	
	INGREDIENT_WATER,
	INGREDIENT_WOOD,
	INGREDIENT_RADIATED_FOOD,
	INGREDIENT_BARLEY,
	INGREDIENT_TOBACCO,
	INGREDIENT_FIBRE
};      

import bool HaveAnyIngredient(ItemCl&item)from"prod_ingredients";
import bool HaveIngredient(ItemCl&item,uint8 ingredient)from"prod_ingredients";
import uint16 GetIngredientReturnItem(ItemCl&item,uint8 ingredient)from"prod_ingredients";
import string IngredientName(uint8 ingredient)from"prod_ingredients";
import uint IngredientsNames(ItemCl&item,array<string>&names)from"prod_ingredients";                              

import uint ValidToolForTarget(ItemCl@tool,ItemCl@target)from"client_smart_cursor";
import bool TryUseSmartCursor(int click)from"client_smart_cursor";
import void TryDrawSmartCursor()from"client_smart_cursor";             

shared interface IWMZoneRender
{
	void SetX(int xin);
	void SetY(int yin);
	void SetColor(uint colorin);
	void SetDrawType(uint8 type);
	void SetZoneLength(int len);
	void SetLayer(uint layer);
	void Draw(uint layer);
}

shared interface IRayMap
{
	void SetDrawType(uint8 type);
	void SetColors(uint color1In,uint color2In);
	void SetId(uint id);
	void Draw();
}

shared interface IBurstRay
{
	void SetDrawType(uint8 type);
	void SetColors(uint color1In,uint color2In);
	void SetId(uint id);
	void Draw();
}

shared interface IDelayedText
{
	void SetId(uint id);
	void Draw();
}

shared interface IMuzzleFlash
{
	void SetDrawType(uint8 type);
	void SetColors(uint color1In,uint color2In);
	void SetId(uint id);
	void Draw();
}

shared interface IBurstMuzzle
{
	void SetDrawType(uint8 type);
	void SetColors(uint color1In,uint color2In);
	void SetId(uint id);
	void Draw();
}

shared interface IWeaponRadiusChosen
{
	void Draw();
	void SetDrawType(uint8 type);
	
}                                                                                                                                                                                                      

import IRayMap@CreateRay(int[]drawData)from"client_drawing";
import IBurstRay@CreateBurstRay(int[]drawData)from"client_drawing";
import IMuzzleFlash@CreateMuzzle(int[]drawData,uint type)from"client_drawing";
import IBurstMuzzle@CreateBurstMuzzle(int[]drawData,uint type)from"client_drawing";
import IDelayedText@_CreateDelayedText(int param0,int param1,int param2,string@param3,int[]@param4)from"client_drawing";
import void CreateCustomRadius(uint color,uint radius)from"client_drawing"; 

import void DrawRays()from"client_drawing";
import void DrawBurstRays()from"client_drawing";
import void DrawTexts()from"client_drawing";
import void DrawMuzzleFlashes()from"client_drawing";
import void DrawBurstMuzzles()from"client_drawing";

import void DrawCustomRadiuses()from"client_drawing";

import void DrawWMZones()from"client_drawing";                                                                                                                                               

import void DrawAchievements()from"achievements";

import void BroadcastDraw()from"client_broadcast";

import void changedParam_Hide(CritterCl&cr,uint,int oldValue)from"parameters";
import void CutsceneDraw()from"client_cutscene";

import void DrawChosenTabs()from"chosen_tabs";

import bool IsPossessMode()from"client_dev_menu";
import bool IsAuthorized()from"client_dev_menu";  

import bool GMToolsAccess()from"client_gmtools";
import void GMToolsDraw(uint layer,int mouseX,int mouseY)from"client_gmtools";
import bool IsGMTEnabled()from"client_main"; 

import uint8 GetCurrentAim()from"client_keybinds";

import void TimeoutsDraw()from"client_timeouts";

import void ColorizeCritter(CritterCl&cr)from"name_colorizing";
import void ColorizeCritterPreview(CritterCl&cr)from"name_colorizing";

import void SetRepairPid(uint16 pid)from"client_main";
import void SetRepairItem(uint id)from"client_main";

import string@CritterDescription_Get(uint description1,uint description2)from"critter_description";

import int stringReplaceText(string&s,string@f,string@t)from"config_file";

import void RenderThrowing()from"throwing";
import void RenderHexShoting()from"hexShot";
import void RenderHexThrowing()from"hexThrow";

import void DrawCritterOnHead()from"client_critter_onhead";

import void EncountersDraw()from"client_fef";

import uint GetContainerId()from"client_container_addons";
import uint GetBodyId()from"client_container_addons";                          

import void DrawFog()from"client_fov";
import void DrawMsFov()from"client_fov";
import void DrawCustomBorder()from"client_fov";

import string DateTimeToString(uint gameTime)from"time";    

class CDialogImage
{
	int x;
	int y;
	int sprite;
	
	CDialogImage()
	{
		{};
		this.Unset();
	}
	
	void Set(int x,int y,string&image)
	{
		this.x=x;
		this.y=y;
		this.sprite=LoadSprite(image,int((2)));
		{};
	}
	
	void Unset()
	{
		this.x=-1;
		this.y=-1;
		this.sprite=-1;
		{};
	}
	
	bool Exists()
	{
		if(this.x<0)
		return(false);
		if(this.y<0)
		return(false);
		if(this.sprite<=0)
		return(false);
		
		return(true);
	}
	
	void Draw()
	{
		int screen=GUI_GetActiveScreen();
		if(screen!=(14))
		return;
		
		int dX=0,dY=0;
		GetHardcodedScreenPos(screen,dX,dY);       
		
		DrawSprite(this.sprite,0,dX+this.x,dY+this.y,0);
		
		if(screen==(1))
		LoadSprite("discord.png",int((4)));
	}
};
CDialogImage DialogImage;

class CWorldmapElement
{
	int id;
	uint layer;
	uint x;
	uint y;
	uint width;
	uint height;
	uint color;
	
	Sprite sprite;
	bool scratch;
	bool center;
	bool applyOffset;
	
	string text;
	int font;
	int flags;
	
	CWorldmapElement(int id,uint layer)
	{
		this.id=id;
		this.layer=layer;
		this.x=0;
		this.y=0;
		this.width=0;
		this.height=0;
		this.color=0;
	}
	
	void SetSprite(Sprite&sprite,bool scratch,bool center,bool applyOffset)
	{
		this.text="";
		
		this.sprite=sprite;
		this.scratch=scratch;
		this.center=center;
		this.applyOffset=applyOffset;
	}
	
	void SetText(string&text,int font,int flags)
	{
		Sprite nul;
		this.sprite=nul;
		
		this.text=text;
		this.font=font;
		this.flags=flags;
	}
	
	void Draw(uint layer)
	{
		if(this.layer==layer)
		{
			if(this.sprite.Id>0)
			DrawSprite(this.sprite.Id,-1,this.x/__GmapZoom+__GmapOffsetX,this.y/__GmapZoom+__GmapOffsetY,(this.width==0?this.sprite.Width:this.width)/__GmapZoom,(this.height==0?this.sprite.Height:this.height)/__GmapZoom,this.scratch,this.center,this.color,this.applyOffset);
			if(this.text.length()>0)
			DrawText(this.text,this.x/__GmapZoom+__GmapOffsetX,this.y/__GmapZoom+__GmapOffsetY,this.width,this.height,this.color,this.font,this.flags);
		}
	}
};
array<CWorldmapElement@>WorldmapElements;

class CTempWorldmapElement:CWorldmapElement
{
	uint expirationTime;
	CTempWorldmapElement(int id,uint layer,uint expirationTime)
	{
		super(id,layer);
		this.expirationTime=expirationTime;
	}
	
	bool IsExpired()
	{
		return(__FullSecond)>=expirationTime;
	}
};
array<CTempWorldmapElement@>TempWorldmapElements;

uint pickupScreenScrollCritter=0;
uint pickupScreenScrollFrom=0;
bool disableItemMove=false;

void _EnableItemsMove(int param1,int param2,int param3,string@param4,array<int>@param5)
{
	disableItemMove=false;
}

void unsetall_location_combatzone(int,int,int,string@,array<int>@)
{
	TempWorldmapElements.resize(0);
}

void location_combatzone(int id,int layer,int expiration,string@,array<int>@coords)
{
	CTempWorldmapElement@element;
	
	bool found=false;
	for(uint e=0,elen=TempWorldmapElements.length();e<elen;e++)
	{
		if(TempWorldmapElements[e].id==id)
		{
			if(layer<0)
			{
				TempWorldmapElements.removeAt(e);
				return;
			}
			@element=TempWorldmapElements[e];
			found=true;
			break;
		}
	}
	
	if(layer<0)
	return;
	if(!found)
	{
		@element=CTempWorldmapElement(id,layer,uint(expiration));
		Sprite sprite;
		sprite.Load("combat_zone.png",int((4)));
		element.SetSprite(sprite,true,true,true);
	}
	
	if(!(@coords!=null)||coords.length()<3)
	return;
	
	element.x=coords[0]-coords[2];
	element.y=coords[1]-coords[2];
	element.width=coords[2]*2;
	element.height=coords[2]*2; 
	
	if(!found)
	TempWorldmapElements.insertLast(element);
}

void worldmap_element(int id,int layer,int type,string@,array<int>@data)
{
	CWorldmapElement@element;
	
	bool found=false;
	for(uint e=0,elen=WorldmapElements.length();e<elen;e++)
	{
		if(WorldmapElements[e].id==id)
		{
			if(layer<0)
			{
				WorldmapElements.removeAt(e);
				return;
			}
			@element=WorldmapElements[e];
			found=true;
			break;
		}
	}
	if(layer<0)
	return;
	if(!found)
	{
		@element=CWorldmapElement(id,layer);
	}
	
	if(!(@data!=null)||data.length()==0)
	return;
	
	Buffer@buff=NewBuffer(data);
	buff>>element.x>>element.y>>element.width>>element.height>>element.color;
	
	if(type==1)
	{
		Sprite sprite;
		
		string spriteName="";
		int spritePath=0;
		bool scratch=false;
		bool center=false;
		bool applyOffset=false;
		
		buff>>spriteName>>spritePath>>scratch>>center>>applyOffset;
		
		if(spriteName.length()>0&&sprite.Load(spriteName,spritePath))
		{
			element.SetSprite(sprite,scratch,center,applyOffset);
		}
		else
		return;
	}
	else if(type==2)
	{
		string text="";
		int font=0;
		int flags=0;
		
		buff>>text>>font>>flags;
		
		if(text.length()>0)
		{
			element.SetText(text,font,flags);
		}
		else
		return;
	}
	else
	return;
	
	if(!found)
	WorldmapElements.insertLast(element);
}  

void get_active_screens(array<int>&result)
{
	GUI_GetActiveScreens(result);
}

bool recheckDialogImage=false;  

void screen_change(bool show,int screen,int p0,int p1,int p2)
{
	if(DialogImage.Exists()&&recheckDialogImage&&
	show&&screen!=(14)&&
	!(screen==(15)||screen==(24)))
	{
		DialogImage.Unset();
		recheckDialogImage=false;
	}
	
	if(!show&&DialogImage.Exists()&&screen==(14))
	{
		recheckDialogImage=true;
	}
	
	if(show)
	GUI_ShowScreen(screen,p0,p1,p2);
	else
	GUI_HideScreen(screen,p0,p1,p2);
}                     

int CurrentCommand=(0);
int CurrentCommandX=0;
int CurrentCommandY=0;   

void render_iface(uint layer)
{ 
	
	uint sc=GUI_GetActiveScreen();
	uint mainsc=GUI_GetActiveMainScreen();
	
	if(layer==2)
	{     
		
		DrawFog();
		DrawMsFov();
		DrawCustomBorder();
		RenderHexThrowing();
		RenderHexShoting();
		
		GUI_Render(true);
		
		if(!__GmapActive)
		{
			if(InterfaceShown)
			DrawIndicators();
			RenderThrowing();
			
			TryDrawSmartCursor();
		}
		
		if(mainsc==(5)&&!__GmapActive)
		{ 
			
			CritterCl@chosen=GetChosen();  
			
			DrawRays();
			DrawBurstRays();
			
			DrawMuzzleFlashes();
			DrawBurstMuzzles();    
			
			if((@chosen!=null))
			{
				if(@chosen==null)CurrentCommand=(0);
				CurrentCommand=chosen.Param[(184)];
				CurrentCommandX=chosen.Param[(185)];
				CurrentCommandY=chosen.Param[(186)];
				if(CurrentCommand!=(0))
				{
					int x=0,y=0;
					GetHexPos(chosen.HexX,chosen.HexY,x,y);
					int x2=0,y2=0;
					GetHexPos(CurrentCommandX,CurrentCommandY,x2,y2);
					if(CurrentCommand==(1))
					{
						int[]data={x,y,0x7F0042BA,x2,y2,0x7F0042BA};
						DrawPrimitive((2),data);
						
						DrawSprite(LoadSprite("command_move.png",(4)),0,x2-16,y2-43,0);
					}
					else if(CurrentCommand==(2))
					{
						int[]data={x,y,0x7FCC0000,x2,y2,0x7FCC0000};
						DrawPrimitive((2),data);
						
						DrawSprite(LoadSprite("command_attack.png",(4)),0,x2-16,y2-43,0);
					}
					else if(CurrentCommand==(3))
					{
						int[]data={x,y,0x7FC8300BA,x2,y2,0x7FC8300BA};
						DrawPrimitive((2),data);
						
						DrawSprite(LoadSprite("command_defend.png",(4)),0,x2-16,y2-43,0);
					}
				}
			}
		} 
		
	}
	
	else if(layer==3)
	{ 
		
		if(mainsc==(5))
		{
			
			DrawText("FOnline 3",0,5,__ScreenWidth-5,10,0,(5),(0x0010)); 
			
			string date=DateTimeToString(__FullSecond);
			DrawText(date,0,15,__ScreenWidth-5,10,0,(5),(0x0010));
			CritterCl@chosen=GetChosen(); 
			
			switch(chosen.Param[(139)])
			{
				case 1:DrawText("Local Currency: Enclave Dollars",0,25,__ScreenWidth-5,10,0,(5),(0x0010));break;
				case 2:DrawText("Local Currency: Memory Chips",0,25,__ScreenWidth-5,10,0,(5),(0x0010));break;
				case 3:DrawText("Local Currency: NCR Scrips",0,25,__ScreenWidth-5,10,0,(5),(0x0010));break;
				case 4:DrawText("Local Currency: VT Pounds",0,25,__ScreenWidth-5,10,0,(5),(0x0010));break;
				case 5:DrawText("Local Currency: Ring Pulls",0,25,__ScreenWidth-5,10,0,(5),(0x0010));break; 
				
			}
		}
		if(__ConfigOnHeadAwareness>0)
		DrawCritterOnHead();
		
		if(IsPossessMode())
		DrawText("Possess mode on",0,0,__ScreenWidth,20,0,(5),(0x0004)|(0x0008)|(0x0200));
		
		TimeoutsDraw(); 
		
		if(IsGMTEnabled()&&GMToolsAccess())
		GMToolsDraw(layer,__MouseX,__MouseY);          
		
		if((sc==(5)||sc==(6)||((sc>9)&&(sc<46))))
		{
			BroadcastDraw();
			CutsceneDraw();
		}
		
		if(sc==(5)&&IsAuthorized())
		{
			uint16 hx=0;
			uint16 hy=0;
			if(GetMonitorHex(__MouseX,__MouseY,hx,hy))
			DrawText(""+hx+", "+hy,0,0,__ScreenWidth,20,((uint((0xFF<<24)|(((60)&0xFF)<<16)|(((248)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0010));
			CritterCl@cr=GetMonitorCritter(__MouseX,__MouseY);
			if((@cr!=null))
			DrawText("Critter> id: "+cr.Id+", pid: "+cr.Pid,0,10,__ScreenWidth,20,((uint((0xFF<<24)|(((60)&0xFF)<<16)|(((248)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0010));
			ItemCl@item=GetMonitorItem(__MouseX,__MouseY);
			if((@item!=null))
			DrawText("Item> pid: "+item.GetProtoId()+"x,y: "+item.HexX+", "+item.HexY,0,20,__ScreenWidth,20,((uint((0xFF<<24)|(((60)&0xFF)<<16)|(((248)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0010));
			
		}
		
		if(GMToolsAccess())
		{
			ItemCl@item=GetMonitorItem(__MouseX,__MouseY);
			if((@item!=null))
			{
				int dy=-10;
				DrawText("All vals: "+item.Val0+" "+item.Val1+" "+item.Val2+" "+item.Val3+" "+item.Val4+" "+item.Val5+" "+item.Val6+" "+item.Val7+" "+item.Val8+" "+item.Val2,__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0100)|(0x0200));
				dy-=10;
				if(item.GetType()==(8))
				{
					DrawText("Locker ID: "+item.LockerId,__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0100)|(0x0200));
					dy-=10;
					DrawText("Container Val4: "+item.Val4,__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0100)|(0x0200));
					dy-=10;
					DrawText("Locker Complex: "+item.LockerComplexity,__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0100)|(0x0200));
					dy-=10;
				}
				if(item.GetType()==(13))
				{
					DrawText("Locker ID: "+item.LockerId,__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0100)|(0x0200));
					dy-=10;
					DrawText("Locker Complex: "+item.LockerComplexity,__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0100)|(0x0200));
					dy-=10;
				}
				DrawText(GetMsgStr((2),(item.GetProtoId()*100)),__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0100)|(0x0200));
			}
		}
		
		if(__ConfigAwareness)
		{
			CritterCl@chosen=GetChosen();
			if((@chosen!=null))
			{
				if(chosen.Param[(301)]!=0)
				{
					CritterCl@cr=GetMonitorCritter(__MouseX,__MouseY);
					if((@cr!=null))
					{
						int dy=-10;  
						
						switch(cr.Param[(138)])
						{
							case 1:
							{
								DrawText("Randomboy",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((255)&0xFF)<<16)|(((0)&0xFF)<<8)|((191)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 2:
							{
								DrawText("Super Mutant",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((113)&0xFF)<<16)|(((171)&0xFF)<<8)|((75)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 3:
							{
								DrawText("Soldier",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((109)&0xFF)<<16)|(((227)&0xFF)<<8)|((138)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 4:
							{
								DrawText("Chosen One",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((147)&0xFF)<<16)|(((0)&0xFF)<<8)|((245)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 5:
							{
								DrawText("Priest",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((255)&0xFF)<<16)|(((144)&0xFF)<<8)|((255)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 6:
							{
								DrawText("Bounty Hunter",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((145)&0xFF)<<16)|(((44)&0xFF)<<8)|((13)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 7:
							{
								DrawText("Deathclaw",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((255)&0xFF)<<16)|(((174)&0xFF)<<8)|((0)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 8:
							{
								DrawText("Cyborg",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((0)&0xFF)<<16)|(((247)&0xFF)<<8)|((235)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 9:
							{
								DrawText("Killer",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((255)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 10:
							{
								DrawText("Assassin",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((125)&0xFF)<<16)|(((125)&0xFF)<<8)|((125)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 11:
							{
								DrawText("Leader",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((255)&0xFF)<<16)|(((255)&0xFF)<<8)|((255)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 12:
							{
								DrawText("Paramedic",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((5)&0xFF)<<16)|(((168)&0xFF)<<8)|((160)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 13:
							{
								DrawText("Sniper",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((163)&0xFF)<<16)|(((158)&0xFF)<<8)|((60)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 14:
							{
								DrawText("Infantry",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((62)&0xFF)<<16)|(((112)&0xFF)<<8)|((173)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 15:
							{
								DrawText("Alien",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((88)&0xFF)<<16)|(((138)&0xFF)<<8)|((92)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 16:
							{
								DrawText("Combat Master",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0)&0xFF)<<8)|((255)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 17:
							{
								DrawText("Wrecker",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((255)&0xFF)<<16)|(((255)&0xFF)<<8)|((0)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 18:
							{
								DrawText("Clone",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((125)&0xFF)<<16)|(((40)&0xFF)<<8)|((78)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
						}
						
						switch(cr.Param[(100)])
						{
							case 1:
							{
								DrawText("Janitor",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((255)&0xFF)<<16)|(((0)&0xFF)<<8)|((191)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							case 2:
							{
								DrawText("Another Class",__MouseX+15,__MouseY+dy,__ScreenWidth,20,(uint((0xFF<<24)|(((255)&0xFF)<<16)|(((0)&0xFF)<<8)|((191)&0xFF))),(5),(0x0100)|(0x0200));
								dy-=10;
								break;
							}
							
						}
						
						if(IsLexem(cr,"$faction")&&cr.IsPlayer())
						{
							if(cr.Param[(121)]==1)
							DrawText("Recruit",__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0xAB)&0xFF)<<16)|(((0xAB)&0xFF)<<8)|((0xAB)&0xFF)))),(5),(0x0100)|(0x0200));
							else if(cr.Param[(121)]==2)
							DrawText("Member",__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0xAB)&0xFF)<<16)|(((0xAB)&0xFF)<<8)|((0xAB)&0xFF)))),(5),(0x0100)|(0x0200));
							else if(cr.Param[(121)]==3)
							DrawText("Trusted",__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0xAB)&0xFF)<<16)|(((0xAB)&0xFF)<<8)|((0xAB)&0xFF)))),(5),(0x0100)|(0x0200));
							else if(cr.Param[(121)]==4)
							DrawText("Officer",__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0xAB)&0xFF)<<16)|(((0xAB)&0xFF)<<8)|((0xAB)&0xFF)))),(5),(0x0100)|(0x0200));
							else if(cr.Param[(121)]==5)
							DrawText("Leader",__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0xAB)&0xFF)<<16)|(((0xAB)&0xFF)<<8)|((0xAB)&0xFF)))),(5),(0x0100)|(0x0200));
							dy-=10;
						}
						
						string factionname;
						if(IsLexem(cr,"$faction"))
						{
							factionname=GetLexem(cr,"$faction");
							DrawText(factionname,__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0100)|(0x0200));
							dy-=10;
						}
						
						if(cr.IsDead())
						{
							DrawText("Dead",__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0x30)&0xFF)<<16)|(((0x30)&0xFF)<<8)|((0x30)&0xFF)))),(5),(0x0100)|(0x0200));
						}
						else
						{
							ItemCl@item=cr.GetItem(0,(1));
							string _item="Unarmed";
							string item_prefix="";
							if((@item!=null))
							{
								if(IsLexem(item,"$-"))
								_item=GetLexem(item,"$-");
								else
								_item=GetMsgStr((2),(item.GetProtoId()*100+item.Info)); 
								
								item_prefix+=showPrefix(item);
								
							}
							
							DrawText(item_prefix+_item,__MouseX+15,__MouseY+dy,__ScreenWidth,20,((@item!=null)&&item.GetType()==(3))?((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xFF)&0xFF)<<8)|((0)&0xFF)))):((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),(5),(0x0100)|(0x0200));
							dy-=10;
							
							ItemCl@armor=cr.GetItem(0,(3));
							ItemCl@helmet=cr.GetItem(0,(4));
							if(cr.IsPlayer()||cr.Param[(67)]==(0)||cr.Param[(67)]==(1)||cr.Param[(67)]==(2)||
							cr.Param[(67)]==(4)||cr.Param[(67)]==(3)||
							(@armor!=null)||(@helmet!=null))
							{
								
								if((@armor!=null))
								{
									string _armor="No armor";
									if(IsLexem(armor,"$-"))
									_armor=GetLexem(armor,"$-");
									else
									_armor=GetMsgStr((2),(armor.GetProtoId()*100+armor.Info));
									
									DrawText(showPrefix(armor)+_armor,__MouseX+15,__MouseY+dy,__ScreenWidth,20,(@armor!=null)&&armor.GetType()==(1)?((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))):((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),(5),(0x0100)|(0x0200));
									dy-=10;
								}
								
								if((@helmet!=null))
								{
									string _helmet="No helmet";
									if(IsLexem(helmet,"$-"))
									_helmet=GetLexem(helmet,"$-");
									else
									_helmet=GetMsgStr((2),(helmet.GetProtoId()*100+helmet.Info));
									DrawText(_helmet,__MouseX+15,__MouseY+dy,__ScreenWidth,20,(@helmet!=null)&&helmet.GetType()==(1)?((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))):((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),(5),(0x0100)|(0x0200));
									dy-=10;
								}
							}
							
							if((!__ConfigShowNpcAwareness&&cr.IsNpc())||!__ConfigShowPlayerAwareness&&cr.IsPlayer())
							{
								int curHp=cr.Param[(72)];
								int maxHp=cr.Param[(7)];
								DrawText(curHp+"/"+maxHp,__MouseX+15,__MouseY+dy,__ScreenWidth,20,cr.IsDead()?((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))):(curHp<1?((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))):(uint((0xFF<<24)|(((0xff-(0xff*curHp)/maxHp)&0xFF)<<16)|((((0xff*curHp)/maxHp)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0100)|(0x0200));
								
								dy-=10;
							}
							
							if((cr.Damage[(502)]>0||cr.Damage[(503)]>0||cr.Damage[(504)]>0||cr.Damage[(505)]>0||cr.Damage[(506)]>0))
							{
								if((!__ConfigShowNpcAwareness&&cr.IsNpc())||!__ConfigShowPlayerAwareness&&cr.IsPlayer())
								{
									string crInjures="";
									crInjures+=(cr.Damage[(502)]>0)?"E ":"";
									crInjures+=(cr.Damage[(503)]>0)?"RA ":"";
									crInjures+=(cr.Damage[(504)]>0)?"LA ":"";
									crInjures+=(cr.Damage[(505)]>0)?"RL ":"";
									crInjures+=(cr.Damage[(506)]>0)?"LL ":"";
									
									DrawText(crInjures,__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0xAA)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0100)|(0x0200));
									dy-=10;
								}
							}
							
							if(cr.IsNpc())
							{
								uint dialog=cr.Param[(104)];
								uint16 pid=cr.Pid;
								string result=GetMsgStr((1),((dialog)!=0?100000+(dialog)*1000+100:((pid)*10)));
								DrawText(result,__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0x66)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0100)|(0x0200));
							}
						}
					}
				}
				else
				{
					CritterCl@cr=GetMonitorCritter(__MouseX,__MouseY);
					if((@cr!=null))
					{
						int dy=-10;
						
						if(cr.Param[(121)]>3)
						{
							if(cr.Param[(121)]==4)DrawText("Officer",__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0xAB)&0xFF)<<16)|(((0xAB)&0xFF)<<8)|((0xAB)&0xFF)))),(5),(0x0100)|(0x0200));
							else if(cr.Param[(121)]==5)DrawText("Leader",__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0xAB)&0xFF)<<16)|(((0xAB)&0xFF)<<8)|((0xAB)&0xFF)))),(5),(0x0100)|(0x0200));
							dy-=10;
						}
						
						string factionname;
						if(IsLexem(cr,"$faction"))
						{
							factionname=GetLexem(cr,"$faction");
							DrawText(factionname,__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0100)|(0x0200));
							dy-=10;
						}
						if(cr.IsDead())
						{
							DrawText("Dead",__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),(5),(0x0100)|(0x0200));
						}
						else
						{
							string lifeRes=GetMsgStr((3),(12510+(cr.Param[(136)]>1?cr.Param[(136)]:1)));
							
							if((cr.Damage[(502)]>0||cr.Damage[(503)]>0||cr.Damage[(504)]>0||cr.Damage[(505)]>0||cr.Damage[(506)]>0))
							{
								DrawText("Injured",__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0xAA)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0100)|(0x0200));
								dy-=10;
							}
							DrawText(lifeRes,__MouseX+15,__MouseY+dy,__ScreenWidth,20,cr.IsDead()?((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))):(cr.Param[(136)]<1?((uint((0xFF<<24)|(((0xAB)&0xFF)<<16)|(((0xAB)&0xFF)<<8)|((0xAB)&0xFF)))):(uint((0xFF<<24)|(((0xff-(0xff*cr.Param[(136)])/5)&0xFF)<<16)|((((0xff*cr.Param[(136)])/5)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0100)|(0x0200));
						}
						
						dy-=10;
						if(cr.IsNpc())
						{
							uint dialog=cr.Param[(104)];
							uint16 pid=cr.Pid;
							string result=GetMsgStr((1),((dialog)!=0?100000+(dialog)*1000+100:((pid)*10)));
							DrawText(result,__MouseX+15,__MouseY+dy,__ScreenWidth,20,((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0x66)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0100)|(0x0200));
						}
						
					}
				}
				
			}
			
		}  
		
		GUI_Render(false);       
		
		if(sc==(14)&&DialogImage.Exists())
		DialogImage.Draw();
		
		DrawChosenTabs();        
		
		DrawAchievements();
	}          
	
	else if((layer==100||layer==101)&&__GmapActive)
	{
		SetDefaultFont((5),((uint((0xFF<<24)|(((60)&0xFF)<<16)|(((248)&0xFF)<<8)|((0)&0xFF)))));             
		
		for(uint e=0,elen=WorldmapElements.length();e<elen;e++)
		{
			WorldmapElements[e].Draw(layer);
		}
		
		EncountersDraw();
	}
}  

bool render_iface_screen(uint screen)
{
	
	return(true);
}   

string generic_description(int descType,int&offsX,int&offsY)
{
	CritterCl@chosen=GetChosen();
	if(!(@chosen!=null))
	return"";
	string result;
	
	if(descType==(0))
	{
		result+=chosen.Name+"\n";
		result+="---------------------\n";
		result+=GetMsgStr((3),(400+((0))))+"\n";
		result+=GetMsgStr((3),(400+((1))))+"\n";
		result+=GetMsgStr((3),(400+((2))))+"\n";
		result+=GetMsgStr((3),(400+((3))))+"\n";
		result+=GetMsgStr((3),(400+((4))))+"\n";
		result+=GetMsgStr((3),(400+((5))))+"\n";
		result+=GetMsgStr((3),(400+((6))))+"\n";
		result+="\n\n---------------------\n";
		
		ItemCl@weaponMain=chosen.GetItem(0,(1));
		if((@weaponMain!=null))
		{
			int use=((weaponMain.Mode)&0xF);
			if(use>2)
			use=0;
			
			string _name=GetMsgStr((2),(weaponMain.GetProtoId()*100+weaponMain.Info));
			if(IsLexem(weaponMain,"$-"))
			_name=GetLexem(weaponMain,"$-");
			result+=showPrefix(weaponMain)+_name+" \n";
			result+=" |-16711936 ";
			if(weaponMain.GetType()==(3))
			{
				int nfix=2;
				result+=GetMsgStr((3),(415))+" ";
				int wpnMinDmg=((use)==0?weaponMain.Proto.Weapon_DmgMin_0:((use)==1?weaponMain.Proto.Weapon_DmgMin_1:((use)==2?weaponMain.Proto.Weapon_DmgMin_2:0)));
				if((((use)==0?weaponMain.Proto.Weapon_Skill_0:((use)==1?weaponMain.Proto.Weapon_Skill_1:((use)==2?weaponMain.Proto.Weapon_Skill_2:0)))==(203)))
				{   
					
					wpnMinDmg+=chosen.Param[(10)]*0.75;
				}
				int bonusmindmg=0;
				if((@weaponMain!=null)&&weaponMain.Val3==(2))bonusmindmg+=24;
				if((@weaponMain!=null)&&weaponMain.Val4==(2))bonusmindmg+=24;
				if((@weaponMain!=null)&&weaponMain.Val5==(2))bonusmindmg+=24;
				if((@weaponMain!=null)&&weaponMain.Val6==(2))bonusmindmg+=24;
				if((@weaponMain!=null)&&weaponMain.Val7==(2))bonusmindmg+=24;
				if((@weaponMain!=null)&&weaponMain.Val8==(2))bonusmindmg+=24;
				int bonusmaxdmg=0;
				if((@weaponMain!=null)&&weaponMain.Val3==(3))bonusmaxdmg+=19;
				if((@weaponMain!=null)&&weaponMain.Val4==(3))bonusmaxdmg+=19;
				if((@weaponMain!=null)&&weaponMain.Val5==(3))bonusmaxdmg+=19;
				if((@weaponMain!=null)&&weaponMain.Val6==(3))bonusmaxdmg+=19;
				if((@weaponMain!=null)&&weaponMain.Val7==(3))bonusmaxdmg+=19;
				if((@weaponMain!=null)&&weaponMain.Val8==(3))bonusmaxdmg+=19;
				
				if((@weaponMain!=null)&&weaponMain.Val3==(101)){bonusmaxdmg+=50;bonusmindmg+=50;}
				if((@weaponMain!=null)&&weaponMain.Val4==(101)){bonusmaxdmg+=50;bonusmindmg+=50;}
				if((@weaponMain!=null)&&weaponMain.Val5==(101)){bonusmaxdmg+=50;bonusmindmg+=50;}
				if((@weaponMain!=null)&&weaponMain.Val6==(101)){bonusmaxdmg+=50;bonusmindmg+=50;}
				if((@weaponMain!=null)&&weaponMain.Val7==(101)){bonusmaxdmg+=50;bonusmindmg+=50;}
				if((@weaponMain!=null)&&weaponMain.Val8==(101)){bonusmaxdmg+=50;bonusmindmg+=50;}
				if((@weaponMain!=null)&&weaponMain.Val2==(101)){bonusmaxdmg+=50;bonusmindmg+=50;}
				wpnMinDmg+=wpnMinDmg*bonusmindmg/100;
				result+=wpnMinDmg+"-";
				
				int wpnMaxDmg=((use)==0?weaponMain.Proto.Weapon_DmgMax_0:((use)==1?weaponMain.Proto.Weapon_DmgMax_1:((use)==2?weaponMain.Proto.Weapon_DmgMax_2:0)));
				if((((use)==0?weaponMain.Proto.Weapon_Skill_0:((use)==1?weaponMain.Proto.Weapon_Skill_1:((use)==2?weaponMain.Proto.Weapon_Skill_2:0)))==(203)))
				{
					wpnMaxDmg+=chosen.Param[(10)]*0.75;;
				}
				wpnMaxDmg+=wpnMaxDmg*bonusmaxdmg/100;
				result+=wpnMaxDmg;
				
				if(((use)==0?weaponMain.Proto.Weapon_MaxDist_0:((use)==1?weaponMain.Proto.Weapon_MaxDist_1:((use)==2?weaponMain.Proto.Weapon_MaxDist_2:0)))>1)
				{
					result+=" "+GetMsgStr((3),(416))+" ";
					int wpnMaxDist=((use)==0?weaponMain.Proto.Weapon_MaxDist_0:((use)==1?weaponMain.Proto.Weapon_MaxDist_1:((use)==2?weaponMain.Proto.Weapon_MaxDist_2:0)));
					if(((use)==0?weaponMain.Proto.Weapon_Skill_0:((use)==1?weaponMain.Proto.Weapon_Skill_1:((use)==2?weaponMain.Proto.Weapon_Skill_2:0)))==(205))
					{
						wpnMaxDist=5+chosen.Param[(0)];
						
						wpnMaxDist+=6*(chosen.Param[(336)]);
					}
					int bonusrange=0;
					if((@weaponMain!=null)&&weaponMain.Val3==(4))bonusrange+=4;
					if((@weaponMain!=null)&&weaponMain.Val4==(4))bonusrange+=4;
					if((@weaponMain!=null)&&weaponMain.Val5==(4))bonusrange+=4;
					if((@weaponMain!=null)&&weaponMain.Val6==(4))bonusrange+=4;
					if((@weaponMain!=null)&&weaponMain.Val7==(4))bonusrange+=4;
					if((@weaponMain!=null)&&weaponMain.Val8==(4))bonusrange+=4;
					if(chosen.Param[(336)]>0&&chosen.Param[(315)]>0&&((use)==0?weaponMain.Proto.Weapon_Skill_0:((use)==1?weaponMain.Proto.Weapon_Skill_1:((use)==2?weaponMain.Proto.Weapon_Skill_2:0)))!=(203)&&((use)==0?weaponMain.Proto.Weapon_Skill_0:((use)==1?weaponMain.Proto.Weapon_Skill_1:((use)==2?weaponMain.Proto.Weapon_Skill_2:0)))!=(210))
					bonusrange+=5;
					if(chosen.Param[(418)]>0)bonusrange+=5;
					if(chosen.Param[(315)]>0&&chosen.Param[(336)]>0)bonusrange+=5;
					wpnMaxDist+=bonusrange;
					if(chosen.Param[(352)]>0)
					wpnMaxDist*=2;
					
					if(wpnMaxDist<2&&((use)==0?weaponMain.Proto.Weapon_Skill_0:((use)==1?weaponMain.Proto.Weapon_Skill_1:((use)==2?weaponMain.Proto.Weapon_Skill_2:0)))!=(203))
					{
						if(chosen.IsPlayer())
						{
							uint16 year=0,month=0,day=0,dayofweek=0,hour=0,minute=0,second=0;
							GetGameTime(__FullSecond,year,month,day,dayofweek,hour,minute,second);
							file f;
							f.open("logs/hexbot.txt","w");
							f.writeString(day+"."+month+" "+chosen.Name+" for real using hexbot!!!");
							f.close();
						}
					}
					result+=wpnMaxDist+"\n";
					nfix--;
				}
				
				if(weaponMain.Proto.Weapon_MaxAmmoCount>0)
				{
					result+=GetMsgStr((3),(417))+" ";
					result+=weaponMain.AmmoCount+"/";
					result+=weaponMain.Proto.Weapon_MaxAmmoCount+" ";
					
					result+=GetMsgStr((3),(10900+(weaponMain.Proto.Weapon_Caliber)));
					result+="\n";
					nfix--;
				}
				else if(weaponMain.IsStackable()&&weaponMain.GetCount()>1&&nfix>=1)
				{
					if(((use)==0?weaponMain.Proto.Weapon_MaxDist_0:((use)==1?weaponMain.Proto.Weapon_MaxDist_1:((use)==2?weaponMain.Proto.Weapon_MaxDist_2:0)))<2)
					{
						result+="\n";
						nfix--;
					}
					result+="Amount: "+weaponMain.GetCount()+"\n";
					nfix--;
				}
				for(int n=0;n<nfix;n++)
				result+="\n";
			}
			else
			{
				if(weaponMain.IsStackable()&&weaponMain.GetCount()>1)
				result+="Amount: "+weaponMain.GetCount()+"\n";
				else if(weaponMain.Proto.Misc_ChargeMax>0)
				result+="Charges: "+weaponMain.Charge+"/"+weaponMain.Proto.Misc_ChargeMax+"\n";
				else
				result+="\n";
				
				result+="\n";
			}
		}
		else
		{
			
			uint8 mode=0;
			ProtoItem@unarmed=chosen.GetSlotProto((1),mode);
			result+=GetMsgStr((3),(414))+"\n";
			result+=GetMsgStr((3),(424))+" ";     
			
			result+=((((mode)&0xF))==0?unarmed.Weapon_DmgMin_0:((((mode)&0xF))==1?unarmed.Weapon_DmgMin_1:((((mode)&0xF))==2?unarmed.Weapon_DmgMin_2:0)))+chosen.Param[(10)]/2+"-";
			result+=((((mode)&0xF))==0?unarmed.Weapon_DmgMax_0:((((mode)&0xF))==1?unarmed.Weapon_DmgMax_1:((((mode)&0xF))==2?unarmed.Weapon_DmgMax_2:0)))+chosen.Param[(10)]/2;
			result+="\n\n";
		}
		result+="---------------------\n";
		
		ItemCl@weaponExt=chosen.GetItem(0,(2));
		if((@weaponExt!=null))
		{
			int use=((weaponExt.Mode)&0xF);
			if(use>2)
			use=0;
			
			string _name=showPrefix(weaponExt)+GetMsgStr((2),(weaponExt.GetProtoId()*100+weaponExt.Info));
			
			if(IsLexem(weaponExt,"$-"))
			_name=GetLexem(weaponExt,"$-");
			result+=_name+"\n";
			result+=" |-16711936 ";
			if(weaponExt.GetType()==(3))
			{
				int nfix=2;
				result+=GetMsgStr((3),(415))+" ";
				
				int wpnMinDmg=((use)==0?weaponExt.Proto.Weapon_DmgMin_0:((use)==1?weaponExt.Proto.Weapon_DmgMin_1:((use)==2?weaponExt.Proto.Weapon_DmgMin_2:0)));
				if((((use)==0?weaponExt.Proto.Weapon_Skill_0:((use)==1?weaponExt.Proto.Weapon_Skill_1:((use)==2?weaponExt.Proto.Weapon_Skill_2:0)))==(203)))
				{   
					
					wpnMinDmg+=chosen.Param[(10)]*0.75;;
				}
				int bonusmindmg=0;
				if((@weaponExt!=null)&&weaponExt.Val3==(2))bonusmindmg+=24;
				if((@weaponExt!=null)&&weaponExt.Val4==(2))bonusmindmg+=24;
				if((@weaponExt!=null)&&weaponExt.Val5==(2))bonusmindmg+=24;
				if((@weaponExt!=null)&&weaponExt.Val6==(2))bonusmindmg+=24;
				if((@weaponExt!=null)&&weaponExt.Val7==(2))bonusmindmg+=24;
				if((@weaponExt!=null)&&weaponExt.Val8==(2))bonusmindmg+=24;
				int bonusmaxdmg=0;
				if((@weaponExt!=null)&&weaponExt.Val3==(3))bonusmaxdmg+=10;
				if((@weaponExt!=null)&&weaponExt.Val4==(3))bonusmaxdmg+=19;
				if((@weaponExt!=null)&&weaponExt.Val5==(3))bonusmaxdmg+=19;
				if((@weaponExt!=null)&&weaponExt.Val6==(3))bonusmaxdmg+=19;
				if((@weaponExt!=null)&&weaponExt.Val7==(3))bonusmaxdmg+=19;
				if((@weaponExt!=null)&&weaponExt.Val8==(3))bonusmaxdmg+=19;
				
				if((@weaponExt!=null)&&weaponExt.Val3==(101)){bonusmaxdmg+=50;bonusmindmg+=50;}
				if((@weaponExt!=null)&&weaponExt.Val4==(101)){bonusmaxdmg+=50;bonusmindmg+=50;}
				if((@weaponExt!=null)&&weaponExt.Val5==(101)){bonusmaxdmg+=50;bonusmindmg+=50;}
				if((@weaponExt!=null)&&weaponExt.Val6==(101)){bonusmaxdmg+=50;bonusmindmg+=50;}
				if((@weaponExt!=null)&&weaponExt.Val7==(101)){bonusmaxdmg+=50;bonusmindmg+=50;}
				if((@weaponExt!=null)&&weaponExt.Val8==(101)){bonusmaxdmg+=50;bonusmindmg+=50;}
				if((@weaponExt!=null)&&weaponExt.Val2==(101)){bonusmaxdmg+=50;bonusmindmg+=50;}
				wpnMinDmg+=wpnMinDmg*bonusmindmg/100;
				result+=wpnMinDmg+"-";
				
				int wpnMaxDmg=((use)==0?weaponExt.Proto.Weapon_DmgMax_0:((use)==1?weaponExt.Proto.Weapon_DmgMax_1:((use)==2?weaponExt.Proto.Weapon_DmgMax_2:0)));
				if((((use)==0?weaponExt.Proto.Weapon_Skill_0:((use)==1?weaponExt.Proto.Weapon_Skill_1:((use)==2?weaponExt.Proto.Weapon_Skill_2:0)))==(203)))
				wpnMaxDmg+=chosen.Param[(10)]*0.75;
				wpnMaxDmg+=wpnMaxDmg*bonusmaxdmg/100;
				result+=wpnMaxDmg;
				if(((use)==0?weaponExt.Proto.Weapon_MaxDist_0:((use)==1?weaponExt.Proto.Weapon_MaxDist_1:((use)==2?weaponExt.Proto.Weapon_MaxDist_2:0)))>1)
				{
					result+=" "+GetMsgStr((3),(416))+" ";
					int wpnMaxDist=((use)==0?weaponExt.Proto.Weapon_MaxDist_0:((use)==1?weaponExt.Proto.Weapon_MaxDist_1:((use)==2?weaponExt.Proto.Weapon_MaxDist_2:0)));
					if(((use)==0?weaponExt.Proto.Weapon_Skill_0:((use)==1?weaponExt.Proto.Weapon_Skill_1:((use)==2?weaponExt.Proto.Weapon_Skill_2:0)))==(205))
					{
						wpnMaxDist=5+chosen.Param[(0)];
						
						wpnMaxDist+=6*(chosen.Param[(336)]);
					}
					int bonusrange=0;
					if((@weaponExt!=null)&&weaponExt.Val3==(4))bonusrange+=4;
					if((@weaponExt!=null)&&weaponExt.Val4==(4))bonusrange+=4;
					if((@weaponExt!=null)&&weaponExt.Val5==(4))bonusrange+=4;
					if((@weaponExt!=null)&&weaponExt.Val6==(4))bonusrange+=4;
					if((@weaponExt!=null)&&weaponExt.Val7==(4))bonusrange+=4;
					if((@weaponExt!=null)&&weaponExt.Val8==(4))bonusrange+=4;
					if(chosen.Param[(336)]>0&&chosen.Param[(315)]>0&&((use)==0?weaponMain.Proto.Weapon_Skill_0:((use)==1?weaponMain.Proto.Weapon_Skill_1:((use)==2?weaponMain.Proto.Weapon_Skill_2:0)))!=(203)&&((use)==0?weaponMain.Proto.Weapon_Skill_0:((use)==1?weaponMain.Proto.Weapon_Skill_1:((use)==2?weaponMain.Proto.Weapon_Skill_2:0)))!=(210))
					bonusrange+=5;
					
					if(chosen.Param[(418)]>0)bonusrange+=5;
					if(chosen.Param[(315)]>0&&chosen.Param[(336)]>0)bonusrange+=5;
					wpnMaxDist+=bonusrange;
					
					if(chosen.Param[(352)]>0)wpnMaxDist*=2;
					result+=wpnMaxDist+"\n";
					nfix--;
				}
				
				if(weaponExt.Proto.Weapon_MaxAmmoCount>0)
				{
					result+=GetMsgStr((3),(417))+" ";
					result+=weaponExt.AmmoCount+"/";
					result+=weaponExt.Proto.Weapon_MaxAmmoCount+" ";
					result+=GetMsgStr((3),(10900+(weaponExt.Proto.Weapon_Caliber)));
					result+="\n";
					nfix--;
				}
				else if(weaponExt.IsStackable()&&weaponExt.GetCount()>1&&nfix>=1)
				{
					if(((use)==0?weaponExt.Proto.Weapon_MaxDist_0:((use)==1?weaponExt.Proto.Weapon_MaxDist_1:((use)==2?weaponExt.Proto.Weapon_MaxDist_2:0)))<2)
					{
						result+="\n";
						nfix--;
					}
					result+="Amount: "+weaponExt.GetCount()+"\n";
					nfix--;
				}
				for(int n=0;n<nfix;n++)
				result+="\n";
			}
			else
			{
				if(weaponExt.IsStackable()&&weaponExt.GetCount()>1)
				result+="Amount: "+weaponExt.GetCount()+"\n";
				else if(weaponExt.Proto.Misc_ChargeMax>0)
				result+="Charges: "+weaponExt.Charge+"/"+weaponExt.Proto.Misc_ChargeMax+"\n";
				else
				result+="\n";
				
				result+="\n";
			}
		}
		else
		{
			
			uint8 mode=0;
			ProtoItem@unarmed=chosen.GetSlotProto((2),mode);
			result+=GetMsgStr((3),(414))+"\n";
			result+=GetMsgStr((3),(424))+" ";     
			
			result+=((((mode)&0xF))==0?unarmed.Weapon_DmgMin_0:((((mode)&0xF))==1?unarmed.Weapon_DmgMin_1:((((mode)&0xF))==2?unarmed.Weapon_DmgMin_2:0)))+chosen.Param[(10)]*0.75+"-";
			
			result+=(((((mode)&0xF))==0?unarmed.Weapon_DmgMax_0:((((mode)&0xF))==1?unarmed.Weapon_DmgMax_1:((((mode)&0xF))==2?unarmed.Weapon_DmgMax_2:0)))+chosen.Param[(10)]*0.75);
			result+="\n\n";
		}
		
		result+="\n";
		result+=GetMsgStr((3),(420))+" ";
		result+=chosen.ItemsWeight()/1000+"/";
		result+=chosen.Param[(11)]/1000+".";
	}
	else if(descType==(1))
	{
		offsX=23;
		result+="\n\n";
		result+=chosen.Param[(0)]+"\n";
		result+=chosen.Param[(1)]+"\n";
		result+=chosen.Param[(2)]+"\n";
		result+=chosen.Param[(3)]+"\n";
		result+=chosen.Param[(4)]+"\n";
		result+=chosen.Param[(5)]+"\n";
		result+=chosen.Param[(6)];
	}
	else if(descType==(2))
	{
		offsX=33;
		result+="\n\n";
		result+="  "+GetMsgStr((3),(407))+" ";
		result+=chosen.Param[(72)]+"/"+chosen.Param[(7)]+"\n";
		result+="  "+GetMsgStr((3),(408))+" ";
		result+=chosen.GetAC((((__FullSecond)/((3)*__TimeMultiplier))%2==1))+"\n";
		result+="              dt/dr/helm \n";
		result+=" "+GetMsgStr((3),(409))+"\n";
		result+=" "+GetMsgStr((3),(410))+"\n";
		result+=" "+GetMsgStr((3),(411))+"\n";
		result+=" "+GetMsgStr((3),(412))+"\n";
		result+="   Electro\n";
		result+=" "+GetMsgStr((3),(413));
	}
	else if(descType==(3))
	{
		uint ddrn=0;
		uint ddrl=0;
		uint ddrf=0;
		uint ddrp=0;
		uint ddre=0;
		uint ddrx=0;
		ItemCl@helmet=chosen.GetItem(0,(4));
		if((@helmet!=null))
		{
			ddrn=helmet.Proto.Armor_DRNormal;
			ddrl=helmet.Proto.Armor_DRLaser;
			ddrf=helmet.Proto.Armor_DRFire;
			ddrp=helmet.Proto.Armor_DRPlasma;
			ddre=helmet.Proto.Armor_DRElectr;
			ddrx=helmet.Proto.Armor_DRExplode;
		}
		offsX=97;
		result+="\n\n\n\n\n";
		result+=chosen.Param[(16)]+"/"+chosen.Param[(23)]+"/"+GetHelmetRes(chosen,1)+"\n";
		result+=chosen.Param[(17)]+"/"+chosen.Param[(24)]+"/"+GetHelmetRes(chosen,2)+"\n";
		result+=chosen.Param[(18)]+"/"+chosen.Param[(25)]+"/"+GetHelmetRes(chosen,3)+"\n";
		result+=chosen.Param[(19)]+"/"+chosen.Param[(26)]+"/"+GetHelmetRes(chosen,4)+"\n";
		result+=chosen.Param[(20)]+"/"+chosen.Param[(27)]+"/"+GetHelmetRes(chosen,5)+"\n";
		result+=chosen.Param[(22)]+"/"+chosen.Param[(29)]+"/"+"-"+"\n";
		if(chosen.Param[(347)]>0)
		result+=chosen.Param[(21)]+"/"+chosen.Param[(28)]+"/"+GetHelmetRes(chosen,6)+"\n";
	}
	
	return result;
}
int GetHelmetRes(CritterCl&cr,uint index)
{
	int dmgType=0;
	switch(index)
	{
		case 1:dmgType=(1);break;
		case 2:dmgType=(2);break;
		case 3:dmgType=(3);break;
		case 4:dmgType=(4);break;
		case 5:dmgType=(5);break;
		case 6:dmgType=(6);break;
	}
	ItemCl@armor=cr.GetItem(0,(4));
	int normal_DR=0;
	int laser_DR=0;
	int fire_DR=0;
	int plasma_DR=0;
	int elect_DR=0;
	int val=0;
	int drVal=0;
	if((@armor!=null))
	{
		normal_DR=armor.Proto.Armor_DRNormal;
		laser_DR=armor.Proto.Armor_DRLaser;
		fire_DR=armor.Proto.Armor_DRFire;
		plasma_DR=armor.Proto.Armor_DRPlasma;
		elect_DR=armor.Proto.Armor_DRElectr;
	}
	if(cr.Param[(419)]>0)
	{
		normal_DR+=7;
		laser_DR+=7;
		fire_DR+=7;
		plasma_DR+=7;
		elect_DR+=7;
	}
	if(cr.Param[(149)]>0)
	{
		normal_DR+=50;
		laser_DR+=50;
		fire_DR+=50;
		plasma_DR+=50;
		elect_DR+=50;
	}
	if(cr.Param[(418)]>0)
	{
		normal_DR-=6;
		laser_DR-=6;
		fire_DR-=6;
		plasma_DR-=6;
		elect_DR-=6;
	}
	if(cr.Param[(313)]>0)normal_DR+=8*cr.Param[(313)];
	if(cr.Param[(432)]>0)
	{
		normal_DR+=4*cr.Param[(432)];
	}
	if(cr.Param[(433)]>0)
	{
		normal_DR+=4*cr.Param[(433)];
	}
	if(cr.Param[(434)]>0)
	{
		laser_DR+=4*cr.Param[(434)];
		plasma_DR+=4*cr.Param[(434)];
		fire_DR+=4*cr.Param[(434)];
	}
	if(cr.Param[(435)]>0)
	{
		laser_DR+=4*cr.Param[(435)];
		plasma_DR+=4*cr.Param[(435)];
		fire_DR+=4*cr.Param[(435)];
	}
	
	if(cr.Param[(562)]==0&&cr.Param[(250)]>0)normal_DR+=15;
	if(cr.Param[(562)]==0&&cr.Param[(248)]>0)normal_DR+=5;
	if(cr.Param[(562)]==0&&cr.Param[(258)]>0)laser_DR+=5;
	if(cr.Param[(562)]==0&&cr.Param[(259)]>0)plasma_DR+=5;
	if(cr.Param[(562)]==0&&cr.Param[(237)]>0)fire_DR+=5;
	
	if(cr.Param[(562)]>0&&cr.Param[(246)]>0)laser_DR+=13;
	
	int emp_DR=500;
	if(cr.Param[(347)]>0&&dmgType==(6))
	{
		switch(cr.Param[(431)])
		{
			case 0:emp_DR=0;break;
			case 1:emp_DR=40;break;
			case 2:emp_DR=80;break;
			case 3:emp_DR=120;break;
		}
		
	}
	switch(dmgType)
	{
		case(1):val=normal_DR;break;
		case(2):val=laser_DR;break;
		case(3):val=fire_DR;break;
		case(4):val=plasma_DR;break;
		case(5):val=elect_DR;break;
		case(6):val=emp_DR;break;
		case(0):
		default:break;
	}
	
	val-=cr.Param[(803)];
	val+=(((2*cr.Param[(782)])>(10))?(10):(((2*cr.Param[(782)])<(0))?(0):(2*cr.Param[(782)])));
	
	if(cr.Param[(380)]>0)
	{
		int max_life=cr.Param[(7)];
		if(cr.Param[(72)]<=max_life/4)val+=15;
		else if(cr.Param[(72)]<=max_life/2)val+=10;
		else if(cr.Param[(72)]<=3*max_life/4)val+=5;
	}
	if(cr.Param[(192)]==2)
	{
		if(cr.Param[(441)]!=1)
		val+=4*cr.Param[(193)];
		else val-=4*cr.Param[(193)];
	}
	if(cr.Param[(555)]>0)
	val-=10;
	if(cr.Param[(419)]>0)return(((val)>(100))?(100):(((val)<(0))?(0):(val)));
	return(((val)>(90))?(90):(((val)<(0))?(0):(val)));
}          

bool isHelmet(ItemCl&item)
{
	if(item.GetProtoId()>=725&&item.GetProtoId()<=741)return true;
	if(item.GetProtoId()==25588||item.GetProtoId()==25589)return true;
	
	return false;
}
string item_description(ItemCl&item,int lookType)
{
	CritterCl@chosen=GetChosen(); 
	
	if(!IsMsgStr((2),(item.GetProtoId()*100+item.Info)+(lookType!=(1)?1:0)))
	{
		if(!IsLexem(item,"$-"))
		return(GetMsgStr((3),(10010)));
	}
	
	string result;
	if(((GUI_IsKeyPressed(0x1D)||GUI_IsKeyPressed(0x9D))&&!(GUI_IsKeyPressed(0x2A)||GUI_IsKeyPressed(0x36))&&!(GUI_IsKeyPressed(0x38)||GUI_IsKeyPressed(0xB8)))&&lookType==(4)&&GUI_GetActiveScreen()==(10))
	{
		if((@chosen!=null)&&item.CritId==chosen.Id)
		{
			if(item.CritSlot>=(1)&&item.CritSlot<=(3)||item.CritSlot>=(1)&&item.CritSlot<=(4))
			{
				array<uint>action={(7),item.Id,item.GetCount(),(0),0,0,0};
				SetChosenActions(action);
				return"";
			}
			else if(item.CritSlot==(0))
			{
				uint8 toSlot=(2);
				if(item.Proto.Type==(1))
				{
					if((item.GetProtoId()>=719)&&(item.GetProtoId()<=749)||item.GetProtoId()==25588||item.GetProtoId()==25589)
					toSlot=(4);
					else
					toSlot=(3);
					
					array<uint>action={(7),item.Id,item.GetCount(),toSlot,0,0,0};
					SetChosenActions(action);
				}
				else if(item.Proto.Type==(3))
				{
					toSlot=(1);
					array<uint>action={(7),item.Id,item.GetCount(),toSlot,0,0,0};
					SetChosenActions(action);
				}
				else if((item.Proto.Type==(2))||
				((((item.Flags)&((0x10000000)))!=0)&&item.Proto.ProtoId!=(59)))
				{
					array<uint>action={(6),item.Id,item.GetProtoId(),(0),chosen.Id,(4),0};
					SetChosenActions(action);
				}
				else if(item.Proto.Type==(5)||item.Proto.Type==(4)||item.Proto.Type==(7))
				{
					toSlot=(2);
					array<uint>action={(7),item.Id,item.GetCount(),toSlot,0,0,0};
					SetChosenActions(action);
				}
				return"";
			}
		}
	}
	
	if(((GUI_IsKeyPressed(0x38)||GUI_IsKeyPressed(0xB8))&&!(GUI_IsKeyPressed(0x1D)||GUI_IsKeyPressed(0x9D))&&!(GUI_IsKeyPressed(0x2A)||GUI_IsKeyPressed(0x36)))&&lookType==(4)&&GUI_GetActiveScreen()==(10))
	{
		if(disableItemMove)
		return"";
		disableItemMove=true;
		RunServerScriptUnsafe("unsafe_client@unsafe_science",item.Id,0,0,"",null);
	} 
	
	if(lookType==(5))
	{
		string fuel=GetMsgStr((3),(561));
		fuel=ReplaceText(fuel,"VALUE",item.Charge/100);
		fuel=ReplaceText(fuel,"MAX_VALUE",(item.Proto.Car_TankVolume)/100);
		string wear=GetMsgStr((3),(562));
		wear=ReplaceText(wear,"VALUE",item.Deterioration*100/(item.Proto.Car_MaxDeterioration));
		result=fuel+"\n"+wear;
	}       
	
	else if(lookType==(1))
	{
		string _name=showPrefix(item)+GetMsgStr((2),(item.GetProtoId()*100+item.Info));
		
		if(IsLexem(item,"$-"))
		_name=GetLexem(item,"$-");
		result+=ReplaceText(GetMsgStr((3),(10000)),"NAME",_name);
		result+=" |-16711936 ";
		
		if(GUI_GetActiveScreen()==(31))
		{
			uint8 brokenCount=item.BrokenCount;
			uint16 wearCount=item.Deterioration;
			result+=" ";
			result+=ReplaceText(ReplaceText(GetMsgStr((3),(500)),"VALUE",100-wearCount*100/(10000)),"MAXVALUE",100-brokenCount);
		}
		if(item.GetType()==(13))
		if(IsLexem(item,"$carowner"))
		{
			string carinfo=GetMsgStr((2),(item.GetProtoId()*100+item.Info));
			result=ReplaceText(GetMsgStr((3),(10000)),"NAME",carinfo)+" Licence plate says this car belongs to "+GetLexem(item,"$carowner")+".";
		}
	}
	
	else
	{
		if(lookType==(4)&&GUI_IsKeyPressed(0x2A))
		{
			if(item.GetProtoId()==(9914)||item.GetProtoId()==(1864)||item.GetProtoId()==(1865)||item.GetProtoId()==(157)||item.GetProtoId()==(4608)||item.GetProtoId()==(571)||item.GetType()==(8)
			||item.GetProtoId()==(22096)||item.GetProtoId()==(22098)||item.GetProtoId()==(22100)
			||item.GetProtoId()==(22102)||item.GetProtoId()==(22104)||item.GetProtoId()==(22106)
			||item.GetProtoId()==(22108)||item.GetProtoId()==(22109)||item.GetProtoId()==(22110)
			||item.GetProtoId()==(22111)||item.GetProtoId()==(22112)||item.GetProtoId()==(22113)
			||item.GetProtoId()==(22114)||item.GetProtoId()==(22115)||item.GetProtoId()==(22116)
			||item.GetProtoId()==(22117))
			return"";
			if(disableItemMove)
			return"";
			disableItemMove=true;
			RunServerScriptUnsafe("unsafe_client@unsafe_DropOne",item.Id,0,0,"",null);
			return"";
		}
		
		if(GUI_GetActiveScreen()==(11)&&GUI_IsKeyPressed(0x2A))
		{
			if(item.GetProtoId()==(9914)||item.GetProtoId()==(1864)||item.GetProtoId()==(1865)||item.GetProtoId()==(157)||item.GetProtoId()==(4608)||item.GetProtoId()==(571)||item.GetType()==(8)
			||item.GetProtoId()==(22096)||item.GetProtoId()==(22098)||item.GetProtoId()==(22100)
			||item.GetProtoId()==(22102)||item.GetProtoId()==(22104)||item.GetProtoId()==(22106)
			||item.GetProtoId()==(22108)||item.GetProtoId()==(22109)||item.GetProtoId()==(22110)
			||item.GetProtoId()==(22111)||item.GetProtoId()==(22112)||item.GetProtoId()==(22113)
			||item.GetProtoId()==(22114)||item.GetProtoId()==(22115)||item.GetProtoId()==(22116)
			||item.GetProtoId()==(22117))
			return"";
			
			if(item.CritId>0)
			{
				if(disableItemMove)
				return"";
				disableItemMove=true;
				
				RunServerScriptUnsafe("unsafe_client@unsafe_DropOne",item.Id,0,0,"",null);
				return"";
			}
		} 
		
		if(GUI_GetActiveScreen()==(11)&&GUI_IsKeyPressed(0x1D))
		{
			
			if(item.GetProtoId()==(9914)||item.GetProtoId()==(1864)||item.GetProtoId()==(1865)||item.GetProtoId()==(157)||item.GetProtoId()==(4608)||item.GetProtoId()==(571)||item.GetType()==(8)
			||item.GetProtoId()==(22096)||item.GetProtoId()==(22098)||item.GetProtoId()==(22100)
			||item.GetProtoId()==(22102)||item.GetProtoId()==(22104)||item.GetProtoId()==(22106)
			||item.GetProtoId()==(22108)||item.GetProtoId()==(22109)||item.GetProtoId()==(22110)
			||item.GetProtoId()==(22111)||item.GetProtoId()==(22112)||item.GetProtoId()==(22113)
			||item.GetProtoId()==(22114)||item.GetProtoId()==(22115)||item.GetProtoId()==(22116)
			||item.GetProtoId()==(22117))
			return"";
			
			uint contId=GetContainerId();
			if(disableItemMove)
			return"";
			disableItemMove=true;
			
			if(contId>0)
			{
				if(!chosen.IsKnockout()&&!chosen.IsDead())
				{
					pickupScreenScrollCritter=GetScroll((3));
					pickupScreenScrollFrom=GetScroll((4));
					if(item.CritId>0)
					RunServerScriptUnsafe("unsafe_client@unsafe_MoveItemCrit2Cont",item.Id,contId,0,"",null);
					else
					RunServerScriptUnsafe("unsafe_client@unsafe_MoveItemCont2Crit",item.Id,contId,0,"",null);
					if(!chosen.IsAnimPlaying())
					chosen.Animate(0,(27));
					return"";
				}
			}
			
			uint bodyId=GetBodyId();
			
			if(bodyId>0)
			{
				CritterCl@body=GetCritter(bodyId);
				if((@body!=null))
				{
					if(!chosen.IsKnockout()&&!chosen.IsDead()&&body.IsDead())
					{
						pickupScreenScrollCritter=GetScroll((3));
						pickupScreenScrollFrom=GetScroll((4));
						if(item.CritId>0)
						RunServerScriptUnsafe("unsafe_client@unsafe_MoveItemCrit2Body",item.Id,bodyId,0,"",null);
						else
						RunServerScriptUnsafe("unsafe_client@unsafe_MoveItemBody2Crit",item.Id,bodyId,0,"",null);
						if(!chosen.IsAnimPlaying())
						chosen.Animate(0,(27));
						return"";
					}
				}
			}
			disableItemMove=false;
		} 
		
		if(lookType==(4)||lookType==(3))
		{
			string _name=showPrefix(item)+GetMsgStr((2),(item.GetProtoId()*100+item.Info));
			if(IsLexem(item,"$-"))
			_name=GetLexem(item,"$-");
			result+="  "+_name+"\n";
			result+=" |-16711936 ";
		}
		if(item.GetType()==(3)&&!item.IsStackable())
		{
			switch(item.Val1)
			{
				case 0:result+="|-1   "+item.Val0+"/10000 xp |-16711936 ";break;
				case 1:result+="|-1   "+item.Val0+"/75000 xp |-16711936 ";break;
				case 2:result+="|-1   "+item.Val0+"/150000 xp |-16711936 ";break;
				case 3:result+="|-1   "+item.Val0+"/1000000 xp |-16711936 ";break;
				case 4:result+="|-1   "+item.Val0+"/5000000 xp |-16711936 ";break;
				case 5:result+="|-1   "+item.Val0+"/50000000 xp |-16711936 ";break;
				case 6:result+="|-1   Max Level |-16711936 ";break;
			}
		}
		
		if(item.GetType()==(1)&&!item.IsStackable()&&!isHelmet(item))
		{
			switch(item.Val1)
			{
				case 0:result+="|-1   "+item.Val0+"/15000 xp |-16711936 ";break;
				case 1:result+="|-1   "+item.Val0+"/100000 xp |-16711936 ";break;
				case 2:result+="|-1   "+item.Val0+"/200000 xp |-16711936 ";break;
				case 3:result+="|-1   "+item.Val0+"/1250000 xp |-16711936 ";break;
				case 4:result+="|-1   "+item.Val0+"/6000000 xp |-16711936 ";break;
				case 5:result+="|-1   "+item.Val0+"/50000000 xp |-16711936 ";break;
				case 6:result+="|-1   Max Level |-16711936 ";break;
			}
		}
		if(item.GetType()==(3)||item.GetType()==(1))
		if(item.Val6>0||item.Val3>0)
		{
			result+="\n   Perks:";
			switch(item.Val6)
			{
				case 1:result+="\n   Bonus Ranged Damage ";break;
				case 2:result+="\n   Bonus Damage ";break;
				case 3:result+="\n   Bonus Attack ";break;
				case 4:result+="\n   Scoped ";break;
				case 5:result+="\n   Better Critical ";break;
				case 6:result+="\n   Fast Trigger ";break;
				case 7:result+="\n   Ammo Upgrade ";break;
				case 8:result+="\n   Bonus Rate of Fire ";break;
				case 9:result+="\n   Slayer ";break;
				case 10:result+="\n   Destroyer ";break;
				case 11:result+="\n   Knockback ";break;
				case 12:result+="\n   Long Range ";break;
				case 13:result+="\n   Penetrate ";break;
				case 14:result+="\n   Poisoned ";break;
				case 15:result+="\n   Frozen Queen ";break;
				case 16:result+="\n   Killing Spree ";break;
				case 17:result+="\n   Life Steal ";break;
				case 18:result+="\n   Chip Shot ";break;
				case 19:result+="\n   Gain Strength ";break;
				case 20:result+="\n   Gain Perception ";break;
				case 21:result+="\n   Gain Endurance ";break;
				case 22:result+="\n   Gain Charisma ";break;
				case 23:result+="\n   Gain Intelligence ";break;
				case 24:result+="\n   Gain Agility ";break;
				case 25:result+="\n   Gain Luck ";break;
				case 26:result+="\n   Cured ";break;
				case 27:result+="\n   Laser Reflector ";break;
				case 28:result+="\n   Anty-Termal System ";break;
				case 29:result+="\n   Defense Enhancement ";break;
				case 30:result+="\n   Advanced Plate ";break;
				case 31:result+="\n   Mirror System ";break;
				case 32:result+="\n   Tesla Addition ";break;
				case 33:result+="\n   Shock Protection ";break;
				case 34:result+="\n   Firegeckon's Enhancement";break;
				case 35:result+="\n   Special Force Bonus ";break;
				case 36:result+="\n   Regeneration ";break;
				case 37:result+="\n   Fill The Gaps ";break;
				case 38:result+="\n   Heavy ";break;
				case 39:result+="\n   Utility ";break;
				case 40:result+="\n   Bonus Move ";break;
				case 41:result+="\n   Heavy Stonewall ";break;
				case 42:result+="\n   Terminator ";break;
				case 43:result+="\n   Explosive Belt ";break;
				case 44:result+="\n   Tesla Attacker";break;
				case 45:result+="\n   Speed Mechanism ";break;
				case 46:result+="\n   Sneaky ";break;
				case 47:result+="\n   More Criticals ";break;
				case 48:result+="\n   Lethal Protection ";break;
				case 100:result+="\n   Enhancement Knockout ";break;
				case 101:result+="\n   More Bonus Damage ";break;
				case 102:result+="\n   Sniper ";break;
				case 103:result+="\n   Bounty Hunter ";break;
				case 104:result+="\n   Bonus Bullets Damage ";break;
				case 105:result+="\n   Gifted";break;
				case 106:result+="\n   Advanced Defense ";break;
				case 107:result+="\n   Super Regen ";break;
				case 108:result+="\n   Powered ";break;
				case 109:result+="\n   Anty-Crit ";break;
				case 59:result+="\n   Iron Skin ";break;
				case 60:result+="\n   Survivalist ";break;
				case 61:result+="\n   Strategic Improvement ";break;
				case 62:result+="\n   Smasher! ";break;
				case 63:result+="\n   Integrated Gloves ";break;
				case 64:result+="\n   Defensive Belt ";break;
				case 65:result+="\n   Spiked ";break;
				case 66:result+="\n   More Critical Damage ";break;
				case 67:result+="\n   Bonus Attack Speed ";break;
			}
		}
		if(item.Val7>0)
		{
			switch(item.Val7)
			{
				case 1:result+="\n   Bonus Ranged Damage ";break;
				case 2:result+="\n   Bonus Damage ";break;
				case 3:result+="\n   Bonus Attack ";break;
				case 4:result+="\n   Scoped ";break;
				case 5:result+="\n   Better Critical ";break;
				case 6:result+="\n   Fast Trigger ";break;
				case 7:result+="\n   Ammo Upgrade ";break;
				case 8:result+="\n   Bonus Rate of Fire ";break;
				case 9:result+="\n   Slayer ";break;
				case 10:result+="\n   Destroyer ";break;
				case 11:result+="\n   Knockback ";break;
				case 12:result+="\n   Long Range ";break;
				case 13:result+="\n   Penetrate ";break;
				case 14:result+="\n   Poisoned ";break;
				case 15:result+="\n   Frozen Queen ";break;
				case 16:result+="\n   Killing Spree ";break;
				case 17:result+="\n   Life Steal ";break;
				case 18:result+="\n   Chip Shot ";break;
				case 19:result+="\n   Gain Strength ";break;
				case 20:result+="\n   Gain Perception ";break;
				case 21:result+="\n   Gain Endurance ";break;
				case 22:result+="\n   Gain Charisma ";break;
				case 23:result+="\n   Gain Intelligence ";break;
				case 24:result+="\n   Gain Agility ";break;
				case 25:result+="\n   Gain Luck ";break;
				case 26:result+="\n   Cured ";break;
				case 27:result+="\n   Laser Reflector ";break;
				case 28:result+="\n   Anty-Termal System ";break;
				case 29:result+="\n   Defense Enhancement ";break;
				case 30:result+="\n   Advanced Plate ";break;
				case 31:result+="\n   Mirror System ";break;
				case 32:result+="\n   Tesla Addition ";break;
				case 33:result+="\n   Shock Protection ";break;
				case 34:result+="\n   Firegeckon's Enhancement";break;
				case 35:result+="\n   Special Force Bonus ";break;
				case 36:result+="\n   Regeneration ";break;
				case 37:result+="\n   Fill The Gaps ";break;
				case 38:result+="\n   Heavy ";break;
				case 39:result+="\n   Utility ";break;
				case 40:result+="\n   Bonus Move ";break;
				case 41:result+="\n   Heavy Stonewall ";break;
				case 42:result+="\n   Terminator ";break;
				case 43:result+="\n   Explosive Belt ";break;
				case 44:result+="\n   Tesla Attacker";break;
				case 45:result+="\n   Speed Mechanism ";break;
				case 46:result+="\n   Sneaky ";break;
				case 47:result+="\n   More Criticals ";break;
				case 48:result+="\n   Lethal Protection ";break;
				case 100:result+="\n   Enhancement Knockout ";break;
				case 101:result+="\n   More Bonus Damage ";break;
				case 102:result+="\n   Sniper ";break;
				case 103:result+="\n   Bounty Hunter ";break;
				case 104:result+="\n   Bonus Bullets Damage ";break;
				case 105:result+="\n   Gifted";break;
				case 106:result+="\n   Advanced Defense ";break;
				case 107:result+="\n   Super Regen ";break;
				case 108:result+="\n   Powered ";break;
				case 109:result+="\n   Anty-Crit ";break;
				case 59:result+="\n   Iron Skin ";break;
				case 60:result+="\n   Survivalist ";break;
				case 61:result+="\n   Strategic Improvement ";break;
				case 62:result+="\n   Smasher! ";break;
				case 63:result+="\n   Integrated Gloves ";break;
				case 64:result+="\n   Defensive Belt ";break;
				case 65:result+="\n   Spiked ";break;
				case 66:result+="\n   More Critical Damage ";break;
				case 67:result+="\n   Bonus Attack Speed ";break;
			}
		}
		if(item.Val8>0)
		{
			switch(item.Val8)
			{
				case 1:result+="\n   Bonus Ranged Damage ";break;
				case 2:result+="\n   Bonus Damage ";break;
				case 3:result+="\n   Bonus Attack ";break;
				case 4:result+="\n   Scoped ";break;
				case 5:result+="\n   Better Critical ";break;
				case 6:result+="\n   Fast Trigger ";break;
				case 7:result+="\n   Ammo Upgrade ";break;
				case 8:result+="\n   Bonus Rate of Fire ";break;
				case 9:result+="\n   Slayer ";break;
				case 10:result+="\n   Destroyer ";break;
				case 11:result+="\n   Knockback ";break;
				case 12:result+="\n   Long Range ";break;
				case 13:result+="\n   Penetrate ";break;
				case 14:result+="\n   Poisoned ";break;
				case 15:result+="\n   Frozen Queen ";break;
				case 16:result+="\n   Killing Spree ";break;
				case 17:result+="\n   Life Steal ";break;
				case 18:result+="\n   Chip Shot ";break;
				case 19:result+="\n   Gain Strength ";break;
				case 20:result+="\n   Gain Perception ";break;
				case 21:result+="\n   Gain Endurance ";break;
				case 22:result+="\n   Gain Charisma ";break;
				case 23:result+="\n   Gain Intelligence ";break;
				case 24:result+="\n   Gain Agility ";break;
				case 25:result+="\n   Gain Luck ";break;
				case 26:result+="\n   Cured ";break;
				case 27:result+="\n   Laser Reflector ";break;
				case 28:result+="\n   Anty-Termal System ";break;
				case 29:result+="\n   Defense Enhancement ";break;
				case 30:result+="\n   Advanced Plate ";break;
				case 31:result+="\n   Mirror System ";break;
				case 32:result+="\n   Tesla Addition ";break;
				case 33:result+="\n   Shock Protection ";break;
				case 34:result+="\n   Firegeckon's Enhancement";break;
				case 35:result+="\n   Special Force Bonus ";break;
				case 36:result+="\n   Regeneration ";break;
				case 37:result+="\n   Fill The Gaps ";break;
				case 38:result+="\n   Heavy ";break;
				case 39:result+="\n   Utility ";break;
				case 40:result+="\n   Bonus Move ";break;
				case 41:result+="\n   Heavy Stonewall ";break;
				case 42:result+="\n   Terminator ";break;
				case 43:result+="\n   Explosive Belt ";break;
				case 44:result+="\n   Tesla Attacker";break;
				case 45:result+="\n   Speed Mechanism ";break;
				case 46:result+="\n   Sneaky ";break;
				case 47:result+="\n   More Criticals ";break;
				case 48:result+="\n   Lethal Protection ";break;
				case 100:result+="\n   Enhancement Knockout ";break;
				case 101:result+="\n   More Bonus Damage ";break;
				case 102:result+="\n   Sniper ";break;
				case 103:result+="\n   Bounty Hunter ";break;
				case 104:result+="\n   Bonus Bullets Damage ";break;
				case 105:result+="\n   Gifted";break;
				case 106:result+="\n   Advanced Defense ";break;
				case 107:result+="\n   Super Regen ";break;
				case 108:result+="\n   Powered ";break;
				case 109:result+="\n   Anty-Crit ";break;
				case 59:result+="\n   Iron Skin ";break;
				case 60:result+="\n   Survivalist ";break;
				case 61:result+="\n   Strategic Improvement ";break;
				case 62:result+="\n   Smasher! ";break;
				case 63:result+="\n   Integrated Gloves ";break;
				case 64:result+="\n   Defensive Belt ";break;
				case 65:result+="\n   Spiked ";break;
				case 66:result+="\n   More Critical Damage ";break;
				case 67:result+="\n   Bonus Attack Speed ";break;
			}
		}
		if(item.Val5>0)
		{
			switch(item.Val5)
			{
				case 1:result+="\n   Bonus Ranged Damage ";break;
				case 2:result+="\n   Bonus Damage ";break;
				case 3:result+="\n   Bonus Attack ";break;
				case 4:result+="\n   Scoped ";break;
				case 5:result+="\n   Better Critical ";break;
				case 6:result+="\n   Fast Trigger ";break;
				case 7:result+="\n   Ammo Upgrade ";break;
				case 8:result+="\n   Bonus Rate of Fire ";break;
				case 9:result+="\n   Slayer ";break;
				case 10:result+="\n   Destroyer ";break;
				case 11:result+="\n   Knockback ";break;
				case 12:result+="\n   Long Range ";break;
				case 13:result+="\n   Penetrate ";break;
				case 14:result+="\n   Poisoned ";break;
				case 15:result+="\n   Frozen Queen ";break;
				case 16:result+="\n   Killing Spree ";break;
				case 17:result+="\n   Life Steal ";break;
				case 18:result+="\n   Chip Shot ";break;
				case 19:result+="\n   Gain Strength ";break;
				case 20:result+="\n   Gain Perception ";break;
				case 21:result+="\n   Gain Endurance ";break;
				case 22:result+="\n   Gain Charisma ";break;
				case 23:result+="\n   Gain Intelligence ";break;
				case 24:result+="\n   Gain Agility ";break;
				case 25:result+="\n   Gain Luck ";break;
				case 26:result+="\n   Cured ";break;
				case 27:result+="\n   Laser Reflector ";break;
				case 28:result+="\n   Anty-Termal System ";break;
				case 29:result+="\n   Defense Enhancement ";break;
				case 30:result+="\n   Advanced Plate ";break;
				case 31:result+="\n   Mirror System ";break;
				case 32:result+="\n   Tesla Addition ";break;
				case 33:result+="\n   Shock Protection ";break;
				case 34:result+="\n   Firegeckon's Enhancement";break;
				case 35:result+="\n   Special Force Bonus ";break;
				case 36:result+="\n   Regeneration ";break;
				case 37:result+="\n   Fill The Gaps ";break;
				case 38:result+="\n   Heavy ";break;
				case 39:result+="\n   Utility ";break;
				case 40:result+="\n   Bonus Move ";break;
				case 41:result+="\n   Heavy Stonewall ";break;
				case 42:result+="\n   Terminator ";break;
				case 43:result+="\n   Explosive Belt ";break;
				case 44:result+="\n   Tesla Attacker";break;
				case 45:result+="\n   Speed Mechanism ";break;
				case 46:result+="\n   Sneaky ";break;
				case 47:result+="\n   More Criticals ";break;
				case 48:result+="\n   Lethal Protection ";break;
				case 100:result+="\n   Enhancement Knockout ";break;
				case 101:result+="\n   More Bonus Damage ";break;
				case 102:result+="\n   Sniper ";break;
				case 103:result+="\n   Bounty Hunter ";break;
				case 104:result+="\n   Bonus Bullets Damage ";break;
				case 105:result+="\n   Gifted";break;
				case 106:result+="\n   Advanced Defense ";break;
				case 107:result+="\n   Super Regen ";break;
				case 108:result+="\n   Powered ";break;
				case 109:result+="\n   Anty-Crit ";break;
				case 59:result+="\n   Iron Skin ";break;
				case 60:result+="\n   Survivalist ";break;
				case 61:result+="\n   Strategic Improvement ";break;
				case 62:result+="\n   Smasher! ";break;
				case 63:result+="\n   Integrated Gloves ";break;
				case 64:result+="\n   Defensive Belt ";break;
				case 65:result+="\n   Spiked ";break;
				case 66:result+="\n   More Critical Damage ";break;
				case 67:result+="\n   Bonus Attack Speed ";break;
			}
		}
		if(item.Val4>0)
		{
			switch(item.Val4)
			{
				case 1:result+="\n   Bonus Ranged Damage ";break;
				case 2:result+="\n   Bonus Damage ";break;
				case 3:result+="\n   Bonus Attack ";break;
				case 4:result+="\n   Scoped ";break;
				case 5:result+="\n   Better Critical ";break;
				case 6:result+="\n   Fast Trigger ";break;
				case 7:result+="\n   Ammo Upgrade ";break;
				case 8:result+="\n   Bonus Rate of Fire ";break;
				case 9:result+="\n   Slayer ";break;
				case 10:result+="\n   Destroyer ";break;
				case 11:result+="\n   Knockback ";break;
				case 12:result+="\n   Long Range ";break;
				case 13:result+="\n   Penetrate ";break;
				case 14:result+="\n   Poisoned ";break;
				case 15:result+="\n   Frozen Queen ";break;
				case 16:result+="\n   Killing Spree ";break;
				case 17:result+="\n   Life Steal ";break;
				case 18:result+="\n   Chip Shot ";break;
				case 19:result+="\n   Gain Strength ";break;
				case 20:result+="\n   Gain Perception ";break;
				case 21:result+="\n   Gain Endurance ";break;
				case 22:result+="\n   Gain Charisma ";break;
				case 23:result+="\n   Gain Intelligence ";break;
				case 24:result+="\n   Gain Agility ";break;
				case 25:result+="\n   Gain Luck ";break;
				case 26:result+="\n   Cured ";break;
				case 27:result+="\n   Laser Reflector ";break;
				case 28:result+="\n   Anty-Termal System ";break;
				case 29:result+="\n   Defense Enhancement ";break;
				case 30:result+="\n   Advanced Plate ";break;
				case 31:result+="\n   Mirror System ";break;
				case 32:result+="\n   Tesla Addition ";break;
				case 33:result+="\n   Shock Protection ";break;
				case 34:result+="\n   Firegeckon's Enhancement";break;
				case 35:result+="\n   Special Force Bonus ";break;
				case 36:result+="\n   Regeneration ";break;
				case 37:result+="\n   Fill The Gaps ";break;
				case 38:result+="\n   Heavy ";break;
				case 39:result+="\n   Utility ";break;
				case 40:result+="\n   Bonus Move ";break;
				case 41:result+="\n   Heavy Stonewall ";break;
				case 42:result+="\n   Terminator ";break;
				case 43:result+="\n   Explosive Belt ";break;
				case 44:result+="\n   Tesla Attacker";break;
				case 45:result+="\n   Speed Mechanism ";break;
				case 46:result+="\n   Sneaky ";break;
				case 47:result+="\n   More Criticals ";break;
				case 48:result+="\n   Lethal Protection ";break;
				case 100:result+="\n   Enhancement Knockout ";break;
				case 101:result+="\n   More Bonus Damage ";break;
				case 102:result+="\n   Sniper ";break;
				case 103:result+="\n   Bounty Hunter ";break;
				case 104:result+="\n   Bonus Bullets Damage ";break;
				case 105:result+="\n   Gifted";break;
				case 106:result+="\n   Advanced Defense ";break;
				case 107:result+="\n   Super Regen ";break;
				case 108:result+="\n   Powered ";break;
				case 109:result+="\n   Anty-Crit ";break;
				case 59:result+="\n   Iron Skin ";break;
				case 60:result+="\n   Survivalist ";break;
				case 61:result+="\n   Strategic Improvement ";break;
				case 62:result+="\n   Smasher! ";break;
				case 63:result+="\n   Integrated Gloves ";break;
				case 64:result+="\n   Defensive Belt ";break;
				case 65:result+="\n   Spiked ";break;
				case 66:result+="\n   More Critical Damage ";break;
				case 67:result+="\n   Bonus Attack Speed ";break;
			}
		}
		if(item.Val3>0)
		{
			switch(item.Val3)
			{
				case 1:result+="\n   Bonus Ranged Damage ";break;
				case 2:result+="\n   Bonus Damage ";break;
				case 3:result+="\n   Bonus Attack ";break;
				case 4:result+="\n   Scoped ";break;
				case 5:result+="\n   Better Critical ";break;
				case 6:result+="\n   Fast Trigger ";break;
				case 7:result+="\n   Ammo Upgrade ";break;
				case 8:result+="\n   Bonus Rate of Fire ";break;
				case 9:result+="\n   Slayer ";break;
				case 10:result+="\n   Destroyer ";break;
				case 11:result+="\n   Knockback ";break;
				case 12:result+="\n   Long Range ";break;
				case 13:result+="\n   Penetrate ";break;
				case 14:result+="\n   Poisoned ";break;
				case 15:result+="\n   Frozen Queen ";break;
				case 16:result+="\n   Killing Spree ";break;
				case 17:result+="\n   Life Steal ";break;
				case 18:result+="\n   Chip Shot ";break;
				case 19:result+="\n   Gain Strength ";break;
				case 20:result+="\n   Gain Perception ";break;
				case 21:result+="\n   Gain Endurance ";break;
				case 22:result+="\n   Gain Charisma ";break;
				case 23:result+="\n   Gain Intelligence ";break;
				case 24:result+="\n   Gain Agility ";break;
				case 25:result+="\n   Gain Luck ";break;
				case 26:result+="\n   Cured ";break;
				case 27:result+="\n   Laser Reflector ";break;
				case 28:result+="\n   Anty-Termal System ";break;
				case 29:result+="\n   Defense Enhancement ";break;
				case 30:result+="\n   Advanced Plate ";break;
				case 31:result+="\n   Mirror System ";break;
				case 32:result+="\n   Tesla Addition ";break;
				case 33:result+="\n   Shock Protection ";break;
				case 34:result+="\n   Firegeckon's Enhancement";break;
				case 35:result+="\n   Special Force Bonus ";break;
				case 36:result+="\n   Regeneration ";break;
				case 37:result+="\n   Fill The Gaps ";break;
				case 38:result+="\n   Heavy ";break;
				case 39:result+="\n   Utility ";break;
				case 40:result+="\n   Bonus Move ";break;
				case 41:result+="\n   Heavy Stonewall ";break;
				case 42:result+="\n   Terminator ";break;
				case 43:result+="\n   Explosive Belt ";break;
				case 44:result+="\n   Tesla Attacker";break;
				case 45:result+="\n   Speed Mechanism ";break;
				case 46:result+="\n   Sneaky ";break;
				case 47:result+="\n   More Criticals ";break;
				case 48:result+="\n   Lethal Protection ";break;
				case 100:result+="\n   Enhancement Knockout ";break;
				case 101:result+="\n   More Bonus Damage ";break;
				case 102:result+="\n   Sniper ";break;
				case 103:result+="\n   Bounty Hunter ";break;
				case 104:result+="\n   Bonus Bullets Damage ";break;
				case 105:result+="\n   Gifted";break;
				case 106:result+="\n   Advanced Defense ";break;
				case 107:result+="\n   Super Regen ";break;
				case 108:result+="\n   Powered ";break;
				case 109:result+="\n   Anty-Crit ";break;
				case 59:result+="\n   Iron Skin ";break;
				case 60:result+="\n   Survivalist ";break;
				case 61:result+="\n   Strategic Improvement ";break;
				case 62:result+="\n   Smasher! ";break;
				case 63:result+="\n   Integrated Gloves ";break;
				case 64:result+="\n   Defensive Belt ";break;
				case 65:result+="\n   Spiked ";break;
				case 66:result+="\n   More Critical Damage ";break;
				case 67:result+="\n   Bonus Attack Speed ";break;
			}
		}
		if(item.Val2>48)
		{
			switch(item.Val2)
			{
				case 1:result+="\n   Bonus Ranged Damage ";break;
				case 2:result+="\n   Bonus Damage ";break;
				case 3:result+="\n   Bonus Attack ";break;
				case 4:result+="\n   Scoped ";break;
				case 5:result+="\n   Better Critical ";break;
				case 6:result+="\n   Fast Trigger ";break;
				case 7:result+="\n   Ammo Upgrade ";break;
				case 8:result+="\n   Bonus Rate of Fire ";break;
				case 9:result+="\n   Slayer ";break;
				case 10:result+="\n   Destroyer ";break;
				case 11:result+="\n   Knockback ";break;
				case 12:result+="\n   Long Range ";break;
				case 13:result+="\n   Penetrate ";break;
				case 14:result+="\n   Poisoned ";break;
				case 15:result+="\n   Frozen Queen ";break;
				case 16:result+="\n   Killing Spree ";break;
				case 17:result+="\n   Life Steal ";break;
				case 18:result+="\n   Chip Shot ";break;
				case 19:result+="\n   Gain Strength ";break;
				case 20:result+="\n   Gain Perception ";break;
				case 21:result+="\n   Gain Endurance ";break;
				case 22:result+="\n   Gain Charisma ";break;
				case 23:result+="\n   Gain Intelligence ";break;
				case 24:result+="\n   Gain Agility ";break;
				case 25:result+="\n   Gain Luck ";break;
				case 26:result+="\n   Cured ";break;
				case 27:result+="\n   Laser Reflector ";break;
				case 28:result+="\n   Anty-Termal System ";break;
				case 29:result+="\n   Defense Enhancement ";break;
				case 30:result+="\n   Advanced Plate ";break;
				case 31:result+="\n   Mirror System ";break;
				case 32:result+="\n   Tesla Addition ";break;
				case 33:result+="\n   Shock Protection ";break;
				case 34:result+="\n   Firegeckon's Enhancement";break;
				case 35:result+="\n   Special Force Bonus ";break;
				case 36:result+="\n   Regeneration ";break;
				case 37:result+="\n   Fill The Gaps ";break;
				case 38:result+="\n   Heavy ";break;
				case 39:result+="\n   Utility ";break;
				case 40:result+="\n   Bonus Move ";break;
				case 41:result+="\n   Heavy Stonewall ";break;
				case 42:result+="\n   Terminator ";break;
				case 43:result+="\n   Explosive Belt ";break;
				case 44:result+="\n   Tesla Attacker";break;
				case 45:result+="\n   Speed Mechanism ";break;
				case 46:result+="\n   Sneaky ";break;
				case 47:result+="\n   More Criticals ";break;
				case 48:result+="\n   Lethal Protection ";break;
				case 100:result+="\n   Enhancement Knockout ";break;
				case 101:result+="\n   More Bonus Damage ";break;
				case 102:result+="\n   Sniper ";break;
				case 103:result+="\n   Bounty Hunter ";break;
				case 104:result+="\n   Bonus Bullets Damage ";break;
				case 105:result+="\n   Gifted";break;
				case 106:result+="\n   Advanced Defense ";break;
				case 107:result+="\n   Super Regen ";break;
				case 108:result+="\n   Powered ";break;
				case 109:result+="\n   Anty-Crit ";break;
				case 59:result+="\n   Iron Skin ";break;
				case 60:result+="\n   Survivalist ";break;
				case 61:result+="\n   Strategic Improvement ";break;
				case 62:result+="\n   Smasher! ";break;
				case 63:result+="\n   Integrated Gloves ";break;
				case 64:result+="\n   Defensive Belt ";break;
				case 65:result+="\n   Spiked ";break;
				case 66:result+="\n   More Critical Damage ";break;
				case 67:result+="\n   Bonus Attack Speed ";break;
			}
		}
		result+=" \n";
		if(item.GetProtoId()==(58)&&item.HolodiskNumber!=0)
		result+=GetMsgStr((7),((item.HolodiskNumber)*10));
		else if(item.GetProtoId()==(9601))
		{
			bool full=false;
			if(lookType==(4)&&
			(item.Val6)!=(0)&&
			IsLexem(item,"$owner")&&
			IsLexem(item,"$info"))
			full=true;
			if(full)
			result+=GetMsgStr((2),(item.GetProtoId()*100+item.Info)+1);
			else
			result+=GetMsgStr((2),(item.GetProtoId()*100+item.Info)+2);
			
			stringReplaceText(result,"\\n","\n");
			string type="blank";
			switch((item.Val6))
			{
				case(1):
				type="military";
				break;
				case(2):
				type="custom-made";
				break;
			}
			stringReplaceText(result,"TYPE",type);
		}
		else
		{
			string _description=GetMsgStr((2),(item.GetProtoId()*100+item.Info)+1);
			if(IsLexem(item,"$~"))
			_description=GetLexem(item,"$~");
			string map_info="";
			if(item.Proto.ProtoId==(1274))
			{
				switch(item.Val0)
				{
					case 1200:map_info="tent ";break;
					case 1201:map_info="cave ";break;
					case 1202:map_info="ruins hideout ";break;
					case 1203:map_info="safehouse ";break;
					case 1204:map_info="small bunker ";break;
					case 1205:map_info="small shelter ";break;
					case 529:map_info="library ";break;
					case 524:map_info="small cabin ";break;
					case 523:map_info="church ";break;
					case 520:map_info="basement ";break;
					case 460:map_info="Nuka Cola outpost ";break;
					case 459:map_info="storage ";break;
					case 458:map_info="parking ";break;
					case 246:map_info="trapper camp ";break;
					case 245:map_info="gas station ";break;
					case 210:map_info="depot ";break;
					case 207:map_info="cave HQ ";break;
					case 205:map_info="scrapheap ";break;
					case 204:map_info="blades HQ ";break;
					case 203:map_info="khans HQ ";break;
					case 202:map_info="camp HQ ";break;
					case 75:map_info="cave HQ ";break;
					case 435:map_info="Enclave bunker ";break;
					case 436:map_info="Brotherhood of Steel bunker ";break;
					case 437:map_info="Vault City Outpost ";break;
					case 439:map_info="Vault ";break;
					case 481:map_info="NCR port ";break;
					case 521:map_info="Casino ";break;
					case 208:map_info="Old Bunker ";break;
					case 528:map_info="ruined jail ";break;
					case 440:map_info="Military Base ";break;
					case 463:map_info="Enclave Depot ";break;
					case 464:map_info="president shelter ";break;
					case 467:map_info="NCR bunker ";break;
					case 468:map_info="Homeland ";break;
					case 469:map_info="Underground station ";break;
					case 470:map_info="Military Depot ";break;
					case 471:map_info="Advanced outpost ";break;
					case 472:map_info="Slavery base ";break;
					case 480:map_info="Underground station MK.II ";break;
					case 482:map_info="Brotherhood of Steel outpost ";break;
					case 518:map_info="Cave labs ";break;
					case 525:map_info="Large church ";break;
					case 373:map_info="Sky Tower, personal dungeon only for 1 character, choose wisely ";break;
					case 374:map_info="Fake Vault, personal dungeon only for 1 character, choose wisely  ";break;
					case 375:map_info="L.A Raiders, personal dungeon only for 1 character, choose wisely  ";break;
					case 383:map_info="Broken Ship, personal dungeon only for 1 character, choose wisely  ";break;
					case 384:map_info="Interplay studio, don't use car for it! ";break;
					case 1206:map_info="High Tech Bunker with T4 Machinery";break;
					default:map_info="Unknown ";break;
					
				}
			}
			result+=_description+map_info;
			
			if(IsLexem(item,"$+"))
			result+="\n"+GetLexem(item,"$+");
		}
		
		if(lookType!=(2))
		{
			if(item.GetType()==(3))
			{
				
				if(item.Proto.Weapon_MaxAmmoCount>0)
				{
					result+="\n";
					int rounds=item.Proto.Weapon_Round_0;
					int rounds2=item.Proto.Weapon_Round_1;
					CritterCl@Chosene=GetChosen();
					if(Chosene.Param[(305)]>1&&Chosene.Param[(428)]>0&&rounds>1)
					rounds++;
					string roundtext=""+rounds;
					if(rounds2>0)
					{
						if(Chosene.Param[(305)]>1&&Chosene.Param[(428)]>0&&rounds2>1)
						rounds2++;
						roundtext+=":"+rounds2;
					}
					string str=GetMsgStr((3),(434));
					str=ReplaceText(str,"VALUE",item.AmmoCount);
					str=ReplaceText(str,"MAX_VALUE",item.Proto.Weapon_MaxAmmoCount);
					str=ReplaceText(str,"AMMO",GetMsgStr((3),(10900+(item.Proto.Weapon_Caliber))));
					result+=str;
					result+="\nRounds: "+roundtext;
					result+="\nDamage: "+item.Proto.Weapon_DmgMin_0+"-"+item.Proto.Weapon_DmgMax_0;
					result+="\nRange: "+item.Proto.Weapon_MaxDist_0+" "+item.Proto.Weapon_MaxDist_1;
				}      
				
				if(item.Proto.Weapon_MinStrength>1)
				{
					result+="\nMinimum Strength: "+item.Proto.Weapon_MinStrength;
				}
			}
			
			else if(item.GetType()==(1))
			{
				result+="\nCrit chance mod: "+(item.Proto.Armor_CMCritChance);
				result+="\nCrit power mod: "+(item.Proto.Armor_CMCritPower);
				if(item.GetProtoId()==(240))
				result+="\nCharges: "+item.Charge+"/"+item.Proto.Misc_ChargeMax;
				result+="\nNormal: DR: "+item.Proto.Armor_DRNormal+"% DT: "+item.Proto.Armor_DTNormal;
				result+="\nLaser: DR: "+item.Proto.Armor_DRLaser+"% DT: "+item.Proto.Armor_DTLaser;
				result+="\nFire: DR: "+item.Proto.Armor_DRFire+"% DT: "+item.Proto.Armor_DTFire;
				result+="\nPlasma: DR: "+item.Proto.Armor_DRPlasma+"% DT: "+item.Proto.Armor_DTPlasma;
				result+="\nExplode: DR: "+item.Proto.Armor_DRExplode+"% DT: "+item.Proto.Armor_DTExplode;
				result+="\nElectro: DR: "+item.Proto.Armor_DRElectr+"% DT: "+item.Proto.Armor_DTElectr;
			} 
			
			else if(item.GetType()==(4))
			{
				result+="\nDM mod: "+(item.Proto.Ammo_DmgMult)+"/"+(item.Proto.Ammo_DmgDiv);
				result+="\nDR mod: "+(item.Proto.Ammo_DrMod)+"%";
				result+="\nAC mod: "+(item.Proto.Ammo_AcMod);
				if(((@item.Proto!=null)?(item.Proto.Ammo_DTDiv>0):false))
				result+="\nArmor Piercing";
			}
			
			else if(item.GetType()==(5))
			{
				if(item.Proto.Misc_ToolSkillNum!=0)
				{
					string str=GetMsgStr((3),(100001+(item.Proto.Misc_ToolSkillNum)*10));
					result+="\n"+str+" bonus: "+item.Proto.Misc_ToolSkillBonus+".";
				}
			}
			
			else if(item.GetType()==(7))
			result+="\n"+ReplaceText(GetMsgStr((3),(550)),"KEY_ID",item.LockerId); 
			
			if(item.IsDeteriorable())
			{
				uint8 flags=item.BrokenFlags;
				uint8 brokenCount=item.BrokenCount;
				uint16 wearCount=item.Deterioration; 
				
				result+="\n";
				if((((flags)&((0x08)))!=0))
				result+=GetMsgStr((3),(506));
				else if((((flags)&((0x01)))!=0))
				result+=GetMsgStr((3),(503));
				else if((((flags)&((0x02)))!=0))
				result+=GetMsgStr((3),(504));
				else if((((flags)&((0x04)))!=0))
				result+=GetMsgStr((3),(505));
				else
				result+=ReplaceText(ReplaceText(GetMsgStr((3),(500)),"VALUE",100-wearCount*100/(10000)),"MAXVALUE",100-brokenCount); 
				
				if((((flags)&((0x10)))!=0))
				result+="\n"+GetMsgStr((3),(501)); 
				
				if((((flags)&((0x20)))!=0))
				result+="\n"+GetMsgStr((3),(502));  
				
			} 
			
			if(HaveAnyIngredient(item))
			{
				array<string>ingredients;
				uint count=IngredientsNames(item,ingredients);
				for(uint i=0;i<count;i++)
				{
					if(ingredients[i].length()>0)
					result+="\nIngredient: "+ingredients[i];
				}
			} 
			
			string weightString=GetMsgStr((3),(435));
			if(item.Proto.Weight*item.GetCount()==1)
			weightString=ReplaceText(weightString,"grams.","gram.");  
			
			result+="\n"+ReplaceText(weightString,"VALUE",item.Proto.Weight*item.GetCount());
			if(IsLexem(item,"$crafter"))result+="\nCrafter: "+GetLexem(item,"$crafter");
			if(IsLexem(item,"$spawnedby"))result+="\nSpawned by: "+GetLexem(item,"$spawnedby");   
			
			if(item.GetProtoId()==(623))
			{
				if(IsLexem(item,"$writtenby"))result+="\n\nWritten by: "+GetLexem(item,"$writtenby");
				result+="\n\n"+(item.Val1==0?"Still waiting to be read.":"Someone has started read it.")+".";
				uint16 chapters=item.Val2-1;
				result+="\nContains "+chapters+" "+(chapters>1?"chapters":"chapter")+" in total. (Level: "+item.Val2+")";
				result+="\n"+item.Val0+" "+(item.Val0>1?"chapters":"chapter")+"left...";
			}
		}
	} 
	
	return(FormatTags(result,item.Lexems));
}

int SelectWeaponBonus(ItemCl&it,int Int_Val_WeaponBonus)
{
	return 0;
}

string showItemBonus(ItemCl&it,int type,int value)
{
	string result="";
	if(type==0)return result;
	if(it.GetType()==(1))
	{
		switch(type)
		{
			case 100:{result="\nNormal DT +"+value+"";break;}
			case 101:{result="\nLaser DT +"+value+"";break;}
			case 102:{result="\nFire DT +"+value+"";break;}
			case 103:{result="\nPlasma DT +"+value+"";break;}
			case 104:{result="\nExplode DT +"+value+"";break;}
			case 105:{result="\nNormal DR +"+value+"%";break;}
			case 106:{result="\nLaser DR +"+value+"%";break;}
			case 107:{result="\nFire DR +"+value+"%";break;}
			case 108:{result="\nPlasma DR +"+value+"%";break;}
			case 109:{result="\nExplode DR +"+value+"%";break;}
			case 110:{result="\nCrit Chance "+value+"";break;}
			case 111:{result="\nCrit Power "+value+"";break;}
			case 112:{result="\nAction Points +"+value+"";break;}
			case 113:{result="\nRad Resist +"+value+"";break;}
			case 114:{result="\nPoison Resist +"+value+"";break;}
			case 115:{result="\nStrength +"+value+"";break;}
			case 116:{result="\nPerception +"+value+"";break;}
			case 117:{result="\nEndurance +"+value+"";break;}
			case 118:{result="\nCharisma +"+value+"";break;}
			case 119:{result="\nIntelligence +"+value+"";break;}
			case 120:{result="\nAgility +"+value+"";break;}
			case 121:{result="\nLuck +"+value+"";break;}
			case 122:{result="\nCarry Weight +"+value+"";break;}
			case 123:{result="\nHealing Rate +"+value+"";break;}
			default:break;
		}
	}
	else if(it.GetType()==(3))
	{
		switch(type)
		{
			case 100:{result="\nCrit Power +"+value+"";break;}
			case 101:{result="\nCrit Chance +"+value+"";break;}
			case 102:{result="\nMin dmg +"+value+"%";break;}
			case 103:{result="\nMax dmg +"+value+"%";break;}
			case 104:{result="\nAccuracy +"+value+"%";break;}
			case 105:{result="\nAction points +"+value+"";break;}
			case 106:{result="\nRange +"+value+"";break;}
			default:break;
		}
	}
	return result;
}

string showPrefix(ItemCl@it)
{
	string result="";
	if(it.Val6>0)
	if(it.Val7>0)
	if(it.Val8>0)
	if(it.Val5>0)
	if(it.Val4>0)
	if(it.Val1==7)
	result+=" |-65536 ";
	else result+=" |-256 ";
	else result+=" |-3394561 ";
	else result+=" |-16711681 ";
	else result+=" |-4210753 ";
	else result+=" |-4227008 ";
	return result;
}

uint8[]Abbr={'F','H','L','M','N','R','S'};
uint8[]AnStart={'A','a','E','e','I','i','O','o'};   

string critter_description(CritterCl&cr,int lookType)
{
	string result;
	int gender=cr.Param[(71)];
	CritterCl@chosen=GetChosen();
	
	if(lookType==(0))
	{
		uint dialog=cr.Param[(104)];
		uint16 pid=cr.Pid;  
		
		{
			
			string head=(cr.IsPlayer()?cr.Name:" ");
			
			if(IsLexem(cr,"$@"))
			{
				head=GetLexem(cr,"$@");
				if(head.rawLength()==0)
				head=" ";
				
				if(cr.IsPlayer()&&head==" ")
				cr.ContourColor=0xFF960000;
				else if(cr.IsNpc()&&head!=" ")
				cr.ContourColor=0xFF969600;
				
				stringReplaceText(head,"|","");
				head=FormatTags(head,"");
			}
			
			if(IsGMTEnabled()&&GMToolsAccess())
			{
				array<string>gm;
				
				string id="<"+cr.Id+">";
				
				if((cr.IsPlayer()&&head!=cr.Name)||(cr.IsNpc()&&IsLexem(cr,"$@")))
				{
					if(cr.IsPlayer())
					gm.insertLast("Player: "+cr.Name);
					else if(cr.IsNpc())
					gm.insertLast("NPC: "+GetMsgStr((1),((dialog)!=0?100000+(dialog)*1000+100:((pid)*10))));
				}
				
				if(__ShowCritId)
				gm.insertLast("ID: "+cr.Id);
				
				if(cr.Param[(510)]>0)
				gm.insertLast("sneaked");
				
				if(gm.length()>0)
				{
					head+="|"+(uint((0xFF<<24)|(((0xFF)&0xFF)<<16)|(((0xFF)&0xFF)<<8)|((0xFF)&0xFF)))+" ";
					for(uint g=0,gLen=gm.length();g<gLen;g++)
					{
						head+="\n("+gm[g]+")";
					}
				}
			}
			
			cr.NameOnHead=head;
			
			if(cr.IsPlayer())
			{
				if(GUI_GetActiveMainScreen()==(6))
				result=(IsLexem(cr,"$name")?GetLexem(cr,"$name"):cr.Name);
				else
				result=cr.Name;
			}
			else
			result=cr.Name; 
			
		}
		
		return(result);
	}
	
	if(cr.IsPlayer())
	{
		if(lookType==(0))
		{} 
		
		if(lookType==(1))
		{
			result+=GetMsgStr((3),(11000+(gender)*1000));
			result+=(IsLexem(cr,"$name")?GetLexem(cr,"$name"):cr.Name);
			result+=".";
		}
		
		else
		{
			result+=GetMsgStr((3),(11000+(gender)*1000)); 
			
			uint ageStr=GetMsgStrNumUpper((3),(11100+((cr.Param[(70)])>99?99:(cr.Param[(70)]))+((gender>1)?1:(gender))*1000));
			if(ageStr!=0)
			result+=GetMsgStr((3),ageStr);
			else
			result+=(IsLexem(cr,"$name")?GetLexem(cr,"$name"):cr.Name);                        
			
		}
	}
	else
	{
		uint dlgId=cr.Param[(104)];
		uint16 npcPid=cr.Pid;
		bool defaultText=false;
		
		if(lookType==(0))
		{
			
		}
		
		if(lookType==(1))
		{
			if(cr.IsLife()&&IsMsgStr((1),((dlgId)!=0?100000+(dlgId)*1000+200:((npcPid)*10+1))))
			result+=GetMsgStr((1),((dlgId)!=0?100000+(dlgId)*1000+200:((npcPid)*10+1)));
			else if(cr.IsKnockout()&&IsMsgStr((1),((dlgId)!=0?100000+(dlgId)*1000+220:((npcPid)*10+1))))
			result+=GetMsgStr((1),((dlgId)!=0?100000+(dlgId)*1000+220:((npcPid)*10+1)));
			else if(cr.IsDead()&&IsMsgStr((1),((dlgId)!=0?100000+(dlgId)*1000+240:((npcPid)*10+1))))
			result+=GetMsgStr((1),((dlgId)!=0?100000+(dlgId)*1000+240:((npcPid)*10+1)));
			else
			defaultText=true;
		}
		
		else
		{
			string rslt="You see ";
			if(IsLexem(cr,"$name"))
			rslt+=GetLexem(cr,"$name");
			
			if(cr.IsLife()&&IsMsgStr((1),((dlgId)!=0?100000+(dlgId)*1000+210:((npcPid)*10+1))))
			{
				if(rslt.rawLength()>8)
				result+=rslt;
				else
				result+=GetMsgStr((1),((dlgId)!=0?100000+(dlgId)*1000+210:((npcPid)*10+1)));
			}
			else if(cr.IsKnockout()&&IsMsgStr((1),((dlgId)!=0?100000+(dlgId)*1000+230:((npcPid)*10+1))))
			{
				if(rslt.rawLength()>8)
				result+=ReplaceText(rslt,"see","see an unconscious");
				else
				result+=GetMsgStr((1),((dlgId)!=0?100000+(dlgId)*1000+230:((npcPid)*10+1)));
			}
			else if(cr.IsDead()&&IsMsgStr((1),((dlgId)!=0?100000+(dlgId)*1000+250:((npcPid)*10+1))))
			{
				if(rslt.rawLength()>8)
				result+=ReplaceText(rslt,"see","see a dead");
				else
				result+=GetMsgStr((1),((dlgId)!=0?100000+(dlgId)*1000+250:((npcPid)*10+1)));
			}
			else
			defaultText=true;
		}
		
		if(defaultText)
		{
			
			if(IsMsgStr((1),((dlgId)!=0?100000+(dlgId)*1000+100:((npcPid)*10))))
			{
				if(cr.IsLife())
				result+=ReplaceText(GetMsgStr((3),(11010)),"NAME",GetMsgStr((1),((dlgId)!=0?100000+(dlgId)*1000+100:((npcPid)*10))));
				else if(cr.IsKnockout())
				result+=ReplaceText(GetMsgStr((3),(11011)),"NAME",GetMsgStr((1),((dlgId)!=0?100000+(dlgId)*1000+100:((npcPid)*10))));
				else if(cr.IsDead())
				result+=ReplaceText(GetMsgStr((3),(11012)),"NAME",GetMsgStr((1),((dlgId)!=0?100000+(dlgId)*1000+100:((npcPid)*10))));
			}
			
			else
			{
				result+=GetMsgStr((3),(11014));
			}
		}
	} 
	
	string extraSpecial="";
	string extraDamage="";
	string classo="";
	switch(cr.Param[(138)])
	{
		case 1:
		{
			classo="Randomboy";
			break;
		}
		case 2:
		{
			classo="Super Mutant";
			break;
		}
		case 3:
		{
			classo="Soldier";
			break;
		}
		case 4:
		{
			classo="Chosen One";
			break;
		}
		case 5:
		{
			classo="Priest";
			break;
		}
		case 6:
		{
			classo="Bounty Hunter";
			break;
		}
		case 7:
		{
			classo="Deathclaw";
			break;
		}
		case 8:
		{
			classo="Cyborg";
			break;
		}
		case 9:
		{
			classo="Killer";
			break;
		}
		case 10:
		{
			classo="Assassin";
			break;
		}
		case 11:
		{
			classo="Leader";
			break;
		}
		case 12:
		{
			classo="Paramedic";
			break;
		}
		case 13:
		{
			classo="Sniper";
			break;
		}
		case 14:
		{
			classo="Infantry";
			break;
		}
	}
	
	if((@chosen!=null)&&chosen.Param[(301)]>0&&cr.IsPlayer())
	{
		string@special=CritterDescription_Get(cr.Param[(138)],
		cr.Param[(139)]); 
		
		if((@special!=null))
		extraSpecial=special;
	} 
	
	{
		array<uint>damage;
		for(uint i=0;i<7;i++)
		{
			if(cr.Damage[(500)+i]!=0&&IsMsgStr((3),(11400+(i)+(gender)*1000)))
			{
				uint len=damage.length();
				damage.insertLast(i);
			}
		}
		
		if(damage.length()>0)
		{
			extraDamage+=GetMsgStr((3),(11003+(gender)*1000));
			
			for(uint i=0;i<damage.length();i++)
			{
				uint dmg=damage[i];
				extraDamage+=GetMsgStr((3),(11400+(dmg)+(gender)*1000));
				
				if(i==damage.length()-1)
				break;
				else if(i==damage.length()-2)
				extraDamage+=GetMsgStr((3),(54));
				else
				extraDamage+=", ";
			}
			extraDamage+=".";
		}
	} 
	
	if(lookType==(2))
	{
		if(result.rawLength()>0&&result.rawGet(result.rawLength()-1)!='.')
		result+=".";
		
		if((@chosen!=null)&&chosen.Param[(301)]>0)
		{
			if(extraSpecial.rawLength()>0)
			result+=" It looks "+(gender==(0)?"h":"sh")+"e's "+extraSpecial+".";
		}
		
		if(extraDamage.rawLength()>0)
		result+=" "+extraDamage;
		
		if((@chosen!=null)&&chosen.Param[(301)]>0)
		{
			result+=" ";
			result+=GetMsgStr((3),(12530+(gender)));
			result=ReplaceText(result,"CUR",cr.Param[(72)]);
			result=ReplaceText(result,"MAX",cr.Param[(7)]);
			result+=" Class: "+classo+" ";
			
			ItemCl@item=cr.GetItem(0,(1));        
			
			if((@item!=null))
			{
				string iName=GetMsgStr((2),(item.GetProtoId()*100+item.Info));
				if(IsLexem(item,"$-"))
				iName=GetLexem(item,"$-");
				
				bool isAn=((iName.rawLength()>1&&('A'<=iName.rawGet(1)&&iName.rawGet(1)<='Z'||'0'<=iName.rawGet(1)&&iName.rawGet(1)<='9'||iName.rawGet(1)=='&')&&Abbr.find(iName.rawGet(0))>=0)||
				AnStart.find(iName.rawGet(0))>=0);
				
				if(item.GetType()==(3))
				{
					
					{
						string pWeap=GetMsgStr((3),(12540));
						if(isAn)
						pWeap=ReplaceText(pWeap,"a WEAPON","an WEAPON");
						result+=pWeap;
						result=ReplaceText(result,"WEAPON",iName);
					}         
					
				}
				else
				{
					string pMisc=GetMsgStr((3),(12542));
					if(isAn)
					pMisc=ReplaceText(pMisc,"a MISC","an MISC");
					result+=pMisc;
					result=ReplaceText(result,"MISC",iName);
				}
			}
		}
		else
		{
			result+=" ";
			result+=GetMsgStr((3),(12500+(gender)));
			
			int hp_proc=cr.Param[(72)]*100/cr.Param[(7)];
			if(cr.IsDead())
			result+=GetMsgStr((3),(12510+(0)));
			else
			result+=GetMsgStr((3),(12510+(cr.Param[(136)]>1?cr.Param[(136)]:1)));
			
			if((cr.Damage[(502)]>0||cr.Damage[(503)]>0||cr.Damage[(504)]>0||cr.Damage[(505)]>0||cr.Damage[(506)]>0))
			{
				if(cr.Param[(136)]<4)
				result+=GetMsgStr((3),(54));
				result+=GetMsgStr((3),(12520+(gender)*2+(cr.Param[(136)]==4?1:0)));
			}
		}
		result+=".";
	}  
	
	bool armVisible=false;
	if(lookType==(2)&&IsLexem(cr,"$tatoo"))
	{                                                                 
		
		armVisible=true;   
		
		string tatoo=GetLexem(cr,"$tatoo");
		if(armVisible&&tatoo.length()>0)
		{
			array<string@>@s=split(tatoo," ");
			result+=" You can see a tattoo with the word"+(s.length()>1?"s":"")+" '"+tatoo+"' on h"+(gender==(0)?"is":"er")+" arm";
		}
		else
		armVisible=false;
	}
	
	bool headVisible=true;
	ItemCl@helmet=cr.GetItem(0,(4));
	if((@helmet!=null))
	headVisible=false;
	
	if(lookType==(2)&&cr.Param[(493)]>0)
	{
		if(armVisible)
		{
			if(headVisible)
			result+=", and another one on forehead. "+(gender==(0)?"H":"Sh")+"e's a slaver.";
			else
			result+=".";
		}
		else
		{
			if(headVisible)
			{
				array<string>rnd=
				{
					(gender==(0)?"H":"Sh")+"e has",
					"You can see"
				}; 
				
				result+=" "+rnd[Random(0,rnd.length()-1)]+" a slaver tattoo on h"+(gender==(0)?"is":"er")+" forehead.";
			}
		}
	}
	else if(lookType==(2)&&armVisible&&cr.Param[(493)]<=0)
	result+=".";
	
	if(cr.IsPlayer()&&lookType==(2)&&IsLexem(cr,"$~"))
	{
		result=GetMsgStr((3),(11000+(gender)*1000))+(IsLexem(cr,"$name")?GetLexem(cr,"$name"):cr.Name)+".";
		string descr=GetLexem(cr,"$~");
		if(descr.rawLength()>0)
		result=descr;
	}
	else if(cr.IsNpc()&&IsLexem(cr,"$~"))
	{
		if(lookType==(0))
		{
			result=(IsLexem(cr,"$name")?GetLexem(cr,"$name"):cr.Name);
		}
		else if(lookType==(1))
		{
			result="You see "+(IsLexem(cr,"$name")?GetLexem(cr,"$name"):cr.Name)+".";
		}
		else if(lookType==(2))
		{
			result="You see "+(IsLexem(cr,"$name")?GetLexem(cr,"$name"):cr.Name)+". "+GetLexem(cr,"$~");
		}
	}
	
	return(FormatTags(result,cr.Lexems));
}  

void critter_in(CritterCl&cr)
{
	CritterCl@chosen=GetChosen();
	
	critter_description(cr,(0));
	if((@chosen!=null))
	{
		ColorizeCritter(cr);
	}
	else
	ColorizeCritterPreview(cr);
}   

void _SetColor(int crId,int status,int reputation,string@param3,array<int>@param4)
{
	CritterCl@cr=GetCritter(crId);
	if(!(@cr!=null))
	return; 
	
	if(status==(2))
	cr.ContourColor=((uint((0xFF<<24)|(((150)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF))));
	else if(status==(1))
	cr.ContourColor=((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((150)&0xFF)<<8)|((0)&0xFF))));
	else
	cr.ContourColor=((uint((0xFF<<24)|(((150)&0xFF)<<16)|(((150)&0xFF)<<8)|((0)&0xFF)))); 
	
	if(reputation>=__ReputationLoved)
	cr.NameColor=((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0)&0xFF)<<8)|((0xFF)&0xFF))));
	else if(reputation>=__ReputationLiked)
	cr.NameColor=((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0)&0xFF)<<8)|((0xC8)&0xFF))));
	else if(reputation>=__ReputationAccepted)
	cr.NameColor=((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xC8)&0xFF)<<8)|((0)&0xFF))));
	else if(reputation>=__ReputationNeutral)
	cr.NameColor=((uint((0xFF<<24)|(((0xAD)&0xFF)<<16)|(((0xAD)&0xFF)<<8)|((0xB9)&0xFF))));
	else if(reputation>=__ReputationAntipathy)
	cr.NameColor=((uint((0xFF<<24)|(((0x8F)&0xFF)<<16)|(((0x6F)&0xFF)<<8)|((0)&0xFF))));
	else if(reputation>=__ReputationHated)
	cr.NameColor=((uint((0xFF<<24)|(((0xC8)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF))));
	else
	cr.NameColor=((uint((0xFF<<24)|(((0xAA)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF))));
}

void _SetScrolls(int scrollCrit,int scrollCont,int param3,string@param4,array<int>@param5)
{
	SetScroll((3),pickupScreenScrollCritter);
	SetScroll((4),pickupScreenScrollFrom);
}

void _RepairSession(int param1,int param2,int param3,string@param4,array<int>@param5)
{
	SetRepairPid(param1);
	SetRepairItem(param2);
	RefreshItemsCollection((1));
}

void _RechargeSession(int param1,int param2,int param3,string@param4,array<int>@param5)
{
	SetRepairPid(param1);
	SetRepairItem(param2);
	RefreshItemsCollection((1));
} 

void _DialogImage(int x,int y,int imageId,string@,array<int>@)
{
	string image="";
	switch(imageId)
	{
		case 1:
		image="items/car_police01.png";
		break;
	}
	if(image!=""&&image.length()>0)
	DialogImage.Set(x,y,image);
}                            

class BagCallbackHide:IGUIScreenCallbackHide
{
	void OnHide(int p0,int p1,int p2)
	{
		SetRepairPid(0);
		RefreshItemsCollection((1));
	}
};

BagCallbackHide BagHide;

void InitBagCallbacks()
{
	IGUIScreenOpt@sc=GUI_GetScreen((31));
	sc.SetCallbackHide(BagHide);
}

void IndicatorMouse(bool down,int click)
{
	if(!down)
	{
		InvItemClicked=false;
		return;
	}
	if(down&&click==(0)&&GUI_GetActiveScreen()==(5))
	{
		if(ItemBar.IsInside(__MouseX,__MouseY))
		InvItemClicked=true;
	}
	else
	InvItemClicked=false;
}

bool ReadIniInt(string&key,int&ret)
{
	string@s=GetIfaceIniStr(key);
	return(@s!=null)&&StrToInt(s,ret);
}

void InitIndicators()
{
	IndicatorDraw=__IndicatorType!=1;
	CounterDraw=__IndicatorType!=0;
	__IndicatorType=3;
	
	Rect IntWMain("IntMain");
	int IntX=-1;
	ReadIniInt("IntX",IntX);
	if(IntX==-1)
	IntX=(__ScreenWidth-IntWMain.W())/2;
	else if(IntX==-2)
	IntX=__ScreenWidth-IntWMain.W();
	else if(IntX==-3)
	IntX=0;
	else
	{
		if(IntX<0)
		IntX=0;
		if(IntX+IntWMain.W()>__ScreenWidth)
		IntX=0;
	}
	int IntY=__ScreenHeight-IntWMain.Y2;
	@ItemBar=@Rect("IntItem",IntX,IntY);
	@AmmoIndicator=@Rect("IntAmmoCount",IntX,IntY);
	@WearIndicator=@Rect("IntWearProcent",IntX,IntY);
	
	string@s=GetIfaceIniStr("IntAmmoCountText");
	if(!(@s!=null)||s.length()<4)
	@AmmoCounter=@Rect(ItemBar,7,8);
	else
	@AmmoCounter=@Rect("IntAmmoCountText",IntX,IntY);
	
	@s=GetIfaceIniStr("IntWearProcentText");
	if(!(@s!=null)||s.length()<4)
	@WearCounter=@Rect(ItemBar,7,19);
	else
	@WearCounter=@Rect("IntWearProcentText",IntX,IntY);
	
	int IntItemOffsX=0;
	int IntItemOffsY=-2;
	ReadIniInt("IntItemOffsX",IntItemOffsX);
	ReadIniInt("IntItemOffsY",IntItemOffsY);
	@AmmoCounterClicked=@Rect(AmmoCounter,IntItemOffsX,IntItemOffsY);
	@WearCounterClicked=@Rect(WearCounter,IntItemOffsX,IntItemOffsY);
}

void DrawIndicators()
{
	if(!InterfaceShown)
	return;     
	
	CritterCl@chosen=GetChosen();
	if(!(@chosen!=null))
	return;
	ItemCl@item=chosen.GetItem(0,(1));
	
	int wear_proc=((@item!=null)&&item.IsDeteriorable())?100-(item.Deterioration*100)/(10000):0;
	int max_ammo=((@item!=null)&&item.GetType()==(3))?item.Proto.Weapon_MaxAmmoCount:0;
	int cur_ammo=((@item!=null)&&item.GetType()==(3))?(((((item.Mode)&0xF))==0?item.Proto.Weapon_Skill_0:((((item.Mode)&0xF))==1?item.Proto.Weapon_Skill_1:((((item.Mode)&0xF))==2?item.Proto.Weapon_Skill_2:0)))==(205)?item.GetCount():item.AmmoCount):0;
	
	if((@item!=null)&&max_ammo==0&&cur_ammo==0&&item.Proto.Misc_ChargeMax>0)
	{
		max_ammo=item.Proto.Misc_ChargeMax;
		cur_ammo=item.Charge;
	}
	
	if((@item!=null)&&wear_proc==0&&item.Proto.IndicatorMax>0)
	{
		wear_proc=item.Indicator;
	}
	
	if((@item!=null)&&cur_ammo==0&&item.IsStackable()&&item.GetCount()>1)
	{
		cur_ammo=item.GetCount();
		if(cur_ammo>max_ammo)
		cur_ammo=max_ammo;
	}
	int ammo_proc=max_ammo==0?0:100*cur_ammo/max_ammo;
	if(IndicatorDraw)
	{
		DrawIndicator(AmmoIndicator,AmmoIndicatorPoints,((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xC8)&0xFF)<<8)|((0)&0xFF)))),ammo_proc,AmmoIndicatorTick,true,false);
		DrawIndicator(WearIndicator,WearIndicatorPoints,((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xFF)&0xFF)<<8)|((0)&0xFF)))),wear_proc,WearIndicatorTick,true,false);
	}
	if(CounterDraw)
	{
		if(max_ammo>0||cur_ammo>0)
		{
			if(cur_ammo!=LastAmmoCount||AmmoString=="")
			{
				LastAmmoCount=cur_ammo;
				if(cur_ammo>99)
				AmmoString=cur_ammo+"";
				else if(cur_ammo>9)
				AmmoString="0"+cur_ammo;
				else
				AmmoString="00"+cur_ammo;
			}
			DrawCounter(InvItemClicked?AmmoCounterClicked:AmmoCounter,AmmoString,InvItemClicked?((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))):((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xC8)&0xFF)<<8)|((0)&0xFF)))),(4));
		}
		if((@item!=null)&&item.IsDeteriorable())
		DrawCounter(InvItemClicked?WearCounterClicked:WearCounter,wear_proc+"%",InvItemClicked?((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xC8)&0xFF)<<8)|((0)&0xFF)))):((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xFF)&0xFF)<<8)|((0)&0xFF)))),(4));
	}
}

class Rect
{
	int X1;
	int Y1;
	int X2;
	int Y2;
	Rect(string&ini_str)
	{
		GUI_GetIniCoords(ini_str,X1,Y1,X2,Y2);
	}
	Rect(string&ini_str,int x_off,int y_off)
	{
		GUI_GetIniCoords(ini_str,X1,Y1,X2,Y2);
		X1+=x_off;
		Y1+=y_off;
		X2+=x_off;
		Y2+=y_off;
	}
	Rect(Rect@rect,int x_off,int y_off)
	{
		this.X1=rect.X1+x_off;
		this.Y1=rect.Y1+y_off;
		this.X2=rect.X2+x_off;
		this.Y2=rect.Y2+y_off;
	}
	
	Rect(int x1,int y1,int x2,int y2)
	{
		X1=x1;
		Y1=y1;
		X2=x2;
		Y2=y2;
	}       
	
	bool IsInside(int x,int y)
	{
		return(X1<=x&&x<=X2&&Y1<=y&&y<=Y2);
	}
	
	int H(){return Y2-Y1+1;}
	int W(){return X2-X1+1;}
};                         

Rect@ItemBar;

string AmmoString;
int LastAmmoCount=0;
bool IndicatorDraw=false;
bool CounterDraw=false;
bool InvItemClicked=false;
array<int>AmmoIndicatorPoints;
uint AmmoIndicatorTick=0;
Rect@AmmoIndicator;
Rect@AmmoCounter;
Rect@AmmoCounterClicked;

array<int>WearIndicatorPoints;
uint WearIndicatorTick=0;
Rect@WearIndicator;
Rect@WearCounter;
Rect@WearCounterClicked;

bool InterfaceShown=true; 

bool IsInterfaceShown()
{
	return(InterfaceShown);
}

void ToggleInterfaceShown()
{
	InterfaceShown=!InterfaceShown;
}

void SetInterfaceShown(bool setting)
{
	InterfaceShown=setting;
} 

void DrawIndicator(Rect@rect,array<int>&points,uint color,int procent,uint&tick,bool is_vertical,bool from_top_or_left,uint changeTick=35)
{
	
	if(GetTick()>=tick)
	{
		int points_count=(is_vertical?rect.H():rect.W())/2*procent/100;
		if(points_count==0&&procent>0)
		points_count=1;
		int points_length=points.length()/3;
		if(points_length!=points_count)
		{
			if(points_count>points_length)
			{
				points_count=points_length+1;
				points.resize(points_count*3);
				points_length*=3;
				if(is_vertical)
				{
					if(from_top_or_left)
					{
						points[points_length]=rect.X1;
						points[points_length+1]=rect.Y1+points_count*2-2;
					}
					else
					{
						points[points_length]=rect.X1;
						points[points_length+1]=rect.Y2-points_count*2+2;
					}
				}
				else
				{
					if(from_top_or_left)
					{
						points[points_length]=rect.X1+points_count*2-2;
						points[points_length+1]=rect.Y1;
					}
					else
					{
						points[points_length]=rect.X2-points_count*2+2;
						points[points_length+1]=rect.Y1;
					}
				}
				
				points[points_length+2]=color;
			}
			else
			{
				points.resize((points_length-1)*3);
			}
		}
		tick=GetTick()+changeTick;
	}
	if(points.length()>0)
	DrawPrimitive((0),points);
}

void DrawCounter(Rect@rect,string&text,uint color,int font)
{
	DrawText(text,rect.X1,rect.Y1,rect.X2,rect.Y2,color,font,0);
}   

array<uint>timers;
array<string>factions;
array<string>townnames;

uint lastsecond;
uint lasthour;

array<uint16>modoc_area_t;
array<uint16>bh_area_t;
array<uint16>klamath_area_t;
array<uint16>den_area_t;
array<uint16>redding_area_t;
array<uint16>gecko_area_t;
array<uint16>necro_area_t;

IPolygon@modoc_area;
IPolygon@bh_area;
IPolygon@klamath_area;
IPolygon@den_area;
IPolygon@redding_area;
IPolygon@gecko_area;
IPolygon@necro_area;

bool Initialized=false;
bool isFlag(ItemCl&item)
{
	for(uint i=9200;i<9599;i++)
	if(item.Proto.ProtoId==i)
	return true;
	
	return false;
	
}
void DrawArea(uint mappid,uint8 mode)
{
}

void DrawInsideStatus(bool inside)
{
	DrawText(inside?"Inside the capture zone":"Outside the capture zone",10,30,__ScreenWidth,20,inside?((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xC8)&0xFF)<<8)|((0)&0xFF)))):((uint((0xFF<<24)|(((0xC8)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))),(5),(0x0008)|(0x0200));
}

void DrawInsideEventStatus()
{
	CritterCl@critter=GetChosen();
	if(!(@critter!=null))
	return;           
	
}

void InitTownDisplay()
{
	if(Initialized)
	return;
	timers.resize((7));
	factions.resize((7));
	townnames.resize((7));
	InitAreas();
	
	townnames[0]="Modoc";
	townnames[1]="Klamath";
	townnames[2]="Gecko";
	townnames[3]="Broken Hills";
	townnames[4]="Den";
	townnames[5]="Redding";
	townnames[6]="Necropolis";
	
	for(uint i=0;i<(7);i++)
	timers[i]=0;
	Initialized=true;
}

void InitAreas()
{
	@modoc_area=NewPolygon();
	modoc_area.AddVertices(modoc_area_v).GetTriangulation(modoc_area_t);
	@bh_area=NewPolygon();
	bh_area.AddVertices(bh_area_v).GetTriangulation(bh_area_t);
	@klamath_area=NewPolygon();
	klamath_area.AddVertices(klamath_area_v).GetTriangulation(klamath_area_t);
	@den_area=NewPolygon();
	den_area.AddVertices(den_area_v).GetTriangulation(den_area_t);
	@redding_area=NewPolygon();
	redding_area.AddVertices(redding_area_v).GetTriangulation(redding_area_t);
	@gecko_area=NewPolygon();
	gecko_area.AddVertices(gecko_area_v).GetTriangulation(gecko_area_t);
	@necro_area=NewPolygon();
	necro_area.AddVertices(necro_area_v).GetTriangulation(necro_area_t);
	
}

void CountDownStop(int town)
{
	timers[town]=0;
}

void CountDownStart(int town,uint time,string@faction)
{
	timers[town]=time;
	factions[town]=faction;
}

bool IsCounting(uint townid)
{
	return timers[townid]>(__FullSecond);
}

string GetTownName(uint townid)
{
	return townnames[townid];
}

string GetFaction(uint townid)
{
	return factions[townid];
}

int GetSeconds(uint townid)
{
	if((__FullSecond)>timers[townid])
	return 0;
	uint ret=timers[townid];
	ret-=(__FullSecond);
	ret/=__TimeMultiplier;
	return int(ret);
}           

void render_map()
{}

void critter_out(CritterCl&cr)
{}  

void item_map_in(ItemCl&item)
{ 
	
}

void item_map_changed(ItemCl&itemNow,ItemCl&itemBefore)
{}

void item_map_out(ItemCl&item)
{}  

void item_inv_in(ItemCl&item)
{}

void item_inv_out(ItemCl&item)
{}  

void item_drop(ItemCl&item)
{}

void draw_capture_zone(int param0,int param1,int param2,string@param3,int[]@param4)
{ 
	
}

