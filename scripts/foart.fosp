                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

int week_patch=1;
int doubleloot=1;
bool dropchance(float chance)
{
	if(chance==0)
	return false;
	if(Random(0,100)<chance)
	return true;
	
	return false;
	
}

bool can_tc_modoc=false;
bool can_tc_klamath=false;
bool can_tc_gecko=false;
bool can_tc_bh=false;
bool can_tc_redding=false;
bool can_tc_den=false;
bool can_tc_necro=false;
bool can_tc_reno=false;

uint when_tc_modoc=0;
uint when_tc_klamath=0;
uint when_tc_gecko=0;
uint when_tc_bh=0;
uint when_tc_redding=0;
uint when_tc_den=0;
uint when_tc_necro=0;
uint when_tc_reno=0;                         

uint8[]FOART_SIGNATURE={0x46,0x4F,0x41,0x52,0x54,0x00,0x17,0x14};                                                                                                  

shared interface Buffer
{
	bool IsRaw(uint len);
	
	Buffer@opCom();
	
	Buffer@opNeg();                    
	
	 Buffer@opShr(int8&value); Buffer@opShl(int8 value); Buffer@Get(int8&value); Buffer@Set(int8&value);
	 Buffer@opShr(int16&value); Buffer@opShl(int16 value); Buffer@Get(int16&value); Buffer@Set(int16&value);
	 Buffer@opShr(int32&value); Buffer@opShl(int32 value); Buffer@Get(int32&value); Buffer@Set(int32&value);
	 Buffer@opShr(int64&value); Buffer@opShl(int64 value); Buffer@Get(int64&value); Buffer@Set(int64&value);
	 Buffer@opShr(uint8&value); Buffer@opShl(uint8 value); Buffer@Get(uint8&value); Buffer@Set(uint8&value);
	 Buffer@opShr(uint16&value); Buffer@opShl(uint16 value); Buffer@Get(uint16&value); Buffer@Set(uint16&value);
	 Buffer@opShr(uint32&value); Buffer@opShl(uint32 value); Buffer@Get(uint32&value); Buffer@Set(uint32&value);
	 Buffer@opShr(uint64&value); Buffer@opShl(uint64 value); Buffer@Get(uint64&value); Buffer@Set(uint64&value);
	 Buffer@opShr(bool&value); Buffer@opShl(bool value); Buffer@Get(bool&value); Buffer@Set(bool&value);
	 Buffer@opShr(string&value); Buffer@opShl(string value); Buffer@Get(string&value); Buffer@Set(string&value);
	 Buffer@opShr(float&value); Buffer@opShl(float value); Buffer@Get(float&value); Buffer@Set(float&value);
	
	 Buffer@opShr(array<int8>&value); Buffer@opShl(array<int8>&value); Buffer@Get(array<int8>&value); Buffer@Set(array<int8>&value);
	 Buffer@opShr(array<int16>&value); Buffer@opShl(array<int16>&value); Buffer@Get(array<int16>&value); Buffer@Set(array<int16>&value);
	 Buffer@opShr(array<int32>&value); Buffer@opShl(array<int32>&value); Buffer@Get(array<int32>&value); Buffer@Set(array<int32>&value);
	 Buffer@opShr(array<int64>&value); Buffer@opShl(array<int64>&value); Buffer@Get(array<int64>&value); Buffer@Set(array<int64>&value);
	 Buffer@opShr(array<uint8>&value); Buffer@opShl(array<uint8>&value); Buffer@Get(array<uint8>&value); Buffer@Set(array<uint8>&value);
	 Buffer@opShr(array<uint16>&value); Buffer@opShl(array<uint16>&value); Buffer@Get(array<uint16>&value); Buffer@Set(array<uint16>&value);
	 Buffer@opShr(array<uint32>&value); Buffer@opShl(array<uint32>&value); Buffer@Get(array<uint32>&value); Buffer@Set(array<uint32>&value);
	 Buffer@opShr(array<uint64>&value); Buffer@opShl(array<uint64>&value); Buffer@Get(array<uint64>&value); Buffer@Set(array<uint64>&value);
	 Buffer@opShr(array<bool>&value); Buffer@opShl(array<bool>&value); Buffer@Get(array<bool>&value); Buffer@Set(array<bool>&value);
	 Buffer@opShr(array<string>&value); Buffer@opShl(array<string>&value); Buffer@Get(array<string>&value); Buffer@Set(array<string>&value);
	 Buffer@opShr(array<float>&value); Buffer@opShl(array<float>&value); Buffer@Get(array<float>&value); Buffer@Set(array<float>&value);
	
	 Buffer@opShr(array<array<int8>>&value); Buffer@opShl(array<array<int8>>&value); Buffer@Get(array<array<int8>>&value); Buffer@Set(array<array<int8>>&value);
	 Buffer@opShr(array<array<int16>>&value); Buffer@opShl(array<array<int16>>&value); Buffer@Get(array<array<int16>>&value); Buffer@Set(array<array<int16>>&value);
	 Buffer@opShr(array<array<int32>>&value); Buffer@opShl(array<array<int32>>&value); Buffer@Get(array<array<int32>>&value); Buffer@Set(array<array<int32>>&value);
	 Buffer@opShr(array<array<int64>>&value); Buffer@opShl(array<array<int64>>&value); Buffer@Get(array<array<int64>>&value); Buffer@Set(array<array<int64>>&value);
	 Buffer@opShr(array<array<uint8>>&value); Buffer@opShl(array<array<uint8>>&value); Buffer@Get(array<array<uint8>>&value); Buffer@Set(array<array<uint8>>&value);
	 Buffer@opShr(array<array<uint16>>&value); Buffer@opShl(array<array<uint16>>&value); Buffer@Get(array<array<uint16>>&value); Buffer@Set(array<array<uint16>>&value);
	 Buffer@opShr(array<array<uint32>>&value); Buffer@opShl(array<array<uint32>>&value); Buffer@Get(array<array<uint32>>&value); Buffer@Set(array<array<uint32>>&value);
	 Buffer@opShr(array<array<uint64>>&value); Buffer@opShl(array<array<uint64>>&value); Buffer@Get(array<array<uint64>>&value); Buffer@Set(array<array<uint64>>&value);
	 Buffer@opShr(array<array<bool>>&value); Buffer@opShl(array<array<bool>>&value); Buffer@Get(array<array<bool>>&value); Buffer@Set(array<array<bool>>&value);
	 Buffer@opShr(array<array<string>>&value); Buffer@opShl(array<array<string>>&value); Buffer@Get(array<array<string>>&value); Buffer@Set(array<array<string>>&value);
	 Buffer@opShr(array<array<float>>&value); Buffer@opShl(array<array<float>>&value); Buffer@Get(array<array<float>>&value); Buffer@Set(array<array<float>>&value);
	
	 Buffer@opShr(array<array<array<int8>>>&value); Buffer@opShl(array<array<array<int8>>>&value); Buffer@Get(array<array<array<int8>>>&value); Buffer@Set(array<array<array<int8>>>&value);
	 Buffer@opShr(array<array<array<int16>>>&value); Buffer@opShl(array<array<array<int16>>>&value); Buffer@Get(array<array<array<int16>>>&value); Buffer@Set(array<array<array<int16>>>&value);
	 Buffer@opShr(array<array<array<int32>>>&value); Buffer@opShl(array<array<array<int32>>>&value); Buffer@Get(array<array<array<int32>>>&value); Buffer@Set(array<array<array<int32>>>&value);
	 Buffer@opShr(array<array<array<int64>>>&value); Buffer@opShl(array<array<array<int64>>>&value); Buffer@Get(array<array<array<int64>>>&value); Buffer@Set(array<array<array<int64>>>&value);
	 Buffer@opShr(array<array<array<uint8>>>&value); Buffer@opShl(array<array<array<uint8>>>&value); Buffer@Get(array<array<array<uint8>>>&value); Buffer@Set(array<array<array<uint8>>>&value);
	 Buffer@opShr(array<array<array<uint16>>>&value); Buffer@opShl(array<array<array<uint16>>>&value); Buffer@Get(array<array<array<uint16>>>&value); Buffer@Set(array<array<array<uint16>>>&value);
	 Buffer@opShr(array<array<array<uint32>>>&value); Buffer@opShl(array<array<array<uint32>>>&value); Buffer@Get(array<array<array<uint32>>>&value); Buffer@Set(array<array<array<uint32>>>&value);
	 Buffer@opShr(array<array<array<uint64>>>&value); Buffer@opShl(array<array<array<uint64>>>&value); Buffer@Get(array<array<array<uint64>>>&value); Buffer@Set(array<array<array<uint64>>>&value);
	 Buffer@opShr(array<array<array<bool>>>&value); Buffer@opShl(array<array<array<bool>>>&value); Buffer@Get(array<array<array<bool>>>&value); Buffer@Set(array<array<array<bool>>>&value);
	 Buffer@opShr(array<array<array<string>>>&value); Buffer@opShl(array<array<array<string>>>&value); Buffer@Get(array<array<array<string>>>&value); Buffer@Set(array<array<array<string>>>&value);
	 Buffer@opShr(array<array<array<float>>>&value); Buffer@opShl(array<array<array<float>>>&value); Buffer@Get(array<array<array<float>>>&value); Buffer@Set(array<array<array<float>>>&value);
	
	 Buffer@opUShr(array<int8>&arr); Buffer@opUShrAssign(array<int8>&arr); array<int8>AsInt8();
	 Buffer@opUShr(array<int16>&arr); Buffer@opUShrAssign(array<int16>&arr); array<int16>AsInt16();
	 Buffer@opUShr(array<int32>&arr); Buffer@opUShrAssign(array<int32>&arr); array<int32>AsInt32();
	 Buffer@opUShr(array<int64>&arr); Buffer@opUShrAssign(array<int64>&arr); array<int64>AsInt64();
	 Buffer@opUShr(array<uint8>&arr); Buffer@opUShrAssign(array<uint8>&arr); array<uint8>AsUint8();
	 Buffer@opUShr(array<uint16>&arr); Buffer@opUShrAssign(array<uint16>&arr); array<uint16>AsUint16();
	 Buffer@opUShr(array<uint32>&arr); Buffer@opUShrAssign(array<uint32>&arr); array<uint32>AsUint32();
	 Buffer@opUShr(array<uint64>&arr); Buffer@opUShrAssign(array<uint64>&arr); array<uint64>AsUint64();
};  

import Buffer@NewBuffer()from"buffer";    

 import Buffer@NewBuffer(array<int8>@data)from"buffer";
 import Buffer@NewBuffer(array<int16>@data)from"buffer";
 import Buffer@NewBuffer(array<int32>@data)from"buffer";
 import Buffer@NewBuffer(array<int64>@data)from"buffer";
 import Buffer@NewBuffer(array<uint8>@data)from"buffer";
 import Buffer@NewBuffer(array<uint16>@data)from"buffer";
 import Buffer@NewBuffer(array<uint32>@data)from"buffer";
 import Buffer@NewBuffer(array<uint64>@data)from"buffer";                 

funcdef void FOART_AddonPreSpawn(Buffer&,uint16,uint16,uint16);
funcdef void FOART_AddonPostSpawn(Buffer&,Item&); 

shared interface FOArt
{
	uint8 Version(); 
	
	bool Load(array<uint8>data);
	bool Save(Buffer&buff);
	bool Save(array<uint8>&data); 
	
	bool Relative();
	void Relative(bool hexes_relative); 
	
	bool AddDefinition(FOArtDefinition@definition);
	FOArtDefinition@GetDefinition(uint index);
	uint GetDefinitions(array<FOArtDefinition@>&output);
	uint GetDefinitionsCount(); 
	
	int Spawn(Map&map,uint16 centerX,uint16 centerY); 
	
};

shared interface FOArtDefinition
{
	uint16 ItemPid{get;} 
	
	void Load(Buffer&buff);
	void Save(Buffer&buff); 
	
	void AddHex(int16 hex_x,int16 hex_y);
	bool GetHex(uint index,int16&hex_x,int16&hex_y);
	uint GetHexes(array<int16>&hexes);
	uint GetHexesCount();
	bool RemoveHex(int16 hex_x,int16 hex_y);
	void RemoveHexes(); 
	
	void SetAddonData(uint8 addon_id,Buffer&buff);
	void RemoveAddonData(uint8 addon_id);  
	
	int Spawn(Map&map,bool relative,uint16 centerX,uint16 centerY);
	uint Spawn(Map&map,uint16 hexX,uint16 hexY);
	
};

shared interface FOArtAddon
{
	uint8 ID();
	
	void Enable();
	void Disable();
	bool Enabled();
	bool Disabled(); 
	
	void SetPreSpawn(FOART_AddonPreSpawn@callback);
	void SetPostSpawn(FOART_AddonPostSpawn@callback);
	
	void PreSpawn(Buffer&data,uint16 pid,uint16 hexX,uint16 hexY);
	void PostSpawn(Buffer&data,Item@item);
	
};                               

class FOArt_Addon:FOArtAddon
{
	uint8 id;
	bool enabled;
	
	FOART_AddonPreSpawn@callbackPreSpawn;
	FOART_AddonPostSpawn@callbackPostSpawn; 
	
	FOArt_Addon(uint8 id)
	{
		this.id=id;
		this.enabled=true;
	}
	
	uint8 ID()
	{
		return(this.id);
	}
	
	void Enable()
	{
		this.enabled=true;
	}
	
	void Disable()
	{
		this.enabled=false;
	}
	
	bool Enabled()
	{
		return((this.enabled==true));
	}
	
	bool Disabled()
	{
		return(!this.Enabled());
	} 
	
	void SetPreSpawn(FOART_AddonPreSpawn@callback)
	{
		if((@callback!=null))
		{
			@this.callbackPreSpawn=@callback;
		}
	}
	
	void SetPostSpawn(FOART_AddonPostSpawn@callback)
	{
		if((@callback!=null))
		{
			@this.callbackPostSpawn=@callback;
		}
	}
	
	void PreSpawn(Buffer&data,uint16 pid,uint16 hexX,uint16 hexY)
	{
		if(this.Enabled()&&(@callbackPreSpawn!=null))
		{
			-data;
			this.callbackPreSpawn(data,pid,hexX,hexY);
			-data;
		}
	}
	
	void PostSpawn(Buffer&data,Item@item)
	{
		if(this.Enabled()&&(@callbackPostSpawn!=null))
		{
			-data;
			this.callbackPostSpawn(data,item);
			-data;
		}
	}
	
};
array<FOArtAddon@>FOArtAddons;

bool AddonsInitialized=false; 

FOArtAddon@NewFOArtAddon(uint8 id)
{
	if((@GetFOArtAddon(id)!=null))
	{
		Log("Addon with id <"+id+"> already exists");
		return(null);
	}
	
	return(@FOArt_Addon(id));
} 

FOArtAddon@GetFOArtAddon(uint8 id)
{
	for(uint addon=0,addonLen=FOArtAddons.length();addon<addonLen;addon++)
	{
		if(FOArtAddons[addon].ID()==id)
		return(FOArtAddons[addon]);
	}
	
	return(null);
}  

string GetFOArtString(Buffer&buff)
{
	string result="";
	
	uint16 len=0;
	buff>>len;
	for(uint s=0;s<len;s++)
	{
		uint8 char=0;
		buff>>char;
		result.rawResize(s+1);
		result.rawSet(s,char);
	}
	return(result);
}                                                                                                                           

void FOArt2238_ItemSpawned(uint itemId,uint spawnerId)
{
	if(itemId==0)
	return;
	
	Item@it=GetItem(itemId);
	if((@it!=null))
	{
		it.Val8=(36278);
		it.Val9=spawnerId;
	}
	else
	Log("FOArt2238_ItemSpawned - bad itemId<"+itemId+">");
	
	Critter@cr=GetCritter(spawnerId);
	if((@cr!=null)&&(@it!=null))
	cr.LastSpawnedItem=itemId;
	else
	Log("FOArt2238_ItemSpawned - bad spawnerId<"+spawnerId+">");
}  

void AddonsInit2238()
{
	Addon2238_Stub();
}

void Addon2238_Stub()
{
	FOArtAddon@stub=NewFOArtAddon((100));
	if((@stub!=null))
	{
		stub.SetPreSpawn(@Addon2238_Stub_PreSpawn);
		
		FOArtAddons.insertLast(stub);
	}
}

void Addon2238_Stub_PreSpawn(Buffer&,uint16 pid,uint16 hexX,uint16 hexY)
{}    

void AddonsInit()
{
	if(AddonsInitialized)
	return; 
	
	Addon_Flags();
	Addon_Light();
	Addon_Image();
	Addon_Lexem();
	Addon_Stack();
	
	Addon_Test(); 
	
	AddonsInit2238(); 
	
	AddonsInitialized=true;
}             

void Addon_Flags()
{
	FOArtAddon@flags=NewFOArtAddon((1));
	if((@flags!=null))
	{
		flags.SetPostSpawn(@Addon_Flags_PostSpawn);
		
		FOArtAddons.insertLast(flags);
		return;
	}
}

void Addon_Flags_PostSpawn(Buffer&buff,Item&item)
{
	if(buff.IsRaw(8))
	{
		uint32 add=0;
		uint32 remove=0;
		
		buff>>add>>remove;
		
		if(add>0)
		((item.Flags)=(item.Flags)|(add));
		
		if(remove>0)
		(item.Flags=((item.Flags)&(~(remove))));
	}
	else if(buff.IsRaw(4))
	{
		uint32 overwrite=0;
		
		buff>>overwrite;
		
		item.Flags=overwrite;
	}
	else
	Log("Addon:Flags invalid data length, ignored");
}           

void Addon_Light()
{
	FOArtAddon@light=NewFOArtAddon((2));
	if((@light!=null))
	{
		light.SetPostSpawn(@Addon_Light_PostSpawn);
		
		FOArtAddons.insertLast(light);
		return;
	}
}

void Addon_Light_PostSpawn(Buffer&buff,Item&item)
{
	uint8 flags=0;
	uint32 color=0;
	int8 intensity=0;
	uint8 radius=0;
	
	buff>>flags>>color>>intensity>>radius;
	
	item.LightFlags=flags;
	item.LightColor=color;
	item.LightIntensity=intensity;
	item.LightDistance=radius;
}            

void Addon_Image()
{
	FOArtAddon@image=NewFOArtAddon((3));
	if((@image!=null))
	{
		image.SetPostSpawn(@Addon_Image_PostSpawn);
		
		FOArtAddons.insertLast(image);
		return;
	}
}

void Addon_Image_PostSpawn(Buffer&buff,Item&item)
{
	string picMap=GetFOArtString(buff);
	string picInv=GetFOArtString(buff);
	
	if(picMap.length()>0)
	item.PicMap=GetStrHash(picMap);
	
	if(picInv.length()>0)
	item.PicInv=GetStrHash(picInv);
}         

void Addon_Lexem()
{
	FOArtAddon@lexem=NewFOArtAddon((4));
	if((@lexem!=null))
	{
		lexem.SetPostSpawn(@Addon_Lexem_PostSpawn);
		
		FOArtAddons.insertLast(lexem);
	}
}

void Addon_Lexem_PostSpawn(Buffer&buff,Item&item)
{
	string lexem=GetFOArtString(buff);
	
	if(lexem.length()>0)
	item.SetLexems(lexem);
}        

void Addon_Stack()
{
	FOArtAddon@stack=NewFOArtAddon((5));
	if((@stack!=null))
	{
		stack.SetPostSpawn(@Addon_Stack_PostSpawn);
		
		FOArtAddons.insertLast(stack);
	}
}

void Addon_Stack_PostSpawn(Buffer&buff,Item&item)
{
	uint32 count=0;
	
	buff>>count;
	
	if(count>0)
	{
		if(item.IsStackable())
		item.SetCount(count);
		else
		Log("Addon:Stack not a stackable item, pid<"+item.Proto.ProtoId+">");
	}
}         

void Addon_Offset()
{
	FOArtAddon@offset=NewFOArtAddon((6));
	if((@offset!=null))
	{
		offset.SetPostSpawn(@Addon_Offset_PostSpawn);
		
		FOArtAddons.insertLast(offset);
	}
}

void Addon_Offset_PostSpawn(Buffer&buff,Item&item)
{
	int16 offset_x=0,offset_y=0;
	
	buff>>offset_x>>offset_y;
	
	if(offset_x!=0)
	item.OffsetX=offset_x;
	
	if(offset_y!=0)
	item.OffsetY=offset_y;
}  

void Addon_Test()
{
	FOArtAddon@test=NewFOArtAddon((255));
	if((@test!=null))
	{
		test.SetPreSpawn(@Addon_Test_PreSpawn);
		test.SetPostSpawn(@Addon_Test_PostSpawn);
		
		FOArtAddons.insertLast(test);
	}
}

void Addon_Test_PreSpawn(Buffer&,uint16 pid,uint16 hexX,uint16 hexY)
{
	Log("Addon:Test pre-spawn pid<"+pid+"> hexX<"+hexX+"> hexY<"+hexY+">");
}

void Addon_Test_PostSpawn(Buffer&,Item&item)
{
	Log("Addon:Test post-spawn item <"+item.Id+">");
}                    

class FOArt_Base:FOArt
{
	uint8 version;
	uint16 map_pid;
	bool hexes_relative;
	
	array<FOArtDefinition@>definitions;
	
	FOArt_Base(uint8 version=0,uint16 map_pid=0,bool hexes_relative=false)
	{
		this.version=version;
		this.map_pid=map_pid;
		this.hexes_relative=hexes_relative;
		this.definitions.resize(0);
	}
	
	uint8 Version()
	{
		return(this.version);
	}  
	
	bool Load(array<uint8>data)
	{
		Buffer@buff=NewBuffer();
		
		for(uint d=0,dLen=data.length();d<dLen;d++)
		{
			buff<<uint8(data[d]);
		}
		-buff;
		
		uint8 version=0;
		buff>>version;
		
		if(version==0)
		{
			Log("version not defined");
			return(false);
		}
		
		{};
		
		if(version==1)
		{
			this.version=version;
			uint32 definitions_count=0;
			
			buff>>this.map_pid>>this.hexes_relative>>definitions_count;
			
			{};
			
			for(uint def=0;def<definitions_count;def++)
			{
				{};
				
				FOArtDefinition@definition=NewFOArtDefinition();
				if(!(@definition!=null))
				{
					{};
					continue;
				}
				
				{};
				definition.Load(buff);
				{};
				this.AddDefinition(definition);
			}
			
			return(true);
		}
		else
		{
			{};
		}
		return(false);
	}
	
	bool Save(Buffer&buff)
	{
		buff<<this.version;
		
		if(this.version==1)
		{
			uint32 definitions_count=definitions.length();
			
			buff<<this.map_pid<<this.hexes_relative<<definitions_count;
			
			for(uint def=0;def<definitions_count;def++)
			{
				definitions[def].Save(buff);
			}
			return(true);
		}
		return(false);
	}
	
	bool Save(array<uint8>&data)
	{
		Buffer@buff=NewBuffer();
		
		if(this.Save(buff))
		{
			-buff;
			while(buff.IsRaw(1))
			{
				uint8 char=0;
				buff>>char;
				data.insertLast(char);
			}
			return(true);
		}
		else
		{
			return(false);
		}
	}  
	
	bool AddDefinition(FOArtDefinition@definition)
	{
		if(!(@definition!=null))
		{
			Log("AddDefinition: definition not valid");
			return(false);
		}
		
		this.definitions.insertLast(@definition);
		return(true);
	}
	
	FOArtDefinition@GetDefinition(uint index)
	{
		if(index>this.definitions.length()-1)
		return(null);
		
		return(this.definitions[index]);
	}
	
	uint GetDefinitions(array<FOArtDefinition@>&output)
	{
		output=this.definitions;
		return(this.definitions.length());
	}
	
	uint GetDefinitionsCount()
	{
		return(this.definitions.length());
	}  
	
	bool Relative()
	{
		return(this.hexes_relative);
	}
	
	void Relative(bool hexes_relative)
	{
		this.hexes_relative=hexes_relative;
	}   
	
	int Spawn(Map&map,uint16 centerX,uint16 centerY)
	{
		AddonsInit(); 
		
		if(this.map_pid>0&&map.GetProtoId()!=this.map_pid)
		{
			Log("Wrong map");
			return(-1);
		}
		
		int count=0;
		for(uint def=0,defLen=this.definitions.length();def<defLen;def++)
		{
			if(!(@this.definitions[def]!=null))
			{
				Log("definitions["+def+"] not valid");
				continue;
			}
			
			{};
			int spawned=definitions[def].Spawn(map,this.hexes_relative,centerX,centerY);
			if(spawned>0)
			count+=spawned;
		}
		
		return(count);
	}
	
};

class FOArt_Definition:FOArtDefinition
{
	uint16 item_pid;
	
	uint16 get_ItemPid()
	{
		return(this.item_pid);
	}
	
	array<int16>hexes;
	
	array<FOArt_AddonData@>addon_data;
	
	FOArt_Definition(uint16 item_pid)
	{
		this.item_pid=item_pid;
		this.RemoveHexes();
	}
	
	void Load(Buffer&buff)
	{
		buff>>this.item_pid;
		
		this.LoadHexes(buff);
		this.LoadAddons(buff);
	} 
	
	void Save(Buffer&buff)
	{
		buff<<this.item_pid;
		
		this.SaveHexes(buff);
		this.SaveAddons(buff);
	}  
	
	void LoadHexes(Buffer&buff)
	{
		this.RemoveHexes();
		
		uint32 hex_count=0;
		buff>>hex_count;
		
		for(uint hex=0;hex<hex_count;hex++)
		{
			int16 hexX=0;
			int16 hexY=0;
			
			buff>>hexX>>hexY;
			if(hexX==0&&hexY==0)
			{
				Log("hex 0,0 !!!");
				break;
			}
			this.AddHex(hexX,hexY);
		}
	}
	
	void SaveHexes(Buffer&buff)
	{
		uint32 hex_count=this.hexes.length();
		uint32 hex_count_2=hex_count/2;
		
		buff<<hex_count_2;
		
		for(uint h=0;h<hex_count;h++)
		{
			buff<<int16(this.hexes[h]);
		}
	}
	
	void AddHex(int16 hex_x,int16 hex_y)
	{
		this.hexes.insertLast(hex_x);
		this.hexes.insertLast(hex_y);
	}
	
	bool GetHex(uint index,int16&hex_x,int16&hex_y)
	{
		uint wantedPosition=index*2;
		
		if(this.hexes.length()==0||this.hexes.length()<wantedPosition+2)
		return(false);
		
		hex_x=this.hexes[wantedPosition++];
		hex_y=this.hexes[wantedPosition];
		
		return(true);
	}
	
	uint GetHexes(array<int16>&hexes)
	{
		hexes=this.hexes;
		return(this.hexes.length());
	}
	
	uint GetHexesCount()
	{
		return(this.hexes.length()/2);
	}
	
	bool RemoveHex(int16 hex_x,int16 hex_y)
	{
		for(uint h=0,hLen=this.hexes.length();h<hLen;h++)
		{
			if(this.hexes[h]==hex_x&&this.hexes[h+1]==hex_y)
			{
				this.hexes.removeAt(h);
				this.hexes.removeAt(h);
				
				return(true);
			}
		}
		
		return(false);
	}
	
	void RemoveHexes()
	{
		this.hexes.resize(0);
	}  
	
	void LoadAddons(Buffer&buff)
	{
		uint8 addon_count=0;
		buff>>addon_count;
		
		for(uint addon=0;addon<addon_count;addon++)
		{
			FOArt_AddonData@new_addon_data=FOArt_AddonData(0);
			new_addon_data.Load(buff);
			this.SetAddonData(new_addon_data.id,new_addon_data.buffer);
		}
	}
	
	void SaveAddons(Buffer&buff)
	{
		uint8 addons_count=this.addon_data.length();
		buff<<addons_count;
		
		for(uint addon=0;addon<addons_count;addon++)
		{
			this.addon_data[addon].Save(buff);
		}
	}
	
	void SetAddonData(uint8 addon_id,Buffer&buff)
	{
		for(uint ad=0,adLen=this.addon_data.length();ad<adLen;ad++)
		{
			if(this.addon_data[ad].id==addon_id)
			{
				{};
				this.addon_data[ad].Copy(buff);
				return;
			}
		}
		
		{};
		FOArt_AddonData@newAddonData=FOArt_AddonData(addon_id);
		newAddonData.Copy(buff);
		this.addon_data.insertLast(@newAddonData);
	}
	
	void RemoveAddonData(uint8 addon_id)
	{
		for(uint ad=0,adLen=this.addon_data.length();ad<adLen;ad++)
		{
			if(this.addon_data[ad].id==addon_id)
			{
				{};
				this.addon_data.removeAt(ad);
				return;
			}
		}
	}   
	
	int Spawn(Map&map,bool relative,uint16 centerX,uint16 centerY)
	{
		AddonsInit(); 
		
		if(this.item_pid!=0)
		{
			ProtoItem@proto=GetProtoItem(this.item_pid);
			if(!(@proto!=null))
			{
				return(-10);
			}
		}
		
		if(this.hexes.length()%2!=0)
		{
			Log("Wrong Definition::hexes length (%2 != 0), cannot continue");
			return(-11);
		}
		
		int count=0;
		for(uint hex=0,hexLen=hexes.length();hex<hexLen;hex+=2)
		{
			uint16 hexX=this.hexes[hex];
			uint16 hexY=this.hexes[hex+1];
			
			if(relative)
			{
				hexX+=centerX;
				hexY+=centerY;
			}
			
			if(this.Spawn(map,hexX,hexY)>0)
			count++;
		}
		return(count);
	}
	
	uint Spawn(Map&map,uint16 hexX,uint16 hexY)
	{
		AddonsInit();
		
		if(hexX>map.GetWidth()||hexY>map.GetHeight())
		{
			Log("Hex "+hexX+","+hexY+" out of map");
			return(0);
		}
		
		for(uint ad=0,adLen=this.addon_data.length();ad<adLen;ad++)
		{
			FOArtAddon@addon=GetFOArtAddon(this.addon_data[ad].id);
			if((@addon!=null))
			{
				addon.PreSpawn(addon_data[ad].buffer,this.item_pid,hexX,hexY);
			}
		}
		
		Item@item=map.AddItem(hexX,hexY,this.item_pid,1);
		if(!(@item!=null))
		{
			Log("Item not spawned");
			return(0);
		}
		
		for(uint ad=0,adLen=this.addon_data.length();ad<adLen;ad++)
		{
			FOArtAddon@addon=GetFOArtAddon(this.addon_data[ad].id);
			if((@addon!=null))
			{
				addon.PostSpawn(addon_data[ad].buffer,item);
			}
		}
		
		item.Update();
		
		return(item.Id);
	}
	
};

class FOArt_AddonData
{
	uint8 id;
	Buffer@buffer;
	
	FOArt_AddonData(uint8 id)
	{
		this.id=id;
		@this.buffer=NewBuffer();
	}
	
	void Load(Buffer&buff)
	{
		{};
		
		uint32 addon_data_length=0;
		
		~this.buffer;
		
		buff>>this.id;
		{};
		
		buff>>addon_data_length;
		{}; 
		
		for(uint d=0;d<addon_data_length;d++)
		{
			uint8 tmp=0;
			buff>>tmp;
			this.buffer<<tmp;
		}
		
		-this.buffer;
	}
	
	void Save(Buffer&buff)
	{
		array<uint8>addon_data;
		
		this.buffer>>>=addon_data;
		
		buff<<this.id;
		buff<<uint32(addon_data.length()); 
		
		for(uint d=0,dLen=addon_data.length();d<dLen;d++)
		{
			buff<<uint8(addon_data[d]);
		}
	}
	
	void Copy(Buffer&buff)
	{
		array<uint8>addon_data;
		
		~this.buffer;
		
		buff>>>=addon_data;
		
		for(uint d=0,dLen=addon_data.length();d<dLen;d++)
		{
			this.buffer<<uint8(addon_data[d]);
		}
		
		-this.buffer;
	}
}; 

FOArt@NewFOArt(uint8 version,uint16 map_pid=0,bool hexes_relative=false)
{
	return(@FOArt_Base(version,map_pid,hexes_relative));
} 

FOArtDefinition@NewFOArtDefinition(uint16 pid=0)
{
	return(@FOArt_Definition(pid));
} 

FOArt@LoadFOArtFile(string&filename)
{
	if(filename.length()<6)
	return(null);
	
	else if(substring(filename,filename.length()-6,filename.length())!=".foart")
	{
		Log(filename+": invalid");
		return(null);
	}
	file artFile;
	
	if(artFile.open(filename,"r")>=0)
	{
		{};
		array<uint8>data;
		
		uint count=artFile.readData(0,data);
		artFile.close();
		
		if(count<FOART_SIGNATURE.length())
		{
			Log(filename+": file corrupted");
			return(null);
		}
		
		for(uint sig=0,sigLen=FOART_SIGNATURE.length();sig<sigLen;sig++)
		{
			if(data[sig]!=FOART_SIGNATURE[sig])
			{
				Log(filename+": wrong signature ["+sig+"]");
				return(null);
			}
		}
		
		for(uint sig=0,sigLen=FOART_SIGNATURE.length();sig<sigLen;sig++)
		data.removeFirst();
		
		FOArt@art=NewFOArt(0);
		if(art.Load(data))
		return(art);
		else
		Log(filename+": not loaded");
	}
	else
	{
		Log(filename+": can't open");
	}
	return(null);
} 

bool SaveFOArtFile(FOArt&art,string&filename)
{
	file artFile;
	if(artFile.open(filename,"w")>=0)
	{
		array<uint8>data;
		for(uint sig=0,sigLen=FOART_SIGNATURE.length();sig<sigLen;sig++)
		{
			data.insertLast(FOART_SIGNATURE[sig]);
		}
		art.Save(data);
		artFile.writeData(data,0);
		artFile.close();
		return(true);
	}
	return(false);
}                                                                                                                                                                                                                                                                               

class FOArt_Running
{
	FOArt@foart;
	uint mapId;
	
	int16 centerX;
	int16 centerY;
	uint hexIndex;
	
	uint ownerId;
	
	uint definitionIndex;
	
	uint started;
	bool finished;
	
	FOArt_Running(FOArt&foart,uint mapId,int16 centerX,int16 centerY,uint ownerId)
	{
		@this.foart=foart;
		this.mapId=mapId;
		this.centerX=centerX;
		this.centerY=centerY;
		this.hexIndex=0;
		this.definitionIndex=0;
		
		this.ownerId=ownerId;
		this.finished=false;
		this.started=__FullSecond;
	}
	
	void Process()
	{
		if(!(@this.foart!=null))
		{
			Log("ERROR !!! FOArt invalid, finishing");
			this.finished=true;
			return;
		}
		
		Map@map=GetMap(this.mapId);
		if(!(@map!=null))
		{
			Log("FOArt: invalid map<"+mapId+">, finishing");
			this.finished=true;
			return;
		}
		
		FOArtDefinition@definition=this.foart.GetDefinition(this.definitionIndex);
		if(!(@definition!=null))
		{
			Log("FOArt: invalid definition index<"+this.definitionIndex+">, finishing");
			this.finished=true;
			return;
		}
		
		int16 hexX=0;
		int16 hexY=0;
		
		if(!definition.GetHex(this.hexIndex,hexX,hexY))
		{
			Log("FOArt: invalid hex index<"+this.hexIndex+">, finishing");
			this.finished=true;
			return;
		}
		
		if(this.foart.Relative())
		{
			hexX+=this.centerX;
			hexY+=this.centerY;
		}
		
		int itemId=definition.Spawn(map,hexX,hexY);
		
		FOArt2238_ItemSpawned(itemId,this.ownerId); 
		
		if(++this.hexIndex==definition.GetHexesCount())
		{
			{};
			hexIndex=0;
			
			if(++this.definitionIndex==this.foart.GetDefinitionsCount())
			{
				{};
				this.finished=true;
			}
		}
	}
};
array<FOArt_Running@>FOArtRunning;

uint FOART_TimeEvent=0;

void unsafe_spawnFast(Critter&cr,int,int,int,string@filename,array<int32>@data)
{
	
	if(cr.GetAccess()<(1))
	{
		Log("FOArt::unsafe_spawnFast called without access : "+cr.Name+"<"+cr.Id+">");
		return;
	} 
	
	if(!(@filename!=null))
	@filename="<unknown>";
	
	Map@map=cr.GetMap();
	if(!(@map!=null))
	{
		 { Log(cr.Name+"<"+cr.Id+"> "+filename+": Not on worldmap"); cr.Say((11),filename+": Not on worldmap"); };
		return;
	}
	
	{};
	Buffer@buff=NewBuffer(data);
	if(!(@buff!=null))
	{
		 { Log(cr.Name+"<"+cr.Id+"> "+filename+": Buffer not valid"); cr.Say((11),filename+": Buffer not valid"); };
		return;
	}
	
	{};
	FOArt@foart=NewFOArt(0);
	if(foart.Load(buff.AsUint8()))
	{
		if(foart.Version()==0)
		 { Log(cr.Name+"<"+cr.Id+"> "+filename+": Load error"); cr.Say((11),filename+": Load error"); };
		
		FOART_Spawn(foart,map,cr.HexX,cr.HexY,cr.Id);
	}
	else
	 { Log(cr.Name+"<"+cr.Id+"> "+filename+": FOArt not loaded"); cr.Say((11),filename+": FOArt not loaded"); };
}

void unsafe_spawnSlow(Critter&cr,int,int,int,string@filename,array<int32>@data)
{
	
	if(cr.GetAccess()<(1))
	{
		Log("FOArt::unsafe_spawnSlow called without access : "+cr.Name+"<"+cr.Id+">");
		return;
	} 
	
	if(!(@filename!=null))
	@filename="<unknown>";
	
	Map@map=cr.GetMap();
	if(!(@map!=null))
	{
		 { Log(cr.Name+"<"+cr.Id+"> "+filename+": Not on worldmap"); cr.Say((11),filename+": Not on worldmap"); };
		return;
	}
	
	{};
	Buffer@buff=NewBuffer(data);
	if(!(@buff!=null))
	{
		 { Log(cr.Name+"<"+cr.Id+"> "+filename+": Buffer not valid"); cr.Say((11),filename+": Buffer not valid"); };
		return;
	}
	
	{};
	FOArt@foart=NewFOArt(0);
	if(foart.Load(buff.AsUint8()))
	{
		if(foart.Version()==0)
		 { Log(cr.Name+"<"+cr.Id+"> "+filename+": Load error"); cr.Say((11),filename+": Load error"); };
		
		FOART_Spawn(foart,map,cr.HexX,cr.HexY,cr.Id,true);
	}
	else
	 { Log(cr.Name+"<"+cr.Id+"> "+filename+": FOArt not loaded"); cr.Say((11),filename+": FOArt not loaded"); };
}

void FOART_Spawn(FOArt@foart,Map&map,uint16 hexX,uint16 hexY,uint ownerId,bool timeEvent=false)
{
	if(timeEvent)
	{
		timeEvent=false; 
		
		if((((100))*__TimeMultiplier/1000)==0)
		{
			Log("ERROR !! FOART_PROCESS_DELAY is too small");
			return;
		}
		
		FOArtRunning.insertLast(@FOArt_Running(foart,map.Id,hexX,hexY,ownerId));
		
		if(FOART_TimeEvent==0)
		timeEvent=true;
		else
		{
			uint duration=0;
			array<uint>values;
			if(!GetTimeEvent(FOART_TimeEvent,duration,values))
			{
				Log("WARNING ! FOArt time event not found, but its id is still set");
				timeEvent=true;
			}
			else
			SetTimeEvent(FOART_TimeEvent,duration,values);
		}
		
		if(timeEvent)
		{
			FOART_TimeEvent=CreateTimeEvent(__FullSecond+(((100))*__TimeMultiplier/1000),"foart"+"@e_FOART_Process",false);
			{};
		}
	}
	else
	{
		int result=foart.Spawn(map,hexX,hexY);
		
		if(result<0)
		Log("FOArt: Spawn error "+result);
		else
		Log("FOArt: spawned "+result+" item"+(result==1?"":"s"));
	}
}

uint e_FOART_Process(array<uint>@)
{
	if(FOArtRunning.length()==0)
	{
		{};
		FOART_TimeEvent=0;
		return(0);
	}
	
	for(uint current=0,max=FOArtRunning.length();current<max;current++)
	{
		FOArtRunning[current].Process();
		
		if(FOArtRunning[current].finished)
		{
			FOArtRunning.removeAt(current);
			break;
		}
	}
	
	return((((100))*__TimeMultiplier/1000));
}   

