                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               

int week_patch=1;
int doubleloot=1;
bool dropchance(float chance)
{
	if(chance==0)
	return false;
	if(Random(0,100)<chance)
	return true;
	
	return false;
	
}

bool can_tc_modoc=false;
bool can_tc_klamath=false;
bool can_tc_gecko=false;
bool can_tc_bh=false;
bool can_tc_redding=false;
bool can_tc_den=false;
bool can_tc_necro=false;
bool can_tc_reno=false;

uint when_tc_modoc=0;
uint when_tc_klamath=0;
uint when_tc_gecko=0;
uint when_tc_bh=0;
uint when_tc_redding=0;
uint when_tc_den=0;
uint when_tc_necro=0;
uint when_tc_reno=0;                                

import void WLog(string&type,string&message)from"debug";
import void WLog(string&type,string&message,int level)from"debug";
import void InitDebug()from"debug";                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

shared class Entire
{
	int Number;
	uint16 HexX;
	uint16 HexY;
	uint8 Direction;
};

uint ParseEntires(Map&map,array<Entire>&entires,int number)
{
	uint oldCount=entires.length();
	uint count=map.CountEntire(number);
	entires.resize(oldCount+count);
	
	for(uint i=0;i<count;i++)
	{
		Entire@ent=entires[oldCount+i];
		if(map.GetEntireCoords(number,i,ent.HexX,ent.HexY,ent.Direction)==false)
		return 0;
		ent.Number=number;
	}
	
	return count;
}

bool IsEntireFree(uint mappid,int number)
{
	Map@map=GetMapByPid(mappid,0);
	return IsEntireFree(map,number);
}

bool IsEntireFree(Map&map,int number)
{
	uint16 x,y;
	x=0;
	y=0;
	return GetEntireFreeHex(map,number,x,y);
}

bool GetEntireFreeHex(Map&map,int number,uint16&hx,uint16&hy,uint skip=0)
{
	uint count=map.CountEntire(number); 
	
	for(uint i=skip;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy)&&map.IsHexPassed(hx,hy))
		return true;
	}
	
	if(hx==0||hy==0||hx>=map.GetWidth()-1||hy>=map.GetHeight()-1)
	return false; 
	
	for(uint i=0;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy))
		{
			for(int x=-1;x<=1;x++)
			{
				for(int y=-1;y<=1;y++)
				{
					if(x==0&&y==0)
					continue;
					if(__MapHexagonal)
					{
						if((hx%2)==1&&((x==-1&&y==1)||(x==1&&y==1)))
						continue;
						if((hx%2)==0&&((x==-1&&y==-1)||(x==1&&y==-1)))
						continue;
					}
					
					if(map.IsHexPassed(hx+x,hy+y))
					{
						hx+=x;
						hy+=y;
						return true;
					}
				}
			}
		}
	}
	return false;
}

bool GetNearEntire(Map&map,int number,uint16&hx,uint16&hy)
{
	uint16 hxBase=hx;
	uint16 hyBase=hy;
	
	array<Entire>entires;
	uint count=ParseEntires(map,entires,number);
	if(count==0)
	return false;
	
	hx=entires[0].HexX;
	hy=entires[0].HexY;
	for(uint i=1;i<count;i++)
	{
		Entire@ent=entires[i];
		if(GetDistantion(hxBase,hyBase,ent.HexX,ent.HexY)<GetDistantion(hxBase,hyBase,hx,hy))
		{
			hx=ent.HexX;
			hy=ent.HexY;
		}
	}
	
	return true;
}                                                                                    

shared class Serializator
{
	Serializator()
	{
		CurPos=0;
		BufSize=0;
		DataSize=0;
	}
	
	Serializator(uint approxSize)
	{
		CurPos=0;
		BufSize=0;
		DataSize=0;
		GrowBuffer(approxSize);
	}
	
	void GrowBuffer()
	{
		BufSize+=(128);
		Array.resize(BufSize);
	}
	
	void GrowBuffer(uint length)
	{
		BufSize+=length;
		Array.resize(BufSize);
	}
	
	bool Save(string&name)
	{
		if(DataSize==0)
		return false;
		bool result=SetAnyData(name,Array,DataSize);
		Clear();
		return result;
	}
	
	bool Load(string&name)
	{
		Clear();
		if(!IsAnyData(name))
		return false;
		if(!GetAnyData(name,Array))
		return false;
		BufSize=Array.length();
		DataSize=BufSize;
		return true;
	}
	
	void Clear()
	{
		CurPos=0;
		BufSize=0;
		DataSize=0;
	}
	
	Serializator@SetCurPos(uint pos)
	{
		if(pos>BufSize)
		GrowBuffer(pos-BufSize+(128));
		CurPos=pos;
		return this;
	}
	
	Serializator@Fill(uint8 value,uint length)
	{
		if(CurPos+length>BufSize)
		GrowBuffer(CurPos+length-BufSize+(128));
		for(uint i=0;i<length;i++)
		Array[CurPos++]=value;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@Set(const int64&value)
	{
		if(CurPos+8>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>56)&0xFF;
		Array[CurPos++]=(value>>48)&0xFF;
		Array[CurPos++]=(value>>40)&0xFF;
		Array[CurPos++]=(value>>32)&0xFF;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const int64&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const int32&value)
	{
		if(CurPos+4>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const int32&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const int16&value)
	{
		if(CurPos+2>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const int16&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const int8&value)
	{
		if(CurPos+1>BufSize)
		GrowBuffer();
		Array[CurPos++]=value;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const int8&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const uint64&value)
	{
		if(CurPos+8>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>56)&0xFF;
		Array[CurPos++]=(value>>48)&0xFF;
		Array[CurPos++]=(value>>40)&0xFF;
		Array[CurPos++]=(value>>32)&0xFF;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const uint64&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const uint32&value)
	{
		if(CurPos+4>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const uint32&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const uint16&value)
	{
		if(CurPos+2>BufSize)
		GrowBuffer();
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const uint16&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const uint8&value)
	{
		if(CurPos+1>BufSize)
		GrowBuffer();
		Array[CurPos++]=value;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const uint8&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const bool&value)
	{
		if(CurPos+1>BufSize)
		GrowBuffer();
		Array[CurPos++]=value?1:0;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const bool&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const string&value)
	{
		uint len=value.rawLength();
		if(CurPos+len+1>BufSize)
		GrowBuffer(CurPos+len+1-BufSize+(128));
		for(uint i=0;i<len;i++)
		Array[CurPos++]=value.rawGet(i);
		Array[CurPos++]=0;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const string&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const float&value)
	{
		int dummy=FloatToInt(value);
		return Set(dummy);
	}
	
	Serializator@opShl(const float&value)
	{
		return Set(value);
	}
	
	Serializator@Set(const array<int64>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*8;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<int64>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<int32>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*4;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<int32>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<int16>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*2;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<int16>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<int8>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<int8>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<uint64>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*8;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<uint64>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<uint32>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*4;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<uint32>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<uint16>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*2;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<uint16>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<uint8>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<uint8>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<bool>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<bool>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<string>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		for(uint i=0,j=valuesLen;i<j;i++)
		len+=values[i].length();
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<string>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const array<float>&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*4;
		if(CurPos+len>BufSize)
		GrowBuffer(CurPos+len-BufSize);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(FloatToInt(values[i]));
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const array<float>&values)
	{
		return Set(values);
	}
	
	Serializator@Set(const Critter&cr)
	{
		if(CurPos+4>BufSize)
		GrowBuffer();
		uint value=cr.Id;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const Critter&cr)
	{
		return Set(cr);
	}
	
	Serializator@Set(const Item&item)
	{
		if(CurPos+4>BufSize)
		GrowBuffer();
		uint value=item.Id;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator@opShl(const Item&item)
	{
		return Set(item);
	}
	
	Serializator@Get(int64&value)
	{
		value=0;
		if(CurPos+8>DataSize)
		return this;
		value|=Array[CurPos++]<<56;
		value|=Array[CurPos++]<<48;
		value|=Array[CurPos++]<<40;
		value|=Array[CurPos++]<<32;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(int64&value)
	{
		return Get(value);
	}
	
	Serializator@Get(int32&value)
	{
		value=0;
		if(CurPos+4>DataSize)
		return this;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(int32&value)
	{
		return Get(value);
	}
	
	Serializator@Get(int16&value)
	{
		value=0;
		if(CurPos+2>DataSize)
		return this;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(int16&value)
	{
		return Get(value);
	}
	
	Serializator@Get(int8&value)
	{
		value=0;
		if(CurPos+1>DataSize)
		return this;
		value=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(int8&value)
	{
		return Get(value);
	}
	
	Serializator@Get(uint64&value)
	{
		value=0;
		if(CurPos+8>DataSize)
		return this;
		value|=Array[CurPos++]<<56;
		value|=Array[CurPos++]<<48;
		value|=Array[CurPos++]<<40;
		value|=Array[CurPos++]<<32;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(uint64&value)
	{
		return Get(value);
	}
	
	Serializator@Get(uint32&value)
	{
		value=0;
		if(CurPos+4>DataSize)
		return this;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(uint32&value)
	{
		return Get(value);
	}
	
	Serializator@Get(uint16&value)
	{
		value=0;
		if(CurPos+2>DataSize)
		return this;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(uint16&value)
	{
		return Get(value);
	}
	
	Serializator@Get(uint8&value)
	{
		value=0;
		if(CurPos+1>DataSize)
		return this;
		value=Array[CurPos++];
		return this;
	}
	
	Serializator@opShr(uint8&value)
	{
		return Get(value);
	}
	
	Serializator@Get(bool&value)
	{
		value=false;
		if(CurPos+1>DataSize)
		return this;
		value=Array[CurPos++]==1?true:false;
		return this;
	}
	
	Serializator@opShr(bool&value)
	{
		return Get(value);
	}
	
	Serializator@Get(string&str)
	{
		uint len=0;
		for(uint i=CurPos;;i++)
		{
			if(i==DataSize)
			{
				str="";
				return this;
			}
			if(Array[i]==0)
			{
				len=i-CurPos;
				break;
			}
		}
		str.rawResize(len);
		for(uint i=0;i<len;i++)
		str.rawSet(i,Array[CurPos++]);
		CurPos++;
		return this;
	}
	
	Serializator@opShr(string&str)
	{
		return Get(str);
	}
	
	Serializator@Get(float&value)
	{
		int dummy=0;
		Get(dummy);
		value=IntToFloat(dummy);
		return this;
	}
	
	Serializator@opShr(float&value)
	{
		return Get(value);
	}
	
	Serializator@Get(array<int64>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<int64>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<int32>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<int32>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<float>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		{
			int dummy=0;
			Get(dummy);
			values[i]=IntToFloat(dummy);
		}
		return this;
	}
	
	Serializator@opShr(array<float>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<int16>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<int16>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<int8>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<int8>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<uint64>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<uint64>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<uint32>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<uint32>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<uint16>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<uint16>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<uint8>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<uint8>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<bool>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<bool>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(array<string>&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator@opShr(array<string>&values)
	{
		return Get(values);
	}
	
	Serializator@Get(Critter@&cr)
	{
		@cr=null;
		if(CurPos+4>DataSize)
		return this;
		uint id=0;
		id|=Array[CurPos++]<<24;
		id|=Array[CurPos++]<<16;
		id|=Array[CurPos++]<<8;
		id|=Array[CurPos++];
		@cr=::GetCritter(id);
		return this;
	}
	
	Serializator@opShr(Critter@&cr)
	{
		return Get(cr);
	}
	
	Serializator@Get(Item@&item)
	{
		@item=null;
		if(CurPos+4>DataSize)
		return this;
		uint id=0;
		id|=Array[CurPos++]<<24;
		id|=Array[CurPos++]<<16;
		id|=Array[CurPos++]<<8;
		id|=Array[CurPos++];
		@item=::GetItem(id);
		return this;
	}
	
	Serializator@opShr(Item@&item)
	{
		return Get(item);
	}
	
	array<uint8>Array;
	uint CurPos;
	uint BufSize;
	uint DataSize;
};                                                                                                                                                                                                                                                                                                                                                                                                                      

import Location@GetLocationOf(Critter&critter)from"utils";
import string GetLocationName(uint locId)from"utils";
import string GetLocationName(Location@loc)from"utils";
import bool ReadPids(array<int>&out pids,bool removeinvalid)from"utils";
import void ReadDefines(string@fileName,dictionary&items,array<string>@defines)from"utils";
import bool ParseDefine(const string&in line,string&out spid,int&out id)from"utils";
import int SkipWhitespaces(const string&in str,int start)from"utils";
import int SkipNonWhitespaces(const string&in str,int start)from"utils";
import bool IsParameterTag(string&str)from"utils";
import string GetParameterString(array<string@>@arr,string&parameter)from"utils";
import int GetIndexOfString(array<string@>@arr,string&str)from"utils";
import string GetConcatenatedString(array<string@>@arr,uint startindex,int stopindex)from"utils";
import string GetConditionOfCritter(Critter@cr)from"utils";
import string GetExtConditionOfCritter(Critter@cr)from"utils";
import uint GetAllOnlinePlayers(array<Critter@>&out players)from"utils";
import uint GetAuthenticatedPlayers(array<Critter@>&out players)from"utils";
import uint GetAuthenticatedPlayers(array<Critter@>&out players,bool ignorePriviledges)from"utils";
import uint GetNumberOfPlayersOnline()from"utils";
import void SetTurnBasedAvailability(Location@loc)from"utils";
import bool IsGuarded(Map@map)from"utils";
import bool IsPublic(Map@map)from"utils";
import bool IsEncounterMap(Map@map)from"utils";
import bool IsTown(Map@map)from"utils";
import bool IsDungeon(Map@map)from"utils";
import bool IsBaseControl(Map@map)from"utils";

import uint GetMapType(Map@map)from"utils";
import void LockDoor(uint x,uint y,Map@map,uint complexity,uint lockid)from"utils";
import void UnlockDoor(uint x,uint y,Map@map)from"utils";
import void ClearContainer(Item@container)from"utils";
import void MoveItemsCritterToCont(Critter&crFrom,Item&contTo,uint specid)from"utils";
import string GetCritterInfo(Critter&cr)from"utils";
import bool AddExpTeam(Critter&critter,int xp)from"utils";
import void ClearEnemyStack(Critter&critter)from"utils";
import void ClearEnemyStacksOnMap(Map@map)from"utils";
import bool IsCurrentEnemy(Critter&cr,uint targetId)from"utils";
import string@GetSafePlayerName(uint id)from"utils";
import string GetSafePlayerName(uint id,string&onSuccess,string&onError)from"utils";
import IDateTime@GetCurrentDateTime()from"utils";
import string GetCurrentDateTimeString()from"utils";
import string GetCurrentDateTimeString(bool date,bool time)from"utils";
import Critter@GetMostSkilled(array<Critter@>@group,int skill)from"utils";
import string GetAuthString(Critter&player)from"utils";
import string GetAuthString(int accesslevel)from"utils";
import bool CanRequestHelp(Critter&player)from"utils";
import void SetRequestedHelp(Critter&player)from"utils";
import void SetRequestedHelp(Critter&player,int minutes)from"utils";
import Critter@GetOnlineGM()from"utils";
import void Preprocess(Critter&player,string&commandString)from"utils";
import bool IsHumanoid(Critter@cr)from"utils";
import uint GetGroupIndex(Critter&cr)from"utils";
import uint GetGroupIndex(int st)from"utils";
import void SetGroupIndex(Critter&cr,uint val)from"utils";
import uint GetGroupRank(Critter&cr)from"utils";
import void SetGroupRank(Critter&cr,uint val)from"utils";
import uint GetGroupMode(Critter&cr)from"utils";
import void SetGroupMode(Critter&cr,uint val)from"utils";
import void SetGroupInfo(Critter&cr,uint faction,uint rank,uint mode)from"utils";
import void SetGroupInfoPack(Critter&cr,uint packInfo)from"utils";
import void ClearEvents(Critter&cr)from"utils";

import int GetGvar(uint gvar)from"utils";
import void SetGvar(uint gvar,uint value)from"utils";
import int GetLLvar(Location&location,uint llvar)from"utils";
import int GetLLvar(uint locationId,uint llvar)from"utils";
import void SetLLvar(Location&location,uint llvar,uint value)from"utils";
import int GetLMvar(Map&map,uint llvar)from"utils";
import int GetLMvar(uint mapId,uint llvar)from"utils";
import void SetLMvar(Map&map,uint llvar,uint value)from"utils";
import int GetLIvar(Item&item,uint llvar)from"utils";
import int GetLIvar(uint itemId,uint llvar)from"utils";
import void SetLIvar(Item&item,uint llvar,uint value)from"utils";
import int GetLvar(Critter&critter,uint lvar)from"utils";
import int GetLvar(uint id,uint lvar)from"utils";
import void SetLvar(Critter&critter,uint lvar,uint value)from"utils";
import void SetLvar(uint id,uint lvar,uint value)from"utils";
import int GetUvar(uint uvar,uint key,uint index)from"utils";
import void SetUvar(uint uvar,uint key,uint index,uint value)from"utils";

import uint GetContainerValue(Item@container)from"utils";
import uint BaseItemValue(uint pid,bool ammo)from"utils";
import uint BaseItemValue(uint pid,uint broken,uint det,bool ammo)from"utils";
import uint BaseItemValue(Item@item)from"utils";
import uint BaseItemValue(Item@item,uint proc)from"utils";
import uint BaseSingleItemValue(Item@item)from"utils";
import uint BaseSingleItemValue(Item@item,uint proc)from"utils";

import void SetBloodType(Critter@cr)from"utils";
import string GetBloodType(Critter@cr)from"utils";
import string GetBloodRandom()from"utils";

import void LogCommandUsage(Critter&player,string&commandString)from"utils";
import void DropTimeouts(Critter&cr)from"utils";

import bool HasItem(Critter@cr,uint pid)from"utils";
import bool HasSomeWeapon(Critter@cr)from"utils";
import uint GetBestWeaponSkill(Critter@cr)from"utils";
import void GiveBag(uint bag,Critter@cr)from"utils";
import void SetQuestGarbager(uint time,uint playerid,uint locid,uint var,uint val)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,uint factionRank,uint factionMode,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,array<int>params,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,bool isMob,uint level)from"utils";
import Critter@AddNpc(Map@map,uint16 pid,uint16 x,uint16 y,uint8 dir,array<int>params,uint dialogId,string&script,uint aiPack,uint bagId,uint teamId,uint factionRank,uint factionMode,bool isMob,uint level)from"utils";
import void AddScore(Critter@cr,uint score,uint points)from"utils";

import bool ReloadWeapon(Critter&cr)from"utils";
import Item@GetRadio(Critter&cr)from"utils";
import Item@GetRepairTool(Critter&cr)from"utils";
import Item@GetEquippedItem(Critter&cr,uint Pid)from"utils";
import Item@GetEquippedItem(Critter&cr,array<uint>&Pids)from"utils";
import Item@GetEquippedItemByType(Critter&cr,uint ItemType)from"utils"; 

import bool SkillRoll(Critter@cr,int skill,int bonus)from"utils";
import int SkillCheck(Critter&cr,int skill,int skillused,Item@item,int bonus)from"utils";
import string SkillName(uint8 skill)from"utils";
import void ChangeCrTypeSafe(Critter&cr,uint8 crType)from"utils";

import bool Pickable(Item@item)from"utils";

import void TransferItemsToContOnMap(Critter&cr,Map@map,int entid,int contpid,int itemtypes)from"utils";
import void TransferItemsFromContOnMap(Critter&cr,Map@map,int entid,int contpid)from"utils";

import string IpToString(uint ip)from"utils";

import void VerboseAction(Critter&cr,string&text)from"utils";
import void VerboseAction(Critter&cr,Critter&target,string&text)from"utils";
import void VerboseExperience(Critter&cr,int xpDiff,int levelDiff)from"utils";

import void SetChosenActions(Critter&cr,array<int>&actions)from"utils";

import void HexLine(uint16 x0,uint16 y0,uint16 x1,uint16 y1,array<uint16>@xList,array<uint16>@yList)from"utils";
import void HexCircle(uint16 x0,uint16 y0,uint16 radius,array<uint16>@xList,array<uint16>@yList)from"utils";

import void StartPersonalDataCleanup()from"utils";

import bool IsPersonalData(Location&location,string&name)from"utils";
import bool GetPersonalData(Location&location,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Location&location,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Location&location,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Location&location,string&name)from"utils";

import bool IsPersonalData(Map&map,string&name)from"utils";
import bool GetPersonalData(Map&map,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Map&map,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Map&map,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Map&map,string&name)from"utils";

import bool IsPersonalData(Critter&critter,string&name)from"utils";
import bool GetPersonalData(Critter&critter,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Critter&critter,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Critter&critter,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Critter&critter,string&name)from"utils";

import bool IsPersonalData(Item&item,string&name)from"utils";
import bool GetPersonalData(Item&item,string&name,array<uint8>&value)from"utils";
import uint GetPersonalData(Item&item,array<string>&names,array<array<uint8>>&values)from"utils";
import bool SetPersonalData(Item&item,string&name,array<uint8>&value)from"utils";
import bool UnsetPersonalData(Item&item,string&name)from"utils";

import bool FindPreferredGridApprox(Map&map,uint16&hx,uint16&hy)from"utils";           

import bool StrToInt(string@s,uint64&inout val)from"strtoint";
import bool StrToInt(string@s,uint&inout val)from"strtoint";
import bool StrToInt(string@s,uint16&inout val)from"strtoint";
import bool StrToInt(string@s,uint8&inout val)from"strtoint";
import bool StrToInt(string@s,int64&inout val)from"strtoint";
import bool StrToInt(string@s,int16&inout val)from"strtoint";
import bool StrToInt(string@s,int8&inout val)from"strtoint";    

import int FindInArray(array<int>&arr,int value)from"utils";
import int FindInArray(array<uint>&arr,uint value)from"utils";
import int FindInArray(array<uint16>&arr,uint16 value)from"utils";
import int FindInArray(array<uint8>&arr,uint8 value)from"utils";
import bool FindInArray(array<int>&arr,int id,int&index)from"utils";
import bool FindInArray(array<uint>&arr,uint id,int&index)from"utils";
import bool FindInArray(array<uint8>&arr,uint8 id,int&index)from"utils";
import int FindInArray(array<string>&arr,string&value)from"utils";
import int FindInArray(array<string@>@arr,string&value)from"utils";
import bool Present(int what,array<int>&where)from"utils";
import bool Present(uint what,array<uint>&where)from"utils";
import bool Present(uint16 what,array<uint16>&where)from"utils";
import bool Present(string&what,array<string>&where)from"utils";
import bool Present(string&what,array<string@>@where)from"utils";

import uint CreateLocationForGroup(Critter&player,uint16 pid,uint16 worldX,uint16 worldY,array<Critter@>&)from"utils";
import bool FindFirstFreeHex(Map@map,uint16&x,uint16&y,uint8 dir,uint16 maxSteps)from"utils";
import bool FindNearestFreeHex(Map&map,uint16&x,uint16&y,uint radius)from"utils";

import bool GetItemCoordinates(Item&item,uint&mapID,uint16&x,uint16&y)from"utils";
import bool ItemOnHex(uint16 pid,Map@map,uint16 x,uint16 y)from"utils";

import void PrintCallstack()from"utils";
import void PrintCallstack(int level)from"utils";

import bool LocationHasCritters(Location&loc,uint findType)from"utils";
import uint LocationGetCritters(Location&loc,uint findType,array<Critter@>@critters)from"utils";
import uint LocationGetPlayersAndFollowers(Location&loc,uint findType,array<Critter@>@critters)from"utils";
import uint MapGetPlayersAndFollowers(Map&map,uint findType,array<Critter@>@critters)from"utils";
import uint CritterGetPlayersAndFollowers(Critter&critter,bool lookOnMe,uint findType,array<Critter@>@critters)from"utils";
import bool LocationHasItems(Location&loc,uint16 protoId)from"utils";
import uint LocationGetItems(Location&loc,uint16 protoId,array<Item@>@items)from"utils";
import void LocationDeleteItems(Location&loc,uint16 protoId)from"utils";

import bool IsDisposableEncounter(Location@loc)from"utils";

import bool IsT4Item(Item&item)from"utils";
import bool IsT3Item(Item&item)from"utils";
import uint16 AddT3Item()from"utils";
import uint16 AddT4Item()from"utils";
import uint16 AddImplant()from"utils";
import uint16 AddT4BP()from"utils";
import uint16 AddRareAmmo()from"utils";
import uint16 AddTypicalAmmo()from"utils";

import void SetDeterioration(Item&item)from"utils";  

shared class CPosition
{
	uint x;
	uint y;
	uint dir;
};

shared interface IRect
{
	bool IsWithin(Critter&cr);
};

shared class Rect:IRect
{
	uint x1;
	uint y1;
	uint x2;
	uint y2;
	
	Rect(uint x1,uint y1,uint x2,uint y2)
	{
		this.x1=x1;
		this.y1=y1;
		this.x2=x2;
		this.y2=y2;
	}
	
	bool IsWithin(Critter&cr)
	{
		return((cr.HexX>=this.x1&&cr.HexX<=this.x2)&&(cr.HexY>=this.y1&&cr.HexY<=this.y2));
	}
};

shared interface IDateTime
{
	uint16 get_Year();
	uint16 get_Month();
	uint16 get_DayOfWeek();
	uint16 get_Day();
	uint16 get_Hour();
	uint16 get_Minute();
	uint16 get_Second();
	uint16 get_Milliseconds();
	string@ToString();
};                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

import bool AddMiscPlane(Critter&npc,uint priority,uint waitMinute,string@funcName)from"npc_planes";
import bool AddMiscPlane(Critter&npc,uint priority,int identifier,uint identifierExt,uint waitSecond,string@funcName)from"npc_planes";
import bool AddWalkPlane(Critter&npc,uint priority,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)from"npc_planes";
import bool AddWalkPlane(Critter&npc,uint priority,int identifier,uint identifierExt,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)from"npc_planes";
import bool AddAttackPlane(Critter&npc,uint priority,Critter&target)from"npc_planes";
import bool AddAttackPlane(Critter&npc,uint priority,uint critId)from"npc_planes";
import bool AddAttackPlane(Critter&npc,uint priority,Critter&target,int minHp)from"npc_planes";
import bool AddAttackPlane(Critter&npc,uint priority,uint critId,int minHp)from"npc_planes";
import bool AddAttackPlane(Critter&npc,uint priority,Critter&target,bool run)from"npc_planes";
import bool AddPickPlane(Critter&npc,uint priority,uint16 hexX,uint16 hexY,uint16 protoId,uint useItemId,bool toOpen)from"npc_planes";
import bool AddPickPlane(Critter&npc,uint priority,Item@item,uint useItemId,bool toOpen)from"npc_planes";
import bool AddPickPlane(Critter&npc,uint priority,Item@item,uint useItemId,bool toOpen,bool run)from"npc_planes";
import bool AddHealCritterPlane(Critter&npc,uint priority,Critter@target,bool run)from"npc_planes";
import bool AddDoctorCritterPlane(Critter&npc,uint priority,Critter@target,bool run)from"npc_planes";

import uint EraseAttackPlane(Critter&npc,uint priority,Critter&target)from"npc_planes";
import uint EraseAttackPlane(Critter&npc,uint priority,uint critId)from"npc_planes";                                       

import bool LockerOpen(Item&item)from"lockers";
import bool LockerClose(Item&item)from"lockers";
import void InjectValue(uint,uint,uint,uint)from"worldmap";                   

class CRoom
{
	uint ownerNpcId;
	
	uint playerId;
	
	int roomnumber;
	
	CHotel@hotel;  
	
	array<uint>locks;
	
	CRoom(Critter@ownerNpc,uint playerId,CHotel@hotel,int roomnumber)
	{
		this.ownerNpcId=ownerNpc.Id;
		this.playerId=playerId;
		@this.hotel=hotel;
		this.roomnumber=roomnumber;
	}   
	
	bool IsFree()
	{
		if(locks.length()==0)
		return false; 
		
		return playerId==0;
	}  
	
	uint GetLockId()
	{
		if(locks.length()==0)
		{
			Log("ERR: empty room <"+roomnumber+"> at hotel <Hotel_"+hotel.GetId()+">");
			return 0;
		}
		Item@lock=GetItem(locks[0]);
		if(!(@lock!=null))
		{
			Log("ERR: lock removed, (hotel, roomnumber): ("+hotel.GetId()+", "+roomnumber+")");
			return 0;
		}
		return lock.LockerId;
	}  
	
	int GetRoomNumber()
	{
		return roomnumber;
	}   
	
	uint GetHotelId()
	{
		return hotel.GetId();
	}  
	
	uint GetPlayerId()
	{
		return playerId;
	}  
	
	bool IsOwner(uint Id)
	{
		if(locks.length()==0)
		return false;
		
		return playerId==Id;
	}  
	
	void AddLock(Item@item)
	{
		WLog("rooms","Adding lock: "+item.Id);
		locks.insertLast(item.Id);
	}  
	
	Item@GetDoor()
	{
		for(uint i=0,j=locks.length();i<j;i++)
		{
			Item@lock=GetItem(locks[i]);
			if(lock.GetType()==(9))
			return lock;
		}
		return null;
	}
	Item@GetContainer()
	{
		for(uint i=0,j=locks.length();i<j;i++)
		{
			Item@lock=GetItem(locks[i]);
			if(lock.GetType()==(8))
			return lock;
		}
		return null;
	}  
	
	void Rent(Critter&npc,Critter&player,uint price,uint days)
	{
		{};
		playerId=player.Id;
		GameVar@var=GetLocalVar((3002),player.Id);
		var=hotel.GetId();
		@var=GetLocalVar((3003),player.Id);
		var=0;
		@var=GetLocalVar((3004),player.Id);
		var=days;    
		
		hotel.SaveData();
		uint expirationDate=((__FullSecond)+(((days)*__TimeMultiplier*86400))); 
		
		Item@lock=GetItem(locks[0]);
		uint[]values={player.Id,npc.Id,lock.LockerId};
		@var=GetLocalVar((3007),player.Id);
		var=CreateTimeEvent(expirationDate,"e_RoomExpire",values,true);
	}  
	
	void Expire(bool forced)
	{
		WLog("rooms","Expiring room");
		GameVar@var=GetLocalVar((3002),playerId);
		var=0;
		@var=GetLocalVar((3003),playerId);
		var=0;
		@var=GetLocalVar((3004),playerId);
		var=0;
		if(forced)
		{
			@var=GetLocalVar((3007),playerId);
			if(var!=0)
			EraseTimeEvent(var.GetValue());
		}
		playerId=0;
		
		Map@map;
		for(uint i=0;i<locks.length();i++)
		{
			@map=null;
			uint16 dummy;
			Item@lock=GetItem(locks[i]);
			if(!lock.IsNotValid)
			@map=lock.GetMapPosition(dummy,dummy);
			if(!(@map!=null))
			continue;             
			
		}
		hotel.SaveData();
	}
};   

uint e_RoomExpire(array<uint>@values)
{
	uint playerId=values[0];
	GameVar@var=GetLocalVar((3002),playerId);
	if(var.GetValue()==0)
	return 0;
	WLog("rooms","Rent period for "+GetSafePlayerName(playerId));
	
	@var=GetLocalVar((3003),playerId);
	if(var.GetValue()>0)
	{
		
		var=0;
		@var=GetLocalVar((3004),playerId);
		WLog("rooms","Rent had been paid, delaying for "+((var.GetValue())*__TimeMultiplier*86400));
		
		return((var.GetValue())*__TimeMultiplier*86400);
	}
	WLog("rooms","Rent over");
	uint npcId=values[1]; 
	
	Critter@cr=GetCritter(npcId);
	if(!(@cr!=null))
	return((10)*60);
	
	CHotel@hotel=GetHotel(cr);
	if(!(@hotel!=null))
	{
		Log("ERR: npc hasn't got hotel assigned");
		return 0;
	}
	CRoom@room;
	uint lockerId=values[2];
	for(uint i=0;i<hotel.rooms.length();i++)
	{
		if(!(@hotel.rooms[i]!=null))
		continue;
		
		if(hotel.rooms[i].GetLockId()==lockerId)
		{
			@room=hotel.rooms[i];
			room.Expire(false);
			return 0;
		}
	}
	Log("ERR: Room not found");
	return 0;
}   

class CHotel
{
	
	uint ownerId;
	
	array<CRoom@>rooms;
	
	array<uint>locks;
	
	uint Price;
	
	uint RentTime;
	
	CHotel(Critter&npc,array<uint>&locks,uint price,uint rentTime)
	{
		this.ownerId=npc.Id;
		this.locks=locks;
		this.Price=price;
		this.RentTime=rentTime;
	}  
	
	void Set(Critter&npc,array<uint>&locks,uint price,uint rentTime)
	{
		this.ownerId=npc.Id;
		this.locks=locks;
		this.Price=price;
		this.RentTime=rentTime;
		rooms.resize(0);
	}  
	
	uint GetId()
	{
		Critter@owner=GetCritter(ownerId);
		return owner.Param[(89)];
	}   
	
	void SaveData()
	{
		Serializator serializer;
		for(uint i=0,j=rooms.length();i<j;i++)
		{
			
			serializer.Set(rooms[i].GetPlayerId());
		}
		serializer.Save("Hotel_"+GetId());
	}   
	
	void InitRooms(Map@map)
	{
		WLog("rooms","#################################");
		WLog("rooms","Initializing hotel rooms: "+locks.length()+" from "+Locks.length()+"locks");
		
		Serializator serializer;
		serializer.Load("Hotel_"+GetId());
		
		Critter@owner=GetCritter(ownerId);
		for(uint i=0,iend=locks.length();i<iend;i++)
		{
			
			uint renting=0;
			serializer.Get(renting);
			CRoom@room=@CRoom(owner,renting,this,locks[i]);
			Map@lockMap;
			for(uint j=0,jend=Locks.length();j<jend;j++)
			{
				Item@Lock=GetItem(Locks[j]);
				if(!(@Lock!=null))
				continue;
				@lockMap=null;
				uint16 dummy;
				if(!Lock.IsNotValid)
				@lockMap=Lock.GetMapPosition(dummy,dummy);
				if(!(@lockMap!=null))
				continue;   
				
				if(Lock.LockerId==locks[i]&&lockMap.Id==map.Id)
				{
					WLog("rooms","!!!! "+map.Id); 
					
					if(i==0&&rooms.length()>0)
					WLog("rooms","!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
					room.AddLock(Lock);
					(Lock.Val3)=GetId();
					(Lock.Val4)=rooms.length(); 
					
				}
			}
			if(room.locks.length()==0)
			Log("ERR: no locks assigned for room <"+locks[i]+"> at hotel <Hotel_"+GetId()+">.");
			rooms.insertLast(room);
		}
		WLog("rooms","#######################################");
	}   
	
	CRoom@GetFreeRoom()
	{
		WLog("rooms","Getting free room, from: "+rooms.length());   
		
		for(uint i=0;i<rooms.length();i++)
		{
			if(rooms[i].IsFree())
			{
				WLog("rooms","Free room found");
				return rooms[i];
			}
		}
		WLog("rooms","No free room found.");
		return null;
	}
	
	void Print()
	{
		WLog("rooms","------------");
		for(uint i=0;i<rooms.length();i++)
		{
			Item@lock=GetItem(rooms[i].locks[0]);
			WLog("rooms","Room "+i+": "+lock.Id);
		}
		WLog("rooms","------------");
	}
};

array<CHotel@>Hotels;   

void AddHotel(Critter&npc,array<uint>&locks,uint price,uint rentTime)
{
	WLog("rooms","Adding hotel...");
	
	CHotel@hotel=GetHotel(npc);
	if((@hotel!=null))
	{
		WLog("rooms","Hotel found already, substitute...");
		hotel.Set(npc,locks,price,rentTime);
	}
	else
	{
		
		WLog("rooms","Creating new hotel object.");
		Hotels.insertLast(@CHotel(npc,locks,price,rentTime));
	}
	
}
void InitHotel(Critter@npc)
{
	CHotel@hotel=GetHotel(npc);
	if(!(@hotel!=null))
	{
		Log("ERR: Couldn't obtain hotel to initialize.");
	}
	hotel.InitRooms(npc.GetMap());
}   

CHotel@GetHotel(uint id)
{
	if(!(@Hotels!=null))
	return null;
	
	for(uint i=0;i<Hotels.length();i++)
	{
		if(!(@Hotels[i]!=null))
		{
			WLog("rooms","Hotel "+i+" is invalid",10);
			continue;
		}
		
		if(Hotels[i].GetId()==id)
		{
			return Hotels[i];
		}
	}
	return null;
}  

CHotel@GetHotel(Critter@npc)
{
	for(uint i=0;i<Hotels.length();i++)
	{
		if(Hotels[i].GetId()==uint(npc.Param[(89)]))
		{
			
			return Hotels[i];
		}
	}
	return null;
}

Map@GetRoomPosition(uint PlayerId,uint16&out hx,uint16&out hy)
{
	CRoom@room=GetRentedRoom(PlayerId);
	if(!(@room!=null))
	return null;
	Item@cont=room.GetDoor();
	return cont.GetMapPosition(hx,hy);
}   

bool d_IsFreeRoom(Critter&player,Critter@npc,int val)
{
	CHotel@hotel=GetHotel(npc);
	
	return(@hotel.GetFreeRoom()!=null);
}  

bool d_NoFreeRooms(Critter&player,Critter@npc,int val)
{
	CHotel@hotel=GetHotel(npc);
	
	return((@hotel.GetFreeRoom()!=null))?false:true;
}   

CRoom@GetRentedRoom(uint PlayerId)
{
	GameVar@var=GetLocalVar((3002),PlayerId);
	
	if(var.GetValue()==0)
	
	return null;
	
	CHotel@hotel=GetHotel(var.GetValue());
	if(!(@hotel!=null))
	{
		Log("ERR: LVAR_renting_id points invalid hotel.");
		return null;
	}
	for(uint i=0;i<hotel.rooms.length();i++)
	{
		if(hotel.rooms[i].IsOwner(PlayerId))
		return@hotel.rooms[i];
	}
	return null;
}   

bool d_AlreadyRenting(Critter&player,Critter@npc,int val)
{
	CRoom@room=GetRentedRoom(player.Id);
	return(@room!=null);
}   

bool d_NotRentingHere(Critter&player,Critter@npc,int val)
{
	CRoom@room=GetRentedRoom(player.Id);
	CHotel@hotel=GetHotel(npc);
	
	if(!(@room!=null)||!(@hotel!=null))
	return true;
	
	return room.GetHotelId()!=hotel.GetId();
}   

bool d_HasMoneyForRent(Critter&player,Critter@npc,int val)
{
	CHotel@hotel=GetHotel(npc);
	if(!(@hotel!=null))
	{
		Log("ERR: No hotel for this npc");
		return false;
	}
	return player.CountItem((41))>=hotel.Price;
}  

bool d_NoMoneyForRent(Critter&player,Critter@npc,int val)
{
	CHotel@hotel=GetHotel(npc);
	if(!(@hotel!=null))
	{
		Log("ERR: No hotel for this npc");
		return false;
	}
	return player.CountItem((41))<hotel.Price;
}   

uint r_RentRoom(Critter&player,Critter@npc,int val)
{
	CHotel@hotel=GetHotel(npc);
	CRoom@room=hotel.GetFreeRoom();
	
	if((@room!=null))
	{
		
		CRoom@curr=GetRentedRoom(player.Id);
		if((@curr!=null))
		curr.Expire(true);
		
		room.Rent(npc,player,hotel.Price,hotel.RentTime);
		
		player.DeleteItem((41),hotel.Price);
		return 0;
	}
	else
	return val;
}

void dlg_ShowRentedRoomInfo(Critter&player,Critter@npc,string@lexems)
{
	if(!(@player!=null)||(!(@npc!=null))||!(@lexems!=null))
	return;
	
	CRoom@curr=GetRentedRoom(player.Id);
	if(!(@curr!=null))
	{
		player.Say((12),"There is no room rented by you.");
		return;
	}
	
	lexems+="$roomnumber"+curr.GetRoomNumber();
	string money;
	string prefix;
	switch(npc.Param[(139)])
	{
		case 1:money="Dollars";
		case 2:money="Chips";
		case 3:money="Scrips";
		case 4:money="Pounds";
		case 5:money="Rings";
		default:money="Caps";
	}
	switch(npc.Param[(139)])
	{
		case 1:prefix="Enclave ";
		case 2:prefix="Memory ";
		case 3:prefix="NCR ";
		case 4:prefix="Vault City ";
		case 5:prefix="Pull ";
		default:prefix="Bottle ";
	}
	lexems+=("$prefix"+prefix);
	lexems+=("$money"+money);
}   

void r_ShowRoom(Critter&player,Critter@npc,int val)
{
	CRoom@room=GetRentedRoom(player.Id);
	CHotel@hotel=GetHotel(npc);
	
	if(!(@room!=null)||!(@hotel!=null)||room.GetHotelId()!=hotel.GetId())
	{
		Log("ERR: Player doesn't rent any room here.");
		return;
	}
	
	Item@door=room.GetDoor();
	if(!(@door!=null))
	{
		Log("ERR: Couldn't find door for the room.");
		return;
	}
	
	AddWalkPlane(npc,0,door.HexX,door.HexY,GetDirection(npc.HexX,npc.HexY,door.HexX,door.HexY),false,1);
}   

void dlg_ShowInfo(Critter&player,Critter@npc,string@lexems)
{
	if(!(@player!=null)||(!(@npc!=null))||!(@lexems!=null))
	return;
	
	CHotel@hotel=GetHotel(npc);
	uint price=0;
	uint time=0;
	if((@hotel!=null))
	{
		price=hotel.Price;
		time=hotel.RentTime;
	}
	lexems+="$price"+price;
	lexems+="$time"+time*__TimeMultiplier;
	string money;
	string prefix;
	switch(npc.Param[(139)])
	{
		case 1:money="Dollars";
		case 2:money="Chips";
		case 3:money="Scrips";
		case 4:money="Pounds";
		case 5:money="Rings";
		default:money="Caps";
	}
	switch(npc.Param[(139)])
	{
		case 1:prefix="Enclave ";
		case 2:prefix="Memory ";
		case 3:prefix="NCR ";
		case 4:prefix="Vault City ";
		case 5:prefix="Pull ";
		default:prefix="Bottle ";
	}
	lexems+=("$prefix"+prefix);
	lexems+=("$money"+money);
}   

bool d_CanPayRent(Critter&player,Critter@npc,int val)
{
	CRoom@room=GetRentedRoom(player.Id);
	if(!(@room!=null))
	return false;
	
	CHotel@hotel=GetHotel(npc);
	if(!(@hotel!=null))
	{
		Log("ERR: No hotel for this npc");
		return false;
	}
	
	if(room.GetHotelId()!=hotel.GetId())
	return false; 
	
	if(player.CountItem((41))<hotel.Price)
	return false;
	
	GameVar@var=GetLocalVar((3003),player.Id);
	if(var.GetValue()>0)
	return false;
	return true;
} 

bool d_CanPayRent(Critter&player,Critter@npc)
{
	return d_CanPayRent(player,npc,0);
}   

void r_PayRent(Critter&player,Critter@npc,int val)
{
	CHotel@hotel=GetHotel(npc);
	if(!(@hotel!=null))
	{
		Log("ERR: No hotel for this npc");
		return;
	}
	
	player.DeleteItem((41),hotel.Price);
	
	GameVar@var=GetLocalVar((3003),player.Id);
	if(var.GetValue()>0)
	Log("WARN: rent has been already paid");
	var=hotel.Price;
}

void r_PayRent(Critter&player,Critter@npc)
{
	r_PayRent(player,npc,0);
}

void test(Critter&crit,int p0,int p1,int p2)
{
	Item@it=crit.AddItem((82),1);
	it.LockerId=2;
	it.LockerCondition=3;
	it.LockerComplexity=4;
	it.Val1=1;
	it.Val2=1;
	it.Val3=1;
	it.Val4=1;
	Log("m2v1"+it.Val1);
	Log("m2v2"+it.Val2);
	Log("m2v3"+it.Val3);
	Log("m2v4"+it.Val4);
	Log("lid"+it.LockerId);
	Log("lcon"+it.LockerId);
	Log("lcom"+it.LockerId);
}

void init(Critter&crit,int p0,int p1,int p2)
{
	uint[]locks={1,2,3};
	AddHotel(GetCritter(((5000000)+(p0))),locks,500,3);
	WLog("rooms","Added hotel");
}     

array<uint>Locks;

void item_init(Item&item,bool firstTime)
{
	
	Locks.insertLast(item.Id);
	
	item.SetEvent((4),"_UseSkill");
}   

bool _UseSkill(Item&item,Critter&crit,int skill)
{
	
	if(!(@item!=null))
	{
		Log("ERROR: Invalid item.");
		return true;
	}
	CHotel@hotel=GetHotel((item.Val3));
	if(!(@hotel!=null))
	{
		Log("ERROR: Invalid hotel id: "+(item.Val3));
		return true;
	}
	if((item.Val4)>=int(hotel.rooms.length()))
	{
		crit.Say((11),"ERROR: Wrong room id: "+(item.Val4)+"/"+hotel.rooms.length());
		return true;
	}
	CRoom@room=hotel.rooms[(item.Val4)];
	if(!(@room!=null))
	{
		crit.Say((11),"ERROR: Couldn't obtain room assigned for that door/container.");
		return true;
	} 
	
	if(skill==-1)
	{
		if((not((item.LockerCondition&(0x01))!=0)))
		{
			GameVar@var=GetLocalVar((3002),crit.Id);  
			
			{};
			if(crit.Id==room.GetPlayerId()||crit.IsNpc())
			{
				if(item.GetType()==(9))
				{
					if(!LockerOpen(item))
					Log("can't open: "+item.MapId+" at "+item.HexX+","+item.HexY);
				}
				else if(item.GetType()==(8))
				{
					Map@map=GetMapByPid((228),0);
					Item@uberCont=map.GetItem((74),(67),(128));
					if(!(@uberCont!=null))
					{
						crit.Say((11),"ERROR: Couldn't find global room container!");
						return true;
					}
					array<Item@>items; 
					
					uberCont.GetItems(crit.Id,items);
					{};
					MoveItems(items,item,0);
					if(item.Proto.Container_Changeble&&!LockerOpen(item))
					Log("can't open: "+item.MapId+" at "+item.HexX+","+item.HexY);
					crit.ShowContainer(null,item,item.Proto.GroundLevel?(2):(1));
				}
				else
				{
					crit.Say((11),"ERR: Improper lock item type");
					Log("ERR: Improper lock item type");
					return true;
				}
				if(item.Val5!=0)
				EraseTimeEvent(item.Val5);
				item.Val5=CreateTimeEvent(((__FullSecond)+(((60)*60))),"e_CloseDoor",item.Id,true);
				return true;
			}
			else
			{
				crit.Say((11),"It's not your room.");
				return true;
			}
		}
		else if(((item.LockerCondition&(0x01))!=0))
		{
			if(item.GetType()==(8))
			{
				Map@map=GetMapByPid((228),0);
				Item@uberCont=map.GetItem((74),(67),(128));
				if(!(@uberCont!=null))
				{
					crit.Say((11),"ERROR: Couldn't find global room container!");
					return true;
				}
				
				array<Item@>items;
				
				item.GetItems(0,items);
				{};
				MoveItems(items,uberCont,crit.Id);
			}
			if(item.Proto.Container_Changeble&&!LockerClose(item))
			Log("can't close: "+item.MapId+" at "+item.HexX+","+item.HexY);
			if(item.Val5!=0)
			EraseTimeEvent(item.Val5);
			
			return true;
		}
		return false;
	}
	else if(skill==(209))
	{
		return true;
	}
	else if(skill==(212)&&crit.GetAccess()==(3))
	{
		crit.Say((11),"LockId: "+item.LockerId+", Hotel: "+(item.Val3)+", room: "+(item.Val4)+"; rented by: "+GetSafePlayerName(room.GetPlayerId()));
		return true;
	}
	else if(skill==(213)&&crit.GetAccess()==(3))
	{   
		
		room.Expire(true);
		crit.Say((11),"Forced room expiration.");
		return true;
	}
	return false;
}
uint e_CloseDoor(array<uint>@values)
{
	Item@item=GetItem(values[0]);
	if(!(@item!=null))
	return 0;
	uint16 x=0,y=0;
	Map@map=item.GetMapPosition(x,y);
	if(!(@map!=null))
	return 0;
	if(@map.GetCritter(x,y)!=null)
	return((3)*__TimeMultiplier);
	
	if(item.GetType()==(8))
	{
		CHotel@hotel=GetHotel((item.Val3));
		if((item.Val4)>=int(hotel.rooms.length()))
		{
			Log("ERROR: Wrong room id: "+(item.Val4)+"/"+hotel.rooms.length());
			return 0;
		}
		CRoom@room=hotel.rooms[(item.Val4)];
		if(!(@room!=null))
		{
			Log("ERROR: Couldn't obtain room assigned for that door/container.");
			return 0;
		}
		
		Map@buff=GetMapByPid((228),0);
		Item@uberCont=buff.GetItem((74),(67),(128));
		
		array<Item@>items;
		
		item.GetItems(0,items);
		MoveItems(items,uberCont,room.GetPlayerId());
	}
	if(!LockerClose(item))
	Log("can't close: "+item.MapId+" at "+item.HexX+","+item.HexY);
	item.Val5=0;
	return 0;
}          

